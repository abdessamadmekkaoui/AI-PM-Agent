"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/dompurify";
exports.ids = ["vendor-chunks/dompurify"];
exports.modules = {

/***/ "(ssr)/./node_modules/dompurify/dist/purify.es.mjs":
/*!***************************************************!*\
  !*** ./node_modules/dompurify/dist/purify.es.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ purify)\n/* harmony export */ });\n/*! @license DOMPurify 3.3.1 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.3.1/LICENSE */ const { entries, setPrototypeOf, isFrozen, getPrototypeOf, getOwnPropertyDescriptor } = Object;\nlet { freeze, seal, create } = Object; // eslint-disable-line import/no-mutable-exports\nlet { apply, construct } = typeof Reflect !== \"undefined\" && Reflect;\nif (!freeze) {\n    freeze = function freeze(x) {\n        return x;\n    };\n}\nif (!seal) {\n    seal = function seal(x) {\n        return x;\n    };\n}\nif (!apply) {\n    apply = function apply(func, thisArg) {\n        for(var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n            args[_key - 2] = arguments[_key];\n        }\n        return func.apply(thisArg, args);\n    };\n}\nif (!construct) {\n    construct = function construct(Func) {\n        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n            args[_key2 - 1] = arguments[_key2];\n        }\n        return new Func(...args);\n    };\n}\nconst arrayForEach = unapply(Array.prototype.forEach);\nconst arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);\nconst arrayPop = unapply(Array.prototype.pop);\nconst arrayPush = unapply(Array.prototype.push);\nconst arraySplice = unapply(Array.prototype.splice);\nconst stringToLowerCase = unapply(String.prototype.toLowerCase);\nconst stringToString = unapply(String.prototype.toString);\nconst stringMatch = unapply(String.prototype.match);\nconst stringReplace = unapply(String.prototype.replace);\nconst stringIndexOf = unapply(String.prototype.indexOf);\nconst stringTrim = unapply(String.prototype.trim);\nconst objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);\nconst regExpTest = unapply(RegExp.prototype.test);\nconst typeErrorCreate = unconstruct(TypeError);\n/**\n * Creates a new function that calls the given function with a specified thisArg and arguments.\n *\n * @param func - The function to be wrapped and called.\n * @returns A new function that calls the given function with a specified thisArg and arguments.\n */ function unapply(func) {\n    return function(thisArg) {\n        if (thisArg instanceof RegExp) {\n            thisArg.lastIndex = 0;\n        }\n        for(var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++){\n            args[_key3 - 1] = arguments[_key3];\n        }\n        return apply(func, thisArg, args);\n    };\n}\n/**\n * Creates a new function that constructs an instance of the given constructor function with the provided arguments.\n *\n * @param func - The constructor function to be wrapped and called.\n * @returns A new function that constructs an instance of the given constructor function with the provided arguments.\n */ function unconstruct(Func) {\n    return function() {\n        for(var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++){\n            args[_key4] = arguments[_key4];\n        }\n        return construct(Func, args);\n    };\n}\n/**\n * Add properties to a lookup table\n *\n * @param set - The set to which elements will be added.\n * @param array - The array containing elements to be added to the set.\n * @param transformCaseFunc - An optional function to transform the case of each element before adding to the set.\n * @returns The modified set with added elements.\n */ function addToSet(set, array) {\n    let transformCaseFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringToLowerCase;\n    if (setPrototypeOf) {\n        // Make 'in' and truthy checks like Boolean(set.constructor)\n        // independent of any properties defined on Object.prototype.\n        // Prevent prototype setters from intercepting set as a this value.\n        setPrototypeOf(set, null);\n    }\n    let l = array.length;\n    while(l--){\n        let element = array[l];\n        if (typeof element === \"string\") {\n            const lcElement = transformCaseFunc(element);\n            if (lcElement !== element) {\n                // Config presets (e.g. tags.js, attrs.js) are immutable.\n                if (!isFrozen(array)) {\n                    array[l] = lcElement;\n                }\n                element = lcElement;\n            }\n        }\n        set[element] = true;\n    }\n    return set;\n}\n/**\n * Clean up an array to harden against CSPP\n *\n * @param array - The array to be cleaned.\n * @returns The cleaned version of the array\n */ function cleanArray(array) {\n    for(let index = 0; index < array.length; index++){\n        const isPropertyExist = objectHasOwnProperty(array, index);\n        if (!isPropertyExist) {\n            array[index] = null;\n        }\n    }\n    return array;\n}\n/**\n * Shallow clone an object\n *\n * @param object - The object to be cloned.\n * @returns A new object that copies the original.\n */ function clone(object) {\n    const newObject = create(null);\n    for (const [property, value] of entries(object)){\n        const isPropertyExist = objectHasOwnProperty(object, property);\n        if (isPropertyExist) {\n            if (Array.isArray(value)) {\n                newObject[property] = cleanArray(value);\n            } else if (value && typeof value === \"object\" && value.constructor === Object) {\n                newObject[property] = clone(value);\n            } else {\n                newObject[property] = value;\n            }\n        }\n    }\n    return newObject;\n}\n/**\n * This method automatically checks if the prop is function or getter and behaves accordingly.\n *\n * @param object - The object to look up the getter function in its prototype chain.\n * @param prop - The property name for which to find the getter function.\n * @returns The getter function found in the prototype chain or a fallback function.\n */ function lookupGetter(object, prop) {\n    while(object !== null){\n        const desc = getOwnPropertyDescriptor(object, prop);\n        if (desc) {\n            if (desc.get) {\n                return unapply(desc.get);\n            }\n            if (typeof desc.value === \"function\") {\n                return unapply(desc.value);\n            }\n        }\n        object = getPrototypeOf(object);\n    }\n    function fallbackValue() {\n        return null;\n    }\n    return fallbackValue;\n}\nconst html$1 = freeze([\n    \"a\",\n    \"abbr\",\n    \"acronym\",\n    \"address\",\n    \"area\",\n    \"article\",\n    \"aside\",\n    \"audio\",\n    \"b\",\n    \"bdi\",\n    \"bdo\",\n    \"big\",\n    \"blink\",\n    \"blockquote\",\n    \"body\",\n    \"br\",\n    \"button\",\n    \"canvas\",\n    \"caption\",\n    \"center\",\n    \"cite\",\n    \"code\",\n    \"col\",\n    \"colgroup\",\n    \"content\",\n    \"data\",\n    \"datalist\",\n    \"dd\",\n    \"decorator\",\n    \"del\",\n    \"details\",\n    \"dfn\",\n    \"dialog\",\n    \"dir\",\n    \"div\",\n    \"dl\",\n    \"dt\",\n    \"element\",\n    \"em\",\n    \"fieldset\",\n    \"figcaption\",\n    \"figure\",\n    \"font\",\n    \"footer\",\n    \"form\",\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    \"head\",\n    \"header\",\n    \"hgroup\",\n    \"hr\",\n    \"html\",\n    \"i\",\n    \"img\",\n    \"input\",\n    \"ins\",\n    \"kbd\",\n    \"label\",\n    \"legend\",\n    \"li\",\n    \"main\",\n    \"map\",\n    \"mark\",\n    \"marquee\",\n    \"menu\",\n    \"menuitem\",\n    \"meter\",\n    \"nav\",\n    \"nobr\",\n    \"ol\",\n    \"optgroup\",\n    \"option\",\n    \"output\",\n    \"p\",\n    \"picture\",\n    \"pre\",\n    \"progress\",\n    \"q\",\n    \"rp\",\n    \"rt\",\n    \"ruby\",\n    \"s\",\n    \"samp\",\n    \"search\",\n    \"section\",\n    \"select\",\n    \"shadow\",\n    \"slot\",\n    \"small\",\n    \"source\",\n    \"spacer\",\n    \"span\",\n    \"strike\",\n    \"strong\",\n    \"style\",\n    \"sub\",\n    \"summary\",\n    \"sup\",\n    \"table\",\n    \"tbody\",\n    \"td\",\n    \"template\",\n    \"textarea\",\n    \"tfoot\",\n    \"th\",\n    \"thead\",\n    \"time\",\n    \"tr\",\n    \"track\",\n    \"tt\",\n    \"u\",\n    \"ul\",\n    \"var\",\n    \"video\",\n    \"wbr\"\n]);\nconst svg$1 = freeze([\n    \"svg\",\n    \"a\",\n    \"altglyph\",\n    \"altglyphdef\",\n    \"altglyphitem\",\n    \"animatecolor\",\n    \"animatemotion\",\n    \"animatetransform\",\n    \"circle\",\n    \"clippath\",\n    \"defs\",\n    \"desc\",\n    \"ellipse\",\n    \"enterkeyhint\",\n    \"exportparts\",\n    \"filter\",\n    \"font\",\n    \"g\",\n    \"glyph\",\n    \"glyphref\",\n    \"hkern\",\n    \"image\",\n    \"inputmode\",\n    \"line\",\n    \"lineargradient\",\n    \"marker\",\n    \"mask\",\n    \"metadata\",\n    \"mpath\",\n    \"part\",\n    \"path\",\n    \"pattern\",\n    \"polygon\",\n    \"polyline\",\n    \"radialgradient\",\n    \"rect\",\n    \"stop\",\n    \"style\",\n    \"switch\",\n    \"symbol\",\n    \"text\",\n    \"textpath\",\n    \"title\",\n    \"tref\",\n    \"tspan\",\n    \"view\",\n    \"vkern\"\n]);\nconst svgFilters = freeze([\n    \"feBlend\",\n    \"feColorMatrix\",\n    \"feComponentTransfer\",\n    \"feComposite\",\n    \"feConvolveMatrix\",\n    \"feDiffuseLighting\",\n    \"feDisplacementMap\",\n    \"feDistantLight\",\n    \"feDropShadow\",\n    \"feFlood\",\n    \"feFuncA\",\n    \"feFuncB\",\n    \"feFuncG\",\n    \"feFuncR\",\n    \"feGaussianBlur\",\n    \"feImage\",\n    \"feMerge\",\n    \"feMergeNode\",\n    \"feMorphology\",\n    \"feOffset\",\n    \"fePointLight\",\n    \"feSpecularLighting\",\n    \"feSpotLight\",\n    \"feTile\",\n    \"feTurbulence\"\n]);\n// List of SVG elements that are disallowed by default.\n// We still need to know them so that we can do namespace\n// checks properly in case one wants to add them to\n// allow-list.\nconst svgDisallowed = freeze([\n    \"animate\",\n    \"color-profile\",\n    \"cursor\",\n    \"discard\",\n    \"font-face\",\n    \"font-face-format\",\n    \"font-face-name\",\n    \"font-face-src\",\n    \"font-face-uri\",\n    \"foreignobject\",\n    \"hatch\",\n    \"hatchpath\",\n    \"mesh\",\n    \"meshgradient\",\n    \"meshpatch\",\n    \"meshrow\",\n    \"missing-glyph\",\n    \"script\",\n    \"set\",\n    \"solidcolor\",\n    \"unknown\",\n    \"use\"\n]);\nconst mathMl$1 = freeze([\n    \"math\",\n    \"menclose\",\n    \"merror\",\n    \"mfenced\",\n    \"mfrac\",\n    \"mglyph\",\n    \"mi\",\n    \"mlabeledtr\",\n    \"mmultiscripts\",\n    \"mn\",\n    \"mo\",\n    \"mover\",\n    \"mpadded\",\n    \"mphantom\",\n    \"mroot\",\n    \"mrow\",\n    \"ms\",\n    \"mspace\",\n    \"msqrt\",\n    \"mstyle\",\n    \"msub\",\n    \"msup\",\n    \"msubsup\",\n    \"mtable\",\n    \"mtd\",\n    \"mtext\",\n    \"mtr\",\n    \"munder\",\n    \"munderover\",\n    \"mprescripts\"\n]);\n// Similarly to SVG, we want to know all MathML elements,\n// even those that we disallow by default.\nconst mathMlDisallowed = freeze([\n    \"maction\",\n    \"maligngroup\",\n    \"malignmark\",\n    \"mlongdiv\",\n    \"mscarries\",\n    \"mscarry\",\n    \"msgroup\",\n    \"mstack\",\n    \"msline\",\n    \"msrow\",\n    \"semantics\",\n    \"annotation\",\n    \"annotation-xml\",\n    \"mprescripts\",\n    \"none\"\n]);\nconst text = freeze([\n    \"#text\"\n]);\nconst html = freeze([\n    \"accept\",\n    \"action\",\n    \"align\",\n    \"alt\",\n    \"autocapitalize\",\n    \"autocomplete\",\n    \"autopictureinpicture\",\n    \"autoplay\",\n    \"background\",\n    \"bgcolor\",\n    \"border\",\n    \"capture\",\n    \"cellpadding\",\n    \"cellspacing\",\n    \"checked\",\n    \"cite\",\n    \"class\",\n    \"clear\",\n    \"color\",\n    \"cols\",\n    \"colspan\",\n    \"controls\",\n    \"controlslist\",\n    \"coords\",\n    \"crossorigin\",\n    \"datetime\",\n    \"decoding\",\n    \"default\",\n    \"dir\",\n    \"disabled\",\n    \"disablepictureinpicture\",\n    \"disableremoteplayback\",\n    \"download\",\n    \"draggable\",\n    \"enctype\",\n    \"enterkeyhint\",\n    \"exportparts\",\n    \"face\",\n    \"for\",\n    \"headers\",\n    \"height\",\n    \"hidden\",\n    \"high\",\n    \"href\",\n    \"hreflang\",\n    \"id\",\n    \"inert\",\n    \"inputmode\",\n    \"integrity\",\n    \"ismap\",\n    \"kind\",\n    \"label\",\n    \"lang\",\n    \"list\",\n    \"loading\",\n    \"loop\",\n    \"low\",\n    \"max\",\n    \"maxlength\",\n    \"media\",\n    \"method\",\n    \"min\",\n    \"minlength\",\n    \"multiple\",\n    \"muted\",\n    \"name\",\n    \"nonce\",\n    \"noshade\",\n    \"novalidate\",\n    \"nowrap\",\n    \"open\",\n    \"optimum\",\n    \"part\",\n    \"pattern\",\n    \"placeholder\",\n    \"playsinline\",\n    \"popover\",\n    \"popovertarget\",\n    \"popovertargetaction\",\n    \"poster\",\n    \"preload\",\n    \"pubdate\",\n    \"radiogroup\",\n    \"readonly\",\n    \"rel\",\n    \"required\",\n    \"rev\",\n    \"reversed\",\n    \"role\",\n    \"rows\",\n    \"rowspan\",\n    \"spellcheck\",\n    \"scope\",\n    \"selected\",\n    \"shape\",\n    \"size\",\n    \"sizes\",\n    \"slot\",\n    \"span\",\n    \"srclang\",\n    \"start\",\n    \"src\",\n    \"srcset\",\n    \"step\",\n    \"style\",\n    \"summary\",\n    \"tabindex\",\n    \"title\",\n    \"translate\",\n    \"type\",\n    \"usemap\",\n    \"valign\",\n    \"value\",\n    \"width\",\n    \"wrap\",\n    \"xmlns\",\n    \"slot\"\n]);\nconst svg = freeze([\n    \"accent-height\",\n    \"accumulate\",\n    \"additive\",\n    \"alignment-baseline\",\n    \"amplitude\",\n    \"ascent\",\n    \"attributename\",\n    \"attributetype\",\n    \"azimuth\",\n    \"basefrequency\",\n    \"baseline-shift\",\n    \"begin\",\n    \"bias\",\n    \"by\",\n    \"class\",\n    \"clip\",\n    \"clippathunits\",\n    \"clip-path\",\n    \"clip-rule\",\n    \"color\",\n    \"color-interpolation\",\n    \"color-interpolation-filters\",\n    \"color-profile\",\n    \"color-rendering\",\n    \"cx\",\n    \"cy\",\n    \"d\",\n    \"dx\",\n    \"dy\",\n    \"diffuseconstant\",\n    \"direction\",\n    \"display\",\n    \"divisor\",\n    \"dur\",\n    \"edgemode\",\n    \"elevation\",\n    \"end\",\n    \"exponent\",\n    \"fill\",\n    \"fill-opacity\",\n    \"fill-rule\",\n    \"filter\",\n    \"filterunits\",\n    \"flood-color\",\n    \"flood-opacity\",\n    \"font-family\",\n    \"font-size\",\n    \"font-size-adjust\",\n    \"font-stretch\",\n    \"font-style\",\n    \"font-variant\",\n    \"font-weight\",\n    \"fx\",\n    \"fy\",\n    \"g1\",\n    \"g2\",\n    \"glyph-name\",\n    \"glyphref\",\n    \"gradientunits\",\n    \"gradienttransform\",\n    \"height\",\n    \"href\",\n    \"id\",\n    \"image-rendering\",\n    \"in\",\n    \"in2\",\n    \"intercept\",\n    \"k\",\n    \"k1\",\n    \"k2\",\n    \"k3\",\n    \"k4\",\n    \"kerning\",\n    \"keypoints\",\n    \"keysplines\",\n    \"keytimes\",\n    \"lang\",\n    \"lengthadjust\",\n    \"letter-spacing\",\n    \"kernelmatrix\",\n    \"kernelunitlength\",\n    \"lighting-color\",\n    \"local\",\n    \"marker-end\",\n    \"marker-mid\",\n    \"marker-start\",\n    \"markerheight\",\n    \"markerunits\",\n    \"markerwidth\",\n    \"maskcontentunits\",\n    \"maskunits\",\n    \"max\",\n    \"mask\",\n    \"mask-type\",\n    \"media\",\n    \"method\",\n    \"mode\",\n    \"min\",\n    \"name\",\n    \"numoctaves\",\n    \"offset\",\n    \"operator\",\n    \"opacity\",\n    \"order\",\n    \"orient\",\n    \"orientation\",\n    \"origin\",\n    \"overflow\",\n    \"paint-order\",\n    \"path\",\n    \"pathlength\",\n    \"patterncontentunits\",\n    \"patterntransform\",\n    \"patternunits\",\n    \"points\",\n    \"preservealpha\",\n    \"preserveaspectratio\",\n    \"primitiveunits\",\n    \"r\",\n    \"rx\",\n    \"ry\",\n    \"radius\",\n    \"refx\",\n    \"refy\",\n    \"repeatcount\",\n    \"repeatdur\",\n    \"restart\",\n    \"result\",\n    \"rotate\",\n    \"scale\",\n    \"seed\",\n    \"shape-rendering\",\n    \"slope\",\n    \"specularconstant\",\n    \"specularexponent\",\n    \"spreadmethod\",\n    \"startoffset\",\n    \"stddeviation\",\n    \"stitchtiles\",\n    \"stop-color\",\n    \"stop-opacity\",\n    \"stroke-dasharray\",\n    \"stroke-dashoffset\",\n    \"stroke-linecap\",\n    \"stroke-linejoin\",\n    \"stroke-miterlimit\",\n    \"stroke-opacity\",\n    \"stroke\",\n    \"stroke-width\",\n    \"style\",\n    \"surfacescale\",\n    \"systemlanguage\",\n    \"tabindex\",\n    \"tablevalues\",\n    \"targetx\",\n    \"targety\",\n    \"transform\",\n    \"transform-origin\",\n    \"text-anchor\",\n    \"text-decoration\",\n    \"text-rendering\",\n    \"textlength\",\n    \"type\",\n    \"u1\",\n    \"u2\",\n    \"unicode\",\n    \"values\",\n    \"viewbox\",\n    \"visibility\",\n    \"version\",\n    \"vert-adv-y\",\n    \"vert-origin-x\",\n    \"vert-origin-y\",\n    \"width\",\n    \"word-spacing\",\n    \"wrap\",\n    \"writing-mode\",\n    \"xchannelselector\",\n    \"ychannelselector\",\n    \"x\",\n    \"x1\",\n    \"x2\",\n    \"xmlns\",\n    \"y\",\n    \"y1\",\n    \"y2\",\n    \"z\",\n    \"zoomandpan\"\n]);\nconst mathMl = freeze([\n    \"accent\",\n    \"accentunder\",\n    \"align\",\n    \"bevelled\",\n    \"close\",\n    \"columnsalign\",\n    \"columnlines\",\n    \"columnspan\",\n    \"denomalign\",\n    \"depth\",\n    \"dir\",\n    \"display\",\n    \"displaystyle\",\n    \"encoding\",\n    \"fence\",\n    \"frame\",\n    \"height\",\n    \"href\",\n    \"id\",\n    \"largeop\",\n    \"length\",\n    \"linethickness\",\n    \"lspace\",\n    \"lquote\",\n    \"mathbackground\",\n    \"mathcolor\",\n    \"mathsize\",\n    \"mathvariant\",\n    \"maxsize\",\n    \"minsize\",\n    \"movablelimits\",\n    \"notation\",\n    \"numalign\",\n    \"open\",\n    \"rowalign\",\n    \"rowlines\",\n    \"rowspacing\",\n    \"rowspan\",\n    \"rspace\",\n    \"rquote\",\n    \"scriptlevel\",\n    \"scriptminsize\",\n    \"scriptsizemultiplier\",\n    \"selection\",\n    \"separator\",\n    \"separators\",\n    \"stretchy\",\n    \"subscriptshift\",\n    \"supscriptshift\",\n    \"symmetric\",\n    \"voffset\",\n    \"width\",\n    \"xmlns\"\n]);\nconst xml = freeze([\n    \"xlink:href\",\n    \"xml:id\",\n    \"xlink:title\",\n    \"xml:space\",\n    \"xmlns:xlink\"\n]);\n// eslint-disable-next-line unicorn/better-regex\nconst MUSTACHE_EXPR = seal(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\nconst ERB_EXPR = seal(/<%[\\w\\W]*|[\\w\\W]*%>/gm);\nconst TMPLIT_EXPR = seal(/\\$\\{[\\w\\W]*/gm); // eslint-disable-line unicorn/better-regex\nconst DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]+$/); // eslint-disable-line no-useless-escape\nconst ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\nconst IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n);\nconst IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\nconst ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n);\nconst DOCTYPE_NAME = seal(/^html$/i);\nconst CUSTOM_ELEMENT = seal(/^[a-z][.\\w]*(-[.\\w]+)+$/i);\nvar EXPRESSIONS = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    ARIA_ATTR: ARIA_ATTR,\n    ATTR_WHITESPACE: ATTR_WHITESPACE,\n    CUSTOM_ELEMENT: CUSTOM_ELEMENT,\n    DATA_ATTR: DATA_ATTR,\n    DOCTYPE_NAME: DOCTYPE_NAME,\n    ERB_EXPR: ERB_EXPR,\n    IS_ALLOWED_URI: IS_ALLOWED_URI,\n    IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,\n    MUSTACHE_EXPR: MUSTACHE_EXPR,\n    TMPLIT_EXPR: TMPLIT_EXPR\n});\n/* eslint-disable @typescript-eslint/indent */ // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\nconst NODE_TYPE = {\n    element: 1,\n    attribute: 2,\n    text: 3,\n    cdataSection: 4,\n    entityReference: 5,\n    // Deprecated\n    entityNode: 6,\n    // Deprecated\n    progressingInstruction: 7,\n    comment: 8,\n    document: 9,\n    documentType: 10,\n    documentFragment: 11,\n    notation: 12 // Deprecated\n};\nconst getGlobal = function getGlobal() {\n    return  true ? null : 0;\n};\n/**\n * Creates a no-op policy for internal use only.\n * Don't export this function outside this module!\n * @param trustedTypes The policy factory.\n * @param purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).\n * @return The policy created (or null, if Trusted Types\n * are not supported or creating the policy failed).\n */ const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {\n    if (typeof trustedTypes !== \"object\" || typeof trustedTypes.createPolicy !== \"function\") {\n        return null;\n    }\n    // Allow the callers to control the unique policy name\n    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n    // Policy creation with duplicate names throws in Trusted Types.\n    let suffix = null;\n    const ATTR_NAME = \"data-tt-policy-suffix\";\n    if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {\n        suffix = purifyHostElement.getAttribute(ATTR_NAME);\n    }\n    const policyName = \"dompurify\" + (suffix ? \"#\" + suffix : \"\");\n    try {\n        return trustedTypes.createPolicy(policyName, {\n            createHTML (html) {\n                return html;\n            },\n            createScriptURL (scriptUrl) {\n                return scriptUrl;\n            }\n        });\n    } catch (_) {\n        // Policy creation failed (most likely another DOMPurify script has\n        // already run). Skip creating the policy, as this will only cause errors\n        // if TT are enforced.\n        console.warn(\"TrustedTypes policy \" + policyName + \" could not be created.\");\n        return null;\n    }\n};\nconst _createHooksMap = function _createHooksMap() {\n    return {\n        afterSanitizeAttributes: [],\n        afterSanitizeElements: [],\n        afterSanitizeShadowDOM: [],\n        beforeSanitizeAttributes: [],\n        beforeSanitizeElements: [],\n        beforeSanitizeShadowDOM: [],\n        uponSanitizeAttribute: [],\n        uponSanitizeElement: [],\n        uponSanitizeShadowNode: []\n    };\n};\nfunction createDOMPurify() {\n    let window1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n    const DOMPurify = (root)=>createDOMPurify(root);\n    DOMPurify.version = \"3.3.1\";\n    DOMPurify.removed = [];\n    if (!window1 || !window1.document || window1.document.nodeType !== NODE_TYPE.document || !window1.Element) {\n        // Not running in a browser, provide a factory function\n        // so that you can pass your own Window\n        DOMPurify.isSupported = false;\n        return DOMPurify;\n    }\n    let { document } = window1;\n    const originalDocument = document;\n    const currentScript = originalDocument.currentScript;\n    const { DocumentFragment, HTMLTemplateElement, Node, Element, NodeFilter, NamedNodeMap = window1.NamedNodeMap || window1.MozNamedAttrMap, HTMLFormElement, DOMParser, trustedTypes } = window1;\n    const ElementPrototype = Element.prototype;\n    const cloneNode = lookupGetter(ElementPrototype, \"cloneNode\");\n    const remove = lookupGetter(ElementPrototype, \"remove\");\n    const getNextSibling = lookupGetter(ElementPrototype, \"nextSibling\");\n    const getChildNodes = lookupGetter(ElementPrototype, \"childNodes\");\n    const getParentNode = lookupGetter(ElementPrototype, \"parentNode\");\n    // As per issue #47, the web-components registry is inherited by a\n    // new document created via createHTMLDocument. As per the spec\n    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n    // a new empty registry is used when creating a template contents owner\n    // document, so we use that as our parent document to ensure nothing\n    // is inherited.\n    if (typeof HTMLTemplateElement === \"function\") {\n        const template = document.createElement(\"template\");\n        if (template.content && template.content.ownerDocument) {\n            document = template.content.ownerDocument;\n        }\n    }\n    let trustedTypesPolicy;\n    let emptyHTML = \"\";\n    const { implementation, createNodeIterator, createDocumentFragment, getElementsByTagName } = document;\n    const { importNode } = originalDocument;\n    let hooks = _createHooksMap();\n    /**\n   * Expose whether this browser supports running the full DOMPurify.\n   */ DOMPurify.isSupported = typeof entries === \"function\" && typeof getParentNode === \"function\" && implementation && implementation.createHTMLDocument !== undefined;\n    const { MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR, DATA_ATTR, ARIA_ATTR, IS_SCRIPT_OR_DATA, ATTR_WHITESPACE, CUSTOM_ELEMENT } = EXPRESSIONS;\n    let { IS_ALLOWED_URI: IS_ALLOWED_URI$1 } = EXPRESSIONS;\n    /**\n   * We consider the elements and attributes below to be safe. Ideally\n   * don't add any new ones but feel free to remove unwanted ones.\n   */ /* allowed element names */ let ALLOWED_TAGS = null;\n    const DEFAULT_ALLOWED_TAGS = addToSet({}, [\n        ...html$1,\n        ...svg$1,\n        ...svgFilters,\n        ...mathMl$1,\n        ...text\n    ]);\n    /* Allowed attribute names */ let ALLOWED_ATTR = null;\n    const DEFAULT_ALLOWED_ATTR = addToSet({}, [\n        ...html,\n        ...svg,\n        ...mathMl,\n        ...xml\n    ]);\n    /*\n   * Configure how DOMPurify should handle custom elements and their attributes as well as customized built-in elements.\n   * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)\n   * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)\n   * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.\n   */ let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {\n        tagNameCheck: {\n            writable: true,\n            configurable: false,\n            enumerable: true,\n            value: null\n        },\n        attributeNameCheck: {\n            writable: true,\n            configurable: false,\n            enumerable: true,\n            value: null\n        },\n        allowCustomizedBuiltInElements: {\n            writable: true,\n            configurable: false,\n            enumerable: true,\n            value: false\n        }\n    }));\n    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */ let FORBID_TAGS = null;\n    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */ let FORBID_ATTR = null;\n    /* Config object to store ADD_TAGS/ADD_ATTR functions (when used as functions) */ const EXTRA_ELEMENT_HANDLING = Object.seal(create(null, {\n        tagCheck: {\n            writable: true,\n            configurable: false,\n            enumerable: true,\n            value: null\n        },\n        attributeCheck: {\n            writable: true,\n            configurable: false,\n            enumerable: true,\n            value: null\n        }\n    }));\n    /* Decide if ARIA attributes are okay */ let ALLOW_ARIA_ATTR = true;\n    /* Decide if custom data attributes are okay */ let ALLOW_DATA_ATTR = true;\n    /* Decide if unknown protocols are okay */ let ALLOW_UNKNOWN_PROTOCOLS = false;\n    /* Decide if self-closing tags in attributes are allowed.\n   * Usually removed due to a mXSS issue in jQuery 3.0 */ let ALLOW_SELF_CLOSE_IN_ATTR = true;\n    /* Output should be safe for common template engines.\n   * This means, DOMPurify removes data attributes, mustaches and ERB\n   */ let SAFE_FOR_TEMPLATES = false;\n    /* Output should be safe even for XML used within HTML and alike.\n   * This means, DOMPurify removes comments when containing risky content.\n   */ let SAFE_FOR_XML = true;\n    /* Decide if document with <html>... should be returned */ let WHOLE_DOCUMENT = false;\n    /* Track whether config is already set on this instance of DOMPurify. */ let SET_CONFIG = false;\n    /* Decide if all elements (e.g. style, script) must be children of\n   * document.body. By default, browsers might move them to document.head */ let FORCE_BODY = false;\n    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n   * string (or a TrustedHTML object if Trusted Types are supported).\n   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n   */ let RETURN_DOM = false;\n    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n   * string  (or a TrustedHTML object if Trusted Types are supported) */ let RETURN_DOM_FRAGMENT = false;\n    /* Try to return a Trusted Type object instead of a string, return a string in\n   * case Trusted Types are not supported  */ let RETURN_TRUSTED_TYPE = false;\n    /* Output should be free from DOM clobbering attacks?\n   * This sanitizes markups named with colliding, clobberable built-in DOM APIs.\n   */ let SANITIZE_DOM = true;\n    /* Achieve full DOM Clobbering protection by isolating the namespace of named\n   * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.\n   *\n   * HTML/DOM spec rules that enable DOM Clobbering:\n   *   - Named Access on Window (§7.3.3)\n   *   - DOM Tree Accessors (§3.1.5)\n   *   - Form Element Parent-Child Relations (§4.10.3)\n   *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)\n   *   - HTMLCollection (§4.2.10.2)\n   *\n   * Namespace isolation is implemented by prefixing `id` and `name` attributes\n   * with a constant string, i.e., `user-content-`\n   */ let SANITIZE_NAMED_PROPS = false;\n    const SANITIZE_NAMED_PROPS_PREFIX = \"user-content-\";\n    /* Keep element content when removing element? */ let KEEP_CONTENT = true;\n    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n   * of importing it into a new Document and returning a sanitized copy */ let IN_PLACE = false;\n    /* Allow usage of profiles like html, svg and mathMl */ let USE_PROFILES = {};\n    /* Tags to ignore content of when KEEP_CONTENT is true */ let FORBID_CONTENTS = null;\n    const DEFAULT_FORBID_CONTENTS = addToSet({}, [\n        \"annotation-xml\",\n        \"audio\",\n        \"colgroup\",\n        \"desc\",\n        \"foreignobject\",\n        \"head\",\n        \"iframe\",\n        \"math\",\n        \"mi\",\n        \"mn\",\n        \"mo\",\n        \"ms\",\n        \"mtext\",\n        \"noembed\",\n        \"noframes\",\n        \"noscript\",\n        \"plaintext\",\n        \"script\",\n        \"style\",\n        \"svg\",\n        \"template\",\n        \"thead\",\n        \"title\",\n        \"video\",\n        \"xmp\"\n    ]);\n    /* Tags that are safe for data: URIs */ let DATA_URI_TAGS = null;\n    const DEFAULT_DATA_URI_TAGS = addToSet({}, [\n        \"audio\",\n        \"video\",\n        \"img\",\n        \"source\",\n        \"image\",\n        \"track\"\n    ]);\n    /* Attributes safe for values like \"javascript:\" */ let URI_SAFE_ATTRIBUTES = null;\n    const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [\n        \"alt\",\n        \"class\",\n        \"for\",\n        \"id\",\n        \"label\",\n        \"name\",\n        \"pattern\",\n        \"placeholder\",\n        \"role\",\n        \"summary\",\n        \"title\",\n        \"value\",\n        \"style\",\n        \"xmlns\"\n    ]);\n    const MATHML_NAMESPACE = \"http://www.w3.org/1998/Math/MathML\";\n    const SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\n    const HTML_NAMESPACE = \"http://www.w3.org/1999/xhtml\";\n    /* Document namespace */ let NAMESPACE = HTML_NAMESPACE;\n    let IS_EMPTY_INPUT = false;\n    /* Allowed XHTML+XML namespaces */ let ALLOWED_NAMESPACES = null;\n    const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [\n        MATHML_NAMESPACE,\n        SVG_NAMESPACE,\n        HTML_NAMESPACE\n    ], stringToString);\n    let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [\n        \"mi\",\n        \"mo\",\n        \"mn\",\n        \"ms\",\n        \"mtext\"\n    ]);\n    let HTML_INTEGRATION_POINTS = addToSet({}, [\n        \"annotation-xml\"\n    ]);\n    // Certain elements are allowed in both SVG and HTML\n    // namespace. We need to specify them explicitly\n    // so that they don't get erroneously deleted from\n    // HTML namespace.\n    const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, [\n        \"title\",\n        \"style\",\n        \"font\",\n        \"a\",\n        \"script\"\n    ]);\n    /* Parsing of strict XHTML documents */ let PARSER_MEDIA_TYPE = null;\n    const SUPPORTED_PARSER_MEDIA_TYPES = [\n        \"application/xhtml+xml\",\n        \"text/html\"\n    ];\n    const DEFAULT_PARSER_MEDIA_TYPE = \"text/html\";\n    let transformCaseFunc = null;\n    /* Keep a reference to config to pass to hooks */ let CONFIG = null;\n    /* Ideally, do not touch anything below this line */ /* ______________________________________________ */ const formElement = document.createElement(\"form\");\n    const isRegexOrFunction = function isRegexOrFunction(testValue) {\n        return testValue instanceof RegExp || testValue instanceof Function;\n    };\n    /**\n   * _parseConfig\n   *\n   * @param cfg optional config literal\n   */ // eslint-disable-next-line complexity\n    const _parseConfig = function _parseConfig() {\n        let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (CONFIG && CONFIG === cfg) {\n            return;\n        }\n        /* Shield configuration object from tampering */ if (!cfg || typeof cfg !== \"object\") {\n            cfg = {};\n        }\n        /* Shield configuration object from prototype pollution */ cfg = clone(cfg);\n        PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes\n        SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;\n        // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.\n        transformCaseFunc = PARSER_MEDIA_TYPE === \"application/xhtml+xml\" ? stringToString : stringToLowerCase;\n        /* Set configuration parameters */ ALLOWED_TAGS = objectHasOwnProperty(cfg, \"ALLOWED_TAGS\") ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;\n        ALLOWED_ATTR = objectHasOwnProperty(cfg, \"ALLOWED_ATTR\") ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;\n        ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, \"ALLOWED_NAMESPACES\") ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;\n        URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, \"ADD_URI_SAFE_ATTR\") ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;\n        DATA_URI_TAGS = objectHasOwnProperty(cfg, \"ADD_DATA_URI_TAGS\") ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;\n        FORBID_CONTENTS = objectHasOwnProperty(cfg, \"FORBID_CONTENTS\") ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;\n        FORBID_TAGS = objectHasOwnProperty(cfg, \"FORBID_TAGS\") ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : clone({});\n        FORBID_ATTR = objectHasOwnProperty(cfg, \"FORBID_ATTR\") ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : clone({});\n        USE_PROFILES = objectHasOwnProperty(cfg, \"USE_PROFILES\") ? cfg.USE_PROFILES : false;\n        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n        ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true\n        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n        SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true\n        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n        RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n        RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n        FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n        SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n        SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false\n        KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n        IN_PLACE = cfg.IN_PLACE || false; // Default false\n        IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;\n        NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n        MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;\n        HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;\n        CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {\n            CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n        }\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {\n            CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n        }\n        if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === \"boolean\") {\n            CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n        }\n        if (SAFE_FOR_TEMPLATES) {\n            ALLOW_DATA_ATTR = false;\n        }\n        if (RETURN_DOM_FRAGMENT) {\n            RETURN_DOM = true;\n        }\n        /* Parse profile info */ if (USE_PROFILES) {\n            ALLOWED_TAGS = addToSet({}, text);\n            ALLOWED_ATTR = [];\n            if (USE_PROFILES.html === true) {\n                addToSet(ALLOWED_TAGS, html$1);\n                addToSet(ALLOWED_ATTR, html);\n            }\n            if (USE_PROFILES.svg === true) {\n                addToSet(ALLOWED_TAGS, svg$1);\n                addToSet(ALLOWED_ATTR, svg);\n                addToSet(ALLOWED_ATTR, xml);\n            }\n            if (USE_PROFILES.svgFilters === true) {\n                addToSet(ALLOWED_TAGS, svgFilters);\n                addToSet(ALLOWED_ATTR, svg);\n                addToSet(ALLOWED_ATTR, xml);\n            }\n            if (USE_PROFILES.mathMl === true) {\n                addToSet(ALLOWED_TAGS, mathMl$1);\n                addToSet(ALLOWED_ATTR, mathMl);\n                addToSet(ALLOWED_ATTR, xml);\n            }\n        }\n        /* Merge configuration parameters */ if (cfg.ADD_TAGS) {\n            if (typeof cfg.ADD_TAGS === \"function\") {\n                EXTRA_ELEMENT_HANDLING.tagCheck = cfg.ADD_TAGS;\n            } else {\n                if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n                    ALLOWED_TAGS = clone(ALLOWED_TAGS);\n                }\n                addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);\n            }\n        }\n        if (cfg.ADD_ATTR) {\n            if (typeof cfg.ADD_ATTR === \"function\") {\n                EXTRA_ELEMENT_HANDLING.attributeCheck = cfg.ADD_ATTR;\n            } else {\n                if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n                    ALLOWED_ATTR = clone(ALLOWED_ATTR);\n                }\n                addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);\n            }\n        }\n        if (cfg.ADD_URI_SAFE_ATTR) {\n            addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);\n        }\n        if (cfg.FORBID_CONTENTS) {\n            if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n                FORBID_CONTENTS = clone(FORBID_CONTENTS);\n            }\n            addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);\n        }\n        if (cfg.ADD_FORBID_CONTENTS) {\n            if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n                FORBID_CONTENTS = clone(FORBID_CONTENTS);\n            }\n            addToSet(FORBID_CONTENTS, cfg.ADD_FORBID_CONTENTS, transformCaseFunc);\n        }\n        /* Add #text in case KEEP_CONTENT is set to true */ if (KEEP_CONTENT) {\n            ALLOWED_TAGS[\"#text\"] = true;\n        }\n        /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */ if (WHOLE_DOCUMENT) {\n            addToSet(ALLOWED_TAGS, [\n                \"html\",\n                \"head\",\n                \"body\"\n            ]);\n        }\n        /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */ if (ALLOWED_TAGS.table) {\n            addToSet(ALLOWED_TAGS, [\n                \"tbody\"\n            ]);\n            delete FORBID_TAGS.tbody;\n        }\n        if (cfg.TRUSTED_TYPES_POLICY) {\n            if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== \"function\") {\n                throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createHTML\" hook.');\n            }\n            if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== \"function\") {\n                throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createScriptURL\" hook.');\n            }\n            // Overwrite existing TrustedTypes policy.\n            trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;\n            // Sign local variables required by `sanitize`.\n            emptyHTML = trustedTypesPolicy.createHTML(\"\");\n        } else {\n            // Uninitialized policy, attempt to initialize the internal dompurify policy.\n            if (trustedTypesPolicy === undefined) {\n                trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);\n            }\n            // If creating the internal policy succeeded sign internal variables.\n            if (trustedTypesPolicy !== null && typeof emptyHTML === \"string\") {\n                emptyHTML = trustedTypesPolicy.createHTML(\"\");\n            }\n        }\n        // Prevent further manipulation of configuration.\n        // Not available in IE8, Safari 5, etc.\n        if (freeze) {\n            freeze(cfg);\n        }\n        CONFIG = cfg;\n    };\n    /* Keep track of all possible SVG and MathML tags\n   * so that we can perform the namespace checks\n   * correctly. */ const ALL_SVG_TAGS = addToSet({}, [\n        ...svg$1,\n        ...svgFilters,\n        ...svgDisallowed\n    ]);\n    const ALL_MATHML_TAGS = addToSet({}, [\n        ...mathMl$1,\n        ...mathMlDisallowed\n    ]);\n    /**\n   * @param element a DOM element whose namespace is being checked\n   * @returns Return false if the element has a\n   *  namespace that a spec-compliant parser would never\n   *  return. Return true otherwise.\n   */ const _checkValidNamespace = function _checkValidNamespace(element) {\n        let parent = getParentNode(element);\n        // In JSDOM, if we're inside shadow DOM, then parentNode\n        // can be null. We just simulate parent in this case.\n        if (!parent || !parent.tagName) {\n            parent = {\n                namespaceURI: NAMESPACE,\n                tagName: \"template\"\n            };\n        }\n        const tagName = stringToLowerCase(element.tagName);\n        const parentTagName = stringToLowerCase(parent.tagName);\n        if (!ALLOWED_NAMESPACES[element.namespaceURI]) {\n            return false;\n        }\n        if (element.namespaceURI === SVG_NAMESPACE) {\n            // The only way to switch from HTML namespace to SVG\n            // is via <svg>. If it happens via any other tag, then\n            // it should be killed.\n            if (parent.namespaceURI === HTML_NAMESPACE) {\n                return tagName === \"svg\";\n            }\n            // The only way to switch from MathML to SVG is via`\n            // svg if parent is either <annotation-xml> or MathML\n            // text integration points.\n            if (parent.namespaceURI === MATHML_NAMESPACE) {\n                return tagName === \"svg\" && (parentTagName === \"annotation-xml\" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n            }\n            // We only allow elements that are defined in SVG\n            // spec. All others are disallowed in SVG namespace.\n            return Boolean(ALL_SVG_TAGS[tagName]);\n        }\n        if (element.namespaceURI === MATHML_NAMESPACE) {\n            // The only way to switch from HTML namespace to MathML\n            // is via <math>. If it happens via any other tag, then\n            // it should be killed.\n            if (parent.namespaceURI === HTML_NAMESPACE) {\n                return tagName === \"math\";\n            }\n            // The only way to switch from SVG to MathML is via\n            // <math> and HTML integration points\n            if (parent.namespaceURI === SVG_NAMESPACE) {\n                return tagName === \"math\" && HTML_INTEGRATION_POINTS[parentTagName];\n            }\n            // We only allow elements that are defined in MathML\n            // spec. All others are disallowed in MathML namespace.\n            return Boolean(ALL_MATHML_TAGS[tagName]);\n        }\n        if (element.namespaceURI === HTML_NAMESPACE) {\n            // The only way to switch from SVG to HTML is via\n            // HTML integration points, and from MathML to HTML\n            // is via MathML text integration points\n            if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n                return false;\n            }\n            if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n                return false;\n            }\n            // We disallow tags that are specific for MathML\n            // or SVG and should never appear in HTML namespace\n            return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);\n        }\n        // For XHTML and XML documents that support custom namespaces\n        if (PARSER_MEDIA_TYPE === \"application/xhtml+xml\" && ALLOWED_NAMESPACES[element.namespaceURI]) {\n            return true;\n        }\n        // The code should never reach this place (this means\n        // that the element somehow got namespace that is not\n        // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).\n        // Return false just in case.\n        return false;\n    };\n    /**\n   * _forceRemove\n   *\n   * @param node a DOM node\n   */ const _forceRemove = function _forceRemove(node) {\n        arrayPush(DOMPurify.removed, {\n            element: node\n        });\n        try {\n            // eslint-disable-next-line unicorn/prefer-dom-node-remove\n            getParentNode(node).removeChild(node);\n        } catch (_) {\n            remove(node);\n        }\n    };\n    /**\n   * _removeAttribute\n   *\n   * @param name an Attribute name\n   * @param element a DOM node\n   */ const _removeAttribute = function _removeAttribute(name, element) {\n        try {\n            arrayPush(DOMPurify.removed, {\n                attribute: element.getAttributeNode(name),\n                from: element\n            });\n        } catch (_) {\n            arrayPush(DOMPurify.removed, {\n                attribute: null,\n                from: element\n            });\n        }\n        element.removeAttribute(name);\n        // We void attribute values for unremovable \"is\" attributes\n        if (name === \"is\") {\n            if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n                try {\n                    _forceRemove(element);\n                } catch (_) {}\n            } else {\n                try {\n                    element.setAttribute(name, \"\");\n                } catch (_) {}\n            }\n        }\n    };\n    /**\n   * _initDocument\n   *\n   * @param dirty - a string of dirty markup\n   * @return a DOM, filled with the dirty markup\n   */ const _initDocument = function _initDocument(dirty) {\n        /* Create a HTML document */ let doc = null;\n        let leadingWhitespace = null;\n        if (FORCE_BODY) {\n            dirty = \"<remove></remove>\" + dirty;\n        } else {\n            /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */ const matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n            leadingWhitespace = matches && matches[0];\n        }\n        if (PARSER_MEDIA_TYPE === \"application/xhtml+xml\" && NAMESPACE === HTML_NAMESPACE) {\n            // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)\n            dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + \"</body></html>\";\n        }\n        const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        /*\n     * Use the DOMParser API by default, fallback later if needs be\n     * DOMParser not work for svg when has multiple root element.\n     */ if (NAMESPACE === HTML_NAMESPACE) {\n            try {\n                doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n            } catch (_) {}\n        }\n        /* Use createHTMLDocument in case DOMParser is not available */ if (!doc || !doc.documentElement) {\n            doc = implementation.createDocument(NAMESPACE, \"template\", null);\n            try {\n                doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;\n            } catch (_) {\n            // Syntax error if dirtyPayload is invalid xml\n            }\n        }\n        const body = doc.body || doc.documentElement;\n        if (dirty && leadingWhitespace) {\n            body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n        }\n        /* Work on whole document or just its body */ if (NAMESPACE === HTML_NAMESPACE) {\n            return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? \"html\" : \"body\")[0];\n        }\n        return WHOLE_DOCUMENT ? doc.documentElement : body;\n    };\n    /**\n   * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.\n   *\n   * @param root The root element or node to start traversing on.\n   * @return The created NodeIterator\n   */ const _createNodeIterator = function _createNodeIterator(root) {\n        return createNodeIterator.call(root.ownerDocument || root, root, // eslint-disable-next-line no-bitwise\n        NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION, null);\n    };\n    /**\n   * _isClobbered\n   *\n   * @param element element to check for clobbering attacks\n   * @return true if clobbered, false if safe\n   */ const _isClobbered = function _isClobbered(element) {\n        return element instanceof HTMLFormElement && (typeof element.nodeName !== \"string\" || typeof element.textContent !== \"string\" || typeof element.removeChild !== \"function\" || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== \"function\" || typeof element.setAttribute !== \"function\" || typeof element.namespaceURI !== \"string\" || typeof element.insertBefore !== \"function\" || typeof element.hasChildNodes !== \"function\");\n    };\n    /**\n   * Checks whether the given object is a DOM node.\n   *\n   * @param value object to check whether it's a DOM node\n   * @return true is object is a DOM node\n   */ const _isNode = function _isNode(value) {\n        return typeof Node === \"function\" && value instanceof Node;\n    };\n    function _executeHooks(hooks, currentNode, data) {\n        arrayForEach(hooks, (hook)=>{\n            hook.call(DOMPurify, currentNode, data, CONFIG);\n        });\n    }\n    /**\n   * _sanitizeElements\n   *\n   * @protect nodeName\n   * @protect textContent\n   * @protect removeChild\n   * @param currentNode to check for permission to exist\n   * @return true if node was killed, false if left alive\n   */ const _sanitizeElements = function _sanitizeElements(currentNode) {\n        let content = null;\n        /* Execute a hook if present */ _executeHooks(hooks.beforeSanitizeElements, currentNode, null);\n        /* Check if element is clobbered or can clobber */ if (_isClobbered(currentNode)) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Now let's check the element's type and name */ const tagName = transformCaseFunc(currentNode.nodeName);\n        /* Execute a hook if present */ _executeHooks(hooks.uponSanitizeElement, currentNode, {\n            tagName,\n            allowedTags: ALLOWED_TAGS\n        });\n        /* Detect mXSS attempts abusing namespace confusion */ if (SAFE_FOR_XML && currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\\w!]/g, currentNode.innerHTML) && regExpTest(/<[/\\w!]/g, currentNode.textContent)) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Remove any occurrence of processing instructions */ if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Remove any kind of possibly harmful comments */ if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\\w]/g, currentNode.data)) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Remove element if anything forbids its presence */ if (!(EXTRA_ELEMENT_HANDLING.tagCheck instanceof Function && EXTRA_ELEMENT_HANDLING.tagCheck(tagName)) && (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName])) {\n            /* Check if we have a custom element to handle */ if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {\n                if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {\n                    return false;\n                }\n                if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {\n                    return false;\n                }\n            }\n            /* Keep content except for bad-listed elements */ if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n                const parentNode = getParentNode(currentNode) || currentNode.parentNode;\n                const childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n                if (childNodes && parentNode) {\n                    const childCount = childNodes.length;\n                    for(let i = childCount - 1; i >= 0; --i){\n                        const childClone = cloneNode(childNodes[i], true);\n                        childClone.__removalCount = (currentNode.__removalCount || 0) + 1;\n                        parentNode.insertBefore(childClone, getNextSibling(currentNode));\n                    }\n                }\n            }\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Check whether element has a valid namespace */ if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Make sure that older browsers don't get fallback-tag mXSS */ if ((tagName === \"noscript\" || tagName === \"noembed\" || tagName === \"noframes\") && regExpTest(/<\\/no(script|embed|frames)/i, currentNode.innerHTML)) {\n            _forceRemove(currentNode);\n            return true;\n        }\n        /* Sanitize element content to be template-safe */ if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {\n            /* Get the element's text content */ content = currentNode.textContent;\n            arrayForEach([\n                MUSTACHE_EXPR,\n                ERB_EXPR,\n                TMPLIT_EXPR\n            ], (expr)=>{\n                content = stringReplace(content, expr, \" \");\n            });\n            if (currentNode.textContent !== content) {\n                arrayPush(DOMPurify.removed, {\n                    element: currentNode.cloneNode()\n                });\n                currentNode.textContent = content;\n            }\n        }\n        /* Execute a hook if present */ _executeHooks(hooks.afterSanitizeElements, currentNode, null);\n        return false;\n    };\n    /**\n   * _isValidAttribute\n   *\n   * @param lcTag Lowercase tag name of containing element.\n   * @param lcName Lowercase attribute name.\n   * @param value Attribute value.\n   * @return Returns true if `value` is valid, otherwise false.\n   */ // eslint-disable-next-line complexity\n    const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n        /* Make sure attribute cannot clobber */ if (SANITIZE_DOM && (lcName === \"id\" || lcName === \"name\") && (value in document || value in formElement)) {\n            return false;\n        }\n        /* Allow valid data-* attributes: At least one character after \"-\"\n        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n        We don't need to check the value; it's always URI safe. */ if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ;\n        else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ;\n        else if (EXTRA_ELEMENT_HANDLING.attributeCheck instanceof Function && EXTRA_ELEMENT_HANDLING.attributeCheck(lcName, lcTag)) ;\n        else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n            if (// First condition does a very basic check if a) it's basically a valid custom element tagname AND\n            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck\n            _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName, lcTag)) || // Alternative, second condition checks if it's an `is`-attribute, AND\n            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n            lcName === \"is\" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ;\n            else {\n                return false;\n            }\n        /* Check value is safe. First, is attr inert? If so, is safe */ } else if (URI_SAFE_ATTRIBUTES[lcName]) ;\n        else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, \"\"))) ;\n        else if ((lcName === \"src\" || lcName === \"xlink:href\" || lcName === \"href\") && lcTag !== \"script\" && stringIndexOf(value, \"data:\") === 0 && DATA_URI_TAGS[lcTag]) ;\n        else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, \"\"))) ;\n        else if (value) {\n            return false;\n        } else ;\n        return true;\n    };\n    /**\n   * _isBasicCustomElement\n   * checks if at least one dash is included in tagName, and it's not the first char\n   * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name\n   *\n   * @param tagName name of the tag of the node to sanitize\n   * @returns Returns true if the tag name meets the basic criteria for a custom element, otherwise false.\n   */ const _isBasicCustomElement = function _isBasicCustomElement(tagName) {\n        return tagName !== \"annotation-xml\" && stringMatch(tagName, CUSTOM_ELEMENT);\n    };\n    /**\n   * _sanitizeAttributes\n   *\n   * @protect attributes\n   * @protect nodeName\n   * @protect removeAttribute\n   * @protect setAttribute\n   *\n   * @param currentNode to sanitize\n   */ const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n        /* Execute a hook if present */ _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);\n        const { attributes } = currentNode;\n        /* Check if we have attributes; if not we might have a text node */ if (!attributes || _isClobbered(currentNode)) {\n            return;\n        }\n        const hookEvent = {\n            attrName: \"\",\n            attrValue: \"\",\n            keepAttr: true,\n            allowedAttributes: ALLOWED_ATTR,\n            forceKeepAttr: undefined\n        };\n        let l = attributes.length;\n        /* Go backwards over all attributes; safely remove bad ones */ while(l--){\n            const attr = attributes[l];\n            const { name, namespaceURI, value: attrValue } = attr;\n            const lcName = transformCaseFunc(name);\n            const initValue = attrValue;\n            let value = name === \"value\" ? initValue : stringTrim(initValue);\n            /* Execute a hook if present */ hookEvent.attrName = lcName;\n            hookEvent.attrValue = value;\n            hookEvent.keepAttr = true;\n            hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n            _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);\n            value = hookEvent.attrValue;\n            /* Full DOM Clobbering protection via namespace isolation,\n       * Prefix id and name attributes with `user-content-`\n       */ if (SANITIZE_NAMED_PROPS && (lcName === \"id\" || lcName === \"name\")) {\n                // Remove the attribute with this value\n                _removeAttribute(name, currentNode);\n                // Prefix the value and later re-create the attribute with the sanitized value\n                value = SANITIZE_NAMED_PROPS_PREFIX + value;\n            }\n            /* Work around a security issue with comments inside attributes */ if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\\/(style|title|textarea)/i, value)) {\n                _removeAttribute(name, currentNode);\n                continue;\n            }\n            /* Make sure we cannot easily use animated hrefs, even if animations are allowed */ if (lcName === \"attributename\" && stringMatch(value, \"href\")) {\n                _removeAttribute(name, currentNode);\n                continue;\n            }\n            /* Did the hooks approve of the attribute? */ if (hookEvent.forceKeepAttr) {\n                continue;\n            }\n            /* Did the hooks approve of the attribute? */ if (!hookEvent.keepAttr) {\n                _removeAttribute(name, currentNode);\n                continue;\n            }\n            /* Work around a security issue in jQuery 3.0 */ if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\\/>/i, value)) {\n                _removeAttribute(name, currentNode);\n                continue;\n            }\n            /* Sanitize attribute content to be template-safe */ if (SAFE_FOR_TEMPLATES) {\n                arrayForEach([\n                    MUSTACHE_EXPR,\n                    ERB_EXPR,\n                    TMPLIT_EXPR\n                ], (expr)=>{\n                    value = stringReplace(value, expr, \" \");\n                });\n            }\n            /* Is `value` valid for this attribute? */ const lcTag = transformCaseFunc(currentNode.nodeName);\n            if (!_isValidAttribute(lcTag, lcName, value)) {\n                _removeAttribute(name, currentNode);\n                continue;\n            }\n            /* Handle attributes that require Trusted Types */ if (trustedTypesPolicy && typeof trustedTypes === \"object\" && typeof trustedTypes.getAttributeType === \"function\") {\n                if (namespaceURI) ;\n                else {\n                    switch(trustedTypes.getAttributeType(lcTag, lcName)){\n                        case \"TrustedHTML\":\n                            {\n                                value = trustedTypesPolicy.createHTML(value);\n                                break;\n                            }\n                        case \"TrustedScriptURL\":\n                            {\n                                value = trustedTypesPolicy.createScriptURL(value);\n                                break;\n                            }\n                    }\n                }\n            }\n            /* Handle invalid data-* attribute set by try-catching it */ if (value !== initValue) {\n                try {\n                    if (namespaceURI) {\n                        currentNode.setAttributeNS(namespaceURI, name, value);\n                    } else {\n                        /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */ currentNode.setAttribute(name, value);\n                    }\n                    if (_isClobbered(currentNode)) {\n                        _forceRemove(currentNode);\n                    } else {\n                        arrayPop(DOMPurify.removed);\n                    }\n                } catch (_) {\n                    _removeAttribute(name, currentNode);\n                }\n            }\n        }\n        /* Execute a hook if present */ _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);\n    };\n    /**\n   * _sanitizeShadowDOM\n   *\n   * @param fragment to iterate over recursively\n   */ const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n        let shadowNode = null;\n        const shadowIterator = _createNodeIterator(fragment);\n        /* Execute a hook if present */ _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);\n        while(shadowNode = shadowIterator.nextNode()){\n            /* Execute a hook if present */ _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);\n            /* Sanitize tags and elements */ _sanitizeElements(shadowNode);\n            /* Check attributes next */ _sanitizeAttributes(shadowNode);\n            /* Deep shadow DOM detected */ if (shadowNode.content instanceof DocumentFragment) {\n                _sanitizeShadowDOM(shadowNode.content);\n            }\n        }\n        /* Execute a hook if present */ _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);\n    };\n    // eslint-disable-next-line complexity\n    DOMPurify.sanitize = function(dirty) {\n        let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let body = null;\n        let importedNode = null;\n        let currentNode = null;\n        let returnNode = null;\n        /* Make sure we have a string to sanitize.\n      DO NOT return early, as this will return the wrong type if\n      the user has requested a DOM object rather than a string */ IS_EMPTY_INPUT = !dirty;\n        if (IS_EMPTY_INPUT) {\n            dirty = \"<!-->\";\n        }\n        /* Stringify, in case dirty is an object */ if (typeof dirty !== \"string\" && !_isNode(dirty)) {\n            if (typeof dirty.toString === \"function\") {\n                dirty = dirty.toString();\n                if (typeof dirty !== \"string\") {\n                    throw typeErrorCreate(\"dirty is not a string, aborting\");\n                }\n            } else {\n                throw typeErrorCreate(\"toString is not a function\");\n            }\n        }\n        /* Return dirty HTML if DOMPurify cannot run */ if (!DOMPurify.isSupported) {\n            return dirty;\n        }\n        /* Assign config vars */ if (!SET_CONFIG) {\n            _parseConfig(cfg);\n        }\n        /* Clean up removed elements */ DOMPurify.removed = [];\n        /* Check if dirty is correctly typed for IN_PLACE */ if (typeof dirty === \"string\") {\n            IN_PLACE = false;\n        }\n        if (IN_PLACE) {\n            /* Do some early pre-sanitization to avoid unsafe root nodes */ if (dirty.nodeName) {\n                const tagName = transformCaseFunc(dirty.nodeName);\n                if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n                    throw typeErrorCreate(\"root node is forbidden and cannot be sanitized in-place\");\n                }\n            }\n        } else if (dirty instanceof Node) {\n            /* If dirty is a DOM element, append to an empty document to avoid\n         elements being stripped by the parser */ body = _initDocument(\"<!---->\");\n            importedNode = body.ownerDocument.importNode(dirty, true);\n            if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === \"BODY\") {\n                /* Node is already a body, use as is */ body = importedNode;\n            } else if (importedNode.nodeName === \"HTML\") {\n                body = importedNode;\n            } else {\n                // eslint-disable-next-line unicorn/prefer-dom-node-append\n                body.appendChild(importedNode);\n            }\n        } else {\n            /* Exit directly if we have nothing to do */ if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes\n            dirty.indexOf(\"<\") === -1) {\n                return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n            }\n            /* Initialize the document to work on */ body = _initDocument(dirty);\n            /* Check we have a DOM node from the data */ if (!body) {\n                return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : \"\";\n            }\n        }\n        /* Remove first element node (ours) if FORCE_BODY is set */ if (body && FORCE_BODY) {\n            _forceRemove(body.firstChild);\n        }\n        /* Get node iterator */ const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);\n        /* Now start iterating over the created document */ while(currentNode = nodeIterator.nextNode()){\n            /* Sanitize tags and elements */ _sanitizeElements(currentNode);\n            /* Check attributes next */ _sanitizeAttributes(currentNode);\n            /* Shadow DOM detected, sanitize it */ if (currentNode.content instanceof DocumentFragment) {\n                _sanitizeShadowDOM(currentNode.content);\n            }\n        }\n        /* If we sanitized `dirty` in-place, return it. */ if (IN_PLACE) {\n            return dirty;\n        }\n        /* Return sanitized string or DOM */ if (RETURN_DOM) {\n            if (RETURN_DOM_FRAGMENT) {\n                returnNode = createDocumentFragment.call(body.ownerDocument);\n                while(body.firstChild){\n                    // eslint-disable-next-line unicorn/prefer-dom-node-append\n                    returnNode.appendChild(body.firstChild);\n                }\n            } else {\n                returnNode = body;\n            }\n            if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {\n                /*\n          AdoptNode() is not used because internal state is not reset\n          (e.g. the past names map of a HTMLFormElement), this is safe\n          in theory but we would rather not risk another attack vector.\n          The state that is cloned by importNode() is explicitly defined\n          by the specs.\n        */ returnNode = importNode.call(originalDocument, returnNode, true);\n            }\n            return returnNode;\n        }\n        let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n        /* Serialize doctype if allowed */ if (WHOLE_DOCUMENT && ALLOWED_TAGS[\"!doctype\"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {\n            serializedHTML = \"<!DOCTYPE \" + body.ownerDocument.doctype.name + \">\\n\" + serializedHTML;\n        }\n        /* Sanitize final string template-safe */ if (SAFE_FOR_TEMPLATES) {\n            arrayForEach([\n                MUSTACHE_EXPR,\n                ERB_EXPR,\n                TMPLIT_EXPR\n            ], (expr)=>{\n                serializedHTML = stringReplace(serializedHTML, expr, \" \");\n            });\n        }\n        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n    };\n    DOMPurify.setConfig = function() {\n        let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        _parseConfig(cfg);\n        SET_CONFIG = true;\n    };\n    DOMPurify.clearConfig = function() {\n        CONFIG = null;\n        SET_CONFIG = false;\n    };\n    DOMPurify.isValidAttribute = function(tag, attr, value) {\n        /* Initialize shared config vars if necessary. */ if (!CONFIG) {\n            _parseConfig({});\n        }\n        const lcTag = transformCaseFunc(tag);\n        const lcName = transformCaseFunc(attr);\n        return _isValidAttribute(lcTag, lcName, value);\n    };\n    DOMPurify.addHook = function(entryPoint, hookFunction) {\n        if (typeof hookFunction !== \"function\") {\n            return;\n        }\n        arrayPush(hooks[entryPoint], hookFunction);\n    };\n    DOMPurify.removeHook = function(entryPoint, hookFunction) {\n        if (hookFunction !== undefined) {\n            const index = arrayLastIndexOf(hooks[entryPoint], hookFunction);\n            return index === -1 ? undefined : arraySplice(hooks[entryPoint], index, 1)[0];\n        }\n        return arrayPop(hooks[entryPoint]);\n    };\n    DOMPurify.removeHooks = function(entryPoint) {\n        hooks[entryPoint] = [];\n    };\n    DOMPurify.removeAllHooks = function() {\n        hooks = _createHooksMap();\n    };\n    return DOMPurify;\n}\nvar purify = createDOMPurify();\n //# sourceMappingURL=purify.es.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZG9tcHVyaWZ5L2Rpc3QvcHVyaWZ5LmVzLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEseUxBQXlMLEdBRXpMLE1BQU0sRUFDSkEsT0FBTyxFQUNQQyxjQUFjLEVBQ2RDLFFBQVEsRUFDUkMsY0FBYyxFQUNkQyx3QkFBd0IsRUFDekIsR0FBR0M7QUFDSixJQUFJLEVBQ0ZDLE1BQU0sRUFDTkMsSUFBSSxFQUNKQyxNQUFNLEVBQ1AsR0FBR0gsUUFBUSxnREFBZ0Q7QUFDNUQsSUFBSSxFQUNGSSxLQUFLLEVBQ0xDLFNBQVMsRUFDVixHQUFHLE9BQU9DLFlBQVksZUFBZUE7QUFDdEMsSUFBSSxDQUFDTCxRQUFRO0lBQ1hBLFNBQVMsU0FBU0EsT0FBT00sQ0FBQztRQUN4QixPQUFPQTtJQUNUO0FBQ0Y7QUFDQSxJQUFJLENBQUNMLE1BQU07SUFDVEEsT0FBTyxTQUFTQSxLQUFLSyxDQUFDO1FBQ3BCLE9BQU9BO0lBQ1Q7QUFDRjtBQUNBLElBQUksQ0FBQ0gsT0FBTztJQUNWQSxRQUFRLFNBQVNBLE1BQU1JLElBQUksRUFBRUMsT0FBTztRQUNsQyxJQUFLLElBQUlDLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsT0FBTyxJQUFJQyxNQUFNSixPQUFPLElBQUlBLE9BQU8sSUFBSSxJQUFJSyxPQUFPLEdBQUdBLE9BQU9MLE1BQU1LLE9BQVE7WUFDMUdGLElBQUksQ0FBQ0UsT0FBTyxFQUFFLEdBQUdKLFNBQVMsQ0FBQ0ksS0FBSztRQUNsQztRQUNBLE9BQU9QLEtBQUtKLEtBQUssQ0FBQ0ssU0FBU0k7SUFDN0I7QUFDRjtBQUNBLElBQUksQ0FBQ1IsV0FBVztJQUNkQSxZQUFZLFNBQVNBLFVBQVVXLElBQUk7UUFDakMsSUFBSyxJQUFJQyxRQUFRTixVQUFVQyxNQUFNLEVBQUVDLE9BQU8sSUFBSUMsTUFBTUcsUUFBUSxJQUFJQSxRQUFRLElBQUksSUFBSUMsUUFBUSxHQUFHQSxRQUFRRCxPQUFPQyxRQUFTO1lBQ2pITCxJQUFJLENBQUNL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QyxFQUFFO1FBQy9FO1FBQ0EsT0FBT3pDLFNBQVN1SixLQUFLLENBQUNxSyxXQUFXO0lBQ25DO0lBQ0F2TSxVQUFVME0sV0FBVyxHQUFHLFNBQVVILFVBQVU7UUFDMUNySyxLQUFLLENBQUNxSyxXQUFXLEdBQUcsRUFBRTtJQUN4QjtJQUNBdk0sVUFBVTJNLGNBQWMsR0FBRztRQUN6QnpLLFFBQVE3QztJQUNWO0lBQ0EsT0FBT1c7QUFDVDtBQUNBLElBQUk0TSxTQUFTN007QUFFZ0IsQ0FDN0Isc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktcG0tYWdlbnQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZG9tcHVyaWZ5L2Rpc3QvcHVyaWZ5LmVzLm1qcz8xNGNhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBAbGljZW5zZSBET01QdXJpZnkgMy4zLjEgfCAoYykgQ3VyZTUzIGFuZCBvdGhlciBjb250cmlidXRvcnMgfCBSZWxlYXNlZCB1bmRlciB0aGUgQXBhY2hlIGxpY2Vuc2UgMi4wIGFuZCBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlIDIuMCB8IGdpdGh1Yi5jb20vY3VyZTUzL0RPTVB1cmlmeS9ibG9iLzMuMy4xL0xJQ0VOU0UgKi9cblxuY29uc3Qge1xuICBlbnRyaWVzLFxuICBzZXRQcm90b3R5cGVPZixcbiAgaXNGcm96ZW4sXG4gIGdldFByb3RvdHlwZU9mLFxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Jcbn0gPSBPYmplY3Q7XG5sZXQge1xuICBmcmVlemUsXG4gIHNlYWwsXG4gIGNyZWF0ZVxufSA9IE9iamVjdDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBpbXBvcnQvbm8tbXV0YWJsZS1leHBvcnRzXG5sZXQge1xuICBhcHBseSxcbiAgY29uc3RydWN0XG59ID0gdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIFJlZmxlY3Q7XG5pZiAoIWZyZWV6ZSkge1xuICBmcmVlemUgPSBmdW5jdGlvbiBmcmVlemUoeCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuaWYgKCFzZWFsKSB7XG4gIHNlYWwgPSBmdW5jdGlvbiBzZWFsKHgpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbmlmICghYXBwbHkpIHtcbiAgYXBwbHkgPSBmdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9O1xufVxuaWYgKCFjb25zdHJ1Y3QpIHtcbiAgY29uc3RydWN0ID0gZnVuY3Rpb24gY29uc3RydWN0KEZ1bmMpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBGdW5jKC4uLmFyZ3MpO1xuICB9O1xufVxuY29uc3QgYXJyYXlGb3JFYWNoID0gdW5hcHBseShBcnJheS5wcm90b3R5cGUuZm9yRWFjaCk7XG5jb25zdCBhcnJheUxhc3RJbmRleE9mID0gdW5hcHBseShBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YpO1xuY29uc3QgYXJyYXlQb3AgPSB1bmFwcGx5KEFycmF5LnByb3RvdHlwZS5wb3ApO1xuY29uc3QgYXJyYXlQdXNoID0gdW5hcHBseShBcnJheS5wcm90b3R5cGUucHVzaCk7XG5jb25zdCBhcnJheVNwbGljZSA9IHVuYXBwbHkoQXJyYXkucHJvdG90eXBlLnNwbGljZSk7XG5jb25zdCBzdHJpbmdUb0xvd2VyQ2FzZSA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS50b0xvd2VyQ2FzZSk7XG5jb25zdCBzdHJpbmdUb1N0cmluZyA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS50b1N0cmluZyk7XG5jb25zdCBzdHJpbmdNYXRjaCA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS5tYXRjaCk7XG5jb25zdCBzdHJpbmdSZXBsYWNlID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xuY29uc3Qgc3RyaW5nSW5kZXhPZiA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mKTtcbmNvbnN0IHN0cmluZ1RyaW0gPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUudHJpbSk7XG5jb25zdCBvYmplY3RIYXNPd25Qcm9wZXJ0eSA9IHVuYXBwbHkoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5jb25zdCByZWdFeHBUZXN0ID0gdW5hcHBseShSZWdFeHAucHJvdG90eXBlLnRlc3QpO1xuY29uc3QgdHlwZUVycm9yQ3JlYXRlID0gdW5jb25zdHJ1Y3QoVHlwZUVycm9yKTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmdW5jdGlvbiB0aGF0IGNhbGxzIHRoZSBnaXZlbiBmdW5jdGlvbiB3aXRoIGEgc3BlY2lmaWVkIHRoaXNBcmcgYW5kIGFyZ3VtZW50cy5cbiAqXG4gKiBAcGFyYW0gZnVuYyAtIFRoZSBmdW5jdGlvbiB0byBiZSB3cmFwcGVkIGFuZCBjYWxsZWQuXG4gKiBAcmV0dXJucyBBIG5ldyBmdW5jdGlvbiB0aGF0IGNhbGxzIHRoZSBnaXZlbiBmdW5jdGlvbiB3aXRoIGEgc3BlY2lmaWVkIHRoaXNBcmcgYW5kIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gdW5hcHBseShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhpc0FyZykge1xuICAgIGlmICh0aGlzQXJnIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICB0aGlzQXJnLmxhc3RJbmRleCA9IDA7XG4gICAgfVxuICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSwgX2tleTMgPSAxOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICBhcmdzW19rZXkzIC0gMV0gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgIH1cbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncyk7XG4gIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZnVuY3Rpb24gdGhhdCBjb25zdHJ1Y3RzIGFuIGluc3RhbmNlIG9mIHRoZSBnaXZlbiBjb25zdHJ1Y3RvciBmdW5jdGlvbiB3aXRoIHRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gKlxuICogQHBhcmFtIGZ1bmMgLSBUaGUgY29uc3RydWN0b3IgZnVuY3Rpb24gdG8gYmUgd3JhcHBlZCBhbmQgY2FsbGVkLlxuICogQHJldHVybnMgQSBuZXcgZnVuY3Rpb24gdGhhdCBjb25zdHJ1Y3RzIGFuIGluc3RhbmNlIG9mIHRoZSBnaXZlbiBjb25zdHJ1Y3RvciBmdW5jdGlvbiB3aXRoIHRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIHVuY29uc3RydWN0KEZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgIGFyZ3NbX2tleTRdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnN0cnVjdChGdW5jLCBhcmdzKTtcbiAgfTtcbn1cbi8qKlxuICogQWRkIHByb3BlcnRpZXMgdG8gYSBsb29rdXAgdGFibGVcbiAqXG4gKiBAcGFyYW0gc2V0IC0gVGhlIHNldCB0byB3aGljaCBlbGVtZW50cyB3aWxsIGJlIGFkZGVkLlxuICogQHBhcmFtIGFycmF5IC0gVGhlIGFycmF5IGNvbnRhaW5pbmcgZWxlbWVudHMgdG8gYmUgYWRkZWQgdG8gdGhlIHNldC5cbiAqIEBwYXJhbSB0cmFuc2Zvcm1DYXNlRnVuYyAtIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSB0aGUgY2FzZSBvZiBlYWNoIGVsZW1lbnQgYmVmb3JlIGFkZGluZyB0byB0aGUgc2V0LlxuICogQHJldHVybnMgVGhlIG1vZGlmaWVkIHNldCB3aXRoIGFkZGVkIGVsZW1lbnRzLlxuICovXG5mdW5jdGlvbiBhZGRUb1NldChzZXQsIGFycmF5KSB7XG4gIGxldCB0cmFuc2Zvcm1DYXNlRnVuYyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogc3RyaW5nVG9Mb3dlckNhc2U7XG4gIGlmIChzZXRQcm90b3R5cGVPZikge1xuICAgIC8vIE1ha2UgJ2luJyBhbmQgdHJ1dGh5IGNoZWNrcyBsaWtlIEJvb2xlYW4oc2V0LmNvbnN0cnVjdG9yKVxuICAgIC8vIGluZGVwZW5kZW50IG9mIGFueSBwcm9wZXJ0aWVzIGRlZmluZWQgb24gT2JqZWN0LnByb3RvdHlwZS5cbiAgICAvLyBQcmV2ZW50IHByb3RvdHlwZSBzZXR0ZXJzIGZyb20gaW50ZXJjZXB0aW5nIHNldCBhcyBhIHRoaXMgdmFsdWUuXG4gICAgc2V0UHJvdG90eXBlT2Yoc2V0LCBudWxsKTtcbiAgfVxuICBsZXQgbCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGwtLSkge1xuICAgIGxldCBlbGVtZW50ID0gYXJyYXlbbF07XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgbGNFbGVtZW50ID0gdHJhbnNmb3JtQ2FzZUZ1bmMoZWxlbWVudCk7XG4gICAgICBpZiAobGNFbGVtZW50ICE9PSBlbGVtZW50KSB7XG4gICAgICAgIC8vIENvbmZpZyBwcmVzZXRzIChlLmcuIHRhZ3MuanMsIGF0dHJzLmpzKSBhcmUgaW1tdXRhYmxlLlxuICAgICAgICBpZiAoIWlzRnJvemVuKGFycmF5KSkge1xuICAgICAgICAgIGFycmF5W2xdID0gbGNFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnQgPSBsY0VsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHNldFtlbGVtZW50XSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHNldDtcbn1cbi8qKlxuICogQ2xlYW4gdXAgYW4gYXJyYXkgdG8gaGFyZGVuIGFnYWluc3QgQ1NQUFxuICpcbiAqIEBwYXJhbSBhcnJheSAtIFRoZSBhcnJheSB0byBiZSBjbGVhbmVkLlxuICogQHJldHVybnMgVGhlIGNsZWFuZWQgdmVyc2lvbiBvZiB0aGUgYXJyYXlcbiAqL1xuZnVuY3Rpb24gY2xlYW5BcnJheShhcnJheSkge1xuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYXJyYXkubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3QgaXNQcm9wZXJ0eUV4aXN0ID0gb2JqZWN0SGFzT3duUHJvcGVydHkoYXJyYXksIGluZGV4KTtcbiAgICBpZiAoIWlzUHJvcGVydHlFeGlzdCkge1xuICAgICAgYXJyYXlbaW5kZXhdID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuLyoqXG4gKiBTaGFsbG93IGNsb25lIGFuIG9iamVjdFxuICpcbiAqIEBwYXJhbSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIGJlIGNsb25lZC5cbiAqIEByZXR1cm5zIEEgbmV3IG9iamVjdCB0aGF0IGNvcGllcyB0aGUgb3JpZ2luYWwuXG4gKi9cbmZ1bmN0aW9uIGNsb25lKG9iamVjdCkge1xuICBjb25zdCBuZXdPYmplY3QgPSBjcmVhdGUobnVsbCk7XG4gIGZvciAoY29uc3QgW3Byb3BlcnR5LCB2YWx1ZV0gb2YgZW50cmllcyhvYmplY3QpKSB7XG4gICAgY29uc3QgaXNQcm9wZXJ0eUV4aXN0ID0gb2JqZWN0SGFzT3duUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSk7XG4gICAgaWYgKGlzUHJvcGVydHlFeGlzdCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIG5ld09iamVjdFtwcm9wZXJ0eV0gPSBjbGVhbkFycmF5KHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgIG5ld09iamVjdFtwcm9wZXJ0eV0gPSBjbG9uZSh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdPYmplY3RbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdPYmplY3Q7XG59XG4vKipcbiAqIFRoaXMgbWV0aG9kIGF1dG9tYXRpY2FsbHkgY2hlY2tzIGlmIHRoZSBwcm9wIGlzIGZ1bmN0aW9uIG9yIGdldHRlciBhbmQgYmVoYXZlcyBhY2NvcmRpbmdseS5cbiAqXG4gKiBAcGFyYW0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byBsb29rIHVwIHRoZSBnZXR0ZXIgZnVuY3Rpb24gaW4gaXRzIHByb3RvdHlwZSBjaGFpbi5cbiAqIEBwYXJhbSBwcm9wIC0gVGhlIHByb3BlcnR5IG5hbWUgZm9yIHdoaWNoIHRvIGZpbmQgdGhlIGdldHRlciBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIFRoZSBnZXR0ZXIgZnVuY3Rpb24gZm91bmQgaW4gdGhlIHByb3RvdHlwZSBjaGFpbiBvciBhIGZhbGxiYWNrIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBsb29rdXBHZXR0ZXIob2JqZWN0LCBwcm9wKSB7XG4gIHdoaWxlIChvYmplY3QgIT09IG51bGwpIHtcbiAgICBjb25zdCBkZXNjID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcCk7XG4gICAgaWYgKGRlc2MpIHtcbiAgICAgIGlmIChkZXNjLmdldCkge1xuICAgICAgICByZXR1cm4gdW5hcHBseShkZXNjLmdldCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGRlc2MudmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHVuYXBwbHkoZGVzYy52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gIH1cbiAgZnVuY3Rpb24gZmFsbGJhY2tWYWx1ZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gZmFsbGJhY2tWYWx1ZTtcbn1cblxuY29uc3QgaHRtbCQxID0gZnJlZXplKFsnYScsICdhYmJyJywgJ2Fjcm9ueW0nLCAnYWRkcmVzcycsICdhcmVhJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYXVkaW8nLCAnYicsICdiZGknLCAnYmRvJywgJ2JpZycsICdibGluaycsICdibG9ja3F1b3RlJywgJ2JvZHknLCAnYnInLCAnYnV0dG9uJywgJ2NhbnZhcycsICdjYXB0aW9uJywgJ2NlbnRlcicsICdjaXRlJywgJ2NvZGUnLCAnY29sJywgJ2NvbGdyb3VwJywgJ2NvbnRlbnQnLCAnZGF0YScsICdkYXRhbGlzdCcsICdkZCcsICdkZWNvcmF0b3InLCAnZGVsJywgJ2RldGFpbHMnLCAnZGZuJywgJ2RpYWxvZycsICdkaXInLCAnZGl2JywgJ2RsJywgJ2R0JywgJ2VsZW1lbnQnLCAnZW0nLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9udCcsICdmb290ZXInLCAnZm9ybScsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkJywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnaHInLCAnaHRtbCcsICdpJywgJ2ltZycsICdpbnB1dCcsICdpbnMnLCAna2JkJywgJ2xhYmVsJywgJ2xlZ2VuZCcsICdsaScsICdtYWluJywgJ21hcCcsICdtYXJrJywgJ21hcnF1ZWUnLCAnbWVudScsICdtZW51aXRlbScsICdtZXRlcicsICduYXYnLCAnbm9icicsICdvbCcsICdvcHRncm91cCcsICdvcHRpb24nLCAnb3V0cHV0JywgJ3AnLCAncGljdHVyZScsICdwcmUnLCAncHJvZ3Jlc3MnLCAncScsICdycCcsICdydCcsICdydWJ5JywgJ3MnLCAnc2FtcCcsICdzZWFyY2gnLCAnc2VjdGlvbicsICdzZWxlY3QnLCAnc2hhZG93JywgJ3Nsb3QnLCAnc21hbGwnLCAnc291cmNlJywgJ3NwYWNlcicsICdzcGFuJywgJ3N0cmlrZScsICdzdHJvbmcnLCAnc3R5bGUnLCAnc3ViJywgJ3N1bW1hcnknLCAnc3VwJywgJ3RhYmxlJywgJ3Rib2R5JywgJ3RkJywgJ3RlbXBsYXRlJywgJ3RleHRhcmVhJywgJ3Rmb290JywgJ3RoJywgJ3RoZWFkJywgJ3RpbWUnLCAndHInLCAndHJhY2snLCAndHQnLCAndScsICd1bCcsICd2YXInLCAndmlkZW8nLCAnd2JyJ10pO1xuY29uc3Qgc3ZnJDEgPSBmcmVlemUoWydzdmcnLCAnYScsICdhbHRnbHlwaCcsICdhbHRnbHlwaGRlZicsICdhbHRnbHlwaGl0ZW0nLCAnYW5pbWF0ZWNvbG9yJywgJ2FuaW1hdGVtb3Rpb24nLCAnYW5pbWF0ZXRyYW5zZm9ybScsICdjaXJjbGUnLCAnY2xpcHBhdGgnLCAnZGVmcycsICdkZXNjJywgJ2VsbGlwc2UnLCAnZW50ZXJrZXloaW50JywgJ2V4cG9ydHBhcnRzJywgJ2ZpbHRlcicsICdmb250JywgJ2cnLCAnZ2x5cGgnLCAnZ2x5cGhyZWYnLCAnaGtlcm4nLCAnaW1hZ2UnLCAnaW5wdXRtb2RlJywgJ2xpbmUnLCAnbGluZWFyZ3JhZGllbnQnLCAnbWFya2VyJywgJ21hc2snLCAnbWV0YWRhdGEnLCAnbXBhdGgnLCAncGFydCcsICdwYXRoJywgJ3BhdHRlcm4nLCAncG9seWdvbicsICdwb2x5bGluZScsICdyYWRpYWxncmFkaWVudCcsICdyZWN0JywgJ3N0b3AnLCAnc3R5bGUnLCAnc3dpdGNoJywgJ3N5bWJvbCcsICd0ZXh0JywgJ3RleHRwYXRoJywgJ3RpdGxlJywgJ3RyZWYnLCAndHNwYW4nLCAndmlldycsICd2a2VybiddKTtcbmNvbnN0IHN2Z0ZpbHRlcnMgPSBmcmVlemUoWydmZUJsZW5kJywgJ2ZlQ29sb3JNYXRyaXgnLCAnZmVDb21wb25lbnRUcmFuc2ZlcicsICdmZUNvbXBvc2l0ZScsICdmZUNvbnZvbHZlTWF0cml4JywgJ2ZlRGlmZnVzZUxpZ2h0aW5nJywgJ2ZlRGlzcGxhY2VtZW50TWFwJywgJ2ZlRGlzdGFudExpZ2h0JywgJ2ZlRHJvcFNoYWRvdycsICdmZUZsb29kJywgJ2ZlRnVuY0EnLCAnZmVGdW5jQicsICdmZUZ1bmNHJywgJ2ZlRnVuY1InLCAnZmVHYXVzc2lhbkJsdXInLCAnZmVJbWFnZScsICdmZU1lcmdlJywgJ2ZlTWVyZ2VOb2RlJywgJ2ZlTW9ycGhvbG9neScsICdmZU9mZnNldCcsICdmZVBvaW50TGlnaHQnLCAnZmVTcGVjdWxhckxpZ2h0aW5nJywgJ2ZlU3BvdExpZ2h0JywgJ2ZlVGlsZScsICdmZVR1cmJ1bGVuY2UnXSk7XG4vLyBMaXN0IG9mIFNWRyBlbGVtZW50cyB0aGF0IGFyZSBkaXNhbGxvd2VkIGJ5IGRlZmF1bHQuXG4vLyBXZSBzdGlsbCBuZWVkIHRvIGtub3cgdGhlbSBzbyB0aGF0IHdlIGNhbiBkbyBuYW1lc3BhY2Vcbi8vIGNoZWNrcyBwcm9wZXJseSBpbiBjYXNlIG9uZSB3YW50cyB0byBhZGQgdGhlbSB0b1xuLy8gYWxsb3ctbGlzdC5cbmNvbnN0IHN2Z0Rpc2FsbG93ZWQgPSBmcmVlemUoWydhbmltYXRlJywgJ2NvbG9yLXByb2ZpbGUnLCAnY3Vyc29yJywgJ2Rpc2NhcmQnLCAnZm9udC1mYWNlJywgJ2ZvbnQtZmFjZS1mb3JtYXQnLCAnZm9udC1mYWNlLW5hbWUnLCAnZm9udC1mYWNlLXNyYycsICdmb250LWZhY2UtdXJpJywgJ2ZvcmVpZ25vYmplY3QnLCAnaGF0Y2gnLCAnaGF0Y2hwYXRoJywgJ21lc2gnLCAnbWVzaGdyYWRpZW50JywgJ21lc2hwYXRjaCcsICdtZXNocm93JywgJ21pc3NpbmctZ2x5cGgnLCAnc2NyaXB0JywgJ3NldCcsICdzb2xpZGNvbG9yJywgJ3Vua25vd24nLCAndXNlJ10pO1xuY29uc3QgbWF0aE1sJDEgPSBmcmVlemUoWydtYXRoJywgJ21lbmNsb3NlJywgJ21lcnJvcicsICdtZmVuY2VkJywgJ21mcmFjJywgJ21nbHlwaCcsICdtaScsICdtbGFiZWxlZHRyJywgJ21tdWx0aXNjcmlwdHMnLCAnbW4nLCAnbW8nLCAnbW92ZXInLCAnbXBhZGRlZCcsICdtcGhhbnRvbScsICdtcm9vdCcsICdtcm93JywgJ21zJywgJ21zcGFjZScsICdtc3FydCcsICdtc3R5bGUnLCAnbXN1YicsICdtc3VwJywgJ21zdWJzdXAnLCAnbXRhYmxlJywgJ210ZCcsICdtdGV4dCcsICdtdHInLCAnbXVuZGVyJywgJ211bmRlcm92ZXInLCAnbXByZXNjcmlwdHMnXSk7XG4vLyBTaW1pbGFybHkgdG8gU1ZHLCB3ZSB3YW50IHRvIGtub3cgYWxsIE1hdGhNTCBlbGVtZW50cyxcbi8vIGV2ZW4gdGhvc2UgdGhhdCB3ZSBkaXNhbGxvdyBieSBkZWZhdWx0LlxuY29uc3QgbWF0aE1sRGlzYWxsb3dlZCA9IGZyZWV6ZShbJ21hY3Rpb24nLCAnbWFsaWduZ3JvdXAnLCAnbWFsaWdubWFyaycsICdtbG9uZ2RpdicsICdtc2NhcnJpZXMnLCAnbXNjYXJyeScsICdtc2dyb3VwJywgJ21zdGFjaycsICdtc2xpbmUnLCAnbXNyb3cnLCAnc2VtYW50aWNzJywgJ2Fubm90YXRpb24nLCAnYW5ub3RhdGlvbi14bWwnLCAnbXByZXNjcmlwdHMnLCAnbm9uZSddKTtcbmNvbnN0IHRleHQgPSBmcmVlemUoWycjdGV4dCddKTtcblxuY29uc3QgaHRtbCA9IGZyZWV6ZShbJ2FjY2VwdCcsICdhY3Rpb24nLCAnYWxpZ24nLCAnYWx0JywgJ2F1dG9jYXBpdGFsaXplJywgJ2F1dG9jb21wbGV0ZScsICdhdXRvcGljdHVyZWlucGljdHVyZScsICdhdXRvcGxheScsICdiYWNrZ3JvdW5kJywgJ2JnY29sb3InLCAnYm9yZGVyJywgJ2NhcHR1cmUnLCAnY2VsbHBhZGRpbmcnLCAnY2VsbHNwYWNpbmcnLCAnY2hlY2tlZCcsICdjaXRlJywgJ2NsYXNzJywgJ2NsZWFyJywgJ2NvbG9yJywgJ2NvbHMnLCAnY29sc3BhbicsICdjb250cm9scycsICdjb250cm9sc2xpc3QnLCAnY29vcmRzJywgJ2Nyb3Nzb3JpZ2luJywgJ2RhdGV0aW1lJywgJ2RlY29kaW5nJywgJ2RlZmF1bHQnLCAnZGlyJywgJ2Rpc2FibGVkJywgJ2Rpc2FibGVwaWN0dXJlaW5waWN0dXJlJywgJ2Rpc2FibGVyZW1vdGVwbGF5YmFjaycsICdkb3dubG9hZCcsICdkcmFnZ2FibGUnLCAnZW5jdHlwZScsICdlbnRlcmtleWhpbnQnLCAnZXhwb3J0cGFydHMnLCAnZmFjZScsICdmb3InLCAnaGVhZGVycycsICdoZWlnaHQnLCAnaGlkZGVuJywgJ2hpZ2gnLCAnaHJlZicsICdocmVmbGFuZycsICdpZCcsICdpbmVydCcsICdpbnB1dG1vZGUnLCAnaW50ZWdyaXR5JywgJ2lzbWFwJywgJ2tpbmQnLCAnbGFiZWwnLCAnbGFuZycsICdsaXN0JywgJ2xvYWRpbmcnLCAnbG9vcCcsICdsb3cnLCAnbWF4JywgJ21heGxlbmd0aCcsICdtZWRpYScsICdtZXRob2QnLCAnbWluJywgJ21pbmxlbmd0aCcsICdtdWx0aXBsZScsICdtdXRlZCcsICduYW1lJywgJ25vbmNlJywgJ25vc2hhZGUnLCAnbm92YWxpZGF0ZScsICdub3dyYXAnLCAnb3BlbicsICdvcHRpbXVtJywgJ3BhcnQnLCAncGF0dGVybicsICdwbGFjZWhvbGRlcicsICdwbGF5c2lubGluZScsICdwb3BvdmVyJywgJ3BvcG92ZXJ0YXJnZXQnLCAncG9wb3ZlcnRhcmdldGFjdGlvbicsICdwb3N0ZXInLCAncHJlbG9hZCcsICdwdWJkYXRlJywgJ3JhZGlvZ3JvdXAnLCAncmVhZG9ubHknLCAncmVsJywgJ3JlcXVpcmVkJywgJ3JldicsICdyZXZlcnNlZCcsICdyb2xlJywgJ3Jvd3MnLCAncm93c3BhbicsICdzcGVsbGNoZWNrJywgJ3Njb3BlJywgJ3NlbGVjdGVkJywgJ3NoYXBlJywgJ3NpemUnLCAnc2l6ZXMnLCAnc2xvdCcsICdzcGFuJywgJ3NyY2xhbmcnLCAnc3RhcnQnLCAnc3JjJywgJ3NyY3NldCcsICdzdGVwJywgJ3N0eWxlJywgJ3N1bW1hcnknLCAndGFiaW5kZXgnLCAndGl0bGUnLCAndHJhbnNsYXRlJywgJ3R5cGUnLCAndXNlbWFwJywgJ3ZhbGlnbicsICd2YWx1ZScsICd3aWR0aCcsICd3cmFwJywgJ3htbG5zJywgJ3Nsb3QnXSk7XG5jb25zdCBzdmcgPSBmcmVlemUoWydhY2NlbnQtaGVpZ2h0JywgJ2FjY3VtdWxhdGUnLCAnYWRkaXRpdmUnLCAnYWxpZ25tZW50LWJhc2VsaW5lJywgJ2FtcGxpdHVkZScsICdhc2NlbnQnLCAnYXR0cmlidXRlbmFtZScsICdhdHRyaWJ1dGV0eXBlJywgJ2F6aW11dGgnLCAnYmFzZWZyZXF1ZW5jeScsICdiYXNlbGluZS1zaGlmdCcsICdiZWdpbicsICdiaWFzJywgJ2J5JywgJ2NsYXNzJywgJ2NsaXAnLCAnY2xpcHBhdGh1bml0cycsICdjbGlwLXBhdGgnLCAnY2xpcC1ydWxlJywgJ2NvbG9yJywgJ2NvbG9yLWludGVycG9sYXRpb24nLCAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2NvbG9yLXByb2ZpbGUnLCAnY29sb3ItcmVuZGVyaW5nJywgJ2N4JywgJ2N5JywgJ2QnLCAnZHgnLCAnZHknLCAnZGlmZnVzZWNvbnN0YW50JywgJ2RpcmVjdGlvbicsICdkaXNwbGF5JywgJ2Rpdmlzb3InLCAnZHVyJywgJ2VkZ2Vtb2RlJywgJ2VsZXZhdGlvbicsICdlbmQnLCAnZXhwb25lbnQnLCAnZmlsbCcsICdmaWxsLW9wYWNpdHknLCAnZmlsbC1ydWxlJywgJ2ZpbHRlcicsICdmaWx0ZXJ1bml0cycsICdmbG9vZC1jb2xvcicsICdmbG9vZC1vcGFjaXR5JywgJ2ZvbnQtZmFtaWx5JywgJ2ZvbnQtc2l6ZScsICdmb250LXNpemUtYWRqdXN0JywgJ2ZvbnQtc3RyZXRjaCcsICdmb250LXN0eWxlJywgJ2ZvbnQtdmFyaWFudCcsICdmb250LXdlaWdodCcsICdmeCcsICdmeScsICdnMScsICdnMicsICdnbHlwaC1uYW1lJywgJ2dseXBocmVmJywgJ2dyYWRpZW50dW5pdHMnLCAnZ3JhZGllbnR0cmFuc2Zvcm0nLCAnaGVpZ2h0JywgJ2hyZWYnLCAnaWQnLCAnaW1hZ2UtcmVuZGVyaW5nJywgJ2luJywgJ2luMicsICdpbnRlcmNlcHQnLCAnaycsICdrMScsICdrMicsICdrMycsICdrNCcsICdrZXJuaW5nJywgJ2tleXBvaW50cycsICdrZXlzcGxpbmVzJywgJ2tleXRpbWVzJywgJ2xhbmcnLCAnbGVuZ3RoYWRqdXN0JywgJ2xldHRlci1zcGFjaW5nJywgJ2tlcm5lbG1hdHJpeCcsICdrZXJuZWx1bml0bGVuZ3RoJywgJ2xpZ2h0aW5nLWNvbG9yJywgJ2xvY2FsJywgJ21hcmtlci1lbmQnLCAnbWFya2VyLW1pZCcsICdtYXJrZXItc3RhcnQnLCAnbWFya2VyaGVpZ2h0JywgJ21hcmtlcnVuaXRzJywgJ21hcmtlcndpZHRoJywgJ21hc2tjb250ZW50dW5pdHMnLCAnbWFza3VuaXRzJywgJ21heCcsICdtYXNrJywgJ21hc2stdHlwZScsICdtZWRpYScsICdtZXRob2QnLCAnbW9kZScsICdtaW4nLCAnbmFtZScsICdudW1vY3RhdmVzJywgJ29mZnNldCcsICdvcGVyYXRvcicsICdvcGFjaXR5JywgJ29yZGVyJywgJ29yaWVudCcsICdvcmllbnRhdGlvbicsICdvcmlnaW4nLCAnb3ZlcmZsb3cnLCAncGFpbnQtb3JkZXInLCAncGF0aCcsICdwYXRobGVuZ3RoJywgJ3BhdHRlcm5jb250ZW50dW5pdHMnLCAncGF0dGVybnRyYW5zZm9ybScsICdwYXR0ZXJudW5pdHMnLCAncG9pbnRzJywgJ3ByZXNlcnZlYWxwaGEnLCAncHJlc2VydmVhc3BlY3RyYXRpbycsICdwcmltaXRpdmV1bml0cycsICdyJywgJ3J4JywgJ3J5JywgJ3JhZGl1cycsICdyZWZ4JywgJ3JlZnknLCAncmVwZWF0Y291bnQnLCAncmVwZWF0ZHVyJywgJ3Jlc3RhcnQnLCAncmVzdWx0JywgJ3JvdGF0ZScsICdzY2FsZScsICdzZWVkJywgJ3NoYXBlLXJlbmRlcmluZycsICdzbG9wZScsICdzcGVjdWxhcmNvbnN0YW50JywgJ3NwZWN1bGFyZXhwb25lbnQnLCAnc3ByZWFkbWV0aG9kJywgJ3N0YXJ0b2Zmc2V0JywgJ3N0ZGRldmlhdGlvbicsICdzdGl0Y2h0aWxlcycsICdzdG9wLWNvbG9yJywgJ3N0b3Atb3BhY2l0eScsICdzdHJva2UtZGFzaGFycmF5JywgJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ3N0cm9rZS1saW5lY2FwJywgJ3N0cm9rZS1saW5lam9pbicsICdzdHJva2UtbWl0ZXJsaW1pdCcsICdzdHJva2Utb3BhY2l0eScsICdzdHJva2UnLCAnc3Ryb2tlLXdpZHRoJywgJ3N0eWxlJywgJ3N1cmZhY2VzY2FsZScsICdzeXN0ZW1sYW5ndWFnZScsICd0YWJpbmRleCcsICd0YWJsZXZhbHVlcycsICd0YXJnZXR4JywgJ3RhcmdldHknLCAndHJhbnNmb3JtJywgJ3RyYW5zZm9ybS1vcmlnaW4nLCAndGV4dC1hbmNob3InLCAndGV4dC1kZWNvcmF0aW9uJywgJ3RleHQtcmVuZGVyaW5nJywgJ3RleHRsZW5ndGgnLCAndHlwZScsICd1MScsICd1MicsICd1bmljb2RlJywgJ3ZhbHVlcycsICd2aWV3Ym94JywgJ3Zpc2liaWxpdHknLCAndmVyc2lvbicsICd2ZXJ0LWFkdi15JywgJ3ZlcnQtb3JpZ2luLXgnLCAndmVydC1vcmlnaW4teScsICd3aWR0aCcsICd3b3JkLXNwYWNpbmcnLCAnd3JhcCcsICd3cml0aW5nLW1vZGUnLCAneGNoYW5uZWxzZWxlY3RvcicsICd5Y2hhbm5lbHNlbGVjdG9yJywgJ3gnLCAneDEnLCAneDInLCAneG1sbnMnLCAneScsICd5MScsICd5MicsICd6JywgJ3pvb21hbmRwYW4nXSk7XG5jb25zdCBtYXRoTWwgPSBmcmVlemUoWydhY2NlbnQnLCAnYWNjZW50dW5kZXInLCAnYWxpZ24nLCAnYmV2ZWxsZWQnLCAnY2xvc2UnLCAnY29sdW1uc2FsaWduJywgJ2NvbHVtbmxpbmVzJywgJ2NvbHVtbnNwYW4nLCAnZGVub21hbGlnbicsICdkZXB0aCcsICdkaXInLCAnZGlzcGxheScsICdkaXNwbGF5c3R5bGUnLCAnZW5jb2RpbmcnLCAnZmVuY2UnLCAnZnJhbWUnLCAnaGVpZ2h0JywgJ2hyZWYnLCAnaWQnLCAnbGFyZ2VvcCcsICdsZW5ndGgnLCAnbGluZXRoaWNrbmVzcycsICdsc3BhY2UnLCAnbHF1b3RlJywgJ21hdGhiYWNrZ3JvdW5kJywgJ21hdGhjb2xvcicsICdtYXRoc2l6ZScsICdtYXRodmFyaWFudCcsICdtYXhzaXplJywgJ21pbnNpemUnLCAnbW92YWJsZWxpbWl0cycsICdub3RhdGlvbicsICdudW1hbGlnbicsICdvcGVuJywgJ3Jvd2FsaWduJywgJ3Jvd2xpbmVzJywgJ3Jvd3NwYWNpbmcnLCAncm93c3BhbicsICdyc3BhY2UnLCAncnF1b3RlJywgJ3NjcmlwdGxldmVsJywgJ3NjcmlwdG1pbnNpemUnLCAnc2NyaXB0c2l6ZW11bHRpcGxpZXInLCAnc2VsZWN0aW9uJywgJ3NlcGFyYXRvcicsICdzZXBhcmF0b3JzJywgJ3N0cmV0Y2h5JywgJ3N1YnNjcmlwdHNoaWZ0JywgJ3N1cHNjcmlwdHNoaWZ0JywgJ3N5bW1ldHJpYycsICd2b2Zmc2V0JywgJ3dpZHRoJywgJ3htbG5zJ10pO1xuY29uc3QgeG1sID0gZnJlZXplKFsneGxpbms6aHJlZicsICd4bWw6aWQnLCAneGxpbms6dGl0bGUnLCAneG1sOnNwYWNlJywgJ3htbG5zOnhsaW5rJ10pO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9iZXR0ZXItcmVnZXhcbmNvbnN0IE1VU1RBQ0hFX0VYUFIgPSBzZWFsKC9cXHtcXHtbXFx3XFxXXSp8W1xcd1xcV10qXFx9XFx9L2dtKTsgLy8gU3BlY2lmeSB0ZW1wbGF0ZSBkZXRlY3Rpb24gcmVnZXggZm9yIFNBRkVfRk9SX1RFTVBMQVRFUyBtb2RlXG5jb25zdCBFUkJfRVhQUiA9IHNlYWwoLzwlW1xcd1xcV10qfFtcXHdcXFddKiU+L2dtKTtcbmNvbnN0IFRNUExJVF9FWFBSID0gc2VhbCgvXFwkXFx7W1xcd1xcV10qL2dtKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSB1bmljb3JuL2JldHRlci1yZWdleFxuY29uc3QgREFUQV9BVFRSID0gc2VhbCgvXmRhdGEtW1xcLVxcdy5cXHUwMEI3LVxcdUZGRkZdKyQvKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuY29uc3QgQVJJQV9BVFRSID0gc2VhbCgvXmFyaWEtW1xcLVxcd10rJC8pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG5jb25zdCBJU19BTExPV0VEX1VSSSA9IHNlYWwoL14oPzooPzooPzpmfGh0KXRwcz98bWFpbHRvfHRlbHxjYWxsdG98c21zfGNpZHx4bXBwfG1hdHJpeCk6fFteYS16XXxbYS16Ky5cXC1dKyg/OlteYS16Ky5cXC06XXwkKSkvaSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG4pO1xuY29uc3QgSVNfU0NSSVBUX09SX0RBVEEgPSBzZWFsKC9eKD86XFx3K3NjcmlwdHxkYXRhKTovaSk7XG5jb25zdCBBVFRSX1dISVRFU1BBQ0UgPSBzZWFsKC9bXFx1MDAwMC1cXHUwMDIwXFx1MDBBMFxcdTE2ODBcXHUxODBFXFx1MjAwMC1cXHUyMDI5XFx1MjA1RlxcdTMwMDBdL2cgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb250cm9sLXJlZ2V4XG4pO1xuY29uc3QgRE9DVFlQRV9OQU1FID0gc2VhbCgvXmh0bWwkL2kpO1xuY29uc3QgQ1VTVE9NX0VMRU1FTlQgPSBzZWFsKC9eW2Etel1bLlxcd10qKC1bLlxcd10rKSskL2kpO1xuXG52YXIgRVhQUkVTU0lPTlMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgQVJJQV9BVFRSOiBBUklBX0FUVFIsXG4gIEFUVFJfV0hJVEVTUEFDRTogQVRUUl9XSElURVNQQUNFLFxuICBDVVNUT01fRUxFTUVOVDogQ1VTVE9NX0VMRU1FTlQsXG4gIERBVEFfQVRUUjogREFUQV9BVFRSLFxuICBET0NUWVBFX05BTUU6IERPQ1RZUEVfTkFNRSxcbiAgRVJCX0VYUFI6IEVSQl9FWFBSLFxuICBJU19BTExPV0VEX1VSSTogSVNfQUxMT1dFRF9VUkksXG4gIElTX1NDUklQVF9PUl9EQVRBOiBJU19TQ1JJUFRfT1JfREFUQSxcbiAgTVVTVEFDSEVfRVhQUjogTVVTVEFDSEVfRVhQUixcbiAgVE1QTElUX0VYUFI6IFRNUExJVF9FWFBSXG59KTtcblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2luZGVudCAqL1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05vZGUvbm9kZVR5cGVcbmNvbnN0IE5PREVfVFlQRSA9IHtcbiAgZWxlbWVudDogMSxcbiAgYXR0cmlidXRlOiAyLFxuICB0ZXh0OiAzLFxuICBjZGF0YVNlY3Rpb246IDQsXG4gIGVudGl0eVJlZmVyZW5jZTogNSxcbiAgLy8gRGVwcmVjYXRlZFxuICBlbnRpdHlOb2RlOiA2LFxuICAvLyBEZXByZWNhdGVkXG4gIHByb2dyZXNzaW5nSW5zdHJ1Y3Rpb246IDcsXG4gIGNvbW1lbnQ6IDgsXG4gIGRvY3VtZW50OiA5LFxuICBkb2N1bWVudFR5cGU6IDEwLFxuICBkb2N1bWVudEZyYWdtZW50OiAxMSxcbiAgbm90YXRpb246IDEyIC8vIERlcHJlY2F0ZWRcbn07XG5jb25zdCBnZXRHbG9iYWwgPSBmdW5jdGlvbiBnZXRHbG9iYWwoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3c7XG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgbm8tb3AgcG9saWN5IGZvciBpbnRlcm5hbCB1c2Ugb25seS5cbiAqIERvbid0IGV4cG9ydCB0aGlzIGZ1bmN0aW9uIG91dHNpZGUgdGhpcyBtb2R1bGUhXG4gKiBAcGFyYW0gdHJ1c3RlZFR5cGVzIFRoZSBwb2xpY3kgZmFjdG9yeS5cbiAqIEBwYXJhbSBwdXJpZnlIb3N0RWxlbWVudCBUaGUgU2NyaXB0IGVsZW1lbnQgdXNlZCB0byBsb2FkIERPTVB1cmlmeSAodG8gZGV0ZXJtaW5lIHBvbGljeSBuYW1lIHN1ZmZpeCkuXG4gKiBAcmV0dXJuIFRoZSBwb2xpY3kgY3JlYXRlZCAob3IgbnVsbCwgaWYgVHJ1c3RlZCBUeXBlc1xuICogYXJlIG5vdCBzdXBwb3J0ZWQgb3IgY3JlYXRpbmcgdGhlIHBvbGljeSBmYWlsZWQpLlxuICovXG5jb25zdCBfY3JlYXRlVHJ1c3RlZFR5cGVzUG9saWN5ID0gZnVuY3Rpb24gX2NyZWF0ZVRydXN0ZWRUeXBlc1BvbGljeSh0cnVzdGVkVHlwZXMsIHB1cmlmeUhvc3RFbGVtZW50KSB7XG4gIGlmICh0eXBlb2YgdHJ1c3RlZFR5cGVzICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgdHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIEFsbG93IHRoZSBjYWxsZXJzIHRvIGNvbnRyb2wgdGhlIHVuaXF1ZSBwb2xpY3kgbmFtZVxuICAvLyBieSBhZGRpbmcgYSBkYXRhLXR0LXBvbGljeS1zdWZmaXggdG8gdGhlIHNjcmlwdCBlbGVtZW50IHdpdGggdGhlIERPTVB1cmlmeS5cbiAgLy8gUG9saWN5IGNyZWF0aW9uIHdpdGggZHVwbGljYXRlIG5hbWVzIHRocm93cyBpbiBUcnVzdGVkIFR5cGVzLlxuICBsZXQgc3VmZml4ID0gbnVsbDtcbiAgY29uc3QgQVRUUl9OQU1FID0gJ2RhdGEtdHQtcG9saWN5LXN1ZmZpeCc7XG4gIGlmIChwdXJpZnlIb3N0RWxlbWVudCAmJiBwdXJpZnlIb3N0RWxlbWVudC5oYXNBdHRyaWJ1dGUoQVRUUl9OQU1FKSkge1xuICAgIHN1ZmZpeCA9IHB1cmlmeUhvc3RFbGVtZW50LmdldEF0dHJpYnV0ZShBVFRSX05BTUUpO1xuICB9XG4gIGNvbnN0IHBvbGljeU5hbWUgPSAnZG9tcHVyaWZ5JyArIChzdWZmaXggPyAnIycgKyBzdWZmaXggOiAnJyk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3kocG9saWN5TmFtZSwge1xuICAgICAgY3JlYXRlSFRNTChodG1sKSB7XG4gICAgICAgIHJldHVybiBodG1sO1xuICAgICAgfSxcbiAgICAgIGNyZWF0ZVNjcmlwdFVSTChzY3JpcHRVcmwpIHtcbiAgICAgICAgcmV0dXJuIHNjcmlwdFVybDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge1xuICAgIC8vIFBvbGljeSBjcmVhdGlvbiBmYWlsZWQgKG1vc3QgbGlrZWx5IGFub3RoZXIgRE9NUHVyaWZ5IHNjcmlwdCBoYXNcbiAgICAvLyBhbHJlYWR5IHJ1bikuIFNraXAgY3JlYXRpbmcgdGhlIHBvbGljeSwgYXMgdGhpcyB3aWxsIG9ubHkgY2F1c2UgZXJyb3JzXG4gICAgLy8gaWYgVFQgYXJlIGVuZm9yY2VkLlxuICAgIGNvbnNvbGUud2FybignVHJ1c3RlZFR5cGVzIHBvbGljeSAnICsgcG9saWN5TmFtZSArICcgY291bGQgbm90IGJlIGNyZWF0ZWQuJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5jb25zdCBfY3JlYXRlSG9va3NNYXAgPSBmdW5jdGlvbiBfY3JlYXRlSG9va3NNYXAoKSB7XG4gIHJldHVybiB7XG4gICAgYWZ0ZXJTYW5pdGl6ZUF0dHJpYnV0ZXM6IFtdLFxuICAgIGFmdGVyU2FuaXRpemVFbGVtZW50czogW10sXG4gICAgYWZ0ZXJTYW5pdGl6ZVNoYWRvd0RPTTogW10sXG4gICAgYmVmb3JlU2FuaXRpemVBdHRyaWJ1dGVzOiBbXSxcbiAgICBiZWZvcmVTYW5pdGl6ZUVsZW1lbnRzOiBbXSxcbiAgICBiZWZvcmVTYW5pdGl6ZVNoYWRvd0RPTTogW10sXG4gICAgdXBvblNhbml0aXplQXR0cmlidXRlOiBbXSxcbiAgICB1cG9uU2FuaXRpemVFbGVtZW50OiBbXSxcbiAgICB1cG9uU2FuaXRpemVTaGFkb3dOb2RlOiBbXVxuICB9O1xufTtcbmZ1bmN0aW9uIGNyZWF0ZURPTVB1cmlmeSgpIHtcbiAgbGV0IHdpbmRvdyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZ2V0R2xvYmFsKCk7XG4gIGNvbnN0IERPTVB1cmlmeSA9IHJvb3QgPT4gY3JlYXRlRE9NUHVyaWZ5KHJvb3QpO1xuICBET01QdXJpZnkudmVyc2lvbiA9ICczLjMuMSc7XG4gIERPTVB1cmlmeS5yZW1vdmVkID0gW107XG4gIGlmICghd2luZG93IHx8ICF3aW5kb3cuZG9jdW1lbnQgfHwgd2luZG93LmRvY3VtZW50Lm5vZGVUeXBlICE9PSBOT0RFX1RZUEUuZG9jdW1lbnQgfHwgIXdpbmRvdy5FbGVtZW50KSB7XG4gICAgLy8gTm90IHJ1bm5pbmcgaW4gYSBicm93c2VyLCBwcm92aWRlIGEgZmFjdG9yeSBmdW5jdGlvblxuICAgIC8vIHNvIHRoYXQgeW91IGNhbiBwYXNzIHlvdXIgb3duIFdpbmRvd1xuICAgIERPTVB1cmlmeS5pc1N1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHJldHVybiBET01QdXJpZnk7XG4gIH1cbiAgbGV0IHtcbiAgICBkb2N1bWVudFxuICB9ID0gd2luZG93O1xuICBjb25zdCBvcmlnaW5hbERvY3VtZW50ID0gZG9jdW1lbnQ7XG4gIGNvbnN0IGN1cnJlbnRTY3JpcHQgPSBvcmlnaW5hbERvY3VtZW50LmN1cnJlbnRTY3JpcHQ7XG4gIGNvbnN0IHtcbiAgICBEb2N1bWVudEZyYWdtZW50LFxuICAgIEhUTUxUZW1wbGF0ZUVsZW1lbnQsXG4gICAgTm9kZSxcbiAgICBFbGVtZW50LFxuICAgIE5vZGVGaWx0ZXIsXG4gICAgTmFtZWROb2RlTWFwID0gd2luZG93Lk5hbWVkTm9kZU1hcCB8fCB3aW5kb3cuTW96TmFtZWRBdHRyTWFwLFxuICAgIEhUTUxGb3JtRWxlbWVudCxcbiAgICBET01QYXJzZXIsXG4gICAgdHJ1c3RlZFR5cGVzXG4gIH0gPSB3aW5kb3c7XG4gIGNvbnN0IEVsZW1lbnRQcm90b3R5cGUgPSBFbGVtZW50LnByb3RvdHlwZTtcbiAgY29uc3QgY2xvbmVOb2RlID0gbG9va3VwR2V0dGVyKEVsZW1lbnRQcm90b3R5cGUsICdjbG9uZU5vZGUnKTtcbiAgY29uc3QgcmVtb3ZlID0gbG9va3VwR2V0dGVyKEVsZW1lbnRQcm90b3R5cGUsICdyZW1vdmUnKTtcbiAgY29uc3QgZ2V0TmV4dFNpYmxpbmcgPSBsb29rdXBHZXR0ZXIoRWxlbWVudFByb3RvdHlwZSwgJ25leHRTaWJsaW5nJyk7XG4gIGNvbnN0IGdldENoaWxkTm9kZXMgPSBsb29rdXBHZXR0ZXIoRWxlbWVudFByb3RvdHlwZSwgJ2NoaWxkTm9kZXMnKTtcbiAgY29uc3QgZ2V0UGFyZW50Tm9kZSA9IGxvb2t1cEdldHRlcihFbGVtZW50UHJvdG90eXBlLCAncGFyZW50Tm9kZScpO1xuICAvLyBBcyBwZXIgaXNzdWUgIzQ3LCB0aGUgd2ViLWNvbXBvbmVudHMgcmVnaXN0cnkgaXMgaW5oZXJpdGVkIGJ5IGFcbiAgLy8gbmV3IGRvY3VtZW50IGNyZWF0ZWQgdmlhIGNyZWF0ZUhUTUxEb2N1bWVudC4gQXMgcGVyIHRoZSBzcGVjXG4gIC8vIChodHRwOi8vdzNjLmdpdGh1Yi5pby93ZWJjb21wb25lbnRzL3NwZWMvY3VzdG9tLyNjcmVhdGluZy1hbmQtcGFzc2luZy1yZWdpc3RyaWVzKVxuICAvLyBhIG5ldyBlbXB0eSByZWdpc3RyeSBpcyB1c2VkIHdoZW4gY3JlYXRpbmcgYSB0ZW1wbGF0ZSBjb250ZW50cyBvd25lclxuICAvLyBkb2N1bWVudCwgc28gd2UgdXNlIHRoYXQgYXMgb3VyIHBhcmVudCBkb2N1bWVudCB0byBlbnN1cmUgbm90aGluZ1xuICAvLyBpcyBpbmhlcml0ZWQuXG4gIGlmICh0eXBlb2YgSFRNTFRlbXBsYXRlRWxlbWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICBpZiAodGVtcGxhdGUuY29udGVudCAmJiB0ZW1wbGF0ZS5jb250ZW50Lm93bmVyRG9jdW1lbnQpIHtcbiAgICAgIGRvY3VtZW50ID0gdGVtcGxhdGUuY29udGVudC5vd25lckRvY3VtZW50O1xuICAgIH1cbiAgfVxuICBsZXQgdHJ1c3RlZFR5cGVzUG9saWN5O1xuICBsZXQgZW1wdHlIVE1MID0gJyc7XG4gIGNvbnN0IHtcbiAgICBpbXBsZW1lbnRhdGlvbixcbiAgICBjcmVhdGVOb2RlSXRlcmF0b3IsXG4gICAgY3JlYXRlRG9jdW1lbnRGcmFnbWVudCxcbiAgICBnZXRFbGVtZW50c0J5VGFnTmFtZVxuICB9ID0gZG9jdW1lbnQ7XG4gIGNvbnN0IHtcbiAgICBpbXBvcnROb2RlXG4gIH0gPSBvcmlnaW5hbERvY3VtZW50O1xuICBsZXQgaG9va3MgPSBfY3JlYXRlSG9va3NNYXAoKTtcbiAgLyoqXG4gICAqIEV4cG9zZSB3aGV0aGVyIHRoaXMgYnJvd3NlciBzdXBwb3J0cyBydW5uaW5nIHRoZSBmdWxsIERPTVB1cmlmeS5cbiAgICovXG4gIERPTVB1cmlmeS5pc1N1cHBvcnRlZCA9IHR5cGVvZiBlbnRyaWVzID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBnZXRQYXJlbnROb2RlID09PSAnZnVuY3Rpb24nICYmIGltcGxlbWVudGF0aW9uICYmIGltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCAhPT0gdW5kZWZpbmVkO1xuICBjb25zdCB7XG4gICAgTVVTVEFDSEVfRVhQUixcbiAgICBFUkJfRVhQUixcbiAgICBUTVBMSVRfRVhQUixcbiAgICBEQVRBX0FUVFIsXG4gICAgQVJJQV9BVFRSLFxuICAgIElTX1NDUklQVF9PUl9EQVRBLFxuICAgIEFUVFJfV0hJVEVTUEFDRSxcbiAgICBDVVNUT01fRUxFTUVOVFxuICB9ID0gRVhQUkVTU0lPTlM7XG4gIGxldCB7XG4gICAgSVNfQUxMT1dFRF9VUkk6IElTX0FMTE9XRURfVVJJJDFcbiAgfSA9IEVYUFJFU1NJT05TO1xuICAvKipcbiAgICogV2UgY29uc2lkZXIgdGhlIGVsZW1lbnRzIGFuZCBhdHRyaWJ1dGVzIGJlbG93IHRvIGJlIHNhZmUuIElkZWFsbHlcbiAgICogZG9uJ3QgYWRkIGFueSBuZXcgb25lcyBidXQgZmVlbCBmcmVlIHRvIHJlbW92ZSB1bndhbnRlZCBvbmVzLlxuICAgKi9cbiAgLyogYWxsb3dlZCBlbGVtZW50IG5hbWVzICovXG4gIGxldCBBTExPV0VEX1RBR1MgPSBudWxsO1xuICBjb25zdCBERUZBVUxUX0FMTE9XRURfVEFHUyA9IGFkZFRvU2V0KHt9LCBbLi4uaHRtbCQxLCAuLi5zdmckMSwgLi4uc3ZnRmlsdGVycywgLi4ubWF0aE1sJDEsIC4uLnRleHRdKTtcbiAgLyogQWxsb3dlZCBhdHRyaWJ1dGUgbmFtZXMgKi9cbiAgbGV0IEFMTE9XRURfQVRUUiA9IG51bGw7XG4gIGNvbnN0IERFRkFVTFRfQUxMT1dFRF9BVFRSID0gYWRkVG9TZXQoe30sIFsuLi5odG1sLCAuLi5zdmcsIC4uLm1hdGhNbCwgLi4ueG1sXSk7XG4gIC8qXG4gICAqIENvbmZpZ3VyZSBob3cgRE9NUHVyaWZ5IHNob3VsZCBoYW5kbGUgY3VzdG9tIGVsZW1lbnRzIGFuZCB0aGVpciBhdHRyaWJ1dGVzIGFzIHdlbGwgYXMgY3VzdG9taXplZCBidWlsdC1pbiBlbGVtZW50cy5cbiAgICogQHByb3BlcnR5IHtSZWdFeHB8RnVuY3Rpb258bnVsbH0gdGFnTmFtZUNoZWNrIG9uZSBvZiBbbnVsbCwgcmVnZXhQYXR0ZXJuLCBwcmVkaWNhdGVdLiBEZWZhdWx0OiBgbnVsbGAgKGRpc2FsbG93IGFueSBjdXN0b20gZWxlbWVudHMpXG4gICAqIEBwcm9wZXJ0eSB7UmVnRXhwfEZ1bmN0aW9ufG51bGx9IGF0dHJpYnV0ZU5hbWVDaGVjayBvbmUgb2YgW251bGwsIHJlZ2V4UGF0dGVybiwgcHJlZGljYXRlXS4gRGVmYXVsdDogYG51bGxgIChkaXNhbGxvdyBhbnkgYXR0cmlidXRlcyBub3Qgb24gdGhlIGFsbG93IGxpc3QpXG4gICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gYWxsb3dDdXN0b21pemVkQnVpbHRJbkVsZW1lbnRzIGFsbG93IGN1c3RvbSBlbGVtZW50cyBkZXJpdmVkIGZyb20gYnVpbHQtaW5zIGlmIHRoZXkgcGFzcyBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2suIERlZmF1bHQ6IGBmYWxzZWAuXG4gICAqL1xuICBsZXQgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcgPSBPYmplY3Quc2VhbChjcmVhdGUobnVsbCwge1xuICAgIHRhZ05hbWVDaGVjazoge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgfSxcbiAgICBhdHRyaWJ1dGVOYW1lQ2hlY2s6IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH0sXG4gICAgYWxsb3dDdXN0b21pemVkQnVpbHRJbkVsZW1lbnRzOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfVxuICB9KSk7XG4gIC8qIEV4cGxpY2l0bHkgZm9yYmlkZGVuIHRhZ3MgKG92ZXJyaWRlcyBBTExPV0VEX1RBR1MvQUREX1RBR1MpICovXG4gIGxldCBGT1JCSURfVEFHUyA9IG51bGw7XG4gIC8qIEV4cGxpY2l0bHkgZm9yYmlkZGVuIGF0dHJpYnV0ZXMgKG92ZXJyaWRlcyBBTExPV0VEX0FUVFIvQUREX0FUVFIpICovXG4gIGxldCBGT1JCSURfQVRUUiA9IG51bGw7XG4gIC8qIENvbmZpZyBvYmplY3QgdG8gc3RvcmUgQUREX1RBR1MvQUREX0FUVFIgZnVuY3Rpb25zICh3aGVuIHVzZWQgYXMgZnVuY3Rpb25zKSAqL1xuICBjb25zdCBFWFRSQV9FTEVNRU5UX0hBTkRMSU5HID0gT2JqZWN0LnNlYWwoY3JlYXRlKG51bGwsIHtcbiAgICB0YWdDaGVjazoge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgfSxcbiAgICBhdHRyaWJ1dGVDaGVjazoge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgfVxuICB9KSk7XG4gIC8qIERlY2lkZSBpZiBBUklBIGF0dHJpYnV0ZXMgYXJlIG9rYXkgKi9cbiAgbGV0IEFMTE9XX0FSSUFfQVRUUiA9IHRydWU7XG4gIC8qIERlY2lkZSBpZiBjdXN0b20gZGF0YSBhdHRyaWJ1dGVzIGFyZSBva2F5ICovXG4gIGxldCBBTExPV19EQVRBX0FUVFIgPSB0cnVlO1xuICAvKiBEZWNpZGUgaWYgdW5rbm93biBwcm90b2NvbHMgYXJlIG9rYXkgKi9cbiAgbGV0IEFMTE9XX1VOS05PV05fUFJPVE9DT0xTID0gZmFsc2U7XG4gIC8qIERlY2lkZSBpZiBzZWxmLWNsb3NpbmcgdGFncyBpbiBhdHRyaWJ1dGVzIGFyZSBhbGxvd2VkLlxuICAgKiBVc3VhbGx5IHJlbW92ZWQgZHVlIHRvIGEgbVhTUyBpc3N1ZSBpbiBqUXVlcnkgMy4wICovXG4gIGxldCBBTExPV19TRUxGX0NMT1NFX0lOX0FUVFIgPSB0cnVlO1xuICAvKiBPdXRwdXQgc2hvdWxkIGJlIHNhZmUgZm9yIGNvbW1vbiB0ZW1wbGF0ZSBlbmdpbmVzLlxuICAgKiBUaGlzIG1lYW5zLCBET01QdXJpZnkgcmVtb3ZlcyBkYXRhIGF0dHJpYnV0ZXMsIG11c3RhY2hlcyBhbmQgRVJCXG4gICAqL1xuICBsZXQgU0FGRV9GT1JfVEVNUExBVEVTID0gZmFsc2U7XG4gIC8qIE91dHB1dCBzaG91bGQgYmUgc2FmZSBldmVuIGZvciBYTUwgdXNlZCB3aXRoaW4gSFRNTCBhbmQgYWxpa2UuXG4gICAqIFRoaXMgbWVhbnMsIERPTVB1cmlmeSByZW1vdmVzIGNvbW1lbnRzIHdoZW4gY29udGFpbmluZyByaXNreSBjb250ZW50LlxuICAgKi9cbiAgbGV0IFNBRkVfRk9SX1hNTCA9IHRydWU7XG4gIC8qIERlY2lkZSBpZiBkb2N1bWVudCB3aXRoIDxodG1sPi4uLiBzaG91bGQgYmUgcmV0dXJuZWQgKi9cbiAgbGV0IFdIT0xFX0RPQ1VNRU5UID0gZmFsc2U7XG4gIC8qIFRyYWNrIHdoZXRoZXIgY29uZmlnIGlzIGFscmVhZHkgc2V0IG9uIHRoaXMgaW5zdGFuY2Ugb2YgRE9NUHVyaWZ5LiAqL1xuICBsZXQgU0VUX0NPTkZJRyA9IGZhbHNlO1xuICAvKiBEZWNpZGUgaWYgYWxsIGVsZW1lbnRzIChlLmcuIHN0eWxlLCBzY3JpcHQpIG11c3QgYmUgY2hpbGRyZW4gb2ZcbiAgICogZG9jdW1lbnQuYm9keS4gQnkgZGVmYXVsdCwgYnJvd3NlcnMgbWlnaHQgbW92ZSB0aGVtIHRvIGRvY3VtZW50LmhlYWQgKi9cbiAgbGV0IEZPUkNFX0JPRFkgPSBmYWxzZTtcbiAgLyogRGVjaWRlIGlmIGEgRE9NIGBIVE1MQm9keUVsZW1lbnRgIHNob3VsZCBiZSByZXR1cm5lZCwgaW5zdGVhZCBvZiBhIGh0bWxcbiAgICogc3RyaW5nIChvciBhIFRydXN0ZWRIVE1MIG9iamVjdCBpZiBUcnVzdGVkIFR5cGVzIGFyZSBzdXBwb3J0ZWQpLlxuICAgKiBJZiBgV0hPTEVfRE9DVU1FTlRgIGlzIGVuYWJsZWQgYSBgSFRNTEh0bWxFbGVtZW50YCB3aWxsIGJlIHJldHVybmVkIGluc3RlYWRcbiAgICovXG4gIGxldCBSRVRVUk5fRE9NID0gZmFsc2U7XG4gIC8qIERlY2lkZSBpZiBhIERPTSBgRG9jdW1lbnRGcmFnbWVudGAgc2hvdWxkIGJlIHJldHVybmVkLCBpbnN0ZWFkIG9mIGEgaHRtbFxuICAgKiBzdHJpbmcgIChvciBhIFRydXN0ZWRIVE1MIG9iamVjdCBpZiBUcnVzdGVkIFR5cGVzIGFyZSBzdXBwb3J0ZWQpICovXG4gIGxldCBSRVRVUk5fRE9NX0ZSQUdNRU5UID0gZmFsc2U7XG4gIC8qIFRyeSB0byByZXR1cm4gYSBUcnVzdGVkIFR5cGUgb2JqZWN0IGluc3RlYWQgb2YgYSBzdHJpbmcsIHJldHVybiBhIHN0cmluZyBpblxuICAgKiBjYXNlIFRydXN0ZWQgVHlwZXMgYXJlIG5vdCBzdXBwb3J0ZWQgICovXG4gIGxldCBSRVRVUk5fVFJVU1RFRF9UWVBFID0gZmFsc2U7XG4gIC8qIE91dHB1dCBzaG91bGQgYmUgZnJlZSBmcm9tIERPTSBjbG9iYmVyaW5nIGF0dGFja3M/XG4gICAqIFRoaXMgc2FuaXRpemVzIG1hcmt1cHMgbmFtZWQgd2l0aCBjb2xsaWRpbmcsIGNsb2JiZXJhYmxlIGJ1aWx0LWluIERPTSBBUElzLlxuICAgKi9cbiAgbGV0IFNBTklUSVpFX0RPTSA9IHRydWU7XG4gIC8qIEFjaGlldmUgZnVsbCBET00gQ2xvYmJlcmluZyBwcm90ZWN0aW9uIGJ5IGlzb2xhdGluZyB0aGUgbmFtZXNwYWNlIG9mIG5hbWVkXG4gICAqIHByb3BlcnRpZXMgYW5kIEpTIHZhcmlhYmxlcywgbWl0aWdhdGluZyBhdHRhY2tzIHRoYXQgYWJ1c2UgdGhlIEhUTUwvRE9NIHNwZWMgcnVsZXMuXG4gICAqXG4gICAqIEhUTUwvRE9NIHNwZWMgcnVsZXMgdGhhdCBlbmFibGUgRE9NIENsb2JiZXJpbmc6XG4gICAqICAgLSBOYW1lZCBBY2Nlc3Mgb24gV2luZG93ICjCpzcuMy4zKVxuICAgKiAgIC0gRE9NIFRyZWUgQWNjZXNzb3JzICjCpzMuMS41KVxuICAgKiAgIC0gRm9ybSBFbGVtZW50IFBhcmVudC1DaGlsZCBSZWxhdGlvbnMgKMKnNC4xMC4zKVxuICAgKiAgIC0gSWZyYW1lIHNyY2RvYyAvIE5lc3RlZCBXaW5kb3dQcm94aWVzICjCpzQuOC41KVxuICAgKiAgIC0gSFRNTENvbGxlY3Rpb24gKMKnNC4yLjEwLjIpXG4gICAqXG4gICAqIE5hbWVzcGFjZSBpc29sYXRpb24gaXMgaW1wbGVtZW50ZWQgYnkgcHJlZml4aW5nIGBpZGAgYW5kIGBuYW1lYCBhdHRyaWJ1dGVzXG4gICAqIHdpdGggYSBjb25zdGFudCBzdHJpbmcsIGkuZS4sIGB1c2VyLWNvbnRlbnQtYFxuICAgKi9cbiAgbGV0IFNBTklUSVpFX05BTUVEX1BST1BTID0gZmFsc2U7XG4gIGNvbnN0IFNBTklUSVpFX05BTUVEX1BST1BTX1BSRUZJWCA9ICd1c2VyLWNvbnRlbnQtJztcbiAgLyogS2VlcCBlbGVtZW50IGNvbnRlbnQgd2hlbiByZW1vdmluZyBlbGVtZW50PyAqL1xuICBsZXQgS0VFUF9DT05URU5UID0gdHJ1ZTtcbiAgLyogSWYgYSBgTm9kZWAgaXMgcGFzc2VkIHRvIHNhbml0aXplKCksIHRoZW4gcGVyZm9ybXMgc2FuaXRpemF0aW9uIGluLXBsYWNlIGluc3RlYWRcbiAgICogb2YgaW1wb3J0aW5nIGl0IGludG8gYSBuZXcgRG9jdW1lbnQgYW5kIHJldHVybmluZyBhIHNhbml0aXplZCBjb3B5ICovXG4gIGxldCBJTl9QTEFDRSA9IGZhbHNlO1xuICAvKiBBbGxvdyB1c2FnZSBvZiBwcm9maWxlcyBsaWtlIGh0bWwsIHN2ZyBhbmQgbWF0aE1sICovXG4gIGxldCBVU0VfUFJPRklMRVMgPSB7fTtcbiAgLyogVGFncyB0byBpZ25vcmUgY29udGVudCBvZiB3aGVuIEtFRVBfQ09OVEVOVCBpcyB0cnVlICovXG4gIGxldCBGT1JCSURfQ09OVEVOVFMgPSBudWxsO1xuICBjb25zdCBERUZBVUxUX0ZPUkJJRF9DT05URU5UUyA9IGFkZFRvU2V0KHt9LCBbJ2Fubm90YXRpb24teG1sJywgJ2F1ZGlvJywgJ2NvbGdyb3VwJywgJ2Rlc2MnLCAnZm9yZWlnbm9iamVjdCcsICdoZWFkJywgJ2lmcmFtZScsICdtYXRoJywgJ21pJywgJ21uJywgJ21vJywgJ21zJywgJ210ZXh0JywgJ25vZW1iZWQnLCAnbm9mcmFtZXMnLCAnbm9zY3JpcHQnLCAncGxhaW50ZXh0JywgJ3NjcmlwdCcsICdzdHlsZScsICdzdmcnLCAndGVtcGxhdGUnLCAndGhlYWQnLCAndGl0bGUnLCAndmlkZW8nLCAneG1wJ10pO1xuICAvKiBUYWdzIHRoYXQgYXJlIHNhZmUgZm9yIGRhdGE6IFVSSXMgKi9cbiAgbGV0IERBVEFfVVJJX1RBR1MgPSBudWxsO1xuICBjb25zdCBERUZBVUxUX0RBVEFfVVJJX1RBR1MgPSBhZGRUb1NldCh7fSwgWydhdWRpbycsICd2aWRlbycsICdpbWcnLCAnc291cmNlJywgJ2ltYWdlJywgJ3RyYWNrJ10pO1xuICAvKiBBdHRyaWJ1dGVzIHNhZmUgZm9yIHZhbHVlcyBsaWtlIFwiamF2YXNjcmlwdDpcIiAqL1xuICBsZXQgVVJJX1NBRkVfQVRUUklCVVRFUyA9IG51bGw7XG4gIGNvbnN0IERFRkFVTFRfVVJJX1NBRkVfQVRUUklCVVRFUyA9IGFkZFRvU2V0KHt9LCBbJ2FsdCcsICdjbGFzcycsICdmb3InLCAnaWQnLCAnbGFiZWwnLCAnbmFtZScsICdwYXR0ZXJuJywgJ3BsYWNlaG9sZGVyJywgJ3JvbGUnLCAnc3VtbWFyeScsICd0aXRsZScsICd2YWx1ZScsICdzdHlsZScsICd4bWxucyddKTtcbiAgY29uc3QgTUFUSE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcbiAgY29uc3QgU1ZHX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4gIGNvbnN0IEhUTUxfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xuICAvKiBEb2N1bWVudCBuYW1lc3BhY2UgKi9cbiAgbGV0IE5BTUVTUEFDRSA9IEhUTUxfTkFNRVNQQUNFO1xuICBsZXQgSVNfRU1QVFlfSU5QVVQgPSBmYWxzZTtcbiAgLyogQWxsb3dlZCBYSFRNTCtYTUwgbmFtZXNwYWNlcyAqL1xuICBsZXQgQUxMT1dFRF9OQU1FU1BBQ0VTID0gbnVsbDtcbiAgY29uc3QgREVGQVVMVF9BTExPV0VEX05BTUVTUEFDRVMgPSBhZGRUb1NldCh7fSwgW01BVEhNTF9OQU1FU1BBQ0UsIFNWR19OQU1FU1BBQ0UsIEhUTUxfTkFNRVNQQUNFXSwgc3RyaW5nVG9TdHJpbmcpO1xuICBsZXQgTUFUSE1MX1RFWFRfSU5URUdSQVRJT05fUE9JTlRTID0gYWRkVG9TZXQoe30sIFsnbWknLCAnbW8nLCAnbW4nLCAnbXMnLCAnbXRleHQnXSk7XG4gIGxldCBIVE1MX0lOVEVHUkFUSU9OX1BPSU5UUyA9IGFkZFRvU2V0KHt9LCBbJ2Fubm90YXRpb24teG1sJ10pO1xuICAvLyBDZXJ0YWluIGVsZW1lbnRzIGFyZSBhbGxvd2VkIGluIGJvdGggU1ZHIGFuZCBIVE1MXG4gIC8vIG5hbWVzcGFjZS4gV2UgbmVlZCB0byBzcGVjaWZ5IHRoZW0gZXhwbGljaXRseVxuICAvLyBzbyB0aGF0IHRoZXkgZG9uJ3QgZ2V0IGVycm9uZW91c2x5IGRlbGV0ZWQgZnJvbVxuICAvLyBIVE1MIG5hbWVzcGFjZS5cbiAgY29uc3QgQ09NTU9OX1NWR19BTkRfSFRNTF9FTEVNRU5UUyA9IGFkZFRvU2V0KHt9LCBbJ3RpdGxlJywgJ3N0eWxlJywgJ2ZvbnQnLCAnYScsICdzY3JpcHQnXSk7XG4gIC8qIFBhcnNpbmcgb2Ygc3RyaWN0IFhIVE1MIGRvY3VtZW50cyAqL1xuICBsZXQgUEFSU0VSX01FRElBX1RZUEUgPSBudWxsO1xuICBjb25zdCBTVVBQT1JURURfUEFSU0VSX01FRElBX1RZUEVTID0gWydhcHBsaWNhdGlvbi94aHRtbCt4bWwnLCAndGV4dC9odG1sJ107XG4gIGNvbnN0IERFRkFVTFRfUEFSU0VSX01FRElBX1RZUEUgPSAndGV4dC9odG1sJztcbiAgbGV0IHRyYW5zZm9ybUNhc2VGdW5jID0gbnVsbDtcbiAgLyogS2VlcCBhIHJlZmVyZW5jZSB0byBjb25maWcgdG8gcGFzcyB0byBob29rcyAqL1xuICBsZXQgQ09ORklHID0gbnVsbDtcbiAgLyogSWRlYWxseSwgZG8gbm90IHRvdWNoIGFueXRoaW5nIGJlbG93IHRoaXMgbGluZSAqL1xuICAvKiBfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fICovXG4gIGNvbnN0IGZvcm1FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuICBjb25zdCBpc1JlZ2V4T3JGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzUmVnZXhPckZ1bmN0aW9uKHRlc3RWYWx1ZSkge1xuICAgIHJldHVybiB0ZXN0VmFsdWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgdGVzdFZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb247XG4gIH07XG4gIC8qKlxuICAgKiBfcGFyc2VDb25maWdcbiAgICpcbiAgICogQHBhcmFtIGNmZyBvcHRpb25hbCBjb25maWcgbGl0ZXJhbFxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgY29uc3QgX3BhcnNlQ29uZmlnID0gZnVuY3Rpb24gX3BhcnNlQ29uZmlnKCkge1xuICAgIGxldCBjZmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGlmIChDT05GSUcgJiYgQ09ORklHID09PSBjZmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyogU2hpZWxkIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZyb20gdGFtcGVyaW5nICovXG4gICAgaWYgKCFjZmcgfHwgdHlwZW9mIGNmZyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGNmZyA9IHt9O1xuICAgIH1cbiAgICAvKiBTaGllbGQgY29uZmlndXJhdGlvbiBvYmplY3QgZnJvbSBwcm90b3R5cGUgcG9sbHV0aW9uICovXG4gICAgY2ZnID0gY2xvbmUoY2ZnKTtcbiAgICBQQVJTRVJfTUVESUFfVFlQRSA9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcHJlZmVyLWluY2x1ZGVzXG4gICAgU1VQUE9SVEVEX1BBUlNFUl9NRURJQV9UWVBFUy5pbmRleE9mKGNmZy5QQVJTRVJfTUVESUFfVFlQRSkgPT09IC0xID8gREVGQVVMVF9QQVJTRVJfTUVESUFfVFlQRSA6IGNmZy5QQVJTRVJfTUVESUFfVFlQRTtcbiAgICAvLyBIVE1MIHRhZ3MgYW5kIGF0dHJpYnV0ZXMgYXJlIG5vdCBjYXNlLXNlbnNpdGl2ZSwgY29udmVydGluZyB0byBsb3dlcmNhc2UuIEtlZXBpbmcgWEhUTUwgYXMgaXMuXG4gICAgdHJhbnNmb3JtQ2FzZUZ1bmMgPSBQQVJTRVJfTUVESUFfVFlQRSA9PT0gJ2FwcGxpY2F0aW9uL3hodG1sK3htbCcgPyBzdHJpbmdUb1N0cmluZyA6IHN0cmluZ1RvTG93ZXJDYXNlO1xuICAgIC8qIFNldCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgKi9cbiAgICBBTExPV0VEX1RBR1MgPSBvYmplY3RIYXNPd25Qcm9wZXJ0eShjZmcsICdBTExPV0VEX1RBR1MnKSA/IGFkZFRvU2V0KHt9LCBjZmcuQUxMT1dFRF9UQUdTLCB0cmFuc2Zvcm1DYXNlRnVuYykgOiBERUZBVUxUX0FMTE9XRURfVEFHUztcbiAgICBBTExPV0VEX0FUVFIgPSBvYmplY3RIYXNPd25Qcm9wZXJ0eShjZmcsICdBTExPV0VEX0FUVFInKSA/IGFkZFRvU2V0KHt9LCBjZmcuQUxMT1dFRF9BVFRSLCB0cmFuc2Zvcm1DYXNlRnVuYykgOiBERUZBVUxUX0FMTE9XRURfQVRUUjtcbiAgICBBTExPV0VEX05BTUVTUEFDRVMgPSBvYmplY3RIYXNPd25Qcm9wZXJ0eShjZmcsICdBTExPV0VEX05BTUVTUEFDRVMnKSA/IGFkZFRvU2V0KHt9LCBjZmcuQUxMT1dFRF9OQU1FU1BBQ0VTLCBzdHJpbmdUb1N0cmluZykgOiBERUZBVUxUX0FMTE9XRURfTkFNRVNQQUNFUztcbiAgICBVUklfU0FGRV9BVFRSSUJVVEVTID0gb2JqZWN0SGFzT3duUHJvcGVydHkoY2ZnLCAnQUREX1VSSV9TQUZFX0FUVFInKSA/IGFkZFRvU2V0KGNsb25lKERFRkFVTFRfVVJJX1NBRkVfQVRUUklCVVRFUyksIGNmZy5BRERfVVJJX1NBRkVfQVRUUiwgdHJhbnNmb3JtQ2FzZUZ1bmMpIDogREVGQVVMVF9VUklfU0FGRV9BVFRSSUJVVEVTO1xuICAgIERBVEFfVVJJX1RBR1MgPSBvYmplY3RIYXNPd25Qcm9wZXJ0eShjZmcsICdBRERfREFUQV9VUklfVEFHUycpID8gYWRkVG9TZXQoY2xvbmUoREVGQVVMVF9EQVRBX1VSSV9UQUdTKSwgY2ZnLkFERF9EQVRBX1VSSV9UQUdTLCB0cmFuc2Zvcm1DYXNlRnVuYykgOiBERUZBVUxUX0RBVEFfVVJJX1RBR1M7XG4gICAgRk9SQklEX0NPTlRFTlRTID0gb2JqZWN0SGFzT3duUHJvcGVydHkoY2ZnLCAnRk9SQklEX0NPTlRFTlRTJykgPyBhZGRUb1NldCh7fSwgY2ZnLkZPUkJJRF9DT05URU5UUywgdHJhbnNmb3JtQ2FzZUZ1bmMpIDogREVGQVVMVF9GT1JCSURfQ09OVEVOVFM7XG4gICAgRk9SQklEX1RBR1MgPSBvYmplY3RIYXNPd25Qcm9wZXJ0eShjZmcsICdGT1JCSURfVEFHUycpID8gYWRkVG9TZXQoe30sIGNmZy5GT1JCSURfVEFHUywgdHJhbnNmb3JtQ2FzZUZ1bmMpIDogY2xvbmUoe30pO1xuICAgIEZPUkJJRF9BVFRSID0gb2JqZWN0SGFzT3duUHJvcGVydHkoY2ZnLCAnRk9SQklEX0FUVFInKSA/IGFkZFRvU2V0KHt9LCBjZmcuRk9SQklEX0FUVFIsIHRyYW5zZm9ybUNhc2VGdW5jKSA6IGNsb25lKHt9KTtcbiAgICBVU0VfUFJPRklMRVMgPSBvYmplY3RIYXNPd25Qcm9wZXJ0eShjZmcsICdVU0VfUFJPRklMRVMnKSA/IGNmZy5VU0VfUFJPRklMRVMgOiBmYWxzZTtcbiAgICBBTExPV19BUklBX0FUVFIgPSBjZmcuQUxMT1dfQVJJQV9BVFRSICE9PSBmYWxzZTsgLy8gRGVmYXVsdCB0cnVlXG4gICAgQUxMT1dfREFUQV9BVFRSID0gY2ZnLkFMTE9XX0RBVEFfQVRUUiAhPT0gZmFsc2U7IC8vIERlZmF1bHQgdHJ1ZVxuICAgIEFMTE9XX1VOS05PV05fUFJPVE9DT0xTID0gY2ZnLkFMTE9XX1VOS05PV05fUFJPVE9DT0xTIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgQUxMT1dfU0VMRl9DTE9TRV9JTl9BVFRSID0gY2ZnLkFMTE9XX1NFTEZfQ0xPU0VfSU5fQVRUUiAhPT0gZmFsc2U7IC8vIERlZmF1bHQgdHJ1ZVxuICAgIFNBRkVfRk9SX1RFTVBMQVRFUyA9IGNmZy5TQUZFX0ZPUl9URU1QTEFURVMgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICBTQUZFX0ZPUl9YTUwgPSBjZmcuU0FGRV9GT1JfWE1MICE9PSBmYWxzZTsgLy8gRGVmYXVsdCB0cnVlXG4gICAgV0hPTEVfRE9DVU1FTlQgPSBjZmcuV0hPTEVfRE9DVU1FTlQgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICBSRVRVUk5fRE9NID0gY2ZnLlJFVFVSTl9ET00gfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICBSRVRVUk5fRE9NX0ZSQUdNRU5UID0gY2ZnLlJFVFVSTl9ET01fRlJBR01FTlQgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICBSRVRVUk5fVFJVU1RFRF9UWVBFID0gY2ZnLlJFVFVSTl9UUlVTVEVEX1RZUEUgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICBGT1JDRV9CT0RZID0gY2ZnLkZPUkNFX0JPRFkgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICBTQU5JVElaRV9ET00gPSBjZmcuU0FOSVRJWkVfRE9NICE9PSBmYWxzZTsgLy8gRGVmYXVsdCB0cnVlXG4gICAgU0FOSVRJWkVfTkFNRURfUFJPUFMgPSBjZmcuU0FOSVRJWkVfTkFNRURfUFJPUFMgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICBLRUVQX0NPTlRFTlQgPSBjZmcuS0VFUF9DT05URU5UICE9PSBmYWxzZTsgLy8gRGVmYXVsdCB0cnVlXG4gICAgSU5fUExBQ0UgPSBjZmcuSU5fUExBQ0UgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICBJU19BTExPV0VEX1VSSSQxID0gY2ZnLkFMTE9XRURfVVJJX1JFR0VYUCB8fCBJU19BTExPV0VEX1VSSTtcbiAgICBOQU1FU1BBQ0UgPSBjZmcuTkFNRVNQQUNFIHx8IEhUTUxfTkFNRVNQQUNFO1xuICAgIE1BVEhNTF9URVhUX0lOVEVHUkFUSU9OX1BPSU5UUyA9IGNmZy5NQVRITUxfVEVYVF9JTlRFR1JBVElPTl9QT0lOVFMgfHwgTUFUSE1MX1RFWFRfSU5URUdSQVRJT05fUE9JTlRTO1xuICAgIEhUTUxfSU5URUdSQVRJT05fUE9JTlRTID0gY2ZnLkhUTUxfSU5URUdSQVRJT05fUE9JTlRTIHx8IEhUTUxfSU5URUdSQVRJT05fUE9JTlRTO1xuICAgIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HID0gY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HIHx8IHt9O1xuICAgIGlmIChjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcgJiYgaXNSZWdleE9yRnVuY3Rpb24oY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjaykpIHtcbiAgICAgIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayA9IGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2s7XG4gICAgfVxuICAgIGlmIChjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcgJiYgaXNSZWdleE9yRnVuY3Rpb24oY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjaykpIHtcbiAgICAgIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjayA9IGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORy5hdHRyaWJ1dGVOYW1lQ2hlY2s7XG4gICAgfVxuICAgIGlmIChjZmcuQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcgJiYgdHlwZW9mIGNmZy5DVVNUT01fRUxFTUVOVF9IQU5ETElORy5hbGxvd0N1c3RvbWl6ZWRCdWlsdEluRWxlbWVudHMgPT09ICdib29sZWFuJykge1xuICAgICAgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcuYWxsb3dDdXN0b21pemVkQnVpbHRJbkVsZW1lbnRzID0gY2ZnLkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmFsbG93Q3VzdG9taXplZEJ1aWx0SW5FbGVtZW50cztcbiAgICB9XG4gICAgaWYgKFNBRkVfRk9SX1RFTVBMQVRFUykge1xuICAgICAgQUxMT1dfREFUQV9BVFRSID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChSRVRVUk5fRE9NX0ZSQUdNRU5UKSB7XG4gICAgICBSRVRVUk5fRE9NID0gdHJ1ZTtcbiAgICB9XG4gICAgLyogUGFyc2UgcHJvZmlsZSBpbmZvICovXG4gICAgaWYgKFVTRV9QUk9GSUxFUykge1xuICAgICAgQUxMT1dFRF9UQUdTID0gYWRkVG9TZXQoe30sIHRleHQpO1xuICAgICAgQUxMT1dFRF9BVFRSID0gW107XG4gICAgICBpZiAoVVNFX1BST0ZJTEVTLmh0bWwgPT09IHRydWUpIHtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBodG1sJDEpO1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIGh0bWwpO1xuICAgICAgfVxuICAgICAgaWYgKFVTRV9QUk9GSUxFUy5zdmcgPT09IHRydWUpIHtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBzdmckMSk7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgc3ZnKTtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCB4bWwpO1xuICAgICAgfVxuICAgICAgaWYgKFVTRV9QUk9GSUxFUy5zdmdGaWx0ZXJzID09PSB0cnVlKSB7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgc3ZnRmlsdGVycyk7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgc3ZnKTtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCB4bWwpO1xuICAgICAgfVxuICAgICAgaWYgKFVTRV9QUk9GSUxFUy5tYXRoTWwgPT09IHRydWUpIHtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBtYXRoTWwkMSk7XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfQVRUUiwgbWF0aE1sKTtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCB4bWwpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBNZXJnZSBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgKi9cbiAgICBpZiAoY2ZnLkFERF9UQUdTKSB7XG4gICAgICBpZiAodHlwZW9mIGNmZy5BRERfVEFHUyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBFWFRSQV9FTEVNRU5UX0hBTkRMSU5HLnRhZ0NoZWNrID0gY2ZnLkFERF9UQUdTO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKEFMTE9XRURfVEFHUyA9PT0gREVGQVVMVF9BTExPV0VEX1RBR1MpIHtcbiAgICAgICAgICBBTExPV0VEX1RBR1MgPSBjbG9uZShBTExPV0VEX1RBR1MpO1xuICAgICAgICB9XG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgY2ZnLkFERF9UQUdTLCB0cmFuc2Zvcm1DYXNlRnVuYyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjZmcuQUREX0FUVFIpIHtcbiAgICAgIGlmICh0eXBlb2YgY2ZnLkFERF9BVFRSID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIEVYVFJBX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlQ2hlY2sgPSBjZmcuQUREX0FUVFI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoQUxMT1dFRF9BVFRSID09PSBERUZBVUxUX0FMTE9XRURfQVRUUikge1xuICAgICAgICAgIEFMTE9XRURfQVRUUiA9IGNsb25lKEFMTE9XRURfQVRUUik7XG4gICAgICAgIH1cbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBjZmcuQUREX0FUVFIsIHRyYW5zZm9ybUNhc2VGdW5jKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNmZy5BRERfVVJJX1NBRkVfQVRUUikge1xuICAgICAgYWRkVG9TZXQoVVJJX1NBRkVfQVRUUklCVVRFUywgY2ZnLkFERF9VUklfU0FGRV9BVFRSLCB0cmFuc2Zvcm1DYXNlRnVuYyk7XG4gICAgfVxuICAgIGlmIChjZmcuRk9SQklEX0NPTlRFTlRTKSB7XG4gICAgICBpZiAoRk9SQklEX0NPTlRFTlRTID09PSBERUZBVUxUX0ZPUkJJRF9DT05URU5UUykge1xuICAgICAgICBGT1JCSURfQ09OVEVOVFMgPSBjbG9uZShGT1JCSURfQ09OVEVOVFMpO1xuICAgICAgfVxuICAgICAgYWRkVG9TZXQoRk9SQklEX0NPTlRFTlRTLCBjZmcuRk9SQklEX0NPTlRFTlRTLCB0cmFuc2Zvcm1DYXNlRnVuYyk7XG4gICAgfVxuICAgIGlmIChjZmcuQUREX0ZPUkJJRF9DT05URU5UUykge1xuICAgICAgaWYgKEZPUkJJRF9DT05URU5UUyA9PT0gREVGQVVMVF9GT1JCSURfQ09OVEVOVFMpIHtcbiAgICAgICAgRk9SQklEX0NPTlRFTlRTID0gY2xvbmUoRk9SQklEX0NPTlRFTlRTKTtcbiAgICAgIH1cbiAgICAgIGFkZFRvU2V0KEZPUkJJRF9DT05URU5UUywgY2ZnLkFERF9GT1JCSURfQ09OVEVOVFMsIHRyYW5zZm9ybUNhc2VGdW5jKTtcbiAgICB9XG4gICAgLyogQWRkICN0ZXh0IGluIGNhc2UgS0VFUF9DT05URU5UIGlzIHNldCB0byB0cnVlICovXG4gICAgaWYgKEtFRVBfQ09OVEVOVCkge1xuICAgICAgQUxMT1dFRF9UQUdTWycjdGV4dCddID0gdHJ1ZTtcbiAgICB9XG4gICAgLyogQWRkIGh0bWwsIGhlYWQgYW5kIGJvZHkgdG8gQUxMT1dFRF9UQUdTIGluIGNhc2UgV0hPTEVfRE9DVU1FTlQgaXMgdHJ1ZSAqL1xuICAgIGlmIChXSE9MRV9ET0NVTUVOVCkge1xuICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBbJ2h0bWwnLCAnaGVhZCcsICdib2R5J10pO1xuICAgIH1cbiAgICAvKiBBZGQgdGJvZHkgdG8gQUxMT1dFRF9UQUdTIGluIGNhc2UgdGFibGVzIGFyZSBwZXJtaXR0ZWQsIHNlZSAjMjg2LCAjMzY1ICovXG4gICAgaWYgKEFMTE9XRURfVEFHUy50YWJsZSkge1xuICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBbJ3Rib2R5J10pO1xuICAgICAgZGVsZXRlIEZPUkJJRF9UQUdTLnRib2R5O1xuICAgIH1cbiAgICBpZiAoY2ZnLlRSVVNURURfVFlQRVNfUE9MSUNZKSB7XG4gICAgICBpZiAodHlwZW9mIGNmZy5UUlVTVEVEX1RZUEVTX1BPTElDWS5jcmVhdGVIVE1MICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IHR5cGVFcnJvckNyZWF0ZSgnVFJVU1RFRF9UWVBFU19QT0xJQ1kgY29uZmlndXJhdGlvbiBvcHRpb24gbXVzdCBwcm92aWRlIGEgXCJjcmVhdGVIVE1MXCIgaG9vay4nKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgY2ZnLlRSVVNURURfVFlQRVNfUE9MSUNZLmNyZWF0ZVNjcmlwdFVSTCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyB0eXBlRXJyb3JDcmVhdGUoJ1RSVVNURURfVFlQRVNfUE9MSUNZIGNvbmZpZ3VyYXRpb24gb3B0aW9uIG11c3QgcHJvdmlkZSBhIFwiY3JlYXRlU2NyaXB0VVJMXCIgaG9vay4nKTtcbiAgICAgIH1cbiAgICAgIC8vIE92ZXJ3cml0ZSBleGlzdGluZyBUcnVzdGVkVHlwZXMgcG9saWN5LlxuICAgICAgdHJ1c3RlZFR5cGVzUG9saWN5ID0gY2ZnLlRSVVNURURfVFlQRVNfUE9MSUNZO1xuICAgICAgLy8gU2lnbiBsb2NhbCB2YXJpYWJsZXMgcmVxdWlyZWQgYnkgYHNhbml0aXplYC5cbiAgICAgIGVtcHR5SFRNTCA9IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVW5pbml0aWFsaXplZCBwb2xpY3ksIGF0dGVtcHQgdG8gaW5pdGlhbGl6ZSB0aGUgaW50ZXJuYWwgZG9tcHVyaWZ5IHBvbGljeS5cbiAgICAgIGlmICh0cnVzdGVkVHlwZXNQb2xpY3kgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0cnVzdGVkVHlwZXNQb2xpY3kgPSBfY3JlYXRlVHJ1c3RlZFR5cGVzUG9saWN5KHRydXN0ZWRUeXBlcywgY3VycmVudFNjcmlwdCk7XG4gICAgICB9XG4gICAgICAvLyBJZiBjcmVhdGluZyB0aGUgaW50ZXJuYWwgcG9saWN5IHN1Y2NlZWRlZCBzaWduIGludGVybmFsIHZhcmlhYmxlcy5cbiAgICAgIGlmICh0cnVzdGVkVHlwZXNQb2xpY3kgIT09IG51bGwgJiYgdHlwZW9mIGVtcHR5SFRNTCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZW1wdHlIVE1MID0gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoJycpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBQcmV2ZW50IGZ1cnRoZXIgbWFuaXB1bGF0aW9uIG9mIGNvbmZpZ3VyYXRpb24uXG4gICAgLy8gTm90IGF2YWlsYWJsZSBpbiBJRTgsIFNhZmFyaSA1LCBldGMuXG4gICAgaWYgKGZyZWV6ZSkge1xuICAgICAgZnJlZXplKGNmZyk7XG4gICAgfVxuICAgIENPTkZJRyA9IGNmZztcbiAgfTtcbiAgLyogS2VlcCB0cmFjayBvZiBhbGwgcG9zc2libGUgU1ZHIGFuZCBNYXRoTUwgdGFnc1xuICAgKiBzbyB0aGF0IHdlIGNhbiBwZXJmb3JtIHRoZSBuYW1lc3BhY2UgY2hlY2tzXG4gICAqIGNvcnJlY3RseS4gKi9cbiAgY29uc3QgQUxMX1NWR19UQUdTID0gYWRkVG9TZXQoe30sIFsuLi5zdmckMSwgLi4uc3ZnRmlsdGVycywgLi4uc3ZnRGlzYWxsb3dlZF0pO1xuICBjb25zdCBBTExfTUFUSE1MX1RBR1MgPSBhZGRUb1NldCh7fSwgWy4uLm1hdGhNbCQxLCAuLi5tYXRoTWxEaXNhbGxvd2VkXSk7XG4gIC8qKlxuICAgKiBAcGFyYW0gZWxlbWVudCBhIERPTSBlbGVtZW50IHdob3NlIG5hbWVzcGFjZSBpcyBiZWluZyBjaGVja2VkXG4gICAqIEByZXR1cm5zIFJldHVybiBmYWxzZSBpZiB0aGUgZWxlbWVudCBoYXMgYVxuICAgKiAgbmFtZXNwYWNlIHRoYXQgYSBzcGVjLWNvbXBsaWFudCBwYXJzZXIgd291bGQgbmV2ZXJcbiAgICogIHJldHVybi4gUmV0dXJuIHRydWUgb3RoZXJ3aXNlLlxuICAgKi9cbiAgY29uc3QgX2NoZWNrVmFsaWROYW1lc3BhY2UgPSBmdW5jdGlvbiBfY2hlY2tWYWxpZE5hbWVzcGFjZShlbGVtZW50KSB7XG4gICAgbGV0IHBhcmVudCA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gICAgLy8gSW4gSlNET00sIGlmIHdlJ3JlIGluc2lkZSBzaGFkb3cgRE9NLCB0aGVuIHBhcmVudE5vZGVcbiAgICAvLyBjYW4gYmUgbnVsbC4gV2UganVzdCBzaW11bGF0ZSBwYXJlbnQgaW4gdGhpcyBjYXNlLlxuICAgIGlmICghcGFyZW50IHx8ICFwYXJlbnQudGFnTmFtZSkge1xuICAgICAgcGFyZW50ID0ge1xuICAgICAgICBuYW1lc3BhY2VVUkk6IE5BTUVTUEFDRSxcbiAgICAgICAgdGFnTmFtZTogJ3RlbXBsYXRlJ1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdGFnTmFtZSA9IHN0cmluZ1RvTG93ZXJDYXNlKGVsZW1lbnQudGFnTmFtZSk7XG4gICAgY29uc3QgcGFyZW50VGFnTmFtZSA9IHN0cmluZ1RvTG93ZXJDYXNlKHBhcmVudC50YWdOYW1lKTtcbiAgICBpZiAoIUFMTE9XRURfTkFNRVNQQUNFU1tlbGVtZW50Lm5hbWVzcGFjZVVSSV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQubmFtZXNwYWNlVVJJID09PSBTVkdfTkFNRVNQQUNFKSB7XG4gICAgICAvLyBUaGUgb25seSB3YXkgdG8gc3dpdGNoIGZyb20gSFRNTCBuYW1lc3BhY2UgdG8gU1ZHXG4gICAgICAvLyBpcyB2aWEgPHN2Zz4uIElmIGl0IGhhcHBlbnMgdmlhIGFueSBvdGhlciB0YWcsIHRoZW5cbiAgICAgIC8vIGl0IHNob3VsZCBiZSBraWxsZWQuXG4gICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICdzdmcnO1xuICAgICAgfVxuICAgICAgLy8gVGhlIG9ubHkgd2F5IHRvIHN3aXRjaCBmcm9tIE1hdGhNTCB0byBTVkcgaXMgdmlhYFxuICAgICAgLy8gc3ZnIGlmIHBhcmVudCBpcyBlaXRoZXIgPGFubm90YXRpb24teG1sPiBvciBNYXRoTUxcbiAgICAgIC8vIHRleHQgaW50ZWdyYXRpb24gcG9pbnRzLlxuICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IE1BVEhNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICdzdmcnICYmIChwYXJlbnRUYWdOYW1lID09PSAnYW5ub3RhdGlvbi14bWwnIHx8IE1BVEhNTF9URVhUX0lOVEVHUkFUSU9OX1BPSU5UU1twYXJlbnRUYWdOYW1lXSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBvbmx5IGFsbG93IGVsZW1lbnRzIHRoYXQgYXJlIGRlZmluZWQgaW4gU1ZHXG4gICAgICAvLyBzcGVjLiBBbGwgb3RoZXJzIGFyZSBkaXNhbGxvd2VkIGluIFNWRyBuYW1lc3BhY2UuXG4gICAgICByZXR1cm4gQm9vbGVhbihBTExfU1ZHX1RBR1NbdGFnTmFtZV0pO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IE1BVEhNTF9OQU1FU1BBQ0UpIHtcbiAgICAgIC8vIFRoZSBvbmx5IHdheSB0byBzd2l0Y2ggZnJvbSBIVE1MIG5hbWVzcGFjZSB0byBNYXRoTUxcbiAgICAgIC8vIGlzIHZpYSA8bWF0aD4uIElmIGl0IGhhcHBlbnMgdmlhIGFueSBvdGhlciB0YWcsIHRoZW5cbiAgICAgIC8vIGl0IHNob3VsZCBiZSBraWxsZWQuXG4gICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICdtYXRoJztcbiAgICAgIH1cbiAgICAgIC8vIFRoZSBvbmx5IHdheSB0byBzd2l0Y2ggZnJvbSBTVkcgdG8gTWF0aE1MIGlzIHZpYVxuICAgICAgLy8gPG1hdGg+IGFuZCBIVE1MIGludGVncmF0aW9uIHBvaW50c1xuICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IFNWR19OQU1FU1BBQ0UpIHtcbiAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICdtYXRoJyAmJiBIVE1MX0lOVEVHUkFUSU9OX1BPSU5UU1twYXJlbnRUYWdOYW1lXTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG9ubHkgYWxsb3cgZWxlbWVudHMgdGhhdCBhcmUgZGVmaW5lZCBpbiBNYXRoTUxcbiAgICAgIC8vIHNwZWMuIEFsbCBvdGhlcnMgYXJlIGRpc2FsbG93ZWQgaW4gTWF0aE1MIG5hbWVzcGFjZS5cbiAgICAgIHJldHVybiBCb29sZWFuKEFMTF9NQVRITUxfVEFHU1t0YWdOYW1lXSk7XG4gICAgfVxuICAgIGlmIChlbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgIC8vIFRoZSBvbmx5IHdheSB0byBzd2l0Y2ggZnJvbSBTVkcgdG8gSFRNTCBpcyB2aWFcbiAgICAgIC8vIEhUTUwgaW50ZWdyYXRpb24gcG9pbnRzLCBhbmQgZnJvbSBNYXRoTUwgdG8gSFRNTFxuICAgICAgLy8gaXMgdmlhIE1hdGhNTCB0ZXh0IGludGVncmF0aW9uIHBvaW50c1xuICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IFNWR19OQU1FU1BBQ0UgJiYgIUhUTUxfSU5URUdSQVRJT05fUE9JTlRTW3BhcmVudFRhZ05hbWVdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBNQVRITUxfTkFNRVNQQUNFICYmICFNQVRITUxfVEVYVF9JTlRFR1JBVElPTl9QT0lOVFNbcGFyZW50VGFnTmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gV2UgZGlzYWxsb3cgdGFncyB0aGF0IGFyZSBzcGVjaWZpYyBmb3IgTWF0aE1MXG4gICAgICAvLyBvciBTVkcgYW5kIHNob3VsZCBuZXZlciBhcHBlYXIgaW4gSFRNTCBuYW1lc3BhY2VcbiAgICAgIHJldHVybiAhQUxMX01BVEhNTF9UQUdTW3RhZ05hbWVdICYmIChDT01NT05fU1ZHX0FORF9IVE1MX0VMRU1FTlRTW3RhZ05hbWVdIHx8ICFBTExfU1ZHX1RBR1NbdGFnTmFtZV0pO1xuICAgIH1cbiAgICAvLyBGb3IgWEhUTUwgYW5kIFhNTCBkb2N1bWVudHMgdGhhdCBzdXBwb3J0IGN1c3RvbSBuYW1lc3BhY2VzXG4gICAgaWYgKFBBUlNFUl9NRURJQV9UWVBFID09PSAnYXBwbGljYXRpb24veGh0bWwreG1sJyAmJiBBTExPV0VEX05BTUVTUEFDRVNbZWxlbWVudC5uYW1lc3BhY2VVUkldKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gVGhlIGNvZGUgc2hvdWxkIG5ldmVyIHJlYWNoIHRoaXMgcGxhY2UgKHRoaXMgbWVhbnNcbiAgICAvLyB0aGF0IHRoZSBlbGVtZW50IHNvbWVob3cgZ290IG5hbWVzcGFjZSB0aGF0IGlzIG5vdFxuICAgIC8vIEhUTUwsIFNWRywgTWF0aE1MIG9yIGFsbG93ZWQgdmlhIEFMTE9XRURfTkFNRVNQQUNFUykuXG4gICAgLy8gUmV0dXJuIGZhbHNlIGp1c3QgaW4gY2FzZS5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIC8qKlxuICAgKiBfZm9yY2VSZW1vdmVcbiAgICpcbiAgICogQHBhcmFtIG5vZGUgYSBET00gbm9kZVxuICAgKi9cbiAgY29uc3QgX2ZvcmNlUmVtb3ZlID0gZnVuY3Rpb24gX2ZvcmNlUmVtb3ZlKG5vZGUpIHtcbiAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHtcbiAgICAgIGVsZW1lbnQ6IG5vZGVcbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcHJlZmVyLWRvbS1ub2RlLXJlbW92ZVxuICAgICAgZ2V0UGFyZW50Tm9kZShub2RlKS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICByZW1vdmUobm9kZSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogX3JlbW92ZUF0dHJpYnV0ZVxuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBhbiBBdHRyaWJ1dGUgbmFtZVxuICAgKiBAcGFyYW0gZWxlbWVudCBhIERPTSBub2RlXG4gICAqL1xuICBjb25zdCBfcmVtb3ZlQXR0cmlidXRlID0gZnVuY3Rpb24gX3JlbW92ZUF0dHJpYnV0ZShuYW1lLCBlbGVtZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIGFycmF5UHVzaChET01QdXJpZnkucmVtb3ZlZCwge1xuICAgICAgICBhdHRyaWJ1dGU6IGVsZW1lbnQuZ2V0QXR0cmlidXRlTm9kZShuYW1lKSxcbiAgICAgICAgZnJvbTogZWxlbWVudFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgYXJyYXlQdXNoKERPTVB1cmlmeS5yZW1vdmVkLCB7XG4gICAgICAgIGF0dHJpYnV0ZTogbnVsbCxcbiAgICAgICAgZnJvbTogZWxlbWVudFxuICAgICAgfSk7XG4gICAgfVxuICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIC8vIFdlIHZvaWQgYXR0cmlidXRlIHZhbHVlcyBmb3IgdW5yZW1vdmFibGUgXCJpc1wiIGF0dHJpYnV0ZXNcbiAgICBpZiAobmFtZSA9PT0gJ2lzJykge1xuICAgICAgaWYgKFJFVFVSTl9ET00gfHwgUkVUVVJOX0RPTV9GUkFHTUVOVCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIF9mb3JjZVJlbW92ZShlbGVtZW50KTtcbiAgICAgICAgfSBjYXRjaCAoXykge31cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgJycpO1xuICAgICAgICB9IGNhdGNoIChfKSB7fVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIF9pbml0RG9jdW1lbnRcbiAgICpcbiAgICogQHBhcmFtIGRpcnR5IC0gYSBzdHJpbmcgb2YgZGlydHkgbWFya3VwXG4gICAqIEByZXR1cm4gYSBET00sIGZpbGxlZCB3aXRoIHRoZSBkaXJ0eSBtYXJrdXBcbiAgICovXG4gIGNvbnN0IF9pbml0RG9jdW1lbnQgPSBmdW5jdGlvbiBfaW5pdERvY3VtZW50KGRpcnR5KSB7XG4gICAgLyogQ3JlYXRlIGEgSFRNTCBkb2N1bWVudCAqL1xuICAgIGxldCBkb2MgPSBudWxsO1xuICAgIGxldCBsZWFkaW5nV2hpdGVzcGFjZSA9IG51bGw7XG4gICAgaWYgKEZPUkNFX0JPRFkpIHtcbiAgICAgIGRpcnR5ID0gJzxyZW1vdmU+PC9yZW1vdmU+JyArIGRpcnR5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBJZiBGT1JDRV9CT0RZIGlzbid0IHVzZWQsIGxlYWRpbmcgd2hpdGVzcGFjZSBuZWVkcyB0byBiZSBwcmVzZXJ2ZWQgbWFudWFsbHkgKi9cbiAgICAgIGNvbnN0IG1hdGNoZXMgPSBzdHJpbmdNYXRjaChkaXJ0eSwgL15bXFxyXFxuXFx0IF0rLyk7XG4gICAgICBsZWFkaW5nV2hpdGVzcGFjZSA9IG1hdGNoZXMgJiYgbWF0Y2hlc1swXTtcbiAgICB9XG4gICAgaWYgKFBBUlNFUl9NRURJQV9UWVBFID09PSAnYXBwbGljYXRpb24veGh0bWwreG1sJyAmJiBOQU1FU1BBQ0UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAvLyBSb290IG9mIFhIVE1MIGRvYyBtdXN0IGNvbnRhaW4geG1sbnMgZGVjbGFyYXRpb24gKHNlZSBodHRwczovL3d3dy53My5vcmcvVFIveGh0bWwxL25vcm1hdGl2ZS5odG1sI3N0cmljdClcbiAgICAgIGRpcnR5ID0gJzxodG1sIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiPjxoZWFkPjwvaGVhZD48Ym9keT4nICsgZGlydHkgKyAnPC9ib2R5PjwvaHRtbD4nO1xuICAgIH1cbiAgICBjb25zdCBkaXJ0eVBheWxvYWQgPSB0cnVzdGVkVHlwZXNQb2xpY3kgPyB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlSFRNTChkaXJ0eSkgOiBkaXJ0eTtcbiAgICAvKlxuICAgICAqIFVzZSB0aGUgRE9NUGFyc2VyIEFQSSBieSBkZWZhdWx0LCBmYWxsYmFjayBsYXRlciBpZiBuZWVkcyBiZVxuICAgICAqIERPTVBhcnNlciBub3Qgd29yayBmb3Igc3ZnIHdoZW4gaGFzIG11bHRpcGxlIHJvb3QgZWxlbWVudC5cbiAgICAgKi9cbiAgICBpZiAoTkFNRVNQQUNFID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZG9jID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhkaXJ0eVBheWxvYWQsIFBBUlNFUl9NRURJQV9UWVBFKTtcbiAgICAgIH0gY2F0Y2ggKF8pIHt9XG4gICAgfVxuICAgIC8qIFVzZSBjcmVhdGVIVE1MRG9jdW1lbnQgaW4gY2FzZSBET01QYXJzZXIgaXMgbm90IGF2YWlsYWJsZSAqL1xuICAgIGlmICghZG9jIHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBkb2MgPSBpbXBsZW1lbnRhdGlvbi5jcmVhdGVEb2N1bWVudChOQU1FU1BBQ0UsICd0ZW1wbGF0ZScsIG51bGwpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZG9jLmRvY3VtZW50RWxlbWVudC5pbm5lckhUTUwgPSBJU19FTVBUWV9JTlBVVCA/IGVtcHR5SFRNTCA6IGRpcnR5UGF5bG9hZDtcbiAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgLy8gU3ludGF4IGVycm9yIGlmIGRpcnR5UGF5bG9hZCBpcyBpbnZhbGlkIHhtbFxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBib2R5ID0gZG9jLmJvZHkgfHwgZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICBpZiAoZGlydHkgJiYgbGVhZGluZ1doaXRlc3BhY2UpIHtcbiAgICAgIGJvZHkuaW5zZXJ0QmVmb3JlKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxlYWRpbmdXaGl0ZXNwYWNlKSwgYm9keS5jaGlsZE5vZGVzWzBdIHx8IG51bGwpO1xuICAgIH1cbiAgICAvKiBXb3JrIG9uIHdob2xlIGRvY3VtZW50IG9yIGp1c3QgaXRzIGJvZHkgKi9cbiAgICBpZiAoTkFNRVNQQUNFID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgcmV0dXJuIGdldEVsZW1lbnRzQnlUYWdOYW1lLmNhbGwoZG9jLCBXSE9MRV9ET0NVTUVOVCA/ICdodG1sJyA6ICdib2R5JylbMF07XG4gICAgfVxuICAgIHJldHVybiBXSE9MRV9ET0NVTUVOVCA/IGRvYy5kb2N1bWVudEVsZW1lbnQgOiBib2R5O1xuICB9O1xuICAvKipcbiAgICogQ3JlYXRlcyBhIE5vZGVJdGVyYXRvciBvYmplY3QgdGhhdCB5b3UgY2FuIHVzZSB0byB0cmF2ZXJzZSBmaWx0ZXJlZCBsaXN0cyBvZiBub2RlcyBvciBlbGVtZW50cyBpbiBhIGRvY3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0gcm9vdCBUaGUgcm9vdCBlbGVtZW50IG9yIG5vZGUgdG8gc3RhcnQgdHJhdmVyc2luZyBvbi5cbiAgICogQHJldHVybiBUaGUgY3JlYXRlZCBOb2RlSXRlcmF0b3JcbiAgICovXG4gIGNvbnN0IF9jcmVhdGVOb2RlSXRlcmF0b3IgPSBmdW5jdGlvbiBfY3JlYXRlTm9kZUl0ZXJhdG9yKHJvb3QpIHtcbiAgICByZXR1cm4gY3JlYXRlTm9kZUl0ZXJhdG9yLmNhbGwocm9vdC5vd25lckRvY3VtZW50IHx8IHJvb3QsIHJvb3QsXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCB8IE5vZGVGaWx0ZXIuU0hPV19DT01NRU5UIHwgTm9kZUZpbHRlci5TSE9XX1RFWFQgfCBOb2RlRmlsdGVyLlNIT1dfUFJPQ0VTU0lOR19JTlNUUlVDVElPTiB8IE5vZGVGaWx0ZXIuU0hPV19DREFUQV9TRUNUSU9OLCBudWxsKTtcbiAgfTtcbiAgLyoqXG4gICAqIF9pc0Nsb2JiZXJlZFxuICAgKlxuICAgKiBAcGFyYW0gZWxlbWVudCBlbGVtZW50IHRvIGNoZWNrIGZvciBjbG9iYmVyaW5nIGF0dGFja3NcbiAgICogQHJldHVybiB0cnVlIGlmIGNsb2JiZXJlZCwgZmFsc2UgaWYgc2FmZVxuICAgKi9cbiAgY29uc3QgX2lzQ2xvYmJlcmVkID0gZnVuY3Rpb24gX2lzQ2xvYmJlcmVkKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxGb3JtRWxlbWVudCAmJiAodHlwZW9mIGVsZW1lbnQubm9kZU5hbWUgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbGVtZW50LnRleHRDb250ZW50ICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZWxlbWVudC5yZW1vdmVDaGlsZCAhPT0gJ2Z1bmN0aW9uJyB8fCAhKGVsZW1lbnQuYXR0cmlidXRlcyBpbnN0YW5jZW9mIE5hbWVkTm9kZU1hcCkgfHwgdHlwZW9mIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBlbGVtZW50LnNldEF0dHJpYnV0ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZWxlbWVudC5uYW1lc3BhY2VVUkkgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbGVtZW50Lmluc2VydEJlZm9yZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZWxlbWVudC5oYXNDaGlsZE5vZGVzICE9PSAnZnVuY3Rpb24nKTtcbiAgfTtcbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYSBET00gbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHZhbHVlIG9iamVjdCB0byBjaGVjayB3aGV0aGVyIGl0J3MgYSBET00gbm9kZVxuICAgKiBAcmV0dXJuIHRydWUgaXMgb2JqZWN0IGlzIGEgRE9NIG5vZGVcbiAgICovXG4gIGNvbnN0IF9pc05vZGUgPSBmdW5jdGlvbiBfaXNOb2RlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBOb2RlID09PSAnZnVuY3Rpb24nICYmIHZhbHVlIGluc3RhbmNlb2YgTm9kZTtcbiAgfTtcbiAgZnVuY3Rpb24gX2V4ZWN1dGVIb29rcyhob29rcywgY3VycmVudE5vZGUsIGRhdGEpIHtcbiAgICBhcnJheUZvckVhY2goaG9va3MsIGhvb2sgPT4ge1xuICAgICAgaG9vay5jYWxsKERPTVB1cmlmeSwgY3VycmVudE5vZGUsIGRhdGEsIENPTkZJRyk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIF9zYW5pdGl6ZUVsZW1lbnRzXG4gICAqXG4gICAqIEBwcm90ZWN0IG5vZGVOYW1lXG4gICAqIEBwcm90ZWN0IHRleHRDb250ZW50XG4gICAqIEBwcm90ZWN0IHJlbW92ZUNoaWxkXG4gICAqIEBwYXJhbSBjdXJyZW50Tm9kZSB0byBjaGVjayBmb3IgcGVybWlzc2lvbiB0byBleGlzdFxuICAgKiBAcmV0dXJuIHRydWUgaWYgbm9kZSB3YXMga2lsbGVkLCBmYWxzZSBpZiBsZWZ0IGFsaXZlXG4gICAqL1xuICBjb25zdCBfc2FuaXRpemVFbGVtZW50cyA9IGZ1bmN0aW9uIF9zYW5pdGl6ZUVsZW1lbnRzKGN1cnJlbnROb2RlKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBudWxsO1xuICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICBfZXhlY3V0ZUhvb2tzKGhvb2tzLmJlZm9yZVNhbml0aXplRWxlbWVudHMsIGN1cnJlbnROb2RlLCBudWxsKTtcbiAgICAvKiBDaGVjayBpZiBlbGVtZW50IGlzIGNsb2JiZXJlZCBvciBjYW4gY2xvYmJlciAqL1xuICAgIGlmIChfaXNDbG9iYmVyZWQoY3VycmVudE5vZGUpKSB7XG4gICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qIE5vdyBsZXQncyBjaGVjayB0aGUgZWxlbWVudCdzIHR5cGUgYW5kIG5hbWUgKi9cbiAgICBjb25zdCB0YWdOYW1lID0gdHJhbnNmb3JtQ2FzZUZ1bmMoY3VycmVudE5vZGUubm9kZU5hbWUpO1xuICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICBfZXhlY3V0ZUhvb2tzKGhvb2tzLnVwb25TYW5pdGl6ZUVsZW1lbnQsIGN1cnJlbnROb2RlLCB7XG4gICAgICB0YWdOYW1lLFxuICAgICAgYWxsb3dlZFRhZ3M6IEFMTE9XRURfVEFHU1xuICAgIH0pO1xuICAgIC8qIERldGVjdCBtWFNTIGF0dGVtcHRzIGFidXNpbmcgbmFtZXNwYWNlIGNvbmZ1c2lvbiAqL1xuICAgIGlmIChTQUZFX0ZPUl9YTUwgJiYgY3VycmVudE5vZGUuaGFzQ2hpbGROb2RlcygpICYmICFfaXNOb2RlKGN1cnJlbnROb2RlLmZpcnN0RWxlbWVudENoaWxkKSAmJiByZWdFeHBUZXN0KC88Wy9cXHchXS9nLCBjdXJyZW50Tm9kZS5pbm5lckhUTUwpICYmIHJlZ0V4cFRlc3QoLzxbL1xcdyFdL2csIGN1cnJlbnROb2RlLnRleHRDb250ZW50KSkge1xuICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiBSZW1vdmUgYW55IG9jY3VycmVuY2Ugb2YgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbnMgKi9cbiAgICBpZiAoY3VycmVudE5vZGUubm9kZVR5cGUgPT09IE5PREVfVFlQRS5wcm9ncmVzc2luZ0luc3RydWN0aW9uKSB7XG4gICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qIFJlbW92ZSBhbnkga2luZCBvZiBwb3NzaWJseSBoYXJtZnVsIGNvbW1lbnRzICovXG4gICAgaWYgKFNBRkVfRk9SX1hNTCAmJiBjdXJyZW50Tm9kZS5ub2RlVHlwZSA9PT0gTk9ERV9UWVBFLmNvbW1lbnQgJiYgcmVnRXhwVGVzdCgvPFsvXFx3XS9nLCBjdXJyZW50Tm9kZS5kYXRhKSkge1xuICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiBSZW1vdmUgZWxlbWVudCBpZiBhbnl0aGluZyBmb3JiaWRzIGl0cyBwcmVzZW5jZSAqL1xuICAgIGlmICghKEVYVFJBX0VMRU1FTlRfSEFORExJTkcudGFnQ2hlY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBFWFRSQV9FTEVNRU5UX0hBTkRMSU5HLnRhZ0NoZWNrKHRhZ05hbWUpKSAmJiAoIUFMTE9XRURfVEFHU1t0YWdOYW1lXSB8fCBGT1JCSURfVEFHU1t0YWdOYW1lXSkpIHtcbiAgICAgIC8qIENoZWNrIGlmIHdlIGhhdmUgYSBjdXN0b20gZWxlbWVudCB0byBoYW5kbGUgKi9cbiAgICAgIGlmICghRk9SQklEX1RBR1NbdGFnTmFtZV0gJiYgX2lzQmFzaWNDdXN0b21FbGVtZW50KHRhZ05hbWUpKSB7XG4gICAgICAgIGlmIChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBSZWdFeHAgJiYgcmVnRXhwVGVzdChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2ssIHRhZ05hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2sodGFnTmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qIEtlZXAgY29udGVudCBleGNlcHQgZm9yIGJhZC1saXN0ZWQgZWxlbWVudHMgKi9cbiAgICAgIGlmIChLRUVQX0NPTlRFTlQgJiYgIUZPUkJJRF9DT05URU5UU1t0YWdOYW1lXSkge1xuICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShjdXJyZW50Tm9kZSkgfHwgY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IGdldENoaWxkTm9kZXMoY3VycmVudE5vZGUpIHx8IGN1cnJlbnROb2RlLmNoaWxkTm9kZXM7XG4gICAgICAgIGlmIChjaGlsZE5vZGVzICYmIHBhcmVudE5vZGUpIHtcbiAgICAgICAgICBjb25zdCBjaGlsZENvdW50ID0gY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IGNoaWxkQ291bnQgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRDbG9uZSA9IGNsb25lTm9kZShjaGlsZE5vZGVzW2ldLCB0cnVlKTtcbiAgICAgICAgICAgIGNoaWxkQ2xvbmUuX19yZW1vdmFsQ291bnQgPSAoY3VycmVudE5vZGUuX19yZW1vdmFsQ291bnQgfHwgMCkgKyAxO1xuICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGRDbG9uZSwgZ2V0TmV4dFNpYmxpbmcoY3VycmVudE5vZGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyogQ2hlY2sgd2hldGhlciBlbGVtZW50IGhhcyBhIHZhbGlkIG5hbWVzcGFjZSAqL1xuICAgIGlmIChjdXJyZW50Tm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgIV9jaGVja1ZhbGlkTmFtZXNwYWNlKGN1cnJlbnROb2RlKSkge1xuICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiBNYWtlIHN1cmUgdGhhdCBvbGRlciBicm93c2VycyBkb24ndCBnZXQgZmFsbGJhY2stdGFnIG1YU1MgKi9cbiAgICBpZiAoKHRhZ05hbWUgPT09ICdub3NjcmlwdCcgfHwgdGFnTmFtZSA9PT0gJ25vZW1iZWQnIHx8IHRhZ05hbWUgPT09ICdub2ZyYW1lcycpICYmIHJlZ0V4cFRlc3QoLzxcXC9ubyhzY3JpcHR8ZW1iZWR8ZnJhbWVzKS9pLCBjdXJyZW50Tm9kZS5pbm5lckhUTUwpKSB7XG4gICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qIFNhbml0aXplIGVsZW1lbnQgY29udGVudCB0byBiZSB0ZW1wbGF0ZS1zYWZlICovXG4gICAgaWYgKFNBRkVfRk9SX1RFTVBMQVRFUyAmJiBjdXJyZW50Tm9kZS5ub2RlVHlwZSA9PT0gTk9ERV9UWVBFLnRleHQpIHtcbiAgICAgIC8qIEdldCB0aGUgZWxlbWVudCdzIHRleHQgY29udGVudCAqL1xuICAgICAgY29udGVudCA9IGN1cnJlbnROb2RlLnRleHRDb250ZW50O1xuICAgICAgYXJyYXlGb3JFYWNoKFtNVVNUQUNIRV9FWFBSLCBFUkJfRVhQUiwgVE1QTElUX0VYUFJdLCBleHByID0+IHtcbiAgICAgICAgY29udGVudCA9IHN0cmluZ1JlcGxhY2UoY29udGVudCwgZXhwciwgJyAnKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGN1cnJlbnROb2RlLnRleHRDb250ZW50ICE9PSBjb250ZW50KSB7XG4gICAgICAgIGFycmF5UHVzaChET01QdXJpZnkucmVtb3ZlZCwge1xuICAgICAgICAgIGVsZW1lbnQ6IGN1cnJlbnROb2RlLmNsb25lTm9kZSgpXG4gICAgICAgIH0pO1xuICAgICAgICBjdXJyZW50Tm9kZS50ZXh0Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICBfZXhlY3V0ZUhvb2tzKGhvb2tzLmFmdGVyU2FuaXRpemVFbGVtZW50cywgY3VycmVudE5vZGUsIG51bGwpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgLyoqXG4gICAqIF9pc1ZhbGlkQXR0cmlidXRlXG4gICAqXG4gICAqIEBwYXJhbSBsY1RhZyBMb3dlcmNhc2UgdGFnIG5hbWUgb2YgY29udGFpbmluZyBlbGVtZW50LlxuICAgKiBAcGFyYW0gbGNOYW1lIExvd2VyY2FzZSBhdHRyaWJ1dGUgbmFtZS5cbiAgICogQHBhcmFtIHZhbHVlIEF0dHJpYnV0ZSB2YWx1ZS5cbiAgICogQHJldHVybiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyB2YWxpZCwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgY29uc3QgX2lzVmFsaWRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBfaXNWYWxpZEF0dHJpYnV0ZShsY1RhZywgbGNOYW1lLCB2YWx1ZSkge1xuICAgIC8qIE1ha2Ugc3VyZSBhdHRyaWJ1dGUgY2Fubm90IGNsb2JiZXIgKi9cbiAgICBpZiAoU0FOSVRJWkVfRE9NICYmIChsY05hbWUgPT09ICdpZCcgfHwgbGNOYW1lID09PSAnbmFtZScpICYmICh2YWx1ZSBpbiBkb2N1bWVudCB8fCB2YWx1ZSBpbiBmb3JtRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyogQWxsb3cgdmFsaWQgZGF0YS0qIGF0dHJpYnV0ZXM6IEF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgYWZ0ZXIgXCItXCJcbiAgICAgICAgKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvbS5odG1sI2VtYmVkZGluZy1jdXN0b20tbm9uLXZpc2libGUtZGF0YS13aXRoLXRoZS1kYXRhLSotYXR0cmlidXRlcylcbiAgICAgICAgWE1MLWNvbXBhdGlibGUgKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZnJhc3RydWN0dXJlLmh0bWwjeG1sLWNvbXBhdGlibGUgYW5kIGh0dHA6Ly93d3cudzMub3JnL1RSL3htbC8jZDBlODA0KVxuICAgICAgICBXZSBkb24ndCBuZWVkIHRvIGNoZWNrIHRoZSB2YWx1ZTsgaXQncyBhbHdheXMgVVJJIHNhZmUuICovXG4gICAgaWYgKEFMTE9XX0RBVEFfQVRUUiAmJiAhRk9SQklEX0FUVFJbbGNOYW1lXSAmJiByZWdFeHBUZXN0KERBVEFfQVRUUiwgbGNOYW1lKSkgOyBlbHNlIGlmIChBTExPV19BUklBX0FUVFIgJiYgcmVnRXhwVGVzdChBUklBX0FUVFIsIGxjTmFtZSkpIDsgZWxzZSBpZiAoRVhUUkFfRUxFTUVOVF9IQU5ETElORy5hdHRyaWJ1dGVDaGVjayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIEVYVFJBX0VMRU1FTlRfSEFORExJTkcuYXR0cmlidXRlQ2hlY2sobGNOYW1lLCBsY1RhZykpIDsgZWxzZSBpZiAoIUFMTE9XRURfQVRUUltsY05hbWVdIHx8IEZPUkJJRF9BVFRSW2xjTmFtZV0pIHtcbiAgICAgIGlmIChcbiAgICAgIC8vIEZpcnN0IGNvbmRpdGlvbiBkb2VzIGEgdmVyeSBiYXNpYyBjaGVjayBpZiBhKSBpdCdzIGJhc2ljYWxseSBhIHZhbGlkIGN1c3RvbSBlbGVtZW50IHRhZ25hbWUgQU5EXG4gICAgICAvLyBiKSBpZiB0aGUgdGFnTmFtZSBwYXNzZXMgd2hhdGV2ZXIgdGhlIHVzZXIgaGFzIGNvbmZpZ3VyZWQgZm9yIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVja1xuICAgICAgLy8gYW5kIGMpIGlmIHRoZSBhdHRyaWJ1dGUgbmFtZSBwYXNzZXMgd2hhdGV2ZXIgdGhlIHVzZXIgaGFzIGNvbmZpZ3VyZWQgZm9yIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVja1xuICAgICAgX2lzQmFzaWNDdXN0b21FbGVtZW50KGxjVGFnKSAmJiAoQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrIGluc3RhbmNlb2YgUmVnRXhwICYmIHJlZ0V4cFRlc3QoQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrLCBsY1RhZykgfHwgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrIGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgQ1VTVE9NX0VMRU1FTlRfSEFORExJTkcudGFnTmFtZUNoZWNrKGxjVGFnKSkgJiYgKENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjayBpbnN0YW5jZW9mIFJlZ0V4cCAmJiByZWdFeHBUZXN0KENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLmF0dHJpYnV0ZU5hbWVDaGVjaywgbGNOYW1lKSB8fCBDVVNUT01fRUxFTUVOVF9IQU5ETElORy5hdHRyaWJ1dGVOYW1lQ2hlY2sgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBDVVNUT01fRUxFTUVOVF9IQU5ETElORy5hdHRyaWJ1dGVOYW1lQ2hlY2sobGNOYW1lLCBsY1RhZykpIHx8XG4gICAgICAvLyBBbHRlcm5hdGl2ZSwgc2Vjb25kIGNvbmRpdGlvbiBjaGVja3MgaWYgaXQncyBhbiBgaXNgLWF0dHJpYnV0ZSwgQU5EXG4gICAgICAvLyB0aGUgdmFsdWUgcGFzc2VzIHdoYXRldmVyIHRoZSB1c2VyIGhhcyBjb25maWd1cmVkIGZvciBDVVNUT01fRUxFTUVOVF9IQU5ETElORy50YWdOYW1lQ2hlY2tcbiAgICAgIGxjTmFtZSA9PT0gJ2lzJyAmJiBDVVNUT01fRUxFTUVOVF9IQU5ETElORy5hbGxvd0N1c3RvbWl6ZWRCdWlsdEluRWxlbWVudHMgJiYgKENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayBpbnN0YW5jZW9mIFJlZ0V4cCAmJiByZWdFeHBUZXN0KENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjaywgdmFsdWUpIHx8IENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIENVU1RPTV9FTEVNRU5UX0hBTkRMSU5HLnRhZ05hbWVDaGVjayh2YWx1ZSkpKSA7IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvKiBDaGVjayB2YWx1ZSBpcyBzYWZlLiBGaXJzdCwgaXMgYXR0ciBpbmVydD8gSWYgc28sIGlzIHNhZmUgKi9cbiAgICB9IGVsc2UgaWYgKFVSSV9TQUZFX0FUVFJJQlVURVNbbGNOYW1lXSkgOyBlbHNlIGlmIChyZWdFeHBUZXN0KElTX0FMTE9XRURfVVJJJDEsIHN0cmluZ1JlcGxhY2UodmFsdWUsIEFUVFJfV0hJVEVTUEFDRSwgJycpKSkgOyBlbHNlIGlmICgobGNOYW1lID09PSAnc3JjJyB8fCBsY05hbWUgPT09ICd4bGluazpocmVmJyB8fCBsY05hbWUgPT09ICdocmVmJykgJiYgbGNUYWcgIT09ICdzY3JpcHQnICYmIHN0cmluZ0luZGV4T2YodmFsdWUsICdkYXRhOicpID09PSAwICYmIERBVEFfVVJJX1RBR1NbbGNUYWddKSA7IGVsc2UgaWYgKEFMTE9XX1VOS05PV05fUFJPVE9DT0xTICYmICFyZWdFeHBUZXN0KElTX1NDUklQVF9PUl9EQVRBLCBzdHJpbmdSZXBsYWNlKHZhbHVlLCBBVFRSX1dISVRFU1BBQ0UsICcnKSkpIDsgZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICAvKipcbiAgICogX2lzQmFzaWNDdXN0b21FbGVtZW50XG4gICAqIGNoZWNrcyBpZiBhdCBsZWFzdCBvbmUgZGFzaCBpcyBpbmNsdWRlZCBpbiB0YWdOYW1lLCBhbmQgaXQncyBub3QgdGhlIGZpcnN0IGNoYXJcbiAgICogZm9yIG1vcmUgc29waGlzdGljYXRlZCBjaGVja2luZyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy92YWxpZGF0ZS1lbGVtZW50LW5hbWVcbiAgICpcbiAgICogQHBhcmFtIHRhZ05hbWUgbmFtZSBvZiB0aGUgdGFnIG9mIHRoZSBub2RlIHRvIHNhbml0aXplXG4gICAqIEByZXR1cm5zIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGFnIG5hbWUgbWVldHMgdGhlIGJhc2ljIGNyaXRlcmlhIGZvciBhIGN1c3RvbSBlbGVtZW50LCBvdGhlcndpc2UgZmFsc2UuXG4gICAqL1xuICBjb25zdCBfaXNCYXNpY0N1c3RvbUVsZW1lbnQgPSBmdW5jdGlvbiBfaXNCYXNpY0N1c3RvbUVsZW1lbnQodGFnTmFtZSkge1xuICAgIHJldHVybiB0YWdOYW1lICE9PSAnYW5ub3RhdGlvbi14bWwnICYmIHN0cmluZ01hdGNoKHRhZ05hbWUsIENVU1RPTV9FTEVNRU5UKTtcbiAgfTtcbiAgLyoqXG4gICAqIF9zYW5pdGl6ZUF0dHJpYnV0ZXNcbiAgICpcbiAgICogQHByb3RlY3QgYXR0cmlidXRlc1xuICAgKiBAcHJvdGVjdCBub2RlTmFtZVxuICAgKiBAcHJvdGVjdCByZW1vdmVBdHRyaWJ1dGVcbiAgICogQHByb3RlY3Qgc2V0QXR0cmlidXRlXG4gICAqXG4gICAqIEBwYXJhbSBjdXJyZW50Tm9kZSB0byBzYW5pdGl6ZVxuICAgKi9cbiAgY29uc3QgX3Nhbml0aXplQXR0cmlidXRlcyA9IGZ1bmN0aW9uIF9zYW5pdGl6ZUF0dHJpYnV0ZXMoY3VycmVudE5vZGUpIHtcbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgX2V4ZWN1dGVIb29rcyhob29rcy5iZWZvcmVTYW5pdGl6ZUF0dHJpYnV0ZXMsIGN1cnJlbnROb2RlLCBudWxsKTtcbiAgICBjb25zdCB7XG4gICAgICBhdHRyaWJ1dGVzXG4gICAgfSA9IGN1cnJlbnROb2RlO1xuICAgIC8qIENoZWNrIGlmIHdlIGhhdmUgYXR0cmlidXRlczsgaWYgbm90IHdlIG1pZ2h0IGhhdmUgYSB0ZXh0IG5vZGUgKi9cbiAgICBpZiAoIWF0dHJpYnV0ZXMgfHwgX2lzQ2xvYmJlcmVkKGN1cnJlbnROb2RlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBob29rRXZlbnQgPSB7XG4gICAgICBhdHRyTmFtZTogJycsXG4gICAgICBhdHRyVmFsdWU6ICcnLFxuICAgICAga2VlcEF0dHI6IHRydWUsXG4gICAgICBhbGxvd2VkQXR0cmlidXRlczogQUxMT1dFRF9BVFRSLFxuICAgICAgZm9yY2VLZWVwQXR0cjogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBsZXQgbCA9IGF0dHJpYnV0ZXMubGVuZ3RoO1xuICAgIC8qIEdvIGJhY2t3YXJkcyBvdmVyIGFsbCBhdHRyaWJ1dGVzOyBzYWZlbHkgcmVtb3ZlIGJhZCBvbmVzICovXG4gICAgd2hpbGUgKGwtLSkge1xuICAgICAgY29uc3QgYXR0ciA9IGF0dHJpYnV0ZXNbbF07XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIG5hbWVzcGFjZVVSSSxcbiAgICAgICAgdmFsdWU6IGF0dHJWYWx1ZVxuICAgICAgfSA9IGF0dHI7XG4gICAgICBjb25zdCBsY05hbWUgPSB0cmFuc2Zvcm1DYXNlRnVuYyhuYW1lKTtcbiAgICAgIGNvbnN0IGluaXRWYWx1ZSA9IGF0dHJWYWx1ZTtcbiAgICAgIGxldCB2YWx1ZSA9IG5hbWUgPT09ICd2YWx1ZScgPyBpbml0VmFsdWUgOiBzdHJpbmdUcmltKGluaXRWYWx1ZSk7XG4gICAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgICBob29rRXZlbnQuYXR0ck5hbWUgPSBsY05hbWU7XG4gICAgICBob29rRXZlbnQuYXR0clZhbHVlID0gdmFsdWU7XG4gICAgICBob29rRXZlbnQua2VlcEF0dHIgPSB0cnVlO1xuICAgICAgaG9va0V2ZW50LmZvcmNlS2VlcEF0dHIgPSB1bmRlZmluZWQ7IC8vIEFsbG93cyBkZXZlbG9wZXJzIHRvIHNlZSB0aGlzIGlzIGEgcHJvcGVydHkgdGhleSBjYW4gc2V0XG4gICAgICBfZXhlY3V0ZUhvb2tzKGhvb2tzLnVwb25TYW5pdGl6ZUF0dHJpYnV0ZSwgY3VycmVudE5vZGUsIGhvb2tFdmVudCk7XG4gICAgICB2YWx1ZSA9IGhvb2tFdmVudC5hdHRyVmFsdWU7XG4gICAgICAvKiBGdWxsIERPTSBDbG9iYmVyaW5nIHByb3RlY3Rpb24gdmlhIG5hbWVzcGFjZSBpc29sYXRpb24sXG4gICAgICAgKiBQcmVmaXggaWQgYW5kIG5hbWUgYXR0cmlidXRlcyB3aXRoIGB1c2VyLWNvbnRlbnQtYFxuICAgICAgICovXG4gICAgICBpZiAoU0FOSVRJWkVfTkFNRURfUFJPUFMgJiYgKGxjTmFtZSA9PT0gJ2lkJyB8fCBsY05hbWUgPT09ICduYW1lJykpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBhdHRyaWJ1dGUgd2l0aCB0aGlzIHZhbHVlXG4gICAgICAgIF9yZW1vdmVBdHRyaWJ1dGUobmFtZSwgY3VycmVudE5vZGUpO1xuICAgICAgICAvLyBQcmVmaXggdGhlIHZhbHVlIGFuZCBsYXRlciByZS1jcmVhdGUgdGhlIGF0dHJpYnV0ZSB3aXRoIHRoZSBzYW5pdGl6ZWQgdmFsdWVcbiAgICAgICAgdmFsdWUgPSBTQU5JVElaRV9OQU1FRF9QUk9QU19QUkVGSVggKyB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIC8qIFdvcmsgYXJvdW5kIGEgc2VjdXJpdHkgaXNzdWUgd2l0aCBjb21tZW50cyBpbnNpZGUgYXR0cmlidXRlcyAqL1xuICAgICAgaWYgKFNBRkVfRk9SX1hNTCAmJiByZWdFeHBUZXN0KC8oKC0tIT98XSk+KXw8XFwvKHN0eWxlfHRpdGxlfHRleHRhcmVhKS9pLCB2YWx1ZSkpIHtcbiAgICAgICAgX3JlbW92ZUF0dHJpYnV0ZShuYW1lLCBjdXJyZW50Tm9kZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLyogTWFrZSBzdXJlIHdlIGNhbm5vdCBlYXNpbHkgdXNlIGFuaW1hdGVkIGhyZWZzLCBldmVuIGlmIGFuaW1hdGlvbnMgYXJlIGFsbG93ZWQgKi9cbiAgICAgIGlmIChsY05hbWUgPT09ICdhdHRyaWJ1dGVuYW1lJyAmJiBzdHJpbmdNYXRjaCh2YWx1ZSwgJ2hyZWYnKSkge1xuICAgICAgICBfcmVtb3ZlQXR0cmlidXRlKG5hbWUsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvKiBEaWQgdGhlIGhvb2tzIGFwcHJvdmUgb2YgdGhlIGF0dHJpYnV0ZT8gKi9cbiAgICAgIGlmIChob29rRXZlbnQuZm9yY2VLZWVwQXR0cikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8qIERpZCB0aGUgaG9va3MgYXBwcm92ZSBvZiB0aGUgYXR0cmlidXRlPyAqL1xuICAgICAgaWYgKCFob29rRXZlbnQua2VlcEF0dHIpIHtcbiAgICAgICAgX3JlbW92ZUF0dHJpYnV0ZShuYW1lLCBjdXJyZW50Tm9kZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLyogV29yayBhcm91bmQgYSBzZWN1cml0eSBpc3N1ZSBpbiBqUXVlcnkgMy4wICovXG4gICAgICBpZiAoIUFMTE9XX1NFTEZfQ0xPU0VfSU5fQVRUUiAmJiByZWdFeHBUZXN0KC9cXC8+L2ksIHZhbHVlKSkge1xuICAgICAgICBfcmVtb3ZlQXR0cmlidXRlKG5hbWUsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvKiBTYW5pdGl6ZSBhdHRyaWJ1dGUgY29udGVudCB0byBiZSB0ZW1wbGF0ZS1zYWZlICovXG4gICAgICBpZiAoU0FGRV9GT1JfVEVNUExBVEVTKSB7XG4gICAgICAgIGFycmF5Rm9yRWFjaChbTVVTVEFDSEVfRVhQUiwgRVJCX0VYUFIsIFRNUExJVF9FWFBSXSwgZXhwciA9PiB7XG4gICAgICAgICAgdmFsdWUgPSBzdHJpbmdSZXBsYWNlKHZhbHVlLCBleHByLCAnICcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8qIElzIGB2YWx1ZWAgdmFsaWQgZm9yIHRoaXMgYXR0cmlidXRlPyAqL1xuICAgICAgY29uc3QgbGNUYWcgPSB0cmFuc2Zvcm1DYXNlRnVuYyhjdXJyZW50Tm9kZS5ub2RlTmFtZSk7XG4gICAgICBpZiAoIV9pc1ZhbGlkQXR0cmlidXRlKGxjVGFnLCBsY05hbWUsIHZhbHVlKSkge1xuICAgICAgICBfcmVtb3ZlQXR0cmlidXRlKG5hbWUsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvKiBIYW5kbGUgYXR0cmlidXRlcyB0aGF0IHJlcXVpcmUgVHJ1c3RlZCBUeXBlcyAqL1xuICAgICAgaWYgKHRydXN0ZWRUeXBlc1BvbGljeSAmJiB0eXBlb2YgdHJ1c3RlZFR5cGVzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdHJ1c3RlZFR5cGVzLmdldEF0dHJpYnV0ZVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKG5hbWVzcGFjZVVSSSkgOyBlbHNlIHtcbiAgICAgICAgICBzd2l0Y2ggKHRydXN0ZWRUeXBlcy5nZXRBdHRyaWJ1dGVUeXBlKGxjVGFnLCBsY05hbWUpKSB7XG4gICAgICAgICAgICBjYXNlICdUcnVzdGVkSFRNTCc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnVHJ1c3RlZFNjcmlwdFVSTCc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVTY3JpcHRVUkwodmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKiBIYW5kbGUgaW52YWxpZCBkYXRhLSogYXR0cmlidXRlIHNldCBieSB0cnktY2F0Y2hpbmcgaXQgKi9cbiAgICAgIGlmICh2YWx1ZSAhPT0gaW5pdFZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKG5hbWVzcGFjZVVSSSkge1xuICAgICAgICAgICAgY3VycmVudE5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlVVJJLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qIEZhbGxiYWNrIHRvIHNldEF0dHJpYnV0ZSgpIGZvciBicm93c2VyLXVucmVjb2duaXplZCBuYW1lc3BhY2VzIGUuZy4gXCJ4LXNjaGVtYVwiLiAqL1xuICAgICAgICAgICAgY3VycmVudE5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF9pc0Nsb2JiZXJlZChjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFycmF5UG9wKERPTVB1cmlmeS5yZW1vdmVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICBfcmVtb3ZlQXR0cmlidXRlKG5hbWUsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgX2V4ZWN1dGVIb29rcyhob29rcy5hZnRlclNhbml0aXplQXR0cmlidXRlcywgY3VycmVudE5vZGUsIG51bGwpO1xuICB9O1xuICAvKipcbiAgICogX3Nhbml0aXplU2hhZG93RE9NXG4gICAqXG4gICAqIEBwYXJhbSBmcmFnbWVudCB0byBpdGVyYXRlIG92ZXIgcmVjdXJzaXZlbHlcbiAgICovXG4gIGNvbnN0IF9zYW5pdGl6ZVNoYWRvd0RPTSA9IGZ1bmN0aW9uIF9zYW5pdGl6ZVNoYWRvd0RPTShmcmFnbWVudCkge1xuICAgIGxldCBzaGFkb3dOb2RlID0gbnVsbDtcbiAgICBjb25zdCBzaGFkb3dJdGVyYXRvciA9IF9jcmVhdGVOb2RlSXRlcmF0b3IoZnJhZ21lbnQpO1xuICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICBfZXhlY3V0ZUhvb2tzKGhvb2tzLmJlZm9yZVNhbml0aXplU2hhZG93RE9NLCBmcmFnbWVudCwgbnVsbCk7XG4gICAgd2hpbGUgKHNoYWRvd05vZGUgPSBzaGFkb3dJdGVyYXRvci5uZXh0Tm9kZSgpKSB7XG4gICAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgICBfZXhlY3V0ZUhvb2tzKGhvb2tzLnVwb25TYW5pdGl6ZVNoYWRvd05vZGUsIHNoYWRvd05vZGUsIG51bGwpO1xuICAgICAgLyogU2FuaXRpemUgdGFncyBhbmQgZWxlbWVudHMgKi9cbiAgICAgIF9zYW5pdGl6ZUVsZW1lbnRzKHNoYWRvd05vZGUpO1xuICAgICAgLyogQ2hlY2sgYXR0cmlidXRlcyBuZXh0ICovXG4gICAgICBfc2FuaXRpemVBdHRyaWJ1dGVzKHNoYWRvd05vZGUpO1xuICAgICAgLyogRGVlcCBzaGFkb3cgRE9NIGRldGVjdGVkICovXG4gICAgICBpZiAoc2hhZG93Tm9kZS5jb250ZW50IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgICBfc2FuaXRpemVTaGFkb3dET00oc2hhZG93Tm9kZS5jb250ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgIF9leGVjdXRlSG9va3MoaG9va3MuYWZ0ZXJTYW5pdGl6ZVNoYWRvd0RPTSwgZnJhZ21lbnQsIG51bGwpO1xuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBET01QdXJpZnkuc2FuaXRpemUgPSBmdW5jdGlvbiAoZGlydHkpIHtcbiAgICBsZXQgY2ZnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBsZXQgYm9keSA9IG51bGw7XG4gICAgbGV0IGltcG9ydGVkTm9kZSA9IG51bGw7XG4gICAgbGV0IGN1cnJlbnROb2RlID0gbnVsbDtcbiAgICBsZXQgcmV0dXJuTm9kZSA9IG51bGw7XG4gICAgLyogTWFrZSBzdXJlIHdlIGhhdmUgYSBzdHJpbmcgdG8gc2FuaXRpemUuXG4gICAgICBETyBOT1QgcmV0dXJuIGVhcmx5LCBhcyB0aGlzIHdpbGwgcmV0dXJuIHRoZSB3cm9uZyB0eXBlIGlmXG4gICAgICB0aGUgdXNlciBoYXMgcmVxdWVzdGVkIGEgRE9NIG9iamVjdCByYXRoZXIgdGhhbiBhIHN0cmluZyAqL1xuICAgIElTX0VNUFRZX0lOUFVUID0gIWRpcnR5O1xuICAgIGlmIChJU19FTVBUWV9JTlBVVCkge1xuICAgICAgZGlydHkgPSAnPCEtLT4nO1xuICAgIH1cbiAgICAvKiBTdHJpbmdpZnksIGluIGNhc2UgZGlydHkgaXMgYW4gb2JqZWN0ICovXG4gICAgaWYgKHR5cGVvZiBkaXJ0eSAhPT0gJ3N0cmluZycgJiYgIV9pc05vZGUoZGlydHkpKSB7XG4gICAgICBpZiAodHlwZW9mIGRpcnR5LnRvU3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRpcnR5ID0gZGlydHkudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkaXJ0eSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyB0eXBlRXJyb3JDcmVhdGUoJ2RpcnR5IGlzIG5vdCBhIHN0cmluZywgYWJvcnRpbmcnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgdHlwZUVycm9yQ3JlYXRlKCd0b1N0cmluZyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBSZXR1cm4gZGlydHkgSFRNTCBpZiBET01QdXJpZnkgY2Fubm90IHJ1biAqL1xuICAgIGlmICghRE9NUHVyaWZ5LmlzU3VwcG9ydGVkKSB7XG4gICAgICByZXR1cm4gZGlydHk7XG4gICAgfVxuICAgIC8qIEFzc2lnbiBjb25maWcgdmFycyAqL1xuICAgIGlmICghU0VUX0NPTkZJRykge1xuICAgICAgX3BhcnNlQ29uZmlnKGNmZyk7XG4gICAgfVxuICAgIC8qIENsZWFuIHVwIHJlbW92ZWQgZWxlbWVudHMgKi9cbiAgICBET01QdXJpZnkucmVtb3ZlZCA9IFtdO1xuICAgIC8qIENoZWNrIGlmIGRpcnR5IGlzIGNvcnJlY3RseSB0eXBlZCBmb3IgSU5fUExBQ0UgKi9cbiAgICBpZiAodHlwZW9mIGRpcnR5ID09PSAnc3RyaW5nJykge1xuICAgICAgSU5fUExBQ0UgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKElOX1BMQUNFKSB7XG4gICAgICAvKiBEbyBzb21lIGVhcmx5IHByZS1zYW5pdGl6YXRpb24gdG8gYXZvaWQgdW5zYWZlIHJvb3Qgbm9kZXMgKi9cbiAgICAgIGlmIChkaXJ0eS5ub2RlTmFtZSkge1xuICAgICAgICBjb25zdCB0YWdOYW1lID0gdHJhbnNmb3JtQ2FzZUZ1bmMoZGlydHkubm9kZU5hbWUpO1xuICAgICAgICBpZiAoIUFMTE9XRURfVEFHU1t0YWdOYW1lXSB8fCBGT1JCSURfVEFHU1t0YWdOYW1lXSkge1xuICAgICAgICAgIHRocm93IHR5cGVFcnJvckNyZWF0ZSgncm9vdCBub2RlIGlzIGZvcmJpZGRlbiBhbmQgY2Fubm90IGJlIHNhbml0aXplZCBpbi1wbGFjZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkaXJ0eSBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgIC8qIElmIGRpcnR5IGlzIGEgRE9NIGVsZW1lbnQsIGFwcGVuZCB0byBhbiBlbXB0eSBkb2N1bWVudCB0byBhdm9pZFxuICAgICAgICAgZWxlbWVudHMgYmVpbmcgc3RyaXBwZWQgYnkgdGhlIHBhcnNlciAqL1xuICAgICAgYm9keSA9IF9pbml0RG9jdW1lbnQoJzwhLS0tLT4nKTtcbiAgICAgIGltcG9ydGVkTm9kZSA9IGJvZHkub3duZXJEb2N1bWVudC5pbXBvcnROb2RlKGRpcnR5LCB0cnVlKTtcbiAgICAgIGlmIChpbXBvcnRlZE5vZGUubm9kZVR5cGUgPT09IE5PREVfVFlQRS5lbGVtZW50ICYmIGltcG9ydGVkTm9kZS5ub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgIC8qIE5vZGUgaXMgYWxyZWFkeSBhIGJvZHksIHVzZSBhcyBpcyAqL1xuICAgICAgICBib2R5ID0gaW1wb3J0ZWROb2RlO1xuICAgICAgfSBlbHNlIGlmIChpbXBvcnRlZE5vZGUubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgICBib2R5ID0gaW1wb3J0ZWROb2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcHJlZmVyLWRvbS1ub2RlLWFwcGVuZFxuICAgICAgICBib2R5LmFwcGVuZENoaWxkKGltcG9ydGVkTm9kZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIEV4aXQgZGlyZWN0bHkgaWYgd2UgaGF2ZSBub3RoaW5nIHRvIGRvICovXG4gICAgICBpZiAoIVJFVFVSTl9ET00gJiYgIVNBRkVfRk9SX1RFTVBMQVRFUyAmJiAhV0hPTEVfRE9DVU1FTlQgJiZcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1pbmNsdWRlc1xuICAgICAgZGlydHkuaW5kZXhPZignPCcpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gdHJ1c3RlZFR5cGVzUG9saWN5ICYmIFJFVFVSTl9UUlVTVEVEX1RZUEUgPyB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlSFRNTChkaXJ0eSkgOiBkaXJ0eTtcbiAgICAgIH1cbiAgICAgIC8qIEluaXRpYWxpemUgdGhlIGRvY3VtZW50IHRvIHdvcmsgb24gKi9cbiAgICAgIGJvZHkgPSBfaW5pdERvY3VtZW50KGRpcnR5KTtcbiAgICAgIC8qIENoZWNrIHdlIGhhdmUgYSBET00gbm9kZSBmcm9tIHRoZSBkYXRhICovXG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgcmV0dXJuIFJFVFVSTl9ET00gPyBudWxsIDogUkVUVVJOX1RSVVNURURfVFlQRSA/IGVtcHR5SFRNTCA6ICcnO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBSZW1vdmUgZmlyc3QgZWxlbWVudCBub2RlIChvdXJzKSBpZiBGT1JDRV9CT0RZIGlzIHNldCAqL1xuICAgIGlmIChib2R5ICYmIEZPUkNFX0JPRFkpIHtcbiAgICAgIF9mb3JjZVJlbW92ZShib2R5LmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICAvKiBHZXQgbm9kZSBpdGVyYXRvciAqL1xuICAgIGNvbnN0IG5vZGVJdGVyYXRvciA9IF9jcmVhdGVOb2RlSXRlcmF0b3IoSU5fUExBQ0UgPyBkaXJ0eSA6IGJvZHkpO1xuICAgIC8qIE5vdyBzdGFydCBpdGVyYXRpbmcgb3ZlciB0aGUgY3JlYXRlZCBkb2N1bWVudCAqL1xuICAgIHdoaWxlIChjdXJyZW50Tm9kZSA9IG5vZGVJdGVyYXRvci5uZXh0Tm9kZSgpKSB7XG4gICAgICAvKiBTYW5pdGl6ZSB0YWdzIGFuZCBlbGVtZW50cyAqL1xuICAgICAgX3Nhbml0aXplRWxlbWVudHMoY3VycmVudE5vZGUpO1xuICAgICAgLyogQ2hlY2sgYXR0cmlidXRlcyBuZXh0ICovXG4gICAgICBfc2FuaXRpemVBdHRyaWJ1dGVzKGN1cnJlbnROb2RlKTtcbiAgICAgIC8qIFNoYWRvdyBET00gZGV0ZWN0ZWQsIHNhbml0aXplIGl0ICovXG4gICAgICBpZiAoY3VycmVudE5vZGUuY29udGVudCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgX3Nhbml0aXplU2hhZG93RE9NKGN1cnJlbnROb2RlLmNvbnRlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB3ZSBzYW5pdGl6ZWQgYGRpcnR5YCBpbi1wbGFjZSwgcmV0dXJuIGl0LiAqL1xuICAgIGlmIChJTl9QTEFDRSkge1xuICAgICAgcmV0dXJuIGRpcnR5O1xuICAgIH1cbiAgICAvKiBSZXR1cm4gc2FuaXRpemVkIHN0cmluZyBvciBET00gKi9cbiAgICBpZiAoUkVUVVJOX0RPTSkge1xuICAgICAgaWYgKFJFVFVSTl9ET01fRlJBR01FTlQpIHtcbiAgICAgICAgcmV0dXJuTm9kZSA9IGNyZWF0ZURvY3VtZW50RnJhZ21lbnQuY2FsbChib2R5Lm93bmVyRG9jdW1lbnQpO1xuICAgICAgICB3aGlsZSAoYm9keS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vcHJlZmVyLWRvbS1ub2RlLWFwcGVuZFxuICAgICAgICAgIHJldHVybk5vZGUuYXBwZW5kQ2hpbGQoYm9keS5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuTm9kZSA9IGJvZHk7XG4gICAgICB9XG4gICAgICBpZiAoQUxMT1dFRF9BVFRSLnNoYWRvd3Jvb3QgfHwgQUxMT1dFRF9BVFRSLnNoYWRvd3Jvb3Rtb2RlKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAgQWRvcHROb2RlKCkgaXMgbm90IHVzZWQgYmVjYXVzZSBpbnRlcm5hbCBzdGF0ZSBpcyBub3QgcmVzZXRcbiAgICAgICAgICAoZS5nLiB0aGUgcGFzdCBuYW1lcyBtYXAgb2YgYSBIVE1MRm9ybUVsZW1lbnQpLCB0aGlzIGlzIHNhZmVcbiAgICAgICAgICBpbiB0aGVvcnkgYnV0IHdlIHdvdWxkIHJhdGhlciBub3QgcmlzayBhbm90aGVyIGF0dGFjayB2ZWN0b3IuXG4gICAgICAgICAgVGhlIHN0YXRlIHRoYXQgaXMgY2xvbmVkIGJ5IGltcG9ydE5vZGUoKSBpcyBleHBsaWNpdGx5IGRlZmluZWRcbiAgICAgICAgICBieSB0aGUgc3BlY3MuXG4gICAgICAgICovXG4gICAgICAgIHJldHVybk5vZGUgPSBpbXBvcnROb2RlLmNhbGwob3JpZ2luYWxEb2N1bWVudCwgcmV0dXJuTm9kZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0dXJuTm9kZTtcbiAgICB9XG4gICAgbGV0IHNlcmlhbGl6ZWRIVE1MID0gV0hPTEVfRE9DVU1FTlQgPyBib2R5Lm91dGVySFRNTCA6IGJvZHkuaW5uZXJIVE1MO1xuICAgIC8qIFNlcmlhbGl6ZSBkb2N0eXBlIGlmIGFsbG93ZWQgKi9cbiAgICBpZiAoV0hPTEVfRE9DVU1FTlQgJiYgQUxMT1dFRF9UQUdTWychZG9jdHlwZSddICYmIGJvZHkub3duZXJEb2N1bWVudCAmJiBib2R5Lm93bmVyRG9jdW1lbnQuZG9jdHlwZSAmJiBib2R5Lm93bmVyRG9jdW1lbnQuZG9jdHlwZS5uYW1lICYmIHJlZ0V4cFRlc3QoRE9DVFlQRV9OQU1FLCBib2R5Lm93bmVyRG9jdW1lbnQuZG9jdHlwZS5uYW1lKSkge1xuICAgICAgc2VyaWFsaXplZEhUTUwgPSAnPCFET0NUWVBFICcgKyBib2R5Lm93bmVyRG9jdW1lbnQuZG9jdHlwZS5uYW1lICsgJz5cXG4nICsgc2VyaWFsaXplZEhUTUw7XG4gICAgfVxuICAgIC8qIFNhbml0aXplIGZpbmFsIHN0cmluZyB0ZW1wbGF0ZS1zYWZlICovXG4gICAgaWYgKFNBRkVfRk9SX1RFTVBMQVRFUykge1xuICAgICAgYXJyYXlGb3JFYWNoKFtNVVNUQUNIRV9FWFBSLCBFUkJfRVhQUiwgVE1QTElUX0VYUFJdLCBleHByID0+IHtcbiAgICAgICAgc2VyaWFsaXplZEhUTUwgPSBzdHJpbmdSZXBsYWNlKHNlcmlhbGl6ZWRIVE1MLCBleHByLCAnICcpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVzdGVkVHlwZXNQb2xpY3kgJiYgUkVUVVJOX1RSVVNURURfVFlQRSA/IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKHNlcmlhbGl6ZWRIVE1MKSA6IHNlcmlhbGl6ZWRIVE1MO1xuICB9O1xuICBET01QdXJpZnkuc2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBjZmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIF9wYXJzZUNvbmZpZyhjZmcpO1xuICAgIFNFVF9DT05GSUcgPSB0cnVlO1xuICB9O1xuICBET01QdXJpZnkuY2xlYXJDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgQ09ORklHID0gbnVsbDtcbiAgICBTRVRfQ09ORklHID0gZmFsc2U7XG4gIH07XG4gIERPTVB1cmlmeS5pc1ZhbGlkQXR0cmlidXRlID0gZnVuY3Rpb24gKHRhZywgYXR0ciwgdmFsdWUpIHtcbiAgICAvKiBJbml0aWFsaXplIHNoYXJlZCBjb25maWcgdmFycyBpZiBuZWNlc3NhcnkuICovXG4gICAgaWYgKCFDT05GSUcpIHtcbiAgICAgIF9wYXJzZUNvbmZpZyh7fSk7XG4gICAgfVxuICAgIGNvbnN0IGxjVGFnID0gdHJhbnNmb3JtQ2FzZUZ1bmModGFnKTtcbiAgICBjb25zdCBsY05hbWUgPSB0cmFuc2Zvcm1DYXNlRnVuYyhhdHRyKTtcbiAgICByZXR1cm4gX2lzVmFsaWRBdHRyaWJ1dGUobGNUYWcsIGxjTmFtZSwgdmFsdWUpO1xuICB9O1xuICBET01QdXJpZnkuYWRkSG9vayA9IGZ1bmN0aW9uIChlbnRyeVBvaW50LCBob29rRnVuY3Rpb24pIHtcbiAgICBpZiAodHlwZW9mIGhvb2tGdW5jdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhcnJheVB1c2goaG9va3NbZW50cnlQb2ludF0sIGhvb2tGdW5jdGlvbik7XG4gIH07XG4gIERPTVB1cmlmeS5yZW1vdmVIb29rID0gZnVuY3Rpb24gKGVudHJ5UG9pbnQsIGhvb2tGdW5jdGlvbikge1xuICAgIGlmIChob29rRnVuY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgaW5kZXggPSBhcnJheUxhc3RJbmRleE9mKGhvb2tzW2VudHJ5UG9pbnRdLCBob29rRnVuY3Rpb24pO1xuICAgICAgcmV0dXJuIGluZGV4ID09PSAtMSA/IHVuZGVmaW5lZCA6IGFycmF5U3BsaWNlKGhvb2tzW2VudHJ5UG9pbnRdLCBpbmRleCwgMSlbMF07XG4gICAgfVxuICAgIHJldHVybiBhcnJheVBvcChob29rc1tlbnRyeVBvaW50XSk7XG4gIH07XG4gIERPTVB1cmlmeS5yZW1vdmVIb29rcyA9IGZ1bmN0aW9uIChlbnRyeVBvaW50KSB7XG4gICAgaG9va3NbZW50cnlQb2ludF0gPSBbXTtcbiAgfTtcbiAgRE9NUHVyaWZ5LnJlbW92ZUFsbEhvb2tzID0gZnVuY3Rpb24gKCkge1xuICAgIGhvb2tzID0gX2NyZWF0ZUhvb2tzTWFwKCk7XG4gIH07XG4gIHJldHVybiBET01QdXJpZnk7XG59XG52YXIgcHVyaWZ5ID0gY3JlYXRlRE9NUHVyaWZ5KCk7XG5cbmV4cG9ydCB7IHB1cmlmeSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wdXJpZnkuZXMubWpzLm1hcFxuIl0sIm5hbWVzIjpbImVudHJpZXMiLCJzZXRQcm90b3R5cGVPZiIsImlzRnJvemVuIiwiZ2V0UHJvdG90eXBlT2YiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJPYmplY3QiLCJmcmVlemUiLCJzZWFsIiwiY3JlYXRlIiwiYXBwbHkiLCJjb25zdHJ1Y3QiLCJSZWZsZWN0IiwieCIsImZ1bmMiLCJ0aGlzQXJnIiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJGdW5jIiwiX2xlbjIiLCJfa2V5MiIsImFycmF5Rm9yRWFjaCIsInVuYXBwbHkiLCJwcm90b3R5cGUiLCJmb3JFYWNoIiwiYXJyYXlMYXN0SW5kZXhPZiIsImxhc3RJbmRleE9mIiwiYXJyYXlQb3AiLCJwb3AiLCJhcnJheVB1c2giLCJwdXNoIiwiYXJyYXlTcGxpY2UiLCJzcGxpY2UiLCJzdHJpbmdUb0xvd2VyQ2FzZSIsIlN0cmluZyIsInRvTG93ZXJDYXNlIiwic3RyaW5nVG9TdHJpbmciLCJ0b1N0cmluZyIsInN0cmluZ01hdGNoIiwibWF0Y2giLCJzdHJpbmdSZXBsYWNlIiwicmVwbGFjZSIsInN0cmluZ0luZGV4T2YiLCJpbmRleE9mIiwic3RyaW5nVHJpbSIsInRyaW0iLCJvYmplY3RIYXNPd25Qcm9wZXJ0eSIsImhhc093blByb3BlcnR5IiwicmVnRXhwVGVzdCIsIlJlZ0V4cCIsInRlc3QiLCJ0eXBlRXJyb3JDcmVhdGUiLCJ1bmNvbnN0cnVjdCIsIlR5cGVFcnJvciIsImxhc3RJbmRleCIsIl9sZW4zIiwiX2tleTMiLCJfbGVuNCIsIl9rZXk0IiwiYWRkVG9TZXQiLCJzZXQiLCJhcnJheSIsInRyYW5zZm9ybUNhc2VGdW5jIiwidW5kZWZpbmVkIiwibCIsImVsZW1lbnQiLCJsY0VsZW1lbnQiLCJjbGVhbkFycmF5IiwiaW5kZXgiLCJpc1Byb3BlcnR5RXhpc3QiLCJjbG9uZSIsIm9iamVjdCIsIm5ld09iamVjdCIsInByb3BlcnR5IiwidmFsdWUiLCJpc0FycmF5IiwiY29uc3RydWN0b3IiLCJsb29rdXBHZXR0ZXIiLCJwcm9wIiwiZGVzYyIsImdldCIsImZhbGxiYWNrVmFsdWUiLCJodG1sJDEiLCJzdmckMSIsInN2Z0ZpbHRlcnMiLCJzdmdEaXNhbGxvd2VkIiwibWF0aE1sJDEiLCJtYXRoTWxEaXNhbGxvd2VkIiwidGV4dCIsImh0bWwiLCJzdmciLCJtYXRoTWwiLCJ4bWwiLCJNVVNUQUNIRV9FWFBSIiwiRVJCX0VYUFIiLCJUTVBMSVRfRVhQUiIsIkRBVEFfQVRUUiIsIkFSSUFfQVRUUiIsIklTX0FMTE9XRURfVVJJIiwiSVNfU0NSSVBUX09SX0RBVEEiLCJBVFRSX1dISVRFU1BBQ0UiLCJET0NUWVBFX05BTUUiLCJDVVNUT01fRUxFTUVOVCIsIkVYUFJFU1NJT05TIiwiX19wcm90b19fIiwiTk9ERV9UWVBFIiwiYXR0cmlidXRlIiwiY2RhdGFTZWN0aW9uIiwiZW50aXR5UmVmZXJlbmNlIiwiZW50aXR5Tm9kZSIsInByb2dyZXNzaW5nSW5zdHJ1Y3Rpb24iLCJjb21tZW50IiwiZG9jdW1lbnQiLCJkb2N1bWVudFR5cGUiLCJkb2N1bWVudEZyYWdtZW50Iiwibm90YXRpb24iLCJnZXRHbG9iYWwiLCJ3aW5kb3ciLCJfY3JlYXRlVHJ1c3RlZFR5cGVzUG9saWN5IiwidHJ1c3RlZFR5cGVzIiwicHVyaWZ5SG9zdEVsZW1lbnQiLCJjcmVhdGVQb2xpY3kiLCJzdWZmaXgiLCJBVFRSX05BTUUiLCJoYXNBdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGUiLCJwb2xpY3lOYW1lIiwiY3JlYXRlSFRNTCIsImNyZWF0ZVNjcmlwdFVSTCIsInNjcmlwdFVybCIsIl8iLCJjb25zb2xlIiwid2FybiIsIl9jcmVhdGVIb29rc01hcCIsImFmdGVyU2FuaXRpemVBdHRyaWJ1dGVzIiwiYWZ0ZXJTYW5pdGl6ZUVsZW1lbnRzIiwiYWZ0ZXJTYW5pdGl6ZVNoYWRvd0RPTSIsImJlZm9yZVNhbml0aXplQXR0cmlidXRlcyIsImJlZm9yZVNhbml0aXplRWxlbWVudHMiLCJiZWZvcmVTYW5pdGl6ZVNoYWRvd0RPTSIsInVwb25TYW5pdGl6ZUF0dHJpYnV0ZSIsInVwb25TYW5pdGl6ZUVsZW1lbnQiLCJ1cG9uU2FuaXRpemVTaGFkb3dOb2RlIiwiY3JlYXRlRE9NUHVyaWZ5IiwiRE9NUHVyaWZ5Iiwicm9vdCIsInZlcnNpb24iLCJyZW1vdmVkIiwibm9kZVR5cGUiLCJFbGVtZW50IiwiaXNTdXBwb3J0ZWQiLCJvcmlnaW5hbERvY3VtZW50IiwiY3VycmVudFNjcmlwdCIsIkRvY3VtZW50RnJhZ21lbnQiLCJIVE1MVGVtcGxhdGVFbGVtZW50IiwiTm9kZSIsIk5vZGVGaWx0ZXIiLCJOYW1lZE5vZGVNYXAiLCJNb3pOYW1lZEF0dHJNYXAiLCJIVE1MRm9ybUVsZW1lbnQiLCJET01QYXJzZXIiLCJFbGVtZW50UHJvdG90eXBlIiwiY2xvbmVOb2RlIiwicmVtb3ZlIiwiZ2V0TmV4dFNpYmxpbmciLCJnZXRDaGlsZE5vZGVzIiwiZ2V0UGFyZW50Tm9kZSIsInRlbXBsYXRlIiwiY3JlYXRlRWxlbWVudCIsImNvbnRlbnQiLCJvd25lckRvY3VtZW50IiwidHJ1c3RlZFR5cGVzUG9saWN5IiwiZW1wdHlIVE1MIiwiaW1wbGVtZW50YXRpb24iLCJjcmVhdGVOb2RlSXRlcmF0b3IiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJpbXBvcnROb2RlIiwiaG9va3MiLCJjcmVhdGVIVE1MRG9jdW1lbnQiLCJJU19BTExPV0VEX1VSSSQxIiwiQUxMT1dFRF9UQUdTIiwiREVGQVVMVF9BTExPV0VEX1RBR1MiLCJBTExPV0VEX0FUVFIiLCJERUZBVUxUX0FMTE9XRURfQVRUUiIsIkNVU1RPTV9FTEVNRU5UX0hBTkRMSU5HIiwidGFnTmFtZUNoZWNrIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiYXR0cmlidXRlTmFtZUNoZWNrIiwiYWxsb3dDdXN0b21pemVkQnVpbHRJbkVsZW1lbnRzIiwiRk9SQklEX1RBR1MiLCJGT1JCSURfQVRUUiIsIkVYVFJBX0VMRU1FTlRfSEFORExJTkciLCJ0YWdDaGVjayIsImF0dHJpYnV0ZUNoZWNrIiwiQUxMT1dfQVJJQV9BVFRSIiwiQUxMT1dfREFUQV9BVFRSIiwiQUxMT1dfVU5LTk9XTl9QUk9UT0NPTFMiLCJBTExPV19TRUxGX0NMT1NFX0lOX0FUVFIiLCJTQUZFX0ZPUl9URU1QTEFURVMiLCJTQUZFX0ZPUl9YTUwiLCJXSE9MRV9ET0NVTUVOVCIsIlNFVF9DT05GSUciLCJGT1JDRV9CT0RZIiwiUkVUVVJOX0RPTSIsIlJFVFVSTl9ET01fRlJBR01FTlQiLCJSRVRVUk5fVFJVU1RFRF9UWVBFIiwiU0FOSVRJWkVfRE9NIiwiU0FOSVRJWkVfTkFNRURfUFJPUFMiLCJTQU5JVElaRV9OQU1FRF9QUk9QU19QUkVGSVgiLCJLRUVQX0NPTlRFTlQiLCJJTl9QTEFDRSIsIlVTRV9QUk9GSUxFUyIsIkZPUkJJRF9DT05URU5UUyIsIkRFRkFVTFRfRk9SQklEX0NPTlRFTlRTIiwiREFUQV9VUklfVEFHUyIsIkRFRkFVTFRfREFUQV9VUklfVEFHUyIsIlVSSV9TQUZFX0FUVFJJQlVURVMiLCJERUZBVUxUX1VSSV9TQUZFX0FUVFJJQlVURVMiLCJNQVRITUxfTkFNRVNQQUNFIiwiU1ZHX05BTUVTUEFDRSIsIkhUTUxfTkFNRVNQQUNFIiwiTkFNRVNQQUNFIiwiSVNfRU1QVFlfSU5QVVQiLCJBTExPV0VEX05BTUVTUEFDRVMiLCJERUZBVUxUX0FMTE9XRURfTkFNRVNQQUNFUyIsIk1BVEhNTF9URVhUX0lOVEVHUkFUSU9OX1BPSU5UUyIsIkhUTUxfSU5URUdSQVRJT05fUE9JTlRTIiwiQ09NTU9OX1NWR19BTkRfSFRNTF9FTEVNRU5UUyIsIlBBUlNFUl9NRURJQV9UWVBFIiwiU1VQUE9SVEVEX1BBUlNFUl9NRURJQV9UWVBFUyIsIkRFRkFVTFRfUEFSU0VSX01FRElBX1RZUEUiLCJDT05GSUciLCJmb3JtRWxlbWVudCIsImlzUmVnZXhPckZ1bmN0aW9uIiwidGVzdFZhbHVlIiwiRnVuY3Rpb24iLCJfcGFyc2VDb25maWciLCJjZmciLCJBRERfVVJJX1NBRkVfQVRUUiIsIkFERF9EQVRBX1VSSV9UQUdTIiwiQUxMT1dFRF9VUklfUkVHRVhQIiwiQUREX1RBR1MiLCJBRERfQVRUUiIsIkFERF9GT1JCSURfQ09OVEVOVFMiLCJ0YWJsZSIsInRib2R5IiwiVFJVU1RFRF9UWVBFU19QT0xJQ1kiLCJBTExfU1ZHX1RBR1MiLCJBTExfTUFUSE1MX1RBR1MiLCJfY2hlY2tWYWxpZE5hbWVzcGFjZSIsInBhcmVudCIsInRhZ05hbWUiLCJuYW1lc3BhY2VVUkkiLCJwYXJlbnRUYWdOYW1lIiwiQm9vbGVhbiIsIl9mb3JjZVJlbW92ZSIsIm5vZGUiLCJyZW1vdmVDaGlsZCIsIl9yZW1vdmVBdHRyaWJ1dGUiLCJuYW1lIiwiZ2V0QXR0cmlidXRlTm9kZSIsImZyb20iLCJyZW1vdmVBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJfaW5pdERvY3VtZW50IiwiZGlydHkiLCJkb2MiLCJsZWFkaW5nV2hpdGVzcGFjZSIsIm1hdGNoZXMiLCJkaXJ0eVBheWxvYWQiLCJwYXJzZUZyb21TdHJpbmciLCJkb2N1bWVudEVsZW1lbnQiLCJjcmVhdGVEb2N1bWVudCIsImlubmVySFRNTCIsImJvZHkiLCJpbnNlcnRCZWZvcmUiLCJjcmVhdGVUZXh0Tm9kZSIsImNoaWxkTm9kZXMiLCJjYWxsIiwiX2NyZWF0ZU5vZGVJdGVyYXRvciIsIlNIT1dfRUxFTUVOVCIsIlNIT1dfQ09NTUVOVCIsIlNIT1dfVEVYVCIsIlNIT1dfUFJPQ0VTU0lOR19JTlNUUlVDVElPTiIsIlNIT1dfQ0RBVEFfU0VDVElPTiIsIl9pc0Nsb2JiZXJlZCIsIm5vZGVOYW1lIiwidGV4dENvbnRlbnQiLCJhdHRyaWJ1dGVzIiwiaGFzQ2hpbGROb2RlcyIsIl9pc05vZGUiLCJfZXhlY3V0ZUhvb2tzIiwiY3VycmVudE5vZGUiLCJkYXRhIiwiaG9vayIsIl9zYW5pdGl6ZUVsZW1lbnRzIiwiYWxsb3dlZFRhZ3MiLCJmaXJzdEVsZW1lbnRDaGlsZCIsIl9pc0Jhc2ljQ3VzdG9tRWxlbWVudCIsInBhcmVudE5vZGUiLCJjaGlsZENvdW50IiwiaSIsImNoaWxkQ2xvbmUiLCJfX3JlbW92YWxDb3VudCIsImV4cHIiLCJfaXNWYWxpZEF0dHJpYnV0ZSIsImxjVGFnIiwibGNOYW1lIiwiX3Nhbml0aXplQXR0cmlidXRlcyIsImhvb2tFdmVudCIsImF0dHJOYW1lIiwiYXR0clZhbHVlIiwia2VlcEF0dHIiLCJhbGxvd2VkQXR0cmlidXRlcyIsImZvcmNlS2VlcEF0dHIiLCJhdHRyIiwiaW5pdFZhbHVlIiwiZ2V0QXR0cmlidXRlVHlwZSIsInNldEF0dHJpYnV0ZU5TIiwiX3Nhbml0aXplU2hhZG93RE9NIiwiZnJhZ21lbnQiLCJzaGFkb3dOb2RlIiwic2hhZG93SXRlcmF0b3IiLCJuZXh0Tm9kZSIsInNhbml0aXplIiwiaW1wb3J0ZWROb2RlIiwicmV0dXJuTm9kZSIsImFwcGVuZENoaWxkIiwiZmlyc3RDaGlsZCIsIm5vZGVJdGVyYXRvciIsInNoYWRvd3Jvb3QiLCJzaGFkb3dyb290bW9kZSIsInNlcmlhbGl6ZWRIVE1MIiwib3V0ZXJIVE1MIiwiZG9jdHlwZSIsInNldENvbmZpZyIsImNsZWFyQ29uZmlnIiwiaXNWYWxpZEF0dHJpYnV0ZSIsInRhZyIsImFkZEhvb2siLCJlbnRyeVBvaW50IiwiaG9va0Z1bmN0aW9uIiwicmVtb3ZlSG9vayIsInJlbW92ZUhvb2tzIiwicmVtb3ZlQWxsSG9va3MiLCJwdXJpZnkiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/dompurify/dist/purify.es.mjs\n");

/***/ })

};
;