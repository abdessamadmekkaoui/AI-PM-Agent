"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cytoscape-fcose";
exports.ids = ["vendor-chunks/cytoscape-fcose"];
exports.modules = {

/***/ "(ssr)/./node_modules/cytoscape-fcose/cytoscape-fcose.js":
/*!*********************************************************!*\
  !*** ./node_modules/cytoscape-fcose/cytoscape-fcose.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n(function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory(__webpack_require__(/*! cose-base */ \"(ssr)/./node_modules/cytoscape-fcose/node_modules/cose-base/cose-base.js\"));\n    else {}\n})(void 0, function(__WEBPACK_EXTERNAL_MODULE__140__) {\n    return /******/ (()=>{\n        /******/ \"use strict\";\n        /******/ var __webpack_modules__ = {\n            /***/ 658: /***/ (module1)=>{\n                // Simple, internal Object.assign() polyfill for options objects etc.\n                module1.exports = Object.assign != null ? Object.assign.bind(Object) : function(tgt) {\n                    for(var _len = arguments.length, srcs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        srcs[_key - 1] = arguments[_key];\n                    }\n                    srcs.forEach(function(src) {\n                        Object.keys(src).forEach(function(k) {\n                            return tgt[k] = src[k];\n                        });\n                    });\n                    return tgt;\n                };\n            /***/ },\n            /***/ 548: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_1401__)=>{\n                var _slicedToArray = function() {\n                    function sliceIterator(arr, i) {\n                        var _arr = [];\n                        var _n = true;\n                        var _d = false;\n                        var _e = undefined;\n                        try {\n                            for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                                _arr.push(_s.value);\n                                if (i && _arr.length === i) break;\n                            }\n                        } catch (err) {\n                            _d = true;\n                            _e = err;\n                        } finally{\n                            try {\n                                if (!_n && _i[\"return\"]) _i[\"return\"]();\n                            } finally{\n                                if (_d) throw _e;\n                            }\n                        }\n                        return _arr;\n                    }\n                    return function(arr, i) {\n                        if (Array.isArray(arr)) {\n                            return arr;\n                        } else if (Symbol.iterator in Object(arr)) {\n                            return sliceIterator(arr, i);\n                        } else {\n                            throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n                        }\n                    };\n                }();\n                /*\n * Auxiliary functions\n */ var LinkedList = __nested_webpack_require_1401__(140).layoutBase.LinkedList;\n                var auxiliary = {};\n                // get the top most nodes\n                auxiliary.getTopMostNodes = function(nodes) {\n                    var nodesMap = {};\n                    for(var i = 0; i < nodes.length; i++){\n                        nodesMap[nodes[i].id()] = true;\n                    }\n                    var roots = nodes.filter(function(ele, i) {\n                        if (typeof ele === \"number\") {\n                            ele = i;\n                        }\n                        var parent = ele.parent()[0];\n                        while(parent != null){\n                            if (nodesMap[parent.id()]) {\n                                return false;\n                            }\n                            parent = parent.parent()[0];\n                        }\n                        return true;\n                    });\n                    return roots;\n                };\n                // find disconnected components and create dummy nodes that connect them\n                auxiliary.connectComponents = function(cy, eles, topMostNodes, dummyNodes) {\n                    var queue = new LinkedList();\n                    var visited = new Set();\n                    var visitedTopMostNodes = [];\n                    var currentNeighbor = void 0;\n                    var minDegreeNode = void 0;\n                    var minDegree = void 0;\n                    var isConnected = false;\n                    var count = 1;\n                    var nodesConnectedToDummy = [];\n                    var components = [];\n                    var _loop = function _loop() {\n                        var cmpt = cy.collection();\n                        components.push(cmpt);\n                        var currentNode = topMostNodes[0];\n                        var childrenOfCurrentNode = cy.collection();\n                        childrenOfCurrentNode.merge(currentNode).merge(currentNode.descendants().intersection(eles));\n                        visitedTopMostNodes.push(currentNode);\n                        childrenOfCurrentNode.forEach(function(node) {\n                            queue.push(node);\n                            visited.add(node);\n                            cmpt.merge(node);\n                        });\n                        var _loop2 = function _loop2() {\n                            currentNode = queue.shift();\n                            // Traverse all neighbors of this node\n                            var neighborNodes = cy.collection();\n                            currentNode.neighborhood().nodes().forEach(function(node) {\n                                if (eles.intersection(currentNode.edgesWith(node)).length > 0) {\n                                    neighborNodes.merge(node);\n                                }\n                            });\n                            for(var i = 0; i < neighborNodes.length; i++){\n                                var neighborNode = neighborNodes[i];\n                                currentNeighbor = topMostNodes.intersection(neighborNode.union(neighborNode.ancestors()));\n                                if (currentNeighbor != null && !visited.has(currentNeighbor[0])) {\n                                    var childrenOfNeighbor = currentNeighbor.union(currentNeighbor.descendants());\n                                    childrenOfNeighbor.forEach(function(node) {\n                                        queue.push(node);\n                                        visited.add(node);\n                                        cmpt.merge(node);\n                                        if (topMostNodes.has(node)) {\n                                            visitedTopMostNodes.push(node);\n                                        }\n                                    });\n                                }\n                            }\n                        };\n                        while(queue.length != 0){\n                            _loop2();\n                        }\n                        cmpt.forEach(function(node) {\n                            eles.intersection(node.connectedEdges()).forEach(function(e) {\n                                // connectedEdges() usually cached\n                                if (cmpt.has(e.source()) && cmpt.has(e.target())) {\n                                    // has() is cheap\n                                    cmpt.merge(e);\n                                }\n                            });\n                        });\n                        if (visitedTopMostNodes.length == topMostNodes.length) {\n                            isConnected = true;\n                        }\n                        if (!isConnected || isConnected && count > 1) {\n                            minDegreeNode = visitedTopMostNodes[0];\n                            minDegree = minDegreeNode.connectedEdges().length;\n                            visitedTopMostNodes.forEach(function(node) {\n                                if (node.connectedEdges().length < minDegree) {\n                                    minDegree = node.connectedEdges().length;\n                                    minDegreeNode = node;\n                                }\n                            });\n                            nodesConnectedToDummy.push(minDegreeNode.id());\n                            // TO DO: Check efficiency of this part\n                            var temp = cy.collection();\n                            temp.merge(visitedTopMostNodes[0]);\n                            visitedTopMostNodes.forEach(function(node) {\n                                temp.merge(node);\n                            });\n                            visitedTopMostNodes = [];\n                            topMostNodes = topMostNodes.difference(temp);\n                            count++;\n                        }\n                    };\n                    do {\n                        _loop();\n                    }while (!isConnected);\n                    if (dummyNodes) {\n                        if (nodesConnectedToDummy.length > 0) {\n                            dummyNodes.set(\"dummy\" + (dummyNodes.size + 1), nodesConnectedToDummy);\n                        }\n                    }\n                    return components;\n                };\n                // relocates componentResult to originalCenter if there is no fixedNodeConstraint\n                auxiliary.relocateComponent = function(originalCenter, componentResult, options) {\n                    if (!options.fixedNodeConstraint) {\n                        var minXCoord = Number.POSITIVE_INFINITY;\n                        var maxXCoord = Number.NEGATIVE_INFINITY;\n                        var minYCoord = Number.POSITIVE_INFINITY;\n                        var maxYCoord = Number.NEGATIVE_INFINITY;\n                        if (options.quality == \"draft\") {\n                            // calculate current bounding box\n                            var _iteratorNormalCompletion = true;\n                            var _didIteratorError = false;\n                            var _iteratorError = undefined;\n                            try {\n                                for(var _iterator = componentResult.nodeIndexes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                                    var _ref = _step.value;\n                                    var _ref2 = _slicedToArray(_ref, 2);\n                                    var key = _ref2[0];\n                                    var value = _ref2[1];\n                                    var cyNode = options.cy.getElementById(key);\n                                    if (cyNode) {\n                                        var nodeBB = cyNode.boundingBox();\n                                        var leftX = componentResult.xCoords[value] - nodeBB.w / 2;\n                                        var rightX = componentResult.xCoords[value] + nodeBB.w / 2;\n                                        var topY = componentResult.yCoords[value] - nodeBB.h / 2;\n                                        var bottomY = componentResult.yCoords[value] + nodeBB.h / 2;\n                                        if (leftX < minXCoord) minXCoord = leftX;\n                                        if (rightX > maxXCoord) maxXCoord = rightX;\n                                        if (topY < minYCoord) minYCoord = topY;\n                                        if (bottomY > maxYCoord) maxYCoord = bottomY;\n                                    }\n                                }\n                            // find difference between current and original center\n                            } catch (err) {\n                                _didIteratorError = true;\n                                _iteratorError = err;\n                            } finally{\n                                try {\n                                    if (!_iteratorNormalCompletion && _iterator.return) {\n                                        _iterator.return();\n                                    }\n                                } finally{\n                                    if (_didIteratorError) {\n                                        throw _iteratorError;\n                                    }\n                                }\n                            }\n                            var diffOnX = originalCenter.x - (maxXCoord + minXCoord) / 2;\n                            var diffOnY = originalCenter.y - (maxYCoord + minYCoord) / 2;\n                            // move component to original center\n                            componentResult.xCoords = componentResult.xCoords.map(function(x) {\n                                return x + diffOnX;\n                            });\n                            componentResult.yCoords = componentResult.yCoords.map(function(y) {\n                                return y + diffOnY;\n                            });\n                        } else {\n                            // calculate current bounding box\n                            Object.keys(componentResult).forEach(function(item) {\n                                var node = componentResult[item];\n                                var leftX = node.getRect().x;\n                                var rightX = node.getRect().x + node.getRect().width;\n                                var topY = node.getRect().y;\n                                var bottomY = node.getRect().y + node.getRect().height;\n                                if (leftX < minXCoord) minXCoord = leftX;\n                                if (rightX > maxXCoord) maxXCoord = rightX;\n                                if (topY < minYCoord) minYCoord = topY;\n                                if (bottomY > maxYCoord) maxYCoord = bottomY;\n                            });\n                            // find difference between current and original center\n                            var _diffOnX = originalCenter.x - (maxXCoord + minXCoord) / 2;\n                            var _diffOnY = originalCenter.y - (maxYCoord + minYCoord) / 2;\n                            // move component to original center\n                            Object.keys(componentResult).forEach(function(item) {\n                                var node = componentResult[item];\n                                node.setCenter(node.getCenterX() + _diffOnX, node.getCenterY() + _diffOnY);\n                            });\n                        }\n                    }\n                };\n                auxiliary.calcBoundingBox = function(parentNode, xCoords, yCoords, nodeIndexes) {\n                    // calculate bounds\n                    var left = Number.MAX_SAFE_INTEGER;\n                    var right = Number.MIN_SAFE_INTEGER;\n                    var top = Number.MAX_SAFE_INTEGER;\n                    var bottom = Number.MIN_SAFE_INTEGER;\n                    var nodeLeft = void 0;\n                    var nodeRight = void 0;\n                    var nodeTop = void 0;\n                    var nodeBottom = void 0;\n                    var nodes = parentNode.descendants().not(\":parent\");\n                    var s = nodes.length;\n                    for(var i = 0; i < s; i++){\n                        var node = nodes[i];\n                        nodeLeft = xCoords[nodeIndexes.get(node.id())] - node.width() / 2;\n                        nodeRight = xCoords[nodeIndexes.get(node.id())] + node.width() / 2;\n                        nodeTop = yCoords[nodeIndexes.get(node.id())] - node.height() / 2;\n                        nodeBottom = yCoords[nodeIndexes.get(node.id())] + node.height() / 2;\n                        if (left > nodeLeft) {\n                            left = nodeLeft;\n                        }\n                        if (right < nodeRight) {\n                            right = nodeRight;\n                        }\n                        if (top > nodeTop) {\n                            top = nodeTop;\n                        }\n                        if (bottom < nodeBottom) {\n                            bottom = nodeBottom;\n                        }\n                    }\n                    var boundingBox = {};\n                    boundingBox.topLeftX = left;\n                    boundingBox.topLeftY = top;\n                    boundingBox.width = right - left;\n                    boundingBox.height = bottom - top;\n                    return boundingBox;\n                };\n                // This function finds and returns parent nodes whose all children are hidden\n                auxiliary.calcParentsWithoutChildren = function(cy, eles) {\n                    var parentsWithoutChildren = cy.collection();\n                    eles.nodes(\":parent\").forEach(function(parent) {\n                        var check = false;\n                        parent.children().forEach(function(child) {\n                            if (child.css(\"display\") != \"none\") {\n                                check = true;\n                            }\n                        });\n                        if (!check) {\n                            parentsWithoutChildren.merge(parent);\n                        }\n                    });\n                    return parentsWithoutChildren;\n                };\n                module1.exports = auxiliary;\n            /***/ },\n            /***/ 816: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_17405__)=>{\n                /**\n  The implementation of the postprocessing part that applies CoSE layout over the spectral layout\n*/ var aux = __nested_webpack_require_17405__(548);\n                var CoSELayout = __nested_webpack_require_17405__(140).CoSELayout;\n                var CoSENode = __nested_webpack_require_17405__(140).CoSENode;\n                var PointD = __nested_webpack_require_17405__(140).layoutBase.PointD;\n                var DimensionD = __nested_webpack_require_17405__(140).layoutBase.DimensionD;\n                var LayoutConstants = __nested_webpack_require_17405__(140).layoutBase.LayoutConstants;\n                var FDLayoutConstants = __nested_webpack_require_17405__(140).layoutBase.FDLayoutConstants;\n                var CoSEConstants = __nested_webpack_require_17405__(140).CoSEConstants;\n                // main function that cose layout is processed\n                var coseLayout = function coseLayout(options, spectralResult) {\n                    var cy = options.cy;\n                    var eles = options.eles;\n                    var nodes = eles.nodes();\n                    var edges = eles.edges();\n                    var nodeIndexes = void 0;\n                    var xCoords = void 0;\n                    var yCoords = void 0;\n                    var idToLNode = {};\n                    if (options.randomize) {\n                        nodeIndexes = spectralResult[\"nodeIndexes\"];\n                        xCoords = spectralResult[\"xCoords\"];\n                        yCoords = spectralResult[\"yCoords\"];\n                    }\n                    var isFn = function isFn(fn) {\n                        return typeof fn === \"function\";\n                    };\n                    var optFn = function optFn(opt, ele) {\n                        if (isFn(opt)) {\n                            return opt(ele);\n                        } else {\n                            return opt;\n                        }\n                    };\n                    /**** Postprocessing functions ****/ var parentsWithoutChildren = aux.calcParentsWithoutChildren(cy, eles);\n                    // transfer cytoscape nodes to cose nodes\n                    var processChildrenList = function processChildrenList(parent, children, layout, options) {\n                        var size = children.length;\n                        for(var i = 0; i < size; i++){\n                            var theChild = children[i];\n                            var children_of_children = null;\n                            if (theChild.intersection(parentsWithoutChildren).length == 0) {\n                                children_of_children = theChild.children();\n                            }\n                            var theNode = void 0;\n                            var dimensions = theChild.layoutDimensions({\n                                nodeDimensionsIncludeLabels: options.nodeDimensionsIncludeLabels\n                            });\n                            if (theChild.outerWidth() != null && theChild.outerHeight() != null) {\n                                if (options.randomize) {\n                                    if (!theChild.isParent()) {\n                                        theNode = parent.add(new CoSENode(layout.graphManager, new PointD(xCoords[nodeIndexes.get(theChild.id())] - dimensions.w / 2, yCoords[nodeIndexes.get(theChild.id())] - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n                                    } else {\n                                        var parentInfo = aux.calcBoundingBox(theChild, xCoords, yCoords, nodeIndexes);\n                                        if (theChild.intersection(parentsWithoutChildren).length == 0) {\n                                            theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parentInfo.width, parentInfo.height)));\n                                        } else {\n                                            // for the parentsWithoutChildren\n                                            theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n                                        }\n                                    }\n                                } else {\n                                    theNode = parent.add(new CoSENode(layout.graphManager, new PointD(theChild.position(\"x\") - dimensions.w / 2, theChild.position(\"y\") - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n                                }\n                            } else {\n                                theNode = parent.add(new CoSENode(this.graphManager));\n                            }\n                            // Attach id to the layout node and repulsion value\n                            theNode.id = theChild.data(\"id\");\n                            theNode.nodeRepulsion = optFn(options.nodeRepulsion, theChild);\n                            // Attach the paddings of cy node to layout node\n                            theNode.paddingLeft = parseInt(theChild.css(\"padding\"));\n                            theNode.paddingTop = parseInt(theChild.css(\"padding\"));\n                            theNode.paddingRight = parseInt(theChild.css(\"padding\"));\n                            theNode.paddingBottom = parseInt(theChild.css(\"padding\"));\n                            //Attach the label properties to both compound and simple nodes if labels will be included in node dimensions\n                            //These properties will be used while updating bounds of compounds during iterations or tiling\n                            //and will be used for simple nodes while transferring final positions to cytoscape\n                            if (options.nodeDimensionsIncludeLabels) {\n                                theNode.labelWidth = theChild.boundingBox({\n                                    includeLabels: true,\n                                    includeNodes: false,\n                                    includeOverlays: false\n                                }).w;\n                                theNode.labelHeight = theChild.boundingBox({\n                                    includeLabels: true,\n                                    includeNodes: false,\n                                    includeOverlays: false\n                                }).h;\n                                theNode.labelPosVertical = theChild.css(\"text-valign\");\n                                theNode.labelPosHorizontal = theChild.css(\"text-halign\");\n                            }\n                            // Map the layout node\n                            idToLNode[theChild.data(\"id\")] = theNode;\n                            if (isNaN(theNode.rect.x)) {\n                                theNode.rect.x = 0;\n                            }\n                            if (isNaN(theNode.rect.y)) {\n                                theNode.rect.y = 0;\n                            }\n                            if (children_of_children != null && children_of_children.length > 0) {\n                                var theNewGraph = void 0;\n                                theNewGraph = layout.getGraphManager().add(layout.newGraph(), theNode);\n                                processChildrenList(theNewGraph, children_of_children, layout, options);\n                            }\n                        }\n                    };\n                    // transfer cytoscape edges to cose edges\n                    var processEdges = function processEdges(layout, gm, edges) {\n                        var idealLengthTotal = 0;\n                        var edgeCount = 0;\n                        for(var i = 0; i < edges.length; i++){\n                            var edge = edges[i];\n                            var sourceNode = idToLNode[edge.data(\"source\")];\n                            var targetNode = idToLNode[edge.data(\"target\")];\n                            if (sourceNode && targetNode && sourceNode !== targetNode && sourceNode.getEdgesBetween(targetNode).length == 0) {\n                                var e1 = gm.add(layout.newEdge(), sourceNode, targetNode);\n                                e1.id = edge.id();\n                                e1.idealLength = optFn(options.idealEdgeLength, edge);\n                                e1.edgeElasticity = optFn(options.edgeElasticity, edge);\n                                idealLengthTotal += e1.idealLength;\n                                edgeCount++;\n                            }\n                        }\n                        // we need to update the ideal edge length constant with the avg. ideal length value after processing edges\n                        // in case there is no edge, use other options\n                        if (options.idealEdgeLength != null) {\n                            if (edgeCount > 0) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = idealLengthTotal / edgeCount;\n                            else if (!isFn(options.idealEdgeLength)) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = options.idealEdgeLength;\n                            else CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\n                            // we need to update these constant values based on the ideal edge length constant\n                            CoSEConstants.MIN_REPULSION_DIST = FDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\n                            CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n                        }\n                    };\n                    // transfer cytoscape constraints to cose layout\n                    var processConstraints = function processConstraints(layout, options) {\n                        // get nodes to be fixed\n                        if (options.fixedNodeConstraint) {\n                            layout.constraints[\"fixedNodeConstraint\"] = options.fixedNodeConstraint;\n                        }\n                        // get nodes to be aligned\n                        if (options.alignmentConstraint) {\n                            layout.constraints[\"alignmentConstraint\"] = options.alignmentConstraint;\n                        }\n                        // get nodes to be relatively placed\n                        if (options.relativePlacementConstraint) {\n                            layout.constraints[\"relativePlacementConstraint\"] = options.relativePlacementConstraint;\n                        }\n                    };\n                    /**** Apply postprocessing ****/ if (options.nestingFactor != null) CoSEConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = options.nestingFactor;\n                    if (options.gravity != null) CoSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;\n                    if (options.numIter != null) CoSEConstants.MAX_ITERATIONS = FDLayoutConstants.MAX_ITERATIONS = options.numIter;\n                    if (options.gravityRange != null) CoSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;\n                    if (options.gravityCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = options.gravityCompound;\n                    if (options.gravityRangeCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = options.gravityRangeCompound;\n                    if (options.initialEnergyOnIncremental != null) CoSEConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = options.initialEnergyOnIncremental;\n                    if (options.tilingCompareBy != null) CoSEConstants.TILING_COMPARE_BY = options.tilingCompareBy;\n                    if (options.quality == \"proof\") LayoutConstants.QUALITY = 2;\n                    else LayoutConstants.QUALITY = 0;\n                    CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS = FDLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = options.nodeDimensionsIncludeLabels;\n                    CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = !options.randomize;\n                    CoSEConstants.ANIMATE = FDLayoutConstants.ANIMATE = LayoutConstants.ANIMATE = options.animate;\n                    CoSEConstants.TILE = options.tile;\n                    CoSEConstants.TILING_PADDING_VERTICAL = typeof options.tilingPaddingVertical === \"function\" ? options.tilingPaddingVertical.call() : options.tilingPaddingVertical;\n                    CoSEConstants.TILING_PADDING_HORIZONTAL = typeof options.tilingPaddingHorizontal === \"function\" ? options.tilingPaddingHorizontal.call() : options.tilingPaddingHorizontal;\n                    CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = true;\n                    CoSEConstants.PURE_INCREMENTAL = !options.randomize;\n                    LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = options.uniformNodeDimensions;\n                    // This part is for debug/demo purpose\n                    if (options.step == \"transformed\") {\n                        CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;\n                        CoSEConstants.ENFORCE_CONSTRAINTS = false;\n                        CoSEConstants.APPLY_LAYOUT = false;\n                    }\n                    if (options.step == \"enforced\") {\n                        CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n                        CoSEConstants.ENFORCE_CONSTRAINTS = true;\n                        CoSEConstants.APPLY_LAYOUT = false;\n                    }\n                    if (options.step == \"cose\") {\n                        CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n                        CoSEConstants.ENFORCE_CONSTRAINTS = false;\n                        CoSEConstants.APPLY_LAYOUT = true;\n                    }\n                    if (options.step == \"all\") {\n                        if (options.randomize) CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;\n                        else CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n                        CoSEConstants.ENFORCE_CONSTRAINTS = true;\n                        CoSEConstants.APPLY_LAYOUT = true;\n                    }\n                    if (options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint) {\n                        CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false;\n                    } else {\n                        CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true;\n                    }\n                    var coseLayout = new CoSELayout();\n                    var gm = coseLayout.newGraphManager();\n                    processChildrenList(gm.addRoot(), aux.getTopMostNodes(nodes), coseLayout, options);\n                    processEdges(coseLayout, gm, edges);\n                    processConstraints(coseLayout, options);\n                    coseLayout.runLayout();\n                    return idToLNode;\n                };\n                module1.exports = {\n                    coseLayout: coseLayout\n                };\n            /***/ },\n            /***/ 212: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_33054__)=>{\n                var _createClass = function() {\n                    function defineProperties(target, props) {\n                        for(var i = 0; i < props.length; i++){\n                            var descriptor = props[i];\n                            descriptor.enumerable = descriptor.enumerable || false;\n                            descriptor.configurable = true;\n                            if (\"value\" in descriptor) descriptor.writable = true;\n                            Object.defineProperty(target, descriptor.key, descriptor);\n                        }\n                    }\n                    return function(Constructor, protoProps, staticProps) {\n                        if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                        if (staticProps) defineProperties(Constructor, staticProps);\n                        return Constructor;\n                    };\n                }();\n                function _classCallCheck(instance, Constructor) {\n                    if (!(instance instanceof Constructor)) {\n                        throw new TypeError(\"Cannot call a class as a function\");\n                    }\n                }\n                /**\n  The implementation of the fcose layout algorithm\n*/ var assign = __nested_webpack_require_33054__(658);\n                var aux = __nested_webpack_require_33054__(548);\n                var _require = __nested_webpack_require_33054__(657), spectralLayout = _require.spectralLayout;\n                var _require2 = __nested_webpack_require_33054__(816), coseLayout = _require2.coseLayout;\n                var defaults = Object.freeze({\n                    // 'draft', 'default' or 'proof' \n                    // - 'draft' only applies spectral layout \n                    // - 'default' improves the quality with subsequent CoSE layout (fast cooling rate)\n                    // - 'proof' improves the quality with subsequent CoSE layout (slow cooling rate) \n                    quality: \"default\",\n                    // Use random node positions at beginning of layout\n                    // if this is set to false, then quality option must be \"proof\"\n                    randomize: true,\n                    // Whether or not to animate the layout\n                    animate: true,\n                    // Duration of animation in ms, if enabled\n                    animationDuration: 1000,\n                    // Easing of animation, if enabled\n                    animationEasing: undefined,\n                    // Fit the viewport to the repositioned nodes\n                    fit: true,\n                    // Padding around layout\n                    padding: 30,\n                    // Whether to include labels in node dimensions. Valid in \"proof\" quality\n                    nodeDimensionsIncludeLabels: false,\n                    // Whether or not simple nodes (non-compound nodes) are of uniform dimensions\n                    uniformNodeDimensions: false,\n                    // Whether to pack disconnected components - valid only if randomize: true\n                    packComponents: true,\n                    // Layout step - all, transformed, enforced, cose - for debug purpose only\n                    step: \"all\",\n                    /* spectral layout options */ // False for random, true for greedy\n                    samplingType: true,\n                    // Sample size to construct distance matrix\n                    sampleSize: 25,\n                    // Separation amount between nodes\n                    nodeSeparation: 75,\n                    // Power iteration tolerance\n                    piTol: 0.0000001,\n                    /* CoSE layout options */ // Node repulsion (non overlapping) multiplier\n                    nodeRepulsion: function nodeRepulsion(node) {\n                        return 4500;\n                    },\n                    // Ideal edge (non nested) length\n                    idealEdgeLength: function idealEdgeLength(edge) {\n                        return 50;\n                    },\n                    // Divisor to compute edge forces\n                    edgeElasticity: function edgeElasticity(edge) {\n                        return 0.45;\n                    },\n                    // Nesting factor (multiplier) to compute ideal edge length for nested edges\n                    nestingFactor: 0.1,\n                    // Gravity force (constant)\n                    gravity: 0.25,\n                    // Maximum number of iterations to perform\n                    numIter: 2500,\n                    // For enabling tiling\n                    tile: true,\n                    // The function that specifies the criteria for comparing nodes while sorting them during tiling operation.\n                    // Takes the node id as a parameter and the default tiling operation is perfomed when this option is not set.\n                    tilingCompareBy: undefined,\n                    // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)\n                    tilingPaddingVertical: 10,\n                    // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)\n                    tilingPaddingHorizontal: 10,\n                    // Gravity range (constant) for compounds\n                    gravityRangeCompound: 1.5,\n                    // Gravity force (constant) for compounds\n                    gravityCompound: 1.0,\n                    // Gravity range (constant)\n                    gravityRange: 3.8,\n                    // Initial cooling factor for incremental layout  \n                    initialEnergyOnIncremental: 0.3,\n                    /* constraint options */ // Fix required nodes to predefined positions\n                    // [{nodeId: 'n1', position: {x: 100, y: 200}, {...}]\n                    fixedNodeConstraint: undefined,\n                    // Align required nodes in vertical/horizontal direction\n                    // {vertical: [['n1', 'n2')], ['n3', 'n4']], horizontal: ['n2', 'n4']}\n                    alignmentConstraint: undefined,\n                    // Place two nodes relatively in vertical/horizontal direction \n                    // [{top: 'n1', bottom: 'n2', gap: 100}, {left: 'n3', right: 'n4', gap: 75}]\n                    relativePlacementConstraint: undefined,\n                    /* layout event callbacks */ ready: function ready() {},\n                    stop: function stop() {} // on layoutstop\n                });\n                var Layout = function() {\n                    function Layout(options) {\n                        _classCallCheck(this, Layout);\n                        this.options = assign({}, defaults, options);\n                    }\n                    _createClass(Layout, [\n                        {\n                            key: \"run\",\n                            value: function run() {\n                                var layout = this;\n                                var options = this.options;\n                                var cy = options.cy;\n                                var eles = options.eles;\n                                var spectralResult = [];\n                                var xCoords = void 0;\n                                var yCoords = void 0;\n                                var coseResult = [];\n                                var components = void 0;\n                                var componentCenters = [];\n                                // basic validity check for constraint inputs \n                                if (options.fixedNodeConstraint && (!Array.isArray(options.fixedNodeConstraint) || options.fixedNodeConstraint.length == 0)) {\n                                    options.fixedNodeConstraint = undefined;\n                                }\n                                if (options.alignmentConstraint) {\n                                    if (options.alignmentConstraint.vertical && (!Array.isArray(options.alignmentConstraint.vertical) || options.alignmentConstraint.vertical.length == 0)) {\n                                        options.alignmentConstraint.vertical = undefined;\n                                    }\n                                    if (options.alignmentConstraint.horizontal && (!Array.isArray(options.alignmentConstraint.horizontal) || options.alignmentConstraint.horizontal.length == 0)) {\n                                        options.alignmentConstraint.horizontal = undefined;\n                                    }\n                                }\n                                if (options.relativePlacementConstraint && (!Array.isArray(options.relativePlacementConstraint) || options.relativePlacementConstraint.length == 0)) {\n                                    options.relativePlacementConstraint = undefined;\n                                }\n                                // if any constraint exists, set some options\n                                var constraintExist = options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint;\n                                if (constraintExist) {\n                                    // constraints work with these options\n                                    options.tile = false;\n                                    options.packComponents = false;\n                                }\n                                // decide component packing is enabled or not\n                                var layUtil = void 0;\n                                var packingEnabled = false;\n                                if (cy.layoutUtilities && options.packComponents) {\n                                    layUtil = cy.layoutUtilities(\"get\");\n                                    if (!layUtil) layUtil = cy.layoutUtilities();\n                                    packingEnabled = true;\n                                }\n                                if (eles.nodes().length > 0) {\n                                    // if packing is not enabled, perform layout on the whole graph\n                                    if (!packingEnabled) {\n                                        // store component center\n                                        var boundingBox = options.eles.boundingBox();\n                                        componentCenters.push({\n                                            x: boundingBox.x1 + boundingBox.w / 2,\n                                            y: boundingBox.y1 + boundingBox.h / 2\n                                        });\n                                        // apply spectral layout\n                                        if (options.randomize) {\n                                            var result = spectralLayout(options);\n                                            spectralResult.push(result);\n                                        }\n                                        // apply cose layout as postprocessing\n                                        if (options.quality == \"default\" || options.quality == \"proof\") {\n                                            coseResult.push(coseLayout(options, spectralResult[0]));\n                                            aux.relocateComponent(componentCenters[0], coseResult[0], options); // relocate center to original position\n                                        } else {\n                                            aux.relocateComponent(componentCenters[0], spectralResult[0], options); // relocate center to original position\n                                        }\n                                    } else {\n                                        // packing is enabled\n                                        var topMostNodes = aux.getTopMostNodes(options.eles.nodes());\n                                        components = aux.connectComponents(cy, options.eles, topMostNodes);\n                                        // store component centers\n                                        components.forEach(function(component) {\n                                            var boundingBox = component.boundingBox();\n                                            componentCenters.push({\n                                                x: boundingBox.x1 + boundingBox.w / 2,\n                                                y: boundingBox.y1 + boundingBox.h / 2\n                                            });\n                                        });\n                                        //send each component to spectral layout if randomized\n                                        if (options.randomize) {\n                                            components.forEach(function(component) {\n                                                options.eles = component;\n                                                spectralResult.push(spectralLayout(options));\n                                            });\n                                        }\n                                        if (options.quality == \"default\" || options.quality == \"proof\") {\n                                            var toBeTiledNodes = cy.collection();\n                                            if (options.tile) {\n                                                // behave nodes to be tiled as one component\n                                                var nodeIndexes = new Map();\n                                                var _xCoords = [];\n                                                var _yCoords = [];\n                                                var count = 0;\n                                                var tempSpectralResult = {\n                                                    nodeIndexes: nodeIndexes,\n                                                    xCoords: _xCoords,\n                                                    yCoords: _yCoords\n                                                };\n                                                var indexesToBeDeleted = [];\n                                                components.forEach(function(component, index) {\n                                                    if (component.edges().length == 0) {\n                                                        component.nodes().forEach(function(node, i) {\n                                                            toBeTiledNodes.merge(component.nodes()[i]);\n                                                            if (!node.isParent()) {\n                                                                tempSpectralResult.nodeIndexes.set(component.nodes()[i].id(), count++);\n                                                                tempSpectralResult.xCoords.push(component.nodes()[0].position().x);\n                                                                tempSpectralResult.yCoords.push(component.nodes()[0].position().y);\n                                                            }\n                                                        });\n                                                        indexesToBeDeleted.push(index);\n                                                    }\n                                                });\n                                                if (toBeTiledNodes.length > 1) {\n                                                    var _boundingBox = toBeTiledNodes.boundingBox();\n                                                    componentCenters.push({\n                                                        x: _boundingBox.x1 + _boundingBox.w / 2,\n                                                        y: _boundingBox.y1 + _boundingBox.h / 2\n                                                    });\n                                                    components.push(toBeTiledNodes);\n                                                    spectralResult.push(tempSpectralResult);\n                                                    for(var i = indexesToBeDeleted.length - 1; i >= 0; i--){\n                                                        components.splice(indexesToBeDeleted[i], 1);\n                                                        spectralResult.splice(indexesToBeDeleted[i], 1);\n                                                        componentCenters.splice(indexesToBeDeleted[i], 1);\n                                                    }\n                                                    ;\n                                                }\n                                            }\n                                            components.forEach(function(component, index) {\n                                                // send each component to cose layout\n                                                options.eles = component;\n                                                coseResult.push(coseLayout(options, spectralResult[index]));\n                                                aux.relocateComponent(componentCenters[index], coseResult[index], options); // relocate center to original position\n                                            });\n                                        } else {\n                                            components.forEach(function(component, index) {\n                                                aux.relocateComponent(componentCenters[index], spectralResult[index], options); // relocate center to original position\n                                            });\n                                        }\n                                        // packing\n                                        var componentsEvaluated = new Set();\n                                        if (components.length > 1) {\n                                            var subgraphs = [];\n                                            var hiddenEles = eles.filter(function(ele) {\n                                                return ele.css(\"display\") == \"none\";\n                                            });\n                                            components.forEach(function(component, index) {\n                                                var nodeIndexes = void 0;\n                                                if (options.quality == \"draft\") {\n                                                    nodeIndexes = spectralResult[index].nodeIndexes;\n                                                }\n                                                if (component.nodes().not(hiddenEles).length > 0) {\n                                                    var subgraph = {};\n                                                    subgraph.edges = [];\n                                                    subgraph.nodes = [];\n                                                    var nodeIndex = void 0;\n                                                    component.nodes().not(hiddenEles).forEach(function(node) {\n                                                        if (options.quality == \"draft\") {\n                                                            if (!node.isParent()) {\n                                                                nodeIndex = nodeIndexes.get(node.id());\n                                                                subgraph.nodes.push({\n                                                                    x: spectralResult[index].xCoords[nodeIndex] - node.boundingbox().w / 2,\n                                                                    y: spectralResult[index].yCoords[nodeIndex] - node.boundingbox().h / 2,\n                                                                    width: node.boundingbox().w,\n                                                                    height: node.boundingbox().h\n                                                                });\n                                                            } else {\n                                                                var parentInfo = aux.calcBoundingBox(node, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                                                                subgraph.nodes.push({\n                                                                    x: parentInfo.topLeftX,\n                                                                    y: parentInfo.topLeftY,\n                                                                    width: parentInfo.width,\n                                                                    height: parentInfo.height\n                                                                });\n                                                            }\n                                                        } else {\n                                                            if (coseResult[index][node.id()]) {\n                                                                subgraph.nodes.push({\n                                                                    x: coseResult[index][node.id()].getLeft(),\n                                                                    y: coseResult[index][node.id()].getTop(),\n                                                                    width: coseResult[index][node.id()].getWidth(),\n                                                                    height: coseResult[index][node.id()].getHeight()\n                                                                });\n                                                            }\n                                                        }\n                                                    });\n                                                    component.edges().forEach(function(edge) {\n                                                        var source = edge.source();\n                                                        var target = edge.target();\n                                                        if (source.css(\"display\") != \"none\" && target.css(\"display\") != \"none\") {\n                                                            if (options.quality == \"draft\") {\n                                                                var sourceNodeIndex = nodeIndexes.get(source.id());\n                                                                var targetNodeIndex = nodeIndexes.get(target.id());\n                                                                var sourceCenter = [];\n                                                                var targetCenter = [];\n                                                                if (source.isParent()) {\n                                                                    var parentInfo = aux.calcBoundingBox(source, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                                                                    sourceCenter.push(parentInfo.topLeftX + parentInfo.width / 2);\n                                                                    sourceCenter.push(parentInfo.topLeftY + parentInfo.height / 2);\n                                                                } else {\n                                                                    sourceCenter.push(spectralResult[index].xCoords[sourceNodeIndex]);\n                                                                    sourceCenter.push(spectralResult[index].yCoords[sourceNodeIndex]);\n                                                                }\n                                                                if (target.isParent()) {\n                                                                    var _parentInfo = aux.calcBoundingBox(target, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                                                                    targetCenter.push(_parentInfo.topLeftX + _parentInfo.width / 2);\n                                                                    targetCenter.push(_parentInfo.topLeftY + _parentInfo.height / 2);\n                                                                } else {\n                                                                    targetCenter.push(spectralResult[index].xCoords[targetNodeIndex]);\n                                                                    targetCenter.push(spectralResult[index].yCoords[targetNodeIndex]);\n                                                                }\n                                                                subgraph.edges.push({\n                                                                    startX: sourceCenter[0],\n                                                                    startY: sourceCenter[1],\n                                                                    endX: targetCenter[0],\n                                                                    endY: targetCenter[1]\n                                                                });\n                                                            } else {\n                                                                if (coseResult[index][source.id()] && coseResult[index][target.id()]) {\n                                                                    subgraph.edges.push({\n                                                                        startX: coseResult[index][source.id()].getCenterX(),\n                                                                        startY: coseResult[index][source.id()].getCenterY(),\n                                                                        endX: coseResult[index][target.id()].getCenterX(),\n                                                                        endY: coseResult[index][target.id()].getCenterY()\n                                                                    });\n                                                                }\n                                                            }\n                                                        }\n                                                    });\n                                                    if (subgraph.nodes.length > 0) {\n                                                        subgraphs.push(subgraph);\n                                                        componentsEvaluated.add(index);\n                                                    }\n                                                }\n                                            });\n                                            var shiftResult = layUtil.packComponents(subgraphs, options.randomize).shifts;\n                                            if (options.quality == \"draft\") {\n                                                spectralResult.forEach(function(result, index) {\n                                                    var newXCoords = result.xCoords.map(function(x) {\n                                                        return x + shiftResult[index].dx;\n                                                    });\n                                                    var newYCoords = result.yCoords.map(function(y) {\n                                                        return y + shiftResult[index].dy;\n                                                    });\n                                                    result.xCoords = newXCoords;\n                                                    result.yCoords = newYCoords;\n                                                });\n                                            } else {\n                                                var _count = 0;\n                                                componentsEvaluated.forEach(function(index) {\n                                                    Object.keys(coseResult[index]).forEach(function(item) {\n                                                        var nodeRectangle = coseResult[index][item];\n                                                        nodeRectangle.setCenter(nodeRectangle.getCenterX() + shiftResult[_count].dx, nodeRectangle.getCenterY() + shiftResult[_count].dy);\n                                                    });\n                                                    _count++;\n                                                });\n                                            }\n                                        }\n                                    }\n                                }\n                                // get each element's calculated position\n                                var getPositions = function getPositions(ele, i) {\n                                    if (options.quality == \"default\" || options.quality == \"proof\") {\n                                        if (typeof ele === \"number\") {\n                                            ele = i;\n                                        }\n                                        var pos = void 0;\n                                        var node = void 0;\n                                        var theId = ele.data(\"id\");\n                                        coseResult.forEach(function(result) {\n                                            if (theId in result) {\n                                                pos = {\n                                                    x: result[theId].getRect().getCenterX(),\n                                                    y: result[theId].getRect().getCenterY()\n                                                };\n                                                node = result[theId];\n                                            }\n                                        });\n                                        if (options.nodeDimensionsIncludeLabels) {\n                                            if (node.labelWidth) {\n                                                if (node.labelPosHorizontal == \"left\") {\n                                                    pos.x += node.labelWidth / 2;\n                                                } else if (node.labelPosHorizontal == \"right\") {\n                                                    pos.x -= node.labelWidth / 2;\n                                                }\n                                            }\n                                            if (node.labelHeight) {\n                                                if (node.labelPosVertical == \"top\") {\n                                                    pos.y += node.labelHeight / 2;\n                                                } else if (node.labelPosVertical == \"bottom\") {\n                                                    pos.y -= node.labelHeight / 2;\n                                                }\n                                            }\n                                        }\n                                        if (pos == undefined) pos = {\n                                            x: ele.position(\"x\"),\n                                            y: ele.position(\"y\")\n                                        };\n                                        return {\n                                            x: pos.x,\n                                            y: pos.y\n                                        };\n                                    } else {\n                                        var _pos = void 0;\n                                        spectralResult.forEach(function(result) {\n                                            var index = result.nodeIndexes.get(ele.id());\n                                            if (index != undefined) {\n                                                _pos = {\n                                                    x: result.xCoords[index],\n                                                    y: result.yCoords[index]\n                                                };\n                                            }\n                                        });\n                                        if (_pos == undefined) _pos = {\n                                            x: ele.position(\"x\"),\n                                            y: ele.position(\"y\")\n                                        };\n                                        return {\n                                            x: _pos.x,\n                                            y: _pos.y\n                                        };\n                                    }\n                                };\n                                // quality = \"draft\" and randomize = false are contradictive so in that case positions don't change\n                                if (options.quality == \"default\" || options.quality == \"proof\" || options.randomize) {\n                                    // transfer calculated positions to nodes (positions of only simple nodes are evaluated, compounds are positioned automatically)\n                                    var parentsWithoutChildren = aux.calcParentsWithoutChildren(cy, eles);\n                                    var _hiddenEles = eles.filter(function(ele) {\n                                        return ele.css(\"display\") == \"none\";\n                                    });\n                                    options.eles = eles.not(_hiddenEles);\n                                    eles.nodes().not(\":parent\").not(_hiddenEles).layoutPositions(layout, options, getPositions);\n                                    if (parentsWithoutChildren.length > 0) {\n                                        parentsWithoutChildren.forEach(function(ele) {\n                                            ele.position(getPositions(ele));\n                                        });\n                                    }\n                                } else {\n                                    console.log(\"If randomize option is set to false, then quality option must be 'default' or 'proof'.\");\n                                }\n                            }\n                        }\n                    ]);\n                    return Layout;\n                }();\n                module1.exports = Layout;\n            /***/ },\n            /***/ 657: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_67183__)=>{\n                /**\n  The implementation of the spectral layout that is the first part of the fcose layout algorithm\n*/ var aux = __nested_webpack_require_67183__(548);\n                var Matrix = __nested_webpack_require_67183__(140).layoutBase.Matrix;\n                var SVD = __nested_webpack_require_67183__(140).layoutBase.SVD;\n                // main function that spectral layout is processed\n                var spectralLayout = function spectralLayout(options) {\n                    var cy = options.cy;\n                    var eles = options.eles;\n                    var nodes = eles.nodes();\n                    var parentNodes = eles.nodes(\":parent\");\n                    var dummyNodes = new Map(); // map to keep dummy nodes and their neighbors\n                    var nodeIndexes = new Map(); // map to keep indexes to nodes\n                    var parentChildMap = new Map(); // mapping btw. compound and its representative node \n                    var allNodesNeighborhood = []; // array to keep neighborhood of all nodes\n                    var xCoords = [];\n                    var yCoords = [];\n                    var samplesColumn = []; // sampled vertices\n                    var minDistancesColumn = [];\n                    var C = []; // column sampling matrix\n                    var PHI = []; // intersection of column and row sampling matrices \n                    var INV = []; // inverse of PHI \n                    var firstSample = void 0; // the first sampled node\n                    var nodeSize = void 0;\n                    var infinity = 100000000;\n                    var small = 0.000000001;\n                    var piTol = options.piTol;\n                    var samplingType = options.samplingType; // false for random, true for greedy\n                    var nodeSeparation = options.nodeSeparation;\n                    var sampleSize = void 0;\n                    /**** Spectral-preprocessing functions ****/ /**** Spectral layout functions ****/ // determine which columns to be sampled\n                    var randomSampleCR = function randomSampleCR() {\n                        var sample = 0;\n                        var count = 0;\n                        var flag = false;\n                        while(count < sampleSize){\n                            sample = Math.floor(Math.random() * nodeSize);\n                            flag = false;\n                            for(var i = 0; i < count; i++){\n                                if (samplesColumn[i] == sample) {\n                                    flag = true;\n                                    break;\n                                }\n                            }\n                            if (!flag) {\n                                samplesColumn[count] = sample;\n                                count++;\n                            } else {\n                                continue;\n                            }\n                        }\n                    };\n                    // takes the index of the node(pivot) to initiate BFS as a parameter\n                    var BFS = function BFS(pivot, index, samplingMethod) {\n                        var path = []; // the front of the path\n                        var front = 0; // the back of the path\n                        var back = 0;\n                        var current = 0;\n                        var temp = void 0;\n                        var distance = [];\n                        var max_dist = 0; // the furthest node to be returned\n                        var max_ind = 1;\n                        for(var i = 0; i < nodeSize; i++){\n                            distance[i] = infinity;\n                        }\n                        path[back] = pivot;\n                        distance[pivot] = 0;\n                        while(back >= front){\n                            current = path[front++];\n                            var neighbors = allNodesNeighborhood[current];\n                            for(var _i = 0; _i < neighbors.length; _i++){\n                                temp = nodeIndexes.get(neighbors[_i]);\n                                if (distance[temp] == infinity) {\n                                    distance[temp] = distance[current] + 1;\n                                    path[++back] = temp;\n                                }\n                            }\n                            C[current][index] = distance[current] * nodeSeparation;\n                        }\n                        if (samplingMethod) {\n                            for(var _i2 = 0; _i2 < nodeSize; _i2++){\n                                if (C[_i2][index] < minDistancesColumn[_i2]) minDistancesColumn[_i2] = C[_i2][index];\n                            }\n                            for(var _i3 = 0; _i3 < nodeSize; _i3++){\n                                if (minDistancesColumn[_i3] > max_dist) {\n                                    max_dist = minDistancesColumn[_i3];\n                                    max_ind = _i3;\n                                }\n                            }\n                        }\n                        return max_ind;\n                    };\n                    // apply BFS to all nodes or selected samples\n                    var allBFS = function allBFS(samplingMethod) {\n                        var sample = void 0;\n                        if (!samplingMethod) {\n                            randomSampleCR();\n                            // call BFS\n                            for(var i = 0; i < sampleSize; i++){\n                                BFS(samplesColumn[i], i, samplingMethod, false);\n                            }\n                        } else {\n                            sample = Math.floor(Math.random() * nodeSize);\n                            firstSample = sample;\n                            for(var _i4 = 0; _i4 < nodeSize; _i4++){\n                                minDistancesColumn[_i4] = infinity;\n                            }\n                            for(var _i5 = 0; _i5 < sampleSize; _i5++){\n                                samplesColumn[_i5] = sample;\n                                sample = BFS(sample, _i5, samplingMethod);\n                            }\n                        }\n                        // form the squared distances for C\n                        for(var _i6 = 0; _i6 < nodeSize; _i6++){\n                            for(var j = 0; j < sampleSize; j++){\n                                C[_i6][j] *= C[_i6][j];\n                            }\n                        }\n                        // form PHI\n                        for(var _i7 = 0; _i7 < sampleSize; _i7++){\n                            PHI[_i7] = [];\n                        }\n                        for(var _i8 = 0; _i8 < sampleSize; _i8++){\n                            for(var _j = 0; _j < sampleSize; _j++){\n                                PHI[_i8][_j] = C[samplesColumn[_j]][_i8];\n                            }\n                        }\n                    };\n                    // perform the SVD algorithm and apply a regularization step\n                    var sample = function sample() {\n                        var SVDResult = SVD.svd(PHI);\n                        var a_q = SVDResult.S;\n                        var a_u = SVDResult.U;\n                        var a_v = SVDResult.V;\n                        var max_s = a_q[0] * a_q[0] * a_q[0];\n                        var a_Sig = [];\n                        //  regularization\n                        for(var i = 0; i < sampleSize; i++){\n                            a_Sig[i] = [];\n                            for(var j = 0; j < sampleSize; j++){\n                                a_Sig[i][j] = 0;\n                                if (i == j) {\n                                    a_Sig[i][j] = a_q[i] / (a_q[i] * a_q[i] + max_s / (a_q[i] * a_q[i]));\n                                }\n                            }\n                        }\n                        INV = Matrix.multMat(Matrix.multMat(a_v, a_Sig), Matrix.transpose(a_u));\n                    };\n                    // calculate final coordinates \n                    var powerIteration = function powerIteration() {\n                        // two largest eigenvalues\n                        var theta1 = void 0;\n                        var theta2 = void 0;\n                        // initial guesses for eigenvectors\n                        var Y1 = [];\n                        var Y2 = [];\n                        var V1 = [];\n                        var V2 = [];\n                        for(var i = 0; i < nodeSize; i++){\n                            Y1[i] = Math.random();\n                            Y2[i] = Math.random();\n                        }\n                        Y1 = Matrix.normalize(Y1);\n                        Y2 = Matrix.normalize(Y2);\n                        var count = 0;\n                        // to keep track of the improvement ratio in power iteration\n                        var current = small;\n                        var previous = small;\n                        var temp = void 0;\n                        while(true){\n                            count++;\n                            for(var _i9 = 0; _i9 < nodeSize; _i9++){\n                                V1[_i9] = Y1[_i9];\n                            }\n                            Y1 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V1), C, INV));\n                            theta1 = Matrix.dotProduct(V1, Y1);\n                            Y1 = Matrix.normalize(Y1);\n                            current = Matrix.dotProduct(V1, Y1);\n                            temp = Math.abs(current / previous);\n                            if (temp <= 1 + piTol && temp >= 1) {\n                                break;\n                            }\n                            previous = current;\n                        }\n                        for(var _i10 = 0; _i10 < nodeSize; _i10++){\n                            V1[_i10] = Y1[_i10];\n                        }\n                        count = 0;\n                        previous = small;\n                        while(true){\n                            count++;\n                            for(var _i11 = 0; _i11 < nodeSize; _i11++){\n                                V2[_i11] = Y2[_i11];\n                            }\n                            V2 = Matrix.minusOp(V2, Matrix.multCons(V1, Matrix.dotProduct(V1, V2)));\n                            Y2 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V2), C, INV));\n                            theta2 = Matrix.dotProduct(V2, Y2);\n                            Y2 = Matrix.normalize(Y2);\n                            current = Matrix.dotProduct(V2, Y2);\n                            temp = Math.abs(current / previous);\n                            if (temp <= 1 + piTol && temp >= 1) {\n                                break;\n                            }\n                            previous = current;\n                        }\n                        for(var _i12 = 0; _i12 < nodeSize; _i12++){\n                            V2[_i12] = Y2[_i12];\n                        }\n                        // theta1 now contains dominant eigenvalue\n                        // theta2 now contains the second-largest eigenvalue\n                        // V1 now contains theta1's eigenvector\n                        // V2 now contains theta2's eigenvector\n                        //populate the two vectors\n                        xCoords = Matrix.multCons(V1, Math.sqrt(Math.abs(theta1)));\n                        yCoords = Matrix.multCons(V2, Math.sqrt(Math.abs(theta2)));\n                    };\n                    /**** Preparation for spectral layout (Preprocessing) ****/ // connect disconnected components (first top level, then inside of each compound node)\n                    aux.connectComponents(cy, eles, aux.getTopMostNodes(nodes), dummyNodes);\n                    parentNodes.forEach(function(ele) {\n                        aux.connectComponents(cy, eles, aux.getTopMostNodes(ele.descendants().intersection(eles)), dummyNodes);\n                    });\n                    // assign indexes to nodes (first real, then dummy nodes)\n                    var index = 0;\n                    for(var i = 0; i < nodes.length; i++){\n                        if (!nodes[i].isParent()) {\n                            nodeIndexes.set(nodes[i].id(), index++);\n                        }\n                    }\n                    var _iteratorNormalCompletion = true;\n                    var _didIteratorError = false;\n                    var _iteratorError = undefined;\n                    try {\n                        for(var _iterator = dummyNodes.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                            var key = _step.value;\n                            nodeIndexes.set(key, index++);\n                        }\n                    // instantiate the neighborhood matrix\n                    } catch (err) {\n                        _didIteratorError = true;\n                        _iteratorError = err;\n                    } finally{\n                        try {\n                            if (!_iteratorNormalCompletion && _iterator.return) {\n                                _iterator.return();\n                            }\n                        } finally{\n                            if (_didIteratorError) {\n                                throw _iteratorError;\n                            }\n                        }\n                    }\n                    for(var _i13 = 0; _i13 < nodeIndexes.size; _i13++){\n                        allNodesNeighborhood[_i13] = [];\n                    }\n                    // form a parent-child map to keep representative node of each compound node  \n                    parentNodes.forEach(function(ele) {\n                        var children = ele.children().intersection(eles);\n                        //      let random = 0;\n                        while(children.nodes(\":childless\").length == 0){\n                            //        random = Math.floor(Math.random() * children.nodes().length); // if all children are compound then proceed randomly\n                            children = children.nodes()[0].children().intersection(eles);\n                        }\n                        //  select the representative node - we can apply different methods here\n                        //      random = Math.floor(Math.random() * children.nodes(\":childless\").length);\n                        var index = 0;\n                        var min = children.nodes(\":childless\")[0].connectedEdges().length;\n                        children.nodes(\":childless\").forEach(function(ele2, i) {\n                            if (ele2.connectedEdges().length < min) {\n                                min = ele2.connectedEdges().length;\n                                index = i;\n                            }\n                        });\n                        parentChildMap.set(ele.id(), children.nodes(\":childless\")[index].id());\n                    });\n                    // add neighborhood relations (first real, then dummy nodes)\n                    nodes.forEach(function(ele) {\n                        var eleIndex = void 0;\n                        if (ele.isParent()) eleIndex = nodeIndexes.get(parentChildMap.get(ele.id()));\n                        else eleIndex = nodeIndexes.get(ele.id());\n                        ele.neighborhood().nodes().forEach(function(node) {\n                            if (eles.intersection(ele.edgesWith(node)).length > 0) {\n                                if (node.isParent()) allNodesNeighborhood[eleIndex].push(parentChildMap.get(node.id()));\n                                else allNodesNeighborhood[eleIndex].push(node.id());\n                            }\n                        });\n                    });\n                    var _loop = function _loop(_key) {\n                        var eleIndex = nodeIndexes.get(_key);\n                        var disconnectedId = void 0;\n                        dummyNodes.get(_key).forEach(function(id) {\n                            if (cy.getElementById(id).isParent()) disconnectedId = parentChildMap.get(id);\n                            else disconnectedId = id;\n                            allNodesNeighborhood[eleIndex].push(disconnectedId);\n                            allNodesNeighborhood[nodeIndexes.get(disconnectedId)].push(_key);\n                        });\n                    };\n                    var _iteratorNormalCompletion2 = true;\n                    var _didIteratorError2 = false;\n                    var _iteratorError2 = undefined;\n                    try {\n                        for(var _iterator2 = dummyNodes.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){\n                            var _key = _step2.value;\n                            _loop(_key);\n                        }\n                    // nodeSize now only considers the size of transformed graph\n                    } catch (err) {\n                        _didIteratorError2 = true;\n                        _iteratorError2 = err;\n                    } finally{\n                        try {\n                            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                                _iterator2.return();\n                            }\n                        } finally{\n                            if (_didIteratorError2) {\n                                throw _iteratorError2;\n                            }\n                        }\n                    }\n                    nodeSize = nodeIndexes.size;\n                    var spectralResult = void 0;\n                    // If number of nodes in transformed graph is 1 or 2, either SVD or powerIteration causes problem\n                    // So skip spectral and layout the graph with cose\n                    if (nodeSize > 2) {\n                        // if # of nodes in transformed graph is smaller than sample size,\n                        // then use # of nodes as sample size\n                        sampleSize = nodeSize < options.sampleSize ? nodeSize : options.sampleSize;\n                        // instantiates the partial matrices that will be used in spectral layout\n                        for(var _i14 = 0; _i14 < nodeSize; _i14++){\n                            C[_i14] = [];\n                        }\n                        for(var _i15 = 0; _i15 < sampleSize; _i15++){\n                            INV[_i15] = [];\n                        }\n                        /**** Apply spectral layout ****/ if (options.quality == \"draft\" || options.step == \"all\") {\n                            allBFS(samplingType);\n                            sample();\n                            powerIteration();\n                            spectralResult = {\n                                nodeIndexes: nodeIndexes,\n                                xCoords: xCoords,\n                                yCoords: yCoords\n                            };\n                        } else {\n                            nodeIndexes.forEach(function(value, key) {\n                                xCoords.push(cy.getElementById(key).position(\"x\"));\n                                yCoords.push(cy.getElementById(key).position(\"y\"));\n                            });\n                            spectralResult = {\n                                nodeIndexes: nodeIndexes,\n                                xCoords: xCoords,\n                                yCoords: yCoords\n                            };\n                        }\n                        return spectralResult;\n                    } else {\n                        var iterator = nodeIndexes.keys();\n                        var firstNode = cy.getElementById(iterator.next().value);\n                        var firstNodePos = firstNode.position();\n                        var firstNodeWidth = firstNode.outerWidth();\n                        xCoords.push(firstNodePos.x);\n                        yCoords.push(firstNodePos.y);\n                        if (nodeSize == 2) {\n                            var secondNode = cy.getElementById(iterator.next().value);\n                            var secondNodeWidth = secondNode.outerWidth();\n                            xCoords.push(firstNodePos.x + firstNodeWidth / 2 + secondNodeWidth / 2 + options.idealEdgeLength);\n                            yCoords.push(firstNodePos.y);\n                        }\n                        spectralResult = {\n                            nodeIndexes: nodeIndexes,\n                            xCoords: xCoords,\n                            yCoords: yCoords\n                        };\n                        return spectralResult;\n                    }\n                };\n                module1.exports = {\n                    spectralLayout: spectralLayout\n                };\n            /***/ },\n            /***/ 579: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_88234__)=>{\n                var impl = __nested_webpack_require_88234__(212);\n                // registers the extension on a cytoscape lib ref\n                var register = function register(cytoscape1) {\n                    if (!cytoscape1) {\n                        return;\n                    } // can't register if cytoscape unspecified\n                    cytoscape1(\"layout\", \"fcose\", impl); // register with cytoscape.js\n                };\n                if (typeof cytoscape !== \"undefined\") {\n                    // expose to global cytoscape (i.e. window.cytoscape)\n                    register(cytoscape);\n                }\n                module1.exports = register;\n            /***/ },\n            /***/ 140: /***/ (module1)=>{\n                module1.exports = __WEBPACK_EXTERNAL_MODULE__140__;\n            /***/ }\n        };\n        /************************************************************************/ /******/ // The module cache\n        /******/ var __webpack_module_cache__ = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_89308__(moduleId) {\n            /******/ // Check if module is in cache\n            /******/ var cachedModule = __webpack_module_cache__[moduleId];\n            /******/ if (cachedModule !== undefined) {\n                /******/ return cachedModule.exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = __webpack_module_cache__[moduleId] = {\n                /******/ // no module.id needed\n                /******/ // no module.loaded needed\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ __webpack_modules__[moduleId](module1, module1.exports, __nested_webpack_require_89308__);\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /************************************************************************/ /******/ /******/ // startup\n        /******/ // Load entry module and return exports\n        /******/ // This entry module is referenced by other modules so it can't be inlined\n        /******/ var __nested_webpack_exports__ = __nested_webpack_require_89308__(579);\n        /******/ /******/ return __nested_webpack_exports__;\n    /******/ })();\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlLWZjb3NlL2N5dG9zY2FwZS1mY29zZS5qcyIsIm1hcHBpbmdzIjoiO0FBQUMsVUFBU0EsaUNBQWlDQyxJQUFJLEVBQUVDLE9BQU87SUFDdkQsSUFBRyxJQUFpRCxFQUNuREUsT0FBT0QsT0FBTyxHQUFHRCxRQUFRRyxtQkFBT0EsQ0FBQywyRkFBVztTQUN4QyxFQUsrQztBQUNyRCxHQUFHLFFBQU0sU0FBU0csZ0NBQWdDO0lBQ2xELE9BQWdCLE1BQUgsR0FBSTtRQUNqQixNQUFNLEdBQUk7UUFDVixNQUFNLEdBQUksSUFBSUMsc0JBQXVCO1lBRXJDLEdBQUcsR0FBRyxLQUNOLEdBQUcsR0FBSSxDQUFDTDtnQkFJUixxRUFBcUU7Z0JBRXJFQSxRQUFPRCxPQUFPLEdBQUdPLE9BQU9DLE1BQU0sSUFBSSxPQUFPRCxPQUFPQyxNQUFNLENBQUNDLElBQUksQ0FBQ0YsVUFBVSxTQUFVRyxHQUFHO29CQUNqRixJQUFLLElBQUlDLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsT0FBT0MsTUFBTUosT0FBTyxJQUFJQSxPQUFPLElBQUksSUFBSUssT0FBTyxHQUFHQSxPQUFPTCxNQUFNSyxPQUFRO3dCQUN0R0YsSUFBSSxDQUFDRSxPQUFPLEVBQUUsR0FBR0osU0FBUyxDQUFDSSxLQUFLO29CQUNsQztvQkFFQUYsS0FBS0csT0FBTyxDQUFDLFNBQVVDLEdBQUc7d0JBQ3hCWCxPQUFPWSxJQUFJLENBQUNELEtBQUtELE9BQU8sQ0FBQyxTQUFVRyxDQUFDOzRCQUNsQyxPQUFPVixHQUFHLENBQUNVLEVBQUUsR0FBR0YsR0FBRyxDQUFDRSxFQUFFO3dCQUN4QjtvQkFDRjtvQkFFQSxPQUFPVjtnQkFDVDtZQUVBLEdBQUcsR0FBRztZQUVOLEdBQUcsR0FBRyxLQUNOLEdBQUcsR0FBSSxDQUFDVCxTQUFRb0IsMEJBQTBCQywrQkFBbUJBO2dCQUk3RCxJQUFJQyxpQkFBaUI7b0JBQWMsU0FBU0MsY0FBY0MsR0FBRyxFQUFFQyxDQUFD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QUFNLEdBQUk7UUFDVixNQUFNLEdBQ04sd0VBQXdFLEdBQ3hFLE1BQU0sR0FDTixNQUFNLEdBQUksVUFBVTtRQUNwQixNQUFNLEdBQUksdUNBQXVDO1FBQ2pELE1BQU0sR0FBSSwwRUFBMEU7UUFDcEYsTUFBTSxHQUFJLElBQUlnZCwwQkFBbUJBLEdBQUcxYixnQ0FBbUJBLENBQUM7UUFDeEQsTUFBTSxHQUNOLE1BQU0sR0FBSSxPQUFPMGIsMEJBQW1CQTtJQUNwQyxNQUFNLEdBQUc7QUFFVCIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLXBtLWFnZW50LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2N5dG9zY2FwZS1mY29zZS9jeXRvc2NhcGUtZmNvc2UuanM/YjY0NyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJjb3NlLWJhc2VcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wiY29zZS1iYXNlXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImN5dG9zY2FwZUZjb3NlXCJdID0gZmFjdG9yeShyZXF1aXJlKFwiY29zZS1iYXNlXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJjeXRvc2NhcGVGY29zZVwiXSA9IGZhY3Rvcnkocm9vdFtcImNvc2VCYXNlXCJdKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzE0MF9fKSB7XG5yZXR1cm4gLyoqKioqKi8gKCgpID0+IHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHRcInVzZSBzdHJpY3RcIjtcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyA2NTg6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cblxuLy8gU2ltcGxlLCBpbnRlcm5hbCBPYmplY3QuYXNzaWduKCkgcG9seWZpbGwgZm9yIG9wdGlvbnMgb2JqZWN0cyBldGMuXG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmFzc2lnbiAhPSBudWxsID8gT2JqZWN0LmFzc2lnbi5iaW5kKE9iamVjdCkgOiBmdW5jdGlvbiAodGd0KSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzcmNzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHNyY3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgc3Jjcy5mb3JFYWNoKGZ1bmN0aW9uIChzcmMpIHtcbiAgICBPYmplY3Qua2V5cyhzcmMpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgIHJldHVybiB0Z3Rba10gPSBzcmNba107XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiB0Z3Q7XG59O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNTQ4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxudmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG4vKlxuICogQXV4aWxpYXJ5IGZ1bmN0aW9uc1xuICovXG5cbnZhciBMaW5rZWRMaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDApLmxheW91dEJhc2UuTGlua2VkTGlzdDtcblxudmFyIGF1eGlsaWFyeSA9IHt9O1xuXG4vLyBnZXQgdGhlIHRvcCBtb3N0IG5vZGVzXG5hdXhpbGlhcnkuZ2V0VG9wTW9zdE5vZGVzID0gZnVuY3Rpb24gKG5vZGVzKSB7XG4gIHZhciBub2Rlc01hcCA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbm9kZXNNYXBbbm9kZXNbaV0uaWQoKV0gPSB0cnVlO1xuICB9XG4gIHZhciByb290cyA9IG5vZGVzLmZpbHRlcihmdW5jdGlvbiAoZWxlLCBpKSB7XG4gICAgaWYgKHR5cGVvZiBlbGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGVsZSA9IGk7XG4gICAgfVxuICAgIHZhciBwYXJlbnQgPSBlbGUucGFyZW50KClbMF07XG4gICAgd2hpbGUgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICBpZiAobm9kZXNNYXBbcGFyZW50LmlkKCldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQoKVswXTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiByb290cztcbn07XG5cbi8vIGZpbmQgZGlzY29ubmVjdGVkIGNvbXBvbmVudHMgYW5kIGNyZWF0ZSBkdW1teSBub2RlcyB0aGF0IGNvbm5lY3QgdGhlbVxuYXV4aWxpYXJ5LmNvbm5lY3RDb21wb25lbnRzID0gZnVuY3Rpb24gKGN5LCBlbGVzLCB0b3BNb3N0Tm9kZXMsIGR1bW15Tm9kZXMpIHtcbiAgdmFyIHF1ZXVlID0gbmV3IExpbmtlZExpc3QoKTtcbiAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gIHZhciB2aXNpdGVkVG9wTW9zdE5vZGVzID0gW107XG4gIHZhciBjdXJyZW50TmVpZ2hib3IgPSB2b2lkIDA7XG4gIHZhciBtaW5EZWdyZWVOb2RlID0gdm9pZCAwO1xuICB2YXIgbWluRGVncmVlID0gdm9pZCAwO1xuXG4gIHZhciBpc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICB2YXIgY291bnQgPSAxO1xuICB2YXIgbm9kZXNDb25uZWN0ZWRUb0R1bW15ID0gW107XG4gIHZhciBjb21wb25lbnRzID0gW107XG5cbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgdmFyIGNtcHQgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgY29tcG9uZW50cy5wdXNoKGNtcHQpO1xuXG4gICAgdmFyIGN1cnJlbnROb2RlID0gdG9wTW9zdE5vZGVzWzBdO1xuICAgIHZhciBjaGlsZHJlbk9mQ3VycmVudE5vZGUgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgY2hpbGRyZW5PZkN1cnJlbnROb2RlLm1lcmdlKGN1cnJlbnROb2RlKS5tZXJnZShjdXJyZW50Tm9kZS5kZXNjZW5kYW50cygpLmludGVyc2VjdGlvbihlbGVzKSk7XG4gICAgdmlzaXRlZFRvcE1vc3ROb2Rlcy5wdXNoKGN1cnJlbnROb2RlKTtcblxuICAgIGNoaWxkcmVuT2ZDdXJyZW50Tm9kZS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBxdWV1ZS5wdXNoKG5vZGUpO1xuICAgICAgdmlzaXRlZC5hZGQobm9kZSk7XG4gICAgICBjbXB0Lm1lcmdlKG5vZGUpO1xuICAgIH0pO1xuXG4gICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMigpIHtcbiAgICAgIGN1cnJlbnROb2RlID0gcXVldWUuc2hpZnQoKTtcblxuICAgICAgLy8gVHJhdmVyc2UgYWxsIG5laWdoYm9ycyBvZiB0aGlzIG5vZGVcbiAgICAgIHZhciBuZWlnaGJvck5vZGVzID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgY3VycmVudE5vZGUubmVpZ2hib3Job29kKCkubm9kZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChlbGVzLmludGVyc2VjdGlvbihjdXJyZW50Tm9kZS5lZGdlc1dpdGgobm9kZSkpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBuZWlnaGJvck5vZGVzLm1lcmdlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZWlnaGJvck5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuZWlnaGJvck5vZGUgPSBuZWlnaGJvck5vZGVzW2ldO1xuICAgICAgICBjdXJyZW50TmVpZ2hib3IgPSB0b3BNb3N0Tm9kZXMuaW50ZXJzZWN0aW9uKG5laWdoYm9yTm9kZS51bmlvbihuZWlnaGJvck5vZGUuYW5jZXN0b3JzKCkpKTtcbiAgICAgICAgaWYgKGN1cnJlbnROZWlnaGJvciAhPSBudWxsICYmICF2aXNpdGVkLmhhcyhjdXJyZW50TmVpZ2hib3JbMF0pKSB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuT2ZOZWlnaGJvciA9IGN1cnJlbnROZWlnaGJvci51bmlvbihjdXJyZW50TmVpZ2hib3IuZGVzY2VuZGFudHMoKSk7XG5cbiAgICAgICAgICBjaGlsZHJlbk9mTmVpZ2hib3IuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcXVldWUucHVzaChub2RlKTtcbiAgICAgICAgICAgIHZpc2l0ZWQuYWRkKG5vZGUpO1xuICAgICAgICAgICAgY21wdC5tZXJnZShub2RlKTtcbiAgICAgICAgICAgIGlmICh0b3BNb3N0Tm9kZXMuaGFzKG5vZGUpKSB7XG4gICAgICAgICAgICAgIHZpc2l0ZWRUb3BNb3N0Tm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB3aGlsZSAocXVldWUubGVuZ3RoICE9IDApIHtcbiAgICAgIF9sb29wMigpO1xuICAgIH1cblxuICAgIGNtcHQuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgZWxlcy5pbnRlcnNlY3Rpb24obm9kZS5jb25uZWN0ZWRFZGdlcygpKS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIC8vIGNvbm5lY3RlZEVkZ2VzKCkgdXN1YWxseSBjYWNoZWRcbiAgICAgICAgaWYgKGNtcHQuaGFzKGUuc291cmNlKCkpICYmIGNtcHQuaGFzKGUudGFyZ2V0KCkpKSB7XG4gICAgICAgICAgLy8gaGFzKCkgaXMgY2hlYXBcbiAgICAgICAgICBjbXB0Lm1lcmdlKGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGlmICh2aXNpdGVkVG9wTW9zdE5vZGVzLmxlbmd0aCA9PSB0b3BNb3N0Tm9kZXMubGVuZ3RoKSB7XG4gICAgICBpc0Nvbm5lY3RlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFpc0Nvbm5lY3RlZCB8fCBpc0Nvbm5lY3RlZCAmJiBjb3VudCA+IDEpIHtcbiAgICAgIG1pbkRlZ3JlZU5vZGUgPSB2aXNpdGVkVG9wTW9zdE5vZGVzWzBdO1xuICAgICAgbWluRGVncmVlID0gbWluRGVncmVlTm9kZS5jb25uZWN0ZWRFZGdlcygpLmxlbmd0aDtcbiAgICAgIHZpc2l0ZWRUb3BNb3N0Tm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5jb25uZWN0ZWRFZGdlcygpLmxlbmd0aCA8IG1pbkRlZ3JlZSkge1xuICAgICAgICAgIG1pbkRlZ3JlZSA9IG5vZGUuY29ubmVjdGVkRWRnZXMoKS5sZW5ndGg7XG4gICAgICAgICAgbWluRGVncmVlTm9kZSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbm9kZXNDb25uZWN0ZWRUb0R1bW15LnB1c2gobWluRGVncmVlTm9kZS5pZCgpKTtcbiAgICAgIC8vIFRPIERPOiBDaGVjayBlZmZpY2llbmN5IG9mIHRoaXMgcGFydFxuICAgICAgdmFyIHRlbXAgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICB0ZW1wLm1lcmdlKHZpc2l0ZWRUb3BNb3N0Tm9kZXNbMF0pO1xuICAgICAgdmlzaXRlZFRvcE1vc3ROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRlbXAubWVyZ2Uobm9kZSk7XG4gICAgICB9KTtcbiAgICAgIHZpc2l0ZWRUb3BNb3N0Tm9kZXMgPSBbXTtcbiAgICAgIHRvcE1vc3ROb2RlcyA9IHRvcE1vc3ROb2Rlcy5kaWZmZXJlbmNlKHRlbXApO1xuICAgICAgY291bnQrKztcbiAgICB9XG4gIH07XG5cbiAgZG8ge1xuICAgIF9sb29wKCk7XG4gIH0gd2hpbGUgKCFpc0Nvbm5lY3RlZCk7XG5cbiAgaWYgKGR1bW15Tm9kZXMpIHtcbiAgICBpZiAobm9kZXNDb25uZWN0ZWRUb0R1bW15Lmxlbmd0aCA+IDApIHtcbiAgICAgIGR1bW15Tm9kZXMuc2V0KCdkdW1teScgKyAoZHVtbXlOb2Rlcy5zaXplICsgMSksIG5vZGVzQ29ubmVjdGVkVG9EdW1teSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb21wb25lbnRzO1xufTtcblxuLy8gcmVsb2NhdGVzIGNvbXBvbmVudFJlc3VsdCB0byBvcmlnaW5hbENlbnRlciBpZiB0aGVyZSBpcyBubyBmaXhlZE5vZGVDb25zdHJhaW50XG5hdXhpbGlhcnkucmVsb2NhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAob3JpZ2luYWxDZW50ZXIsIGNvbXBvbmVudFJlc3VsdCwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMuZml4ZWROb2RlQ29uc3RyYWludCkge1xuICAgIHZhciBtaW5YQ29vcmQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgdmFyIG1heFhDb29yZCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICB2YXIgbWluWUNvb3JkID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHZhciBtYXhZQ29vcmQgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgaWYgKG9wdGlvbnMucXVhbGl0eSA9PSBcImRyYWZ0XCIpIHtcbiAgICAgIC8vIGNhbGN1bGF0ZSBjdXJyZW50IGJvdW5kaW5nIGJveFxuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGNvbXBvbmVudFJlc3VsdC5ub2RlSW5kZXhlc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgX3JlZiA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMik7XG5cbiAgICAgICAgICB2YXIga2V5ID0gX3JlZjJbMF07XG4gICAgICAgICAgdmFyIHZhbHVlID0gX3JlZjJbMV07XG5cbiAgICAgICAgICB2YXIgY3lOb2RlID0gb3B0aW9ucy5jeS5nZXRFbGVtZW50QnlJZChrZXkpO1xuICAgICAgICAgIGlmIChjeU5vZGUpIHtcbiAgICAgICAgICAgIHZhciBub2RlQkIgPSBjeU5vZGUuYm91bmRpbmdCb3goKTtcbiAgICAgICAgICAgIHZhciBsZWZ0WCA9IGNvbXBvbmVudFJlc3VsdC54Q29vcmRzW3ZhbHVlXSAtIG5vZGVCQi53IC8gMjtcbiAgICAgICAgICAgIHZhciByaWdodFggPSBjb21wb25lbnRSZXN1bHQueENvb3Jkc1t2YWx1ZV0gKyBub2RlQkIudyAvIDI7XG4gICAgICAgICAgICB2YXIgdG9wWSA9IGNvbXBvbmVudFJlc3VsdC55Q29vcmRzW3ZhbHVlXSAtIG5vZGVCQi5oIC8gMjtcbiAgICAgICAgICAgIHZhciBib3R0b21ZID0gY29tcG9uZW50UmVzdWx0LnlDb29yZHNbdmFsdWVdICsgbm9kZUJCLmggLyAyO1xuXG4gICAgICAgICAgICBpZiAobGVmdFggPCBtaW5YQ29vcmQpIG1pblhDb29yZCA9IGxlZnRYO1xuICAgICAgICAgICAgaWYgKHJpZ2h0WCA+IG1heFhDb29yZCkgbWF4WENvb3JkID0gcmlnaHRYO1xuICAgICAgICAgICAgaWYgKHRvcFkgPCBtaW5ZQ29vcmQpIG1pbllDb29yZCA9IHRvcFk7XG4gICAgICAgICAgICBpZiAoYm90dG9tWSA+IG1heFlDb29yZCkgbWF4WUNvb3JkID0gYm90dG9tWTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmluZCBkaWZmZXJlbmNlIGJldHdlZW4gY3VycmVudCBhbmQgb3JpZ2luYWwgY2VudGVyXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGRpZmZPblggPSBvcmlnaW5hbENlbnRlci54IC0gKG1heFhDb29yZCArIG1pblhDb29yZCkgLyAyO1xuICAgICAgdmFyIGRpZmZPblkgPSBvcmlnaW5hbENlbnRlci55IC0gKG1heFlDb29yZCArIG1pbllDb29yZCkgLyAyO1xuICAgICAgLy8gbW92ZSBjb21wb25lbnQgdG8gb3JpZ2luYWwgY2VudGVyXG4gICAgICBjb21wb25lbnRSZXN1bHQueENvb3JkcyA9IGNvbXBvbmVudFJlc3VsdC54Q29vcmRzLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4geCArIGRpZmZPblg7XG4gICAgICB9KTtcbiAgICAgIGNvbXBvbmVudFJlc3VsdC55Q29vcmRzID0gY29tcG9uZW50UmVzdWx0LnlDb29yZHMubWFwKGZ1bmN0aW9uICh5KSB7XG4gICAgICAgIHJldHVybiB5ICsgZGlmZk9uWTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjYWxjdWxhdGUgY3VycmVudCBib3VuZGluZyBib3hcbiAgICAgIE9iamVjdC5rZXlzKGNvbXBvbmVudFJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgbm9kZSA9IGNvbXBvbmVudFJlc3VsdFtpdGVtXTtcbiAgICAgICAgdmFyIGxlZnRYID0gbm9kZS5nZXRSZWN0KCkueDtcbiAgICAgICAgdmFyIHJpZ2h0WCA9IG5vZGUuZ2V0UmVjdCgpLnggKyBub2RlLmdldFJlY3QoKS53aWR0aDtcbiAgICAgICAgdmFyIHRvcFkgPSBub2RlLmdldFJlY3QoKS55O1xuICAgICAgICB2YXIgYm90dG9tWSA9IG5vZGUuZ2V0UmVjdCgpLnkgKyBub2RlLmdldFJlY3QoKS5oZWlnaHQ7XG5cbiAgICAgICAgaWYgKGxlZnRYIDwgbWluWENvb3JkKSBtaW5YQ29vcmQgPSBsZWZ0WDtcbiAgICAgICAgaWYgKHJpZ2h0WCA+IG1heFhDb29yZCkgbWF4WENvb3JkID0gcmlnaHRYO1xuICAgICAgICBpZiAodG9wWSA8IG1pbllDb29yZCkgbWluWUNvb3JkID0gdG9wWTtcbiAgICAgICAgaWYgKGJvdHRvbVkgPiBtYXhZQ29vcmQpIG1heFlDb29yZCA9IGJvdHRvbVk7XG4gICAgICB9KTtcbiAgICAgIC8vIGZpbmQgZGlmZmVyZW5jZSBiZXR3ZWVuIGN1cnJlbnQgYW5kIG9yaWdpbmFsIGNlbnRlclxuICAgICAgdmFyIF9kaWZmT25YID0gb3JpZ2luYWxDZW50ZXIueCAtIChtYXhYQ29vcmQgKyBtaW5YQ29vcmQpIC8gMjtcbiAgICAgIHZhciBfZGlmZk9uWSA9IG9yaWdpbmFsQ2VudGVyLnkgLSAobWF4WUNvb3JkICsgbWluWUNvb3JkKSAvIDI7XG4gICAgICAvLyBtb3ZlIGNvbXBvbmVudCB0byBvcmlnaW5hbCBjZW50ZXJcbiAgICAgIE9iamVjdC5rZXlzKGNvbXBvbmVudFJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgbm9kZSA9IGNvbXBvbmVudFJlc3VsdFtpdGVtXTtcbiAgICAgICAgbm9kZS5zZXRDZW50ZXIobm9kZS5nZXRDZW50ZXJYKCkgKyBfZGlmZk9uWCwgbm9kZS5nZXRDZW50ZXJZKCkgKyBfZGlmZk9uWSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG5cbmF1eGlsaWFyeS5jYWxjQm91bmRpbmdCb3ggPSBmdW5jdGlvbiAocGFyZW50Tm9kZSwgeENvb3JkcywgeUNvb3Jkcywgbm9kZUluZGV4ZXMpIHtcbiAgLy8gY2FsY3VsYXRlIGJvdW5kc1xuICB2YXIgbGVmdCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICB2YXIgcmlnaHQgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbiAgdmFyIHRvcCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICB2YXIgYm90dG9tID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gIHZhciBub2RlTGVmdCA9IHZvaWQgMDtcbiAgdmFyIG5vZGVSaWdodCA9IHZvaWQgMDtcbiAgdmFyIG5vZGVUb3AgPSB2b2lkIDA7XG4gIHZhciBub2RlQm90dG9tID0gdm9pZCAwO1xuXG4gIHZhciBub2RlcyA9IHBhcmVudE5vZGUuZGVzY2VuZGFudHMoKS5ub3QoXCI6cGFyZW50XCIpO1xuICB2YXIgcyA9IG5vZGVzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgbm9kZUxlZnQgPSB4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlLmlkKCkpXSAtIG5vZGUud2lkdGgoKSAvIDI7XG4gICAgbm9kZVJpZ2h0ID0geENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZS5pZCgpKV0gKyBub2RlLndpZHRoKCkgLyAyO1xuICAgIG5vZGVUb3AgPSB5Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlLmlkKCkpXSAtIG5vZGUuaGVpZ2h0KCkgLyAyO1xuICAgIG5vZGVCb3R0b20gPSB5Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlLmlkKCkpXSArIG5vZGUuaGVpZ2h0KCkgLyAyO1xuXG4gICAgaWYgKGxlZnQgPiBub2RlTGVmdCkge1xuICAgICAgbGVmdCA9IG5vZGVMZWZ0O1xuICAgIH1cblxuICAgIGlmIChyaWdodCA8IG5vZGVSaWdodCkge1xuICAgICAgcmlnaHQgPSBub2RlUmlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKHRvcCA+IG5vZGVUb3ApIHtcbiAgICAgIHRvcCA9IG5vZGVUb3A7XG4gICAgfVxuXG4gICAgaWYgKGJvdHRvbSA8IG5vZGVCb3R0b20pIHtcbiAgICAgIGJvdHRvbSA9IG5vZGVCb3R0b207XG4gICAgfVxuICB9XG5cbiAgdmFyIGJvdW5kaW5nQm94ID0ge307XG4gIGJvdW5kaW5nQm94LnRvcExlZnRYID0gbGVmdDtcbiAgYm91bmRpbmdCb3gudG9wTGVmdFkgPSB0b3A7XG4gIGJvdW5kaW5nQm94LndpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICBib3VuZGluZ0JveC5oZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gIHJldHVybiBib3VuZGluZ0JveDtcbn07XG5cbi8vIFRoaXMgZnVuY3Rpb24gZmluZHMgYW5kIHJldHVybnMgcGFyZW50IG5vZGVzIHdob3NlIGFsbCBjaGlsZHJlbiBhcmUgaGlkZGVuXG5hdXhpbGlhcnkuY2FsY1BhcmVudHNXaXRob3V0Q2hpbGRyZW4gPSBmdW5jdGlvbiAoY3ksIGVsZXMpIHtcbiAgdmFyIHBhcmVudHNXaXRob3V0Q2hpbGRyZW4gPSBjeS5jb2xsZWN0aW9uKCk7XG4gIGVsZXMubm9kZXMoJzpwYXJlbnQnKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICB2YXIgY2hlY2sgPSBmYWxzZTtcbiAgICBwYXJlbnQuY2hpbGRyZW4oKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLmNzcygnZGlzcGxheScpICE9ICdub25lJykge1xuICAgICAgICBjaGVjayA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFjaGVjaykge1xuICAgICAgcGFyZW50c1dpdGhvdXRDaGlsZHJlbi5tZXJnZShwYXJlbnQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBhcmVudHNXaXRob3V0Q2hpbGRyZW47XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF1eGlsaWFyeTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDgxNjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG5cbi8qKlxuICBUaGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIHBvc3Rwcm9jZXNzaW5nIHBhcnQgdGhhdCBhcHBsaWVzIENvU0UgbGF5b3V0IG92ZXIgdGhlIHNwZWN0cmFsIGxheW91dFxuKi9cblxudmFyIGF1eCA9IF9fd2VicGFja19yZXF1aXJlX18oNTQ4KTtcbnZhciBDb1NFTGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDApLkNvU0VMYXlvdXQ7XG52YXIgQ29TRU5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MCkuQ29TRU5vZGU7XG52YXIgUG9pbnREID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDApLmxheW91dEJhc2UuUG9pbnREO1xudmFyIERpbWVuc2lvbkQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MCkubGF5b3V0QmFzZS5EaW1lbnNpb25EO1xudmFyIExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKS5sYXlvdXRCYXNlLkxheW91dENvbnN0YW50cztcbnZhciBGRExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKS5sYXlvdXRCYXNlLkZETGF5b3V0Q29uc3RhbnRzO1xudmFyIENvU0VDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MCkuQ29TRUNvbnN0YW50cztcblxuLy8gbWFpbiBmdW5jdGlvbiB0aGF0IGNvc2UgbGF5b3V0IGlzIHByb2Nlc3NlZFxudmFyIGNvc2VMYXlvdXQgPSBmdW5jdGlvbiBjb3NlTGF5b3V0KG9wdGlvbnMsIHNwZWN0cmFsUmVzdWx0KSB7XG5cbiAgdmFyIGN5ID0gb3B0aW9ucy5jeTtcbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKTtcbiAgdmFyIGVkZ2VzID0gZWxlcy5lZGdlcygpO1xuXG4gIHZhciBub2RlSW5kZXhlcyA9IHZvaWQgMDtcbiAgdmFyIHhDb29yZHMgPSB2b2lkIDA7XG4gIHZhciB5Q29vcmRzID0gdm9pZCAwO1xuICB2YXIgaWRUb0xOb2RlID0ge307XG5cbiAgaWYgKG9wdGlvbnMucmFuZG9taXplKSB7XG4gICAgbm9kZUluZGV4ZXMgPSBzcGVjdHJhbFJlc3VsdFtcIm5vZGVJbmRleGVzXCJdO1xuICAgIHhDb29yZHMgPSBzcGVjdHJhbFJlc3VsdFtcInhDb29yZHNcIl07XG4gICAgeUNvb3JkcyA9IHNwZWN0cmFsUmVzdWx0W1wieUNvb3Jkc1wiXTtcbiAgfVxuXG4gIHZhciBpc0ZuID0gZnVuY3Rpb24gaXNGbihmbikge1xuICAgIHJldHVybiB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbic7XG4gIH07XG5cbiAgdmFyIG9wdEZuID0gZnVuY3Rpb24gb3B0Rm4ob3B0LCBlbGUpIHtcbiAgICBpZiAoaXNGbihvcHQpKSB7XG4gICAgICByZXR1cm4gb3B0KGVsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcHQ7XG4gICAgfVxuICB9O1xuXG4gIC8qKioqIFBvc3Rwcm9jZXNzaW5nIGZ1bmN0aW9ucyAqKioqL1xuXG4gIHZhciBwYXJlbnRzV2l0aG91dENoaWxkcmVuID0gYXV4LmNhbGNQYXJlbnRzV2l0aG91dENoaWxkcmVuKGN5LCBlbGVzKTtcblxuICAvLyB0cmFuc2ZlciBjeXRvc2NhcGUgbm9kZXMgdG8gY29zZSBub2Rlc1xuICB2YXIgcHJvY2Vzc0NoaWxkcmVuTGlzdCA9IGZ1bmN0aW9uIHByb2Nlc3NDaGlsZHJlbkxpc3QocGFyZW50LCBjaGlsZHJlbiwgbGF5b3V0LCBvcHRpb25zKSB7XG4gICAgdmFyIHNpemUgPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgIHZhciB0aGVDaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgdmFyIGNoaWxkcmVuX29mX2NoaWxkcmVuID0gbnVsbDtcbiAgICAgIGlmICh0aGVDaGlsZC5pbnRlcnNlY3Rpb24ocGFyZW50c1dpdGhvdXRDaGlsZHJlbikubGVuZ3RoID09IDApIHtcbiAgICAgICAgY2hpbGRyZW5fb2ZfY2hpbGRyZW4gPSB0aGVDaGlsZC5jaGlsZHJlbigpO1xuICAgICAgfVxuICAgICAgdmFyIHRoZU5vZGUgPSB2b2lkIDA7XG5cbiAgICAgIHZhciBkaW1lbnNpb25zID0gdGhlQ2hpbGQubGF5b3V0RGltZW5zaW9ucyh7XG4gICAgICAgIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogb3B0aW9ucy5ub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHNcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhlQ2hpbGQub3V0ZXJXaWR0aCgpICE9IG51bGwgJiYgdGhlQ2hpbGQub3V0ZXJIZWlnaHQoKSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnJhbmRvbWl6ZSkge1xuICAgICAgICAgIGlmICghdGhlQ2hpbGQuaXNQYXJlbnQoKSkge1xuICAgICAgICAgICAgdGhlTm9kZSA9IHBhcmVudC5hZGQobmV3IENvU0VOb2RlKGxheW91dC5ncmFwaE1hbmFnZXIsIG5ldyBQb2ludEQoeENvb3Jkc1tub2RlSW5kZXhlcy5nZXQodGhlQ2hpbGQuaWQoKSldIC0gZGltZW5zaW9ucy53IC8gMiwgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQodGhlQ2hpbGQuaWQoKSldIC0gZGltZW5zaW9ucy5oIC8gMiksIG5ldyBEaW1lbnNpb25EKHBhcnNlRmxvYXQoZGltZW5zaW9ucy53KSwgcGFyc2VGbG9hdChkaW1lbnNpb25zLmgpKSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50SW5mbyA9IGF1eC5jYWxjQm91bmRpbmdCb3godGhlQ2hpbGQsIHhDb29yZHMsIHlDb29yZHMsIG5vZGVJbmRleGVzKTtcbiAgICAgICAgICAgIGlmICh0aGVDaGlsZC5pbnRlcnNlY3Rpb24ocGFyZW50c1dpdGhvdXRDaGlsZHJlbikubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgdGhlTm9kZSA9IHBhcmVudC5hZGQobmV3IENvU0VOb2RlKGxheW91dC5ncmFwaE1hbmFnZXIsIG5ldyBQb2ludEQocGFyZW50SW5mby50b3BMZWZ0WCwgcGFyZW50SW5mby50b3BMZWZ0WSksIG5ldyBEaW1lbnNpb25EKHBhcmVudEluZm8ud2lkdGgsIHBhcmVudEluZm8uaGVpZ2h0KSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gZm9yIHRoZSBwYXJlbnRzV2l0aG91dENoaWxkcmVuXG4gICAgICAgICAgICAgIHRoZU5vZGUgPSBwYXJlbnQuYWRkKG5ldyBDb1NFTm9kZShsYXlvdXQuZ3JhcGhNYW5hZ2VyLCBuZXcgUG9pbnREKHBhcmVudEluZm8udG9wTGVmdFgsIHBhcmVudEluZm8udG9wTGVmdFkpLCBuZXcgRGltZW5zaW9uRChwYXJzZUZsb2F0KGRpbWVuc2lvbnMudyksIHBhcnNlRmxvYXQoZGltZW5zaW9ucy5oKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhlTm9kZSA9IHBhcmVudC5hZGQobmV3IENvU0VOb2RlKGxheW91dC5ncmFwaE1hbmFnZXIsIG5ldyBQb2ludEQodGhlQ2hpbGQucG9zaXRpb24oJ3gnKSAtIGRpbWVuc2lvbnMudyAvIDIsIHRoZUNoaWxkLnBvc2l0aW9uKCd5JykgLSBkaW1lbnNpb25zLmggLyAyKSwgbmV3IERpbWVuc2lvbkQocGFyc2VGbG9hdChkaW1lbnNpb25zLncpLCBwYXJzZUZsb2F0KGRpbWVuc2lvbnMuaCkpKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoZU5vZGUgPSBwYXJlbnQuYWRkKG5ldyBDb1NFTm9kZSh0aGlzLmdyYXBoTWFuYWdlcikpO1xuICAgICAgfVxuICAgICAgLy8gQXR0YWNoIGlkIHRvIHRoZSBsYXlvdXQgbm9kZSBhbmQgcmVwdWxzaW9uIHZhbHVlXG4gICAgICB0aGVOb2RlLmlkID0gdGhlQ2hpbGQuZGF0YShcImlkXCIpO1xuICAgICAgdGhlTm9kZS5ub2RlUmVwdWxzaW9uID0gb3B0Rm4ob3B0aW9ucy5ub2RlUmVwdWxzaW9uLCB0aGVDaGlsZCk7XG4gICAgICAvLyBBdHRhY2ggdGhlIHBhZGRpbmdzIG9mIGN5IG5vZGUgdG8gbGF5b3V0IG5vZGVcbiAgICAgIHRoZU5vZGUucGFkZGluZ0xlZnQgPSBwYXJzZUludCh0aGVDaGlsZC5jc3MoJ3BhZGRpbmcnKSk7XG4gICAgICB0aGVOb2RlLnBhZGRpbmdUb3AgPSBwYXJzZUludCh0aGVDaGlsZC5jc3MoJ3BhZGRpbmcnKSk7XG4gICAgICB0aGVOb2RlLnBhZGRpbmdSaWdodCA9IHBhcnNlSW50KHRoZUNoaWxkLmNzcygncGFkZGluZycpKTtcbiAgICAgIHRoZU5vZGUucGFkZGluZ0JvdHRvbSA9IHBhcnNlSW50KHRoZUNoaWxkLmNzcygncGFkZGluZycpKTtcblxuICAgICAgLy9BdHRhY2ggdGhlIGxhYmVsIHByb3BlcnRpZXMgdG8gYm90aCBjb21wb3VuZCBhbmQgc2ltcGxlIG5vZGVzIGlmIGxhYmVscyB3aWxsIGJlIGluY2x1ZGVkIGluIG5vZGUgZGltZW5zaW9uc1xuICAgICAgLy9UaGVzZSBwcm9wZXJ0aWVzIHdpbGwgYmUgdXNlZCB3aGlsZSB1cGRhdGluZyBib3VuZHMgb2YgY29tcG91bmRzIGR1cmluZyBpdGVyYXRpb25zIG9yIHRpbGluZ1xuICAgICAgLy9hbmQgd2lsbCBiZSB1c2VkIGZvciBzaW1wbGUgbm9kZXMgd2hpbGUgdHJhbnNmZXJyaW5nIGZpbmFsIHBvc2l0aW9ucyB0byBjeXRvc2NhcGVcbiAgICAgIGlmIChvcHRpb25zLm5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVscykge1xuICAgICAgICB0aGVOb2RlLmxhYmVsV2lkdGggPSB0aGVDaGlsZC5ib3VuZGluZ0JveCh7IGluY2x1ZGVMYWJlbHM6IHRydWUsIGluY2x1ZGVOb2RlczogZmFsc2UsIGluY2x1ZGVPdmVybGF5czogZmFsc2UgfSkudztcbiAgICAgICAgdGhlTm9kZS5sYWJlbEhlaWdodCA9IHRoZUNoaWxkLmJvdW5kaW5nQm94KHsgaW5jbHVkZUxhYmVsczogdHJ1ZSwgaW5jbHVkZU5vZGVzOiBmYWxzZSwgaW5jbHVkZU92ZXJsYXlzOiBmYWxzZSB9KS5oO1xuICAgICAgICB0aGVOb2RlLmxhYmVsUG9zVmVydGljYWwgPSB0aGVDaGlsZC5jc3MoXCJ0ZXh0LXZhbGlnblwiKTtcbiAgICAgICAgdGhlTm9kZS5sYWJlbFBvc0hvcml6b250YWwgPSB0aGVDaGlsZC5jc3MoXCJ0ZXh0LWhhbGlnblwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gTWFwIHRoZSBsYXlvdXQgbm9kZVxuICAgICAgaWRUb0xOb2RlW3RoZUNoaWxkLmRhdGEoXCJpZFwiKV0gPSB0aGVOb2RlO1xuXG4gICAgICBpZiAoaXNOYU4odGhlTm9kZS5yZWN0LngpKSB7XG4gICAgICAgIHRoZU5vZGUucmVjdC54ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTmFOKHRoZU5vZGUucmVjdC55KSkge1xuICAgICAgICB0aGVOb2RlLnJlY3QueSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGlsZHJlbl9vZl9jaGlsZHJlbiAhPSBudWxsICYmIGNoaWxkcmVuX29mX2NoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHRoZU5ld0dyYXBoID0gdm9pZCAwO1xuICAgICAgICB0aGVOZXdHcmFwaCA9IGxheW91dC5nZXRHcmFwaE1hbmFnZXIoKS5hZGQobGF5b3V0Lm5ld0dyYXBoKCksIHRoZU5vZGUpO1xuICAgICAgICBwcm9jZXNzQ2hpbGRyZW5MaXN0KHRoZU5ld0dyYXBoLCBjaGlsZHJlbl9vZl9jaGlsZHJlbiwgbGF5b3V0LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gdHJhbnNmZXIgY3l0b3NjYXBlIGVkZ2VzIHRvIGNvc2UgZWRnZXNcbiAgdmFyIHByb2Nlc3NFZGdlcyA9IGZ1bmN0aW9uIHByb2Nlc3NFZGdlcyhsYXlvdXQsIGdtLCBlZGdlcykge1xuICAgIHZhciBpZGVhbExlbmd0aFRvdGFsID0gMDtcbiAgICB2YXIgZWRnZUNvdW50ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgICAgdmFyIHNvdXJjZU5vZGUgPSBpZFRvTE5vZGVbZWRnZS5kYXRhKFwic291cmNlXCIpXTtcbiAgICAgIHZhciB0YXJnZXROb2RlID0gaWRUb0xOb2RlW2VkZ2UuZGF0YShcInRhcmdldFwiKV07XG4gICAgICBpZiAoc291cmNlTm9kZSAmJiB0YXJnZXROb2RlICYmIHNvdXJjZU5vZGUgIT09IHRhcmdldE5vZGUgJiYgc291cmNlTm9kZS5nZXRFZGdlc0JldHdlZW4odGFyZ2V0Tm9kZSkubGVuZ3RoID09IDApIHtcbiAgICAgICAgdmFyIGUxID0gZ20uYWRkKGxheW91dC5uZXdFZGdlKCksIHNvdXJjZU5vZGUsIHRhcmdldE5vZGUpO1xuICAgICAgICBlMS5pZCA9IGVkZ2UuaWQoKTtcbiAgICAgICAgZTEuaWRlYWxMZW5ndGggPSBvcHRGbihvcHRpb25zLmlkZWFsRWRnZUxlbmd0aCwgZWRnZSk7XG4gICAgICAgIGUxLmVkZ2VFbGFzdGljaXR5ID0gb3B0Rm4ob3B0aW9ucy5lZGdlRWxhc3RpY2l0eSwgZWRnZSk7XG4gICAgICAgIGlkZWFsTGVuZ3RoVG90YWwgKz0gZTEuaWRlYWxMZW5ndGg7XG4gICAgICAgIGVkZ2VDb3VudCsrO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaWRlYWwgZWRnZSBsZW5ndGggY29uc3RhbnQgd2l0aCB0aGUgYXZnLiBpZGVhbCBsZW5ndGggdmFsdWUgYWZ0ZXIgcHJvY2Vzc2luZyBlZGdlc1xuICAgIC8vIGluIGNhc2UgdGhlcmUgaXMgbm8gZWRnZSwgdXNlIG90aGVyIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGggIT0gbnVsbCkge1xuICAgICAgaWYgKGVkZ2VDb3VudCA+IDApIENvU0VDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggPSBpZGVhbExlbmd0aFRvdGFsIC8gZWRnZUNvdW50O2Vsc2UgaWYgKCFpc0ZuKG9wdGlvbnMuaWRlYWxFZGdlTGVuZ3RoKSkgLy8gaW4gY2FzZSB0aGVyZSBpcyBubyBlZGdlLCBidXQgb3B0aW9uIGdpdmVzIGEgdmFsdWUgdG8gdXNlXG4gICAgICAgIENvU0VDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggPSBvcHRpb25zLmlkZWFsRWRnZUxlbmd0aDtlbHNlIC8vIGluIGNhc2UgdGhlcmUgaXMgbm8gZWRnZSBhbmQgd2UgY2Fubm90IGdldCBhIHZhbHVlIGZyb20gb3B0aW9uIChiZWNhdXNlIGl0J3MgYSBmdW5jdGlvbilcbiAgICAgICAgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCA9IDUwO1xuICAgICAgLy8gd2UgbmVlZCB0byB1cGRhdGUgdGhlc2UgY29uc3RhbnQgdmFsdWVzIGJhc2VkIG9uIHRoZSBpZGVhbCBlZGdlIGxlbmd0aCBjb25zdGFudFxuICAgICAgQ29TRUNvbnN0YW50cy5NSU5fUkVQVUxTSU9OX0RJU1QgPSBGRExheW91dENvbnN0YW50cy5NSU5fUkVQVUxTSU9OX0RJU1QgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIIC8gMTAuMDtcbiAgICAgIENvU0VDb25zdGFudHMuREVGQVVMVF9SQURJQUxfU0VQQVJBVElPTiA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEg7XG4gICAgfVxuICB9O1xuXG4gIC8vIHRyYW5zZmVyIGN5dG9zY2FwZSBjb25zdHJhaW50cyB0byBjb3NlIGxheW91dFxuICB2YXIgcHJvY2Vzc0NvbnN0cmFpbnRzID0gZnVuY3Rpb24gcHJvY2Vzc0NvbnN0cmFpbnRzKGxheW91dCwgb3B0aW9ucykge1xuICAgIC8vIGdldCBub2RlcyB0byBiZSBmaXhlZFxuICAgIGlmIChvcHRpb25zLmZpeGVkTm9kZUNvbnN0cmFpbnQpIHtcbiAgICAgIGxheW91dC5jb25zdHJhaW50c1tcImZpeGVkTm9kZUNvbnN0cmFpbnRcIl0gPSBvcHRpb25zLmZpeGVkTm9kZUNvbnN0cmFpbnQ7XG4gICAgfVxuICAgIC8vIGdldCBub2RlcyB0byBiZSBhbGlnbmVkXG4gICAgaWYgKG9wdGlvbnMuYWxpZ25tZW50Q29uc3RyYWludCkge1xuICAgICAgbGF5b3V0LmNvbnN0cmFpbnRzW1wiYWxpZ25tZW50Q29uc3RyYWludFwiXSA9IG9wdGlvbnMuYWxpZ25tZW50Q29uc3RyYWludDtcbiAgICB9XG4gICAgLy8gZ2V0IG5vZGVzIHRvIGJlIHJlbGF0aXZlbHkgcGxhY2VkXG4gICAgaWYgKG9wdGlvbnMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50KSB7XG4gICAgICBsYXlvdXQuY29uc3RyYWludHNbXCJyZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnRcIl0gPSBvcHRpb25zLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludDtcbiAgICB9XG4gIH07XG5cbiAgLyoqKiogQXBwbHkgcG9zdHByb2Nlc3NpbmcgKioqKi9cbiAgaWYgKG9wdGlvbnMubmVzdGluZ0ZhY3RvciAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLlBFUl9MRVZFTF9JREVBTF9FREdFX0xFTkdUSF9GQUNUT1IgPSBGRExheW91dENvbnN0YW50cy5QRVJfTEVWRUxfSURFQUxfRURHRV9MRU5HVEhfRkFDVE9SID0gb3B0aW9ucy5uZXN0aW5nRmFjdG9yO1xuICBpZiAob3B0aW9ucy5ncmF2aXR5ICE9IG51bGwpIENvU0VDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1NUUkVOR1RIID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1NUUkVOR1RIID0gb3B0aW9ucy5ncmF2aXR5O1xuICBpZiAob3B0aW9ucy5udW1JdGVyICE9IG51bGwpIENvU0VDb25zdGFudHMuTUFYX0lURVJBVElPTlMgPSBGRExheW91dENvbnN0YW50cy5NQVhfSVRFUkFUSU9OUyA9IG9wdGlvbnMubnVtSXRlcjtcbiAgaWYgKG9wdGlvbnMuZ3Jhdml0eVJhbmdlICE9IG51bGwpIENvU0VDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUiA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9SQU5HRV9GQUNUT1IgPSBvcHRpb25zLmdyYXZpdHlSYW5nZTtcbiAgaWYgKG9wdGlvbnMuZ3Jhdml0eUNvbXBvdW5kICE9IG51bGwpIENvU0VDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1NUUkVOR1RIID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1NUUkVOR1RIID0gb3B0aW9ucy5ncmF2aXR5Q29tcG91bmQ7XG4gIGlmIChvcHRpb25zLmdyYXZpdHlSYW5nZUNvbXBvdW5kICE9IG51bGwpIENvU0VDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUiA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9SQU5HRV9GQUNUT1IgPSBvcHRpb25zLmdyYXZpdHlSYW5nZUNvbXBvdW5kO1xuICBpZiAob3B0aW9ucy5pbml0aWFsRW5lcmd5T25JbmNyZW1lbnRhbCAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUwgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMID0gb3B0aW9ucy5pbml0aWFsRW5lcmd5T25JbmNyZW1lbnRhbDtcblxuICBpZiAob3B0aW9ucy50aWxpbmdDb21wYXJlQnkgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5USUxJTkdfQ09NUEFSRV9CWSA9IG9wdGlvbnMudGlsaW5nQ29tcGFyZUJ5O1xuXG4gIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gJ3Byb29mJykgTGF5b3V0Q29uc3RhbnRzLlFVQUxJVFkgPSAyO2Vsc2UgTGF5b3V0Q29uc3RhbnRzLlFVQUxJVFkgPSAwO1xuXG4gIENvU0VDb25zdGFudHMuTk9ERV9ESU1FTlNJT05TX0lOQ0xVREVfTEFCRUxTID0gRkRMYXlvdXRDb25zdGFudHMuTk9ERV9ESU1FTlNJT05TX0lOQ0xVREVfTEFCRUxTID0gTGF5b3V0Q29uc3RhbnRzLk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUyA9IG9wdGlvbnMubm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzO1xuICBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfSU5DUkVNRU5UQUwgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfSU5DUkVNRU5UQUwgPSAhb3B0aW9ucy5yYW5kb21pemU7XG4gIENvU0VDb25zdGFudHMuQU5JTUFURSA9IEZETGF5b3V0Q29uc3RhbnRzLkFOSU1BVEUgPSBMYXlvdXRDb25zdGFudHMuQU5JTUFURSA9IG9wdGlvbnMuYW5pbWF0ZTtcbiAgQ29TRUNvbnN0YW50cy5USUxFID0gb3B0aW9ucy50aWxlO1xuICBDb1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX1ZFUlRJQ0FMID0gdHlwZW9mIG9wdGlvbnMudGlsaW5nUGFkZGluZ1ZlcnRpY2FsID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy50aWxpbmdQYWRkaW5nVmVydGljYWwuY2FsbCgpIDogb3B0aW9ucy50aWxpbmdQYWRkaW5nVmVydGljYWw7XG4gIENvU0VDb25zdGFudHMuVElMSU5HX1BBRERJTkdfSE9SSVpPTlRBTCA9IHR5cGVvZiBvcHRpb25zLnRpbGluZ1BhZGRpbmdIb3Jpem9udGFsID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy50aWxpbmdQYWRkaW5nSG9yaXpvbnRhbC5jYWxsKCkgOiBvcHRpb25zLnRpbGluZ1BhZGRpbmdIb3Jpem9udGFsO1xuXG4gIENvU0VDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfSU5DUkVNRU5UQUwgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTCA9IHRydWU7XG4gIENvU0VDb25zdGFudHMuUFVSRV9JTkNSRU1FTlRBTCA9ICFvcHRpb25zLnJhbmRvbWl6ZTtcbiAgTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfVU5JRk9STV9MRUFGX05PREVfU0laRVMgPSBvcHRpb25zLnVuaWZvcm1Ob2RlRGltZW5zaW9ucztcblxuICAvLyBUaGlzIHBhcnQgaXMgZm9yIGRlYnVnL2RlbW8gcHVycG9zZVxuICBpZiAob3B0aW9ucy5zdGVwID09IFwidHJhbnNmb3JtZWRcIikge1xuICAgIENvU0VDb25zdGFudHMuVFJBTlNGT1JNX09OX0NPTlNUUkFJTlRfSEFORExJTkcgPSB0cnVlO1xuICAgIENvU0VDb25zdGFudHMuRU5GT1JDRV9DT05TVFJBSU5UUyA9IGZhbHNlO1xuICAgIENvU0VDb25zdGFudHMuQVBQTFlfTEFZT1VUID0gZmFsc2U7XG4gIH1cbiAgaWYgKG9wdGlvbnMuc3RlcCA9PSBcImVuZm9yY2VkXCIpIHtcbiAgICBDb1NFQ29uc3RhbnRzLlRSQU5TRk9STV9PTl9DT05TVFJBSU5UX0hBTkRMSU5HID0gZmFsc2U7XG4gICAgQ29TRUNvbnN0YW50cy5FTkZPUkNFX0NPTlNUUkFJTlRTID0gdHJ1ZTtcbiAgICBDb1NFQ29uc3RhbnRzLkFQUExZX0xBWU9VVCA9IGZhbHNlO1xuICB9XG4gIGlmIChvcHRpb25zLnN0ZXAgPT0gXCJjb3NlXCIpIHtcbiAgICBDb1NFQ29uc3RhbnRzLlRSQU5TRk9STV9PTl9DT05TVFJBSU5UX0hBTkRMSU5HID0gZmFsc2U7XG4gICAgQ29TRUNvbnN0YW50cy5FTkZPUkNFX0NPTlNUUkFJTlRTID0gZmFsc2U7XG4gICAgQ29TRUNvbnN0YW50cy5BUFBMWV9MQVlPVVQgPSB0cnVlO1xuICB9XG4gIGlmIChvcHRpb25zLnN0ZXAgPT0gXCJhbGxcIikge1xuICAgIGlmIChvcHRpb25zLnJhbmRvbWl6ZSkgQ29TRUNvbnN0YW50cy5UUkFOU0ZPUk1fT05fQ09OU1RSQUlOVF9IQU5ETElORyA9IHRydWU7ZWxzZSBDb1NFQ29uc3RhbnRzLlRSQU5TRk9STV9PTl9DT05TVFJBSU5UX0hBTkRMSU5HID0gZmFsc2U7XG4gICAgQ29TRUNvbnN0YW50cy5FTkZPUkNFX0NPTlNUUkFJTlRTID0gdHJ1ZTtcbiAgICBDb1NFQ29uc3RhbnRzLkFQUExZX0xBWU9VVCA9IHRydWU7XG4gIH1cblxuICBpZiAob3B0aW9ucy5maXhlZE5vZGVDb25zdHJhaW50IHx8IG9wdGlvbnMuYWxpZ25tZW50Q29uc3RyYWludCB8fCBvcHRpb25zLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCkge1xuICAgIENvU0VDb25zdGFudHMuVFJFRV9SRURVQ1RJT05fT05fSU5DUkVNRU5UQUwgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBDb1NFQ29uc3RhbnRzLlRSRUVfUkVEVUNUSU9OX09OX0lOQ1JFTUVOVEFMID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBjb3NlTGF5b3V0ID0gbmV3IENvU0VMYXlvdXQoKTtcbiAgdmFyIGdtID0gY29zZUxheW91dC5uZXdHcmFwaE1hbmFnZXIoKTtcblxuICBwcm9jZXNzQ2hpbGRyZW5MaXN0KGdtLmFkZFJvb3QoKSwgYXV4LmdldFRvcE1vc3ROb2Rlcyhub2RlcyksIGNvc2VMYXlvdXQsIG9wdGlvbnMpO1xuICBwcm9jZXNzRWRnZXMoY29zZUxheW91dCwgZ20sIGVkZ2VzKTtcbiAgcHJvY2Vzc0NvbnN0cmFpbnRzKGNvc2VMYXlvdXQsIG9wdGlvbnMpO1xuXG4gIGNvc2VMYXlvdXQucnVuTGF5b3V0KCk7XG5cbiAgcmV0dXJuIGlkVG9MTm9kZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0geyBjb3NlTGF5b3V0OiBjb3NlTGF5b3V0IH07XG5cbi8qKiovIH0pLFxuXG4vKioqLyAyMTI6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAgVGhlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBmY29zZSBsYXlvdXQgYWxnb3JpdGhtXG4qL1xuXG52YXIgYXNzaWduID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTgpO1xudmFyIGF1eCA9IF9fd2VicGFja19yZXF1aXJlX18oNTQ4KTtcblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTcpLFxuICAgIHNwZWN0cmFsTGF5b3V0ID0gX3JlcXVpcmUuc3BlY3RyYWxMYXlvdXQ7XG5cbnZhciBfcmVxdWlyZTIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxNiksXG4gICAgY29zZUxheW91dCA9IF9yZXF1aXJlMi5jb3NlTGF5b3V0O1xuXG52YXIgZGVmYXVsdHMgPSBPYmplY3QuZnJlZXplKHtcblxuICAvLyAnZHJhZnQnLCAnZGVmYXVsdCcgb3IgJ3Byb29mJyBcbiAgLy8gLSAnZHJhZnQnIG9ubHkgYXBwbGllcyBzcGVjdHJhbCBsYXlvdXQgXG4gIC8vIC0gJ2RlZmF1bHQnIGltcHJvdmVzIHRoZSBxdWFsaXR5IHdpdGggc3Vic2VxdWVudCBDb1NFIGxheW91dCAoZmFzdCBjb29saW5nIHJhdGUpXG4gIC8vIC0gJ3Byb29mJyBpbXByb3ZlcyB0aGUgcXVhbGl0eSB3aXRoIHN1YnNlcXVlbnQgQ29TRSBsYXlvdXQgKHNsb3cgY29vbGluZyByYXRlKSBcbiAgcXVhbGl0eTogXCJkZWZhdWx0XCIsXG4gIC8vIFVzZSByYW5kb20gbm9kZSBwb3NpdGlvbnMgYXQgYmVnaW5uaW5nIG9mIGxheW91dFxuICAvLyBpZiB0aGlzIGlzIHNldCB0byBmYWxzZSwgdGhlbiBxdWFsaXR5IG9wdGlvbiBtdXN0IGJlIFwicHJvb2ZcIlxuICByYW5kb21pemU6IHRydWUsXG4gIC8vIFdoZXRoZXIgb3Igbm90IHRvIGFuaW1hdGUgdGhlIGxheW91dFxuICBhbmltYXRlOiB0cnVlLFxuICAvLyBEdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMsIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRHVyYXRpb246IDEwMDAsXG4gIC8vIEVhc2luZyBvZiBhbmltYXRpb24sIGlmIGVuYWJsZWRcbiAgYW5pbWF0aW9uRWFzaW5nOiB1bmRlZmluZWQsXG4gIC8vIEZpdCB0aGUgdmlld3BvcnQgdG8gdGhlIHJlcG9zaXRpb25lZCBub2Rlc1xuICBmaXQ6IHRydWUsXG4gIC8vIFBhZGRpbmcgYXJvdW5kIGxheW91dFxuICBwYWRkaW5nOiAzMCxcbiAgLy8gV2hldGhlciB0byBpbmNsdWRlIGxhYmVscyBpbiBub2RlIGRpbWVuc2lvbnMuIFZhbGlkIGluIFwicHJvb2ZcIiBxdWFsaXR5XG4gIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogZmFsc2UsXG4gIC8vIFdoZXRoZXIgb3Igbm90IHNpbXBsZSBub2RlcyAobm9uLWNvbXBvdW5kIG5vZGVzKSBhcmUgb2YgdW5pZm9ybSBkaW1lbnNpb25zXG4gIHVuaWZvcm1Ob2RlRGltZW5zaW9uczogZmFsc2UsXG4gIC8vIFdoZXRoZXIgdG8gcGFjayBkaXNjb25uZWN0ZWQgY29tcG9uZW50cyAtIHZhbGlkIG9ubHkgaWYgcmFuZG9taXplOiB0cnVlXG4gIHBhY2tDb21wb25lbnRzOiB0cnVlLFxuICAvLyBMYXlvdXQgc3RlcCAtIGFsbCwgdHJhbnNmb3JtZWQsIGVuZm9yY2VkLCBjb3NlIC0gZm9yIGRlYnVnIHB1cnBvc2Ugb25seVxuICBzdGVwOiBcImFsbFwiLFxuXG4gIC8qIHNwZWN0cmFsIGxheW91dCBvcHRpb25zICovXG5cbiAgLy8gRmFsc2UgZm9yIHJhbmRvbSwgdHJ1ZSBmb3IgZ3JlZWR5XG4gIHNhbXBsaW5nVHlwZTogdHJ1ZSxcbiAgLy8gU2FtcGxlIHNpemUgdG8gY29uc3RydWN0IGRpc3RhbmNlIG1hdHJpeFxuICBzYW1wbGVTaXplOiAyNSxcbiAgLy8gU2VwYXJhdGlvbiBhbW91bnQgYmV0d2VlbiBub2Rlc1xuICBub2RlU2VwYXJhdGlvbjogNzUsXG4gIC8vIFBvd2VyIGl0ZXJhdGlvbiB0b2xlcmFuY2VcbiAgcGlUb2w6IDAuMDAwMDAwMSxcblxuICAvKiBDb1NFIGxheW91dCBvcHRpb25zICovXG5cbiAgLy8gTm9kZSByZXB1bHNpb24gKG5vbiBvdmVybGFwcGluZykgbXVsdGlwbGllclxuICBub2RlUmVwdWxzaW9uOiBmdW5jdGlvbiBub2RlUmVwdWxzaW9uKG5vZGUpIHtcbiAgICByZXR1cm4gNDUwMDtcbiAgfSxcbiAgLy8gSWRlYWwgZWRnZSAobm9uIG5lc3RlZCkgbGVuZ3RoXG4gIGlkZWFsRWRnZUxlbmd0aDogZnVuY3Rpb24gaWRlYWxFZGdlTGVuZ3RoKGVkZ2UpIHtcbiAgICByZXR1cm4gNTA7XG4gIH0sXG4gIC8vIERpdmlzb3IgdG8gY29tcHV0ZSBlZGdlIGZvcmNlc1xuICBlZGdlRWxhc3RpY2l0eTogZnVuY3Rpb24gZWRnZUVsYXN0aWNpdHkoZWRnZSkge1xuICAgIHJldHVybiAwLjQ1O1xuICB9LFxuICAvLyBOZXN0aW5nIGZhY3RvciAobXVsdGlwbGllcikgdG8gY29tcHV0ZSBpZGVhbCBlZGdlIGxlbmd0aCBmb3IgbmVzdGVkIGVkZ2VzXG4gIG5lc3RpbmdGYWN0b3I6IDAuMSxcbiAgLy8gR3Jhdml0eSBmb3JjZSAoY29uc3RhbnQpXG4gIGdyYXZpdHk6IDAuMjUsXG4gIC8vIE1heGltdW0gbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybVxuICBudW1JdGVyOiAyNTAwLFxuICAvLyBGb3IgZW5hYmxpbmcgdGlsaW5nXG4gIHRpbGU6IHRydWUsXG4gIC8vIFRoZSBmdW5jdGlvbiB0aGF0IHNwZWNpZmllcyB0aGUgY3JpdGVyaWEgZm9yIGNvbXBhcmluZyBub2RlcyB3aGlsZSBzb3J0aW5nIHRoZW0gZHVyaW5nIHRpbGluZyBvcGVyYXRpb24uXG4gIC8vIFRha2VzIHRoZSBub2RlIGlkIGFzIGEgcGFyYW1ldGVyIGFuZCB0aGUgZGVmYXVsdCB0aWxpbmcgb3BlcmF0aW9uIGlzIHBlcmZvbWVkIHdoZW4gdGhpcyBvcHRpb24gaXMgbm90IHNldC5cbiAgdGlsaW5nQ29tcGFyZUJ5OiB1bmRlZmluZWQsXG4gIC8vIFJlcHJlc2VudHMgdGhlIGFtb3VudCBvZiB0aGUgdmVydGljYWwgc3BhY2UgdG8gcHV0IGJldHdlZW4gdGhlIHplcm8gZGVncmVlIG1lbWJlcnMgZHVyaW5nIHRoZSB0aWxpbmcgb3BlcmF0aW9uKGNhbiBhbHNvIGJlIGEgZnVuY3Rpb24pXG4gIHRpbGluZ1BhZGRpbmdWZXJ0aWNhbDogMTAsXG4gIC8vIFJlcHJlc2VudHMgdGhlIGFtb3VudCBvZiB0aGUgaG9yaXpvbnRhbCBzcGFjZSB0byBwdXQgYmV0d2VlbiB0aGUgemVybyBkZWdyZWUgbWVtYmVycyBkdXJpbmcgdGhlIHRpbGluZyBvcGVyYXRpb24oY2FuIGFsc28gYmUgYSBmdW5jdGlvbilcbiAgdGlsaW5nUGFkZGluZ0hvcml6b250YWw6IDEwLFxuICAvLyBHcmF2aXR5IHJhbmdlIChjb25zdGFudCkgZm9yIGNvbXBvdW5kc1xuICBncmF2aXR5UmFuZ2VDb21wb3VuZDogMS41LFxuICAvLyBHcmF2aXR5IGZvcmNlIChjb25zdGFudCkgZm9yIGNvbXBvdW5kc1xuICBncmF2aXR5Q29tcG91bmQ6IDEuMCxcbiAgLy8gR3Jhdml0eSByYW5nZSAoY29uc3RhbnQpXG4gIGdyYXZpdHlSYW5nZTogMy44LFxuICAvLyBJbml0aWFsIGNvb2xpbmcgZmFjdG9yIGZvciBpbmNyZW1lbnRhbCBsYXlvdXQgIFxuICBpbml0aWFsRW5lcmd5T25JbmNyZW1lbnRhbDogMC4zLFxuXG4gIC8qIGNvbnN0cmFpbnQgb3B0aW9ucyAqL1xuXG4gIC8vIEZpeCByZXF1aXJlZCBub2RlcyB0byBwcmVkZWZpbmVkIHBvc2l0aW9uc1xuICAvLyBbe25vZGVJZDogJ24xJywgcG9zaXRpb246IHt4OiAxMDAsIHk6IDIwMH0sIHsuLi59XVxuICBmaXhlZE5vZGVDb25zdHJhaW50OiB1bmRlZmluZWQsXG4gIC8vIEFsaWduIHJlcXVpcmVkIG5vZGVzIGluIHZlcnRpY2FsL2hvcml6b250YWwgZGlyZWN0aW9uXG4gIC8vIHt2ZXJ0aWNhbDogW1snbjEnLCAnbjInKV0sIFsnbjMnLCAnbjQnXV0sIGhvcml6b250YWw6IFsnbjInLCAnbjQnXX1cbiAgYWxpZ25tZW50Q29uc3RyYWludDogdW5kZWZpbmVkLFxuICAvLyBQbGFjZSB0d28gbm9kZXMgcmVsYXRpdmVseSBpbiB2ZXJ0aWNhbC9ob3Jpem9udGFsIGRpcmVjdGlvbiBcbiAgLy8gW3t0b3A6ICduMScsIGJvdHRvbTogJ24yJywgZ2FwOiAxMDB9LCB7bGVmdDogJ24zJywgcmlnaHQ6ICduNCcsIGdhcDogNzV9XVxuICByZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQ6IHVuZGVmaW5lZCxcblxuICAvKiBsYXlvdXQgZXZlbnQgY2FsbGJhY2tzICovXG4gIHJlYWR5OiBmdW5jdGlvbiByZWFkeSgpIHt9LCAvLyBvbiBsYXlvdXRyZWFkeVxuICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge30gLy8gb24gbGF5b3V0c3RvcFxufSk7XG5cbnZhciBMYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExheW91dChvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExheW91dCk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBhc3NpZ24oe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMYXlvdXQsIFt7XG4gICAga2V5OiAncnVuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcnVuKCkge1xuICAgICAgdmFyIGxheW91dCA9IHRoaXM7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIHZhciBjeSA9IG9wdGlvbnMuY3k7XG4gICAgICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcblxuICAgICAgdmFyIHNwZWN0cmFsUmVzdWx0ID0gW107XG4gICAgICB2YXIgeENvb3JkcyA9IHZvaWQgMDtcbiAgICAgIHZhciB5Q29vcmRzID0gdm9pZCAwO1xuICAgICAgdmFyIGNvc2VSZXN1bHQgPSBbXTtcbiAgICAgIHZhciBjb21wb25lbnRzID0gdm9pZCAwO1xuICAgICAgdmFyIGNvbXBvbmVudENlbnRlcnMgPSBbXTtcblxuICAgICAgLy8gYmFzaWMgdmFsaWRpdHkgY2hlY2sgZm9yIGNvbnN0cmFpbnQgaW5wdXRzIFxuICAgICAgaWYgKG9wdGlvbnMuZml4ZWROb2RlQ29uc3RyYWludCAmJiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5maXhlZE5vZGVDb25zdHJhaW50KSB8fCBvcHRpb25zLmZpeGVkTm9kZUNvbnN0cmFpbnQubGVuZ3RoID09IDApKSB7XG4gICAgICAgIG9wdGlvbnMuZml4ZWROb2RlQ29uc3RyYWludCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuYWxpZ25tZW50Q29uc3RyYWludCkge1xuICAgICAgICBpZiAob3B0aW9ucy5hbGlnbm1lbnRDb25zdHJhaW50LnZlcnRpY2FsICYmICghQXJyYXkuaXNBcnJheShvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWwpIHx8IG9wdGlvbnMuYWxpZ25tZW50Q29uc3RyYWludC52ZXJ0aWNhbC5sZW5ndGggPT0gMCkpIHtcbiAgICAgICAgICBvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuYWxpZ25tZW50Q29uc3RyYWludC5ob3Jpem9udGFsICYmICghQXJyYXkuaXNBcnJheShvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQuaG9yaXpvbnRhbCkgfHwgb3B0aW9ucy5hbGlnbm1lbnRDb25zdHJhaW50Lmhvcml6b250YWwubGVuZ3RoID09IDApKSB7XG4gICAgICAgICAgb3B0aW9ucy5hbGlnbm1lbnRDb25zdHJhaW50Lmhvcml6b250YWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50ICYmICghQXJyYXkuaXNBcnJheShvcHRpb25zLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCkgfHwgb3B0aW9ucy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQubGVuZ3RoID09IDApKSB7XG4gICAgICAgIG9wdGlvbnMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBhbnkgY29uc3RyYWludCBleGlzdHMsIHNldCBzb21lIG9wdGlvbnNcbiAgICAgIHZhciBjb25zdHJhaW50RXhpc3QgPSBvcHRpb25zLmZpeGVkTm9kZUNvbnN0cmFpbnQgfHwgb3B0aW9ucy5hbGlnbm1lbnRDb25zdHJhaW50IHx8IG9wdGlvbnMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50O1xuICAgICAgaWYgKGNvbnN0cmFpbnRFeGlzdCkge1xuICAgICAgICAvLyBjb25zdHJhaW50cyB3b3JrIHdpdGggdGhlc2Ugb3B0aW9uc1xuICAgICAgICBvcHRpb25zLnRpbGUgPSBmYWxzZTtcbiAgICAgICAgb3B0aW9ucy5wYWNrQ29tcG9uZW50cyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBkZWNpZGUgY29tcG9uZW50IHBhY2tpbmcgaXMgZW5hYmxlZCBvciBub3RcbiAgICAgIHZhciBsYXlVdGlsID0gdm9pZCAwO1xuICAgICAgdmFyIHBhY2tpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgICBpZiAoY3kubGF5b3V0VXRpbGl0aWVzICYmIG9wdGlvbnMucGFja0NvbXBvbmVudHMpIHtcbiAgICAgICAgbGF5VXRpbCA9IGN5LmxheW91dFV0aWxpdGllcyhcImdldFwiKTtcbiAgICAgICAgaWYgKCFsYXlVdGlsKSBsYXlVdGlsID0gY3kubGF5b3V0VXRpbGl0aWVzKCk7XG4gICAgICAgIHBhY2tpbmdFbmFibGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZXMubm9kZXMoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIGlmIHBhY2tpbmcgaXMgbm90IGVuYWJsZWQsIHBlcmZvcm0gbGF5b3V0IG9uIHRoZSB3aG9sZSBncmFwaFxuICAgICAgICBpZiAoIXBhY2tpbmdFbmFibGVkKSB7XG4gICAgICAgICAgLy8gc3RvcmUgY29tcG9uZW50IGNlbnRlclxuICAgICAgICAgIHZhciBib3VuZGluZ0JveCA9IG9wdGlvbnMuZWxlcy5ib3VuZGluZ0JveCgpO1xuICAgICAgICAgIGNvbXBvbmVudENlbnRlcnMucHVzaCh7IHg6IGJvdW5kaW5nQm94LngxICsgYm91bmRpbmdCb3gudyAvIDIsIHk6IGJvdW5kaW5nQm94LnkxICsgYm91bmRpbmdCb3guaCAvIDIgfSk7XG4gICAgICAgICAgLy8gYXBwbHkgc3BlY3RyYWwgbGF5b3V0XG4gICAgICAgICAgaWYgKG9wdGlvbnMucmFuZG9taXplKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gc3BlY3RyYWxMYXlvdXQob3B0aW9ucyk7XG4gICAgICAgICAgICBzcGVjdHJhbFJlc3VsdC5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGFwcGx5IGNvc2UgbGF5b3V0IGFzIHBvc3Rwcm9jZXNzaW5nXG4gICAgICAgICAgaWYgKG9wdGlvbnMucXVhbGl0eSA9PSBcImRlZmF1bHRcIiB8fCBvcHRpb25zLnF1YWxpdHkgPT0gXCJwcm9vZlwiKSB7XG4gICAgICAgICAgICBjb3NlUmVzdWx0LnB1c2goY29zZUxheW91dChvcHRpb25zLCBzcGVjdHJhbFJlc3VsdFswXSkpO1xuICAgICAgICAgICAgYXV4LnJlbG9jYXRlQ29tcG9uZW50KGNvbXBvbmVudENlbnRlcnNbMF0sIGNvc2VSZXN1bHRbMF0sIG9wdGlvbnMpOyAvLyByZWxvY2F0ZSBjZW50ZXIgdG8gb3JpZ2luYWwgcG9zaXRpb25cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXV4LnJlbG9jYXRlQ29tcG9uZW50KGNvbXBvbmVudENlbnRlcnNbMF0sIHNwZWN0cmFsUmVzdWx0WzBdLCBvcHRpb25zKTsgLy8gcmVsb2NhdGUgY2VudGVyIHRvIG9yaWdpbmFsIHBvc2l0aW9uXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHBhY2tpbmcgaXMgZW5hYmxlZFxuICAgICAgICAgIHZhciB0b3BNb3N0Tm9kZXMgPSBhdXguZ2V0VG9wTW9zdE5vZGVzKG9wdGlvbnMuZWxlcy5ub2RlcygpKTtcbiAgICAgICAgICBjb21wb25lbnRzID0gYXV4LmNvbm5lY3RDb21wb25lbnRzKGN5LCBvcHRpb25zLmVsZXMsIHRvcE1vc3ROb2Rlcyk7XG4gICAgICAgICAgLy8gc3RvcmUgY29tcG9uZW50IGNlbnRlcnNcbiAgICAgICAgICBjb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgdmFyIGJvdW5kaW5nQm94ID0gY29tcG9uZW50LmJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgICBjb21wb25lbnRDZW50ZXJzLnB1c2goeyB4OiBib3VuZGluZ0JveC54MSArIGJvdW5kaW5nQm94LncgLyAyLCB5OiBib3VuZGluZ0JveC55MSArIGJvdW5kaW5nQm94LmggLyAyIH0pO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy9zZW5kIGVhY2ggY29tcG9uZW50IHRvIHNwZWN0cmFsIGxheW91dCBpZiByYW5kb21pemVkXG4gICAgICAgICAgaWYgKG9wdGlvbnMucmFuZG9taXplKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICBvcHRpb25zLmVsZXMgPSBjb21wb25lbnQ7XG4gICAgICAgICAgICAgIHNwZWN0cmFsUmVzdWx0LnB1c2goc3BlY3RyYWxMYXlvdXQob3B0aW9ucykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMucXVhbGl0eSA9PSBcImRlZmF1bHRcIiB8fCBvcHRpb25zLnF1YWxpdHkgPT0gXCJwcm9vZlwiKSB7XG4gICAgICAgICAgICB2YXIgdG9CZVRpbGVkTm9kZXMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy50aWxlKSB7XG4gICAgICAgICAgICAgIC8vIGJlaGF2ZSBub2RlcyB0byBiZSB0aWxlZCBhcyBvbmUgY29tcG9uZW50XG4gICAgICAgICAgICAgIHZhciBub2RlSW5kZXhlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgdmFyIF94Q29vcmRzID0gW107XG4gICAgICAgICAgICAgIHZhciBfeUNvb3JkcyA9IFtdO1xuICAgICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgICAgICB2YXIgdGVtcFNwZWN0cmFsUmVzdWx0ID0geyBub2RlSW5kZXhlczogbm9kZUluZGV4ZXMsIHhDb29yZHM6IF94Q29vcmRzLCB5Q29vcmRzOiBfeUNvb3JkcyB9O1xuICAgICAgICAgICAgICB2YXIgaW5kZXhlc1RvQmVEZWxldGVkID0gW107XG4gICAgICAgICAgICAgIGNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50LCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnQuZWRnZXMoKS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgY29tcG9uZW50Lm5vZGVzKCkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSwgaSkge1xuICAgICAgICAgICAgICAgICAgICB0b0JlVGlsZWROb2Rlcy5tZXJnZShjb21wb25lbnQubm9kZXMoKVtpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5pc1BhcmVudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGVtcFNwZWN0cmFsUmVzdWx0Lm5vZGVJbmRleGVzLnNldChjb21wb25lbnQubm9kZXMoKVtpXS5pZCgpLCBjb3VudCsrKTtcbiAgICAgICAgICAgICAgICAgICAgICB0ZW1wU3BlY3RyYWxSZXN1bHQueENvb3Jkcy5wdXNoKGNvbXBvbmVudC5ub2RlcygpWzBdLnBvc2l0aW9uKCkueCk7XG4gICAgICAgICAgICAgICAgICAgICAgdGVtcFNwZWN0cmFsUmVzdWx0LnlDb29yZHMucHVzaChjb21wb25lbnQubm9kZXMoKVswXS5wb3NpdGlvbigpLnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIGluZGV4ZXNUb0JlRGVsZXRlZC5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAodG9CZVRpbGVkTm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHZhciBfYm91bmRpbmdCb3ggPSB0b0JlVGlsZWROb2Rlcy5ib3VuZGluZ0JveCgpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudENlbnRlcnMucHVzaCh7IHg6IF9ib3VuZGluZ0JveC54MSArIF9ib3VuZGluZ0JveC53IC8gMiwgeTogX2JvdW5kaW5nQm94LnkxICsgX2JvdW5kaW5nQm94LmggLyAyIH0pO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaCh0b0JlVGlsZWROb2Rlcyk7XG4gICAgICAgICAgICAgICAgc3BlY3RyYWxSZXN1bHQucHVzaCh0ZW1wU3BlY3RyYWxSZXN1bHQpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBpbmRleGVzVG9CZURlbGV0ZWQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMuc3BsaWNlKGluZGV4ZXNUb0JlRGVsZXRlZFtpXSwgMSk7XG4gICAgICAgICAgICAgICAgICBzcGVjdHJhbFJlc3VsdC5zcGxpY2UoaW5kZXhlc1RvQmVEZWxldGVkW2ldLCAxKTtcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudENlbnRlcnMuc3BsaWNlKGluZGV4ZXNUb0JlRGVsZXRlZFtpXSwgMSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgIC8vIHNlbmQgZWFjaCBjb21wb25lbnQgdG8gY29zZSBsYXlvdXRcbiAgICAgICAgICAgICAgb3B0aW9ucy5lbGVzID0gY29tcG9uZW50O1xuICAgICAgICAgICAgICBjb3NlUmVzdWx0LnB1c2goY29zZUxheW91dChvcHRpb25zLCBzcGVjdHJhbFJlc3VsdFtpbmRleF0pKTtcbiAgICAgICAgICAgICAgYXV4LnJlbG9jYXRlQ29tcG9uZW50KGNvbXBvbmVudENlbnRlcnNbaW5kZXhdLCBjb3NlUmVzdWx0W2luZGV4XSwgb3B0aW9ucyk7IC8vIHJlbG9jYXRlIGNlbnRlciB0byBvcmlnaW5hbCBwb3NpdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50LCBpbmRleCkge1xuICAgICAgICAgICAgICBhdXgucmVsb2NhdGVDb21wb25lbnQoY29tcG9uZW50Q2VudGVyc1tpbmRleF0sIHNwZWN0cmFsUmVzdWx0W2luZGV4XSwgb3B0aW9ucyk7IC8vIHJlbG9jYXRlIGNlbnRlciB0byBvcmlnaW5hbCBwb3NpdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcGFja2luZ1xuICAgICAgICAgIHZhciBjb21wb25lbnRzRXZhbHVhdGVkID0gbmV3IFNldCgpO1xuICAgICAgICAgIGlmIChjb21wb25lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBzdWJncmFwaHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBoaWRkZW5FbGVzID0gZWxlcy5maWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgICAgICByZXR1cm4gZWxlLmNzcygnZGlzcGxheScpID09ICdub25lJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgIHZhciBub2RlSW5kZXhlcyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucXVhbGl0eSA9PSBcImRyYWZ0XCIpIHtcbiAgICAgICAgICAgICAgICBub2RlSW5kZXhlcyA9IHNwZWN0cmFsUmVzdWx0W2luZGV4XS5ub2RlSW5kZXhlcztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChjb21wb25lbnQubm9kZXMoKS5ub3QoaGlkZGVuRWxlcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBzdWJncmFwaCA9IHt9O1xuICAgICAgICAgICAgICAgIHN1YmdyYXBoLmVkZ2VzID0gW107XG4gICAgICAgICAgICAgICAgc3ViZ3JhcGgubm9kZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZUluZGV4ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5ub2RlcygpLm5vdChoaWRkZW5FbGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5xdWFsaXR5ID09IFwiZHJhZnRcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUuaXNQYXJlbnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgIG5vZGVJbmRleCA9IG5vZGVJbmRleGVzLmdldChub2RlLmlkKCkpO1xuICAgICAgICAgICAgICAgICAgICAgIHN1YmdyYXBoLm5vZGVzLnB1c2goeyB4OiBzcGVjdHJhbFJlc3VsdFtpbmRleF0ueENvb3Jkc1tub2RlSW5kZXhdIC0gbm9kZS5ib3VuZGluZ2JveCgpLncgLyAyLCB5OiBzcGVjdHJhbFJlc3VsdFtpbmRleF0ueUNvb3Jkc1tub2RlSW5kZXhdIC0gbm9kZS5ib3VuZGluZ2JveCgpLmggLyAyLCB3aWR0aDogbm9kZS5ib3VuZGluZ2JveCgpLncsIGhlaWdodDogbm9kZS5ib3VuZGluZ2JveCgpLmggfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudEluZm8gPSBhdXguY2FsY0JvdW5kaW5nQm94KG5vZGUsIHNwZWN0cmFsUmVzdWx0W2luZGV4XS54Q29vcmRzLCBzcGVjdHJhbFJlc3VsdFtpbmRleF0ueUNvb3Jkcywgbm9kZUluZGV4ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgIHN1YmdyYXBoLm5vZGVzLnB1c2goeyB4OiBwYXJlbnRJbmZvLnRvcExlZnRYLCB5OiBwYXJlbnRJbmZvLnRvcExlZnRZLCB3aWR0aDogcGFyZW50SW5mby53aWR0aCwgaGVpZ2h0OiBwYXJlbnRJbmZvLmhlaWdodCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvc2VSZXN1bHRbaW5kZXhdW25vZGUuaWQoKV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdWJncmFwaC5ub2Rlcy5wdXNoKHsgeDogY29zZVJlc3VsdFtpbmRleF1bbm9kZS5pZCgpXS5nZXRMZWZ0KCksIHk6IGNvc2VSZXN1bHRbaW5kZXhdW25vZGUuaWQoKV0uZ2V0VG9wKCksIHdpZHRoOiBjb3NlUmVzdWx0W2luZGV4XVtub2RlLmlkKCldLmdldFdpZHRoKCksIGhlaWdodDogY29zZVJlc3VsdFtpbmRleF1bbm9kZS5pZCgpXS5nZXRIZWlnaHQoKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5lZGdlcygpLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBlZGdlLnNvdXJjZSgpO1xuICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGVkZ2UudGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNzcyhcImRpc3BsYXlcIikgIT0gXCJub25lXCIgJiYgdGFyZ2V0LmNzcyhcImRpc3BsYXlcIikgIT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucXVhbGl0eSA9PSBcImRyYWZ0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlTm9kZUluZGV4ID0gbm9kZUluZGV4ZXMuZ2V0KHNvdXJjZS5pZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0Tm9kZUluZGV4ID0gbm9kZUluZGV4ZXMuZ2V0KHRhcmdldC5pZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlQ2VudGVyID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldENlbnRlciA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuaXNQYXJlbnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudEluZm8gPSBhdXguY2FsY0JvdW5kaW5nQm94KHNvdXJjZSwgc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnhDb29yZHMsIHNwZWN0cmFsUmVzdWx0W2luZGV4XS55Q29vcmRzLCBub2RlSW5kZXhlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VDZW50ZXIucHVzaChwYXJlbnRJbmZvLnRvcExlZnRYICsgcGFyZW50SW5mby53aWR0aCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlQ2VudGVyLnB1c2gocGFyZW50SW5mby50b3BMZWZ0WSArIHBhcmVudEluZm8uaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUNlbnRlci5wdXNoKHNwZWN0cmFsUmVzdWx0W2luZGV4XS54Q29vcmRzW3NvdXJjZU5vZGVJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlQ2VudGVyLnB1c2goc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnlDb29yZHNbc291cmNlTm9kZUluZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuaXNQYXJlbnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9wYXJlbnRJbmZvID0gYXV4LmNhbGNCb3VuZGluZ0JveCh0YXJnZXQsIHNwZWN0cmFsUmVzdWx0W2luZGV4XS54Q29vcmRzLCBzcGVjdHJhbFJlc3VsdFtpbmRleF0ueUNvb3Jkcywgbm9kZUluZGV4ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q2VudGVyLnB1c2goX3BhcmVudEluZm8udG9wTGVmdFggKyBfcGFyZW50SW5mby53aWR0aCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q2VudGVyLnB1c2goX3BhcmVudEluZm8udG9wTGVmdFkgKyBfcGFyZW50SW5mby5oZWlnaHQgLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q2VudGVyLnB1c2goc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnhDb29yZHNbdGFyZ2V0Tm9kZUluZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRDZW50ZXIucHVzaChzcGVjdHJhbFJlc3VsdFtpbmRleF0ueUNvb3Jkc1t0YXJnZXROb2RlSW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgc3ViZ3JhcGguZWRnZXMucHVzaCh7IHN0YXJ0WDogc291cmNlQ2VudGVyWzBdLCBzdGFydFk6IHNvdXJjZUNlbnRlclsxXSwgZW5kWDogdGFyZ2V0Q2VudGVyWzBdLCBlbmRZOiB0YXJnZXRDZW50ZXJbMV0gfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGNvc2VSZXN1bHRbaW5kZXhdW3NvdXJjZS5pZCgpXSAmJiBjb3NlUmVzdWx0W2luZGV4XVt0YXJnZXQuaWQoKV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmdyYXBoLmVkZ2VzLnB1c2goeyBzdGFydFg6IGNvc2VSZXN1bHRbaW5kZXhdW3NvdXJjZS5pZCgpXS5nZXRDZW50ZXJYKCksIHN0YXJ0WTogY29zZVJlc3VsdFtpbmRleF1bc291cmNlLmlkKCldLmdldENlbnRlclkoKSwgZW5kWDogY29zZVJlc3VsdFtpbmRleF1bdGFyZ2V0LmlkKCldLmdldENlbnRlclgoKSwgZW5kWTogY29zZVJlc3VsdFtpbmRleF1bdGFyZ2V0LmlkKCldLmdldENlbnRlclkoKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc3ViZ3JhcGgubm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgc3ViZ3JhcGhzLnB1c2goc3ViZ3JhcGgpO1xuICAgICAgICAgICAgICAgICAgY29tcG9uZW50c0V2YWx1YXRlZC5hZGQoaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgc2hpZnRSZXN1bHQgPSBsYXlVdGlsLnBhY2tDb21wb25lbnRzKHN1YmdyYXBocywgb3B0aW9ucy5yYW5kb21pemUpLnNoaWZ0cztcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkcmFmdFwiKSB7XG4gICAgICAgICAgICAgIHNwZWN0cmFsUmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKHJlc3VsdCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3WENvb3JkcyA9IHJlc3VsdC54Q29vcmRzLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHggKyBzaGlmdFJlc3VsdFtpbmRleF0uZHg7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1lDb29yZHMgPSByZXN1bHQueUNvb3Jkcy5tYXAoZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB5ICsgc2hpZnRSZXN1bHRbaW5kZXhdLmR5O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlc3VsdC54Q29vcmRzID0gbmV3WENvb3JkcztcbiAgICAgICAgICAgICAgICByZXN1bHQueUNvb3JkcyA9IG5ld1lDb29yZHM7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9jb3VudCA9IDA7XG4gICAgICAgICAgICAgIGNvbXBvbmVudHNFdmFsdWF0ZWQuZm9yRWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhjb3NlUmVzdWx0W2luZGV4XSkuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgdmFyIG5vZGVSZWN0YW5nbGUgPSBjb3NlUmVzdWx0W2luZGV4XVtpdGVtXTtcbiAgICAgICAgICAgICAgICAgIG5vZGVSZWN0YW5nbGUuc2V0Q2VudGVyKG5vZGVSZWN0YW5nbGUuZ2V0Q2VudGVyWCgpICsgc2hpZnRSZXN1bHRbX2NvdW50XS5keCwgbm9kZVJlY3RhbmdsZS5nZXRDZW50ZXJZKCkgKyBzaGlmdFJlc3VsdFtfY291bnRdLmR5KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBfY291bnQrKztcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGdldCBlYWNoIGVsZW1lbnQncyBjYWxjdWxhdGVkIHBvc2l0aW9uXG4gICAgICB2YXIgZ2V0UG9zaXRpb25zID0gZnVuY3Rpb24gZ2V0UG9zaXRpb25zKGVsZSwgaSkge1xuICAgICAgICBpZiAob3B0aW9ucy5xdWFsaXR5ID09IFwiZGVmYXVsdFwiIHx8IG9wdGlvbnMucXVhbGl0eSA9PSBcInByb29mXCIpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGVsZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgZWxlID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHBvcyA9IHZvaWQgMDtcbiAgICAgICAgICB2YXIgbm9kZSA9IHZvaWQgMDtcbiAgICAgICAgICB2YXIgdGhlSWQgPSBlbGUuZGF0YSgnaWQnKTtcbiAgICAgICAgICBjb3NlUmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKHRoZUlkIGluIHJlc3VsdCkge1xuICAgICAgICAgICAgICBwb3MgPSB7IHg6IHJlc3VsdFt0aGVJZF0uZ2V0UmVjdCgpLmdldENlbnRlclgoKSwgeTogcmVzdWx0W3RoZUlkXS5nZXRSZWN0KCkuZ2V0Q2VudGVyWSgpIH07XG4gICAgICAgICAgICAgIG5vZGUgPSByZXN1bHRbdGhlSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChvcHRpb25zLm5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVscykge1xuICAgICAgICAgICAgaWYgKG5vZGUubGFiZWxXaWR0aCkge1xuICAgICAgICAgICAgICBpZiAobm9kZS5sYWJlbFBvc0hvcml6b250YWwgPT0gXCJsZWZ0XCIpIHtcbiAgICAgICAgICAgICAgICBwb3MueCArPSBub2RlLmxhYmVsV2lkdGggLyAyO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUubGFiZWxQb3NIb3Jpem9udGFsID09IFwicmlnaHRcIikge1xuICAgICAgICAgICAgICAgIHBvcy54IC09IG5vZGUubGFiZWxXaWR0aCAvIDI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLmxhYmVsSGVpZ2h0KSB7XG4gICAgICAgICAgICAgIGlmIChub2RlLmxhYmVsUG9zVmVydGljYWwgPT0gXCJ0b3BcIikge1xuICAgICAgICAgICAgICAgIHBvcy55ICs9IG5vZGUubGFiZWxIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUubGFiZWxQb3NWZXJ0aWNhbCA9PSBcImJvdHRvbVwiKSB7XG4gICAgICAgICAgICAgICAgcG9zLnkgLT0gbm9kZS5sYWJlbEhlaWdodCAvIDI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBvcyA9PSB1bmRlZmluZWQpIHBvcyA9IHsgeDogZWxlLnBvc2l0aW9uKFwieFwiKSwgeTogZWxlLnBvc2l0aW9uKFwieVwiKSB9O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBwb3MueCxcbiAgICAgICAgICAgIHk6IHBvcy55XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX3BvcyA9IHZvaWQgMDtcbiAgICAgICAgICBzcGVjdHJhbFJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHJlc3VsdC5ub2RlSW5kZXhlcy5nZXQoZWxlLmlkKCkpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBfcG9zID0geyB4OiByZXN1bHQueENvb3Jkc1tpbmRleF0sIHk6IHJlc3VsdC55Q29vcmRzW2luZGV4XSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChfcG9zID09IHVuZGVmaW5lZCkgX3BvcyA9IHsgeDogZWxlLnBvc2l0aW9uKFwieFwiKSwgeTogZWxlLnBvc2l0aW9uKFwieVwiKSB9O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBfcG9zLngsXG4gICAgICAgICAgICB5OiBfcG9zLnlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBxdWFsaXR5ID0gXCJkcmFmdFwiIGFuZCByYW5kb21pemUgPSBmYWxzZSBhcmUgY29udHJhZGljdGl2ZSBzbyBpbiB0aGF0IGNhc2UgcG9zaXRpb25zIGRvbid0IGNoYW5nZVxuICAgICAgaWYgKG9wdGlvbnMucXVhbGl0eSA9PSBcImRlZmF1bHRcIiB8fCBvcHRpb25zLnF1YWxpdHkgPT0gXCJwcm9vZlwiIHx8IG9wdGlvbnMucmFuZG9taXplKSB7XG4gICAgICAgIC8vIHRyYW5zZmVyIGNhbGN1bGF0ZWQgcG9zaXRpb25zIHRvIG5vZGVzIChwb3NpdGlvbnMgb2Ygb25seSBzaW1wbGUgbm9kZXMgYXJlIGV2YWx1YXRlZCwgY29tcG91bmRzIGFyZSBwb3NpdGlvbmVkIGF1dG9tYXRpY2FsbHkpXG4gICAgICAgIHZhciBwYXJlbnRzV2l0aG91dENoaWxkcmVuID0gYXV4LmNhbGNQYXJlbnRzV2l0aG91dENoaWxkcmVuKGN5LCBlbGVzKTtcbiAgICAgICAgdmFyIF9oaWRkZW5FbGVzID0gZWxlcy5maWx0ZXIoZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgIHJldHVybiBlbGUuY3NzKCdkaXNwbGF5JykgPT0gJ25vbmUnO1xuICAgICAgICB9KTtcbiAgICAgICAgb3B0aW9ucy5lbGVzID0gZWxlcy5ub3QoX2hpZGRlbkVsZXMpO1xuXG4gICAgICAgIGVsZXMubm9kZXMoKS5ub3QoXCI6cGFyZW50XCIpLm5vdChfaGlkZGVuRWxlcykubGF5b3V0UG9zaXRpb25zKGxheW91dCwgb3B0aW9ucywgZ2V0UG9zaXRpb25zKTtcblxuICAgICAgICBpZiAocGFyZW50c1dpdGhvdXRDaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcGFyZW50c1dpdGhvdXRDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICAgIGVsZS5wb3NpdGlvbihnZXRQb3NpdGlvbnMoZWxlKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiSWYgcmFuZG9taXplIG9wdGlvbiBpcyBzZXQgdG8gZmFsc2UsIHRoZW4gcXVhbGl0eSBvcHRpb24gbXVzdCBiZSAnZGVmYXVsdCcgb3IgJ3Byb29mJy5cIik7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExheW91dDtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMYXlvdXQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA2NTc6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG4vKipcbiAgVGhlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBzcGVjdHJhbCBsYXlvdXQgdGhhdCBpcyB0aGUgZmlyc3QgcGFydCBvZiB0aGUgZmNvc2UgbGF5b3V0IGFsZ29yaXRobVxuKi9cblxudmFyIGF1eCA9IF9fd2VicGFja19yZXF1aXJlX18oNTQ4KTtcbnZhciBNYXRyaXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MCkubGF5b3V0QmFzZS5NYXRyaXg7XG52YXIgU1ZEID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDApLmxheW91dEJhc2UuU1ZEO1xuXG4vLyBtYWluIGZ1bmN0aW9uIHRoYXQgc3BlY3RyYWwgbGF5b3V0IGlzIHByb2Nlc3NlZFxudmFyIHNwZWN0cmFsTGF5b3V0ID0gZnVuY3Rpb24gc3BlY3RyYWxMYXlvdXQob3B0aW9ucykge1xuXG4gIHZhciBjeSA9IG9wdGlvbnMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCk7XG4gIHZhciBwYXJlbnROb2RlcyA9IGVsZXMubm9kZXMoXCI6cGFyZW50XCIpO1xuXG4gIHZhciBkdW1teU5vZGVzID0gbmV3IE1hcCgpOyAvLyBtYXAgdG8ga2VlcCBkdW1teSBub2RlcyBhbmQgdGhlaXIgbmVpZ2hib3JzXG4gIHZhciBub2RlSW5kZXhlcyA9IG5ldyBNYXAoKTsgLy8gbWFwIHRvIGtlZXAgaW5kZXhlcyB0byBub2Rlc1xuICB2YXIgcGFyZW50Q2hpbGRNYXAgPSBuZXcgTWFwKCk7IC8vIG1hcHBpbmcgYnR3LiBjb21wb3VuZCBhbmQgaXRzIHJlcHJlc2VudGF0aXZlIG5vZGUgXG4gIHZhciBhbGxOb2Rlc05laWdoYm9yaG9vZCA9IFtdOyAvLyBhcnJheSB0byBrZWVwIG5laWdoYm9yaG9vZCBvZiBhbGwgbm9kZXNcbiAgdmFyIHhDb29yZHMgPSBbXTtcbiAgdmFyIHlDb29yZHMgPSBbXTtcblxuICB2YXIgc2FtcGxlc0NvbHVtbiA9IFtdOyAvLyBzYW1wbGVkIHZlcnRpY2VzXG4gIHZhciBtaW5EaXN0YW5jZXNDb2x1bW4gPSBbXTtcbiAgdmFyIEMgPSBbXTsgLy8gY29sdW1uIHNhbXBsaW5nIG1hdHJpeFxuICB2YXIgUEhJID0gW107IC8vIGludGVyc2VjdGlvbiBvZiBjb2x1bW4gYW5kIHJvdyBzYW1wbGluZyBtYXRyaWNlcyBcbiAgdmFyIElOViA9IFtdOyAvLyBpbnZlcnNlIG9mIFBISSBcblxuICB2YXIgZmlyc3RTYW1wbGUgPSB2b2lkIDA7IC8vIHRoZSBmaXJzdCBzYW1wbGVkIG5vZGVcbiAgdmFyIG5vZGVTaXplID0gdm9pZCAwO1xuXG4gIHZhciBpbmZpbml0eSA9IDEwMDAwMDAwMDtcbiAgdmFyIHNtYWxsID0gMC4wMDAwMDAwMDE7XG5cbiAgdmFyIHBpVG9sID0gb3B0aW9ucy5waVRvbDtcbiAgdmFyIHNhbXBsaW5nVHlwZSA9IG9wdGlvbnMuc2FtcGxpbmdUeXBlOyAvLyBmYWxzZSBmb3IgcmFuZG9tLCB0cnVlIGZvciBncmVlZHlcbiAgdmFyIG5vZGVTZXBhcmF0aW9uID0gb3B0aW9ucy5ub2RlU2VwYXJhdGlvbjtcbiAgdmFyIHNhbXBsZVNpemUgPSB2b2lkIDA7XG5cbiAgLyoqKiogU3BlY3RyYWwtcHJlcHJvY2Vzc2luZyBmdW5jdGlvbnMgKioqKi9cblxuICAvKioqKiBTcGVjdHJhbCBsYXlvdXQgZnVuY3Rpb25zICoqKiovXG5cbiAgLy8gZGV0ZXJtaW5lIHdoaWNoIGNvbHVtbnMgdG8gYmUgc2FtcGxlZFxuICB2YXIgcmFuZG9tU2FtcGxlQ1IgPSBmdW5jdGlvbiByYW5kb21TYW1wbGVDUigpIHtcbiAgICB2YXIgc2FtcGxlID0gMDtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBmbGFnID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoY291bnQgPCBzYW1wbGVTaXplKSB7XG4gICAgICBzYW1wbGUgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBub2RlU2l6ZSk7XG5cbiAgICAgIGZsYWcgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBpZiAoc2FtcGxlc0NvbHVtbltpXSA9PSBzYW1wbGUpIHtcbiAgICAgICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWZsYWcpIHtcbiAgICAgICAgc2FtcGxlc0NvbHVtbltjb3VudF0gPSBzYW1wbGU7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gdGFrZXMgdGhlIGluZGV4IG9mIHRoZSBub2RlKHBpdm90KSB0byBpbml0aWF0ZSBCRlMgYXMgYSBwYXJhbWV0ZXJcbiAgdmFyIEJGUyA9IGZ1bmN0aW9uIEJGUyhwaXZvdCwgaW5kZXgsIHNhbXBsaW5nTWV0aG9kKSB7XG4gICAgdmFyIHBhdGggPSBbXTsgLy8gdGhlIGZyb250IG9mIHRoZSBwYXRoXG4gICAgdmFyIGZyb250ID0gMDsgLy8gdGhlIGJhY2sgb2YgdGhlIHBhdGhcbiAgICB2YXIgYmFjayA9IDA7XG4gICAgdmFyIGN1cnJlbnQgPSAwO1xuICAgIHZhciB0ZW1wID0gdm9pZCAwO1xuICAgIHZhciBkaXN0YW5jZSA9IFtdO1xuXG4gICAgdmFyIG1heF9kaXN0ID0gMDsgLy8gdGhlIGZ1cnRoZXN0IG5vZGUgdG8gYmUgcmV0dXJuZWRcbiAgICB2YXIgbWF4X2luZCA9IDE7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVTaXplOyBpKyspIHtcbiAgICAgIGRpc3RhbmNlW2ldID0gaW5maW5pdHk7XG4gICAgfVxuXG4gICAgcGF0aFtiYWNrXSA9IHBpdm90O1xuICAgIGRpc3RhbmNlW3Bpdm90XSA9IDA7XG5cbiAgICB3aGlsZSAoYmFjayA+PSBmcm9udCkge1xuICAgICAgY3VycmVudCA9IHBhdGhbZnJvbnQrK107XG4gICAgICB2YXIgbmVpZ2hib3JzID0gYWxsTm9kZXNOZWlnaGJvcmhvb2RbY3VycmVudF07XG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbmVpZ2hib3JzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB0ZW1wID0gbm9kZUluZGV4ZXMuZ2V0KG5laWdoYm9yc1tfaV0pO1xuICAgICAgICBpZiAoZGlzdGFuY2VbdGVtcF0gPT0gaW5maW5pdHkpIHtcbiAgICAgICAgICBkaXN0YW5jZVt0ZW1wXSA9IGRpc3RhbmNlW2N1cnJlbnRdICsgMTtcbiAgICAgICAgICBwYXRoWysrYmFja10gPSB0ZW1wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBDW2N1cnJlbnRdW2luZGV4XSA9IGRpc3RhbmNlW2N1cnJlbnRdICogbm9kZVNlcGFyYXRpb247XG4gICAgfVxuXG4gICAgaWYgKHNhbXBsaW5nTWV0aG9kKSB7XG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBub2RlU2l6ZTsgX2kyKyspIHtcbiAgICAgICAgaWYgKENbX2kyXVtpbmRleF0gPCBtaW5EaXN0YW5jZXNDb2x1bW5bX2kyXSkgbWluRGlzdGFuY2VzQ29sdW1uW19pMl0gPSBDW19pMl1baW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBub2RlU2l6ZTsgX2kzKyspIHtcbiAgICAgICAgaWYgKG1pbkRpc3RhbmNlc0NvbHVtbltfaTNdID4gbWF4X2Rpc3QpIHtcbiAgICAgICAgICBtYXhfZGlzdCA9IG1pbkRpc3RhbmNlc0NvbHVtbltfaTNdO1xuICAgICAgICAgIG1heF9pbmQgPSBfaTM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heF9pbmQ7XG4gIH07XG5cbiAgLy8gYXBwbHkgQkZTIHRvIGFsbCBub2RlcyBvciBzZWxlY3RlZCBzYW1wbGVzXG4gIHZhciBhbGxCRlMgPSBmdW5jdGlvbiBhbGxCRlMoc2FtcGxpbmdNZXRob2QpIHtcblxuICAgIHZhciBzYW1wbGUgPSB2b2lkIDA7XG5cbiAgICBpZiAoIXNhbXBsaW5nTWV0aG9kKSB7XG4gICAgICByYW5kb21TYW1wbGVDUigpO1xuXG4gICAgICAvLyBjYWxsIEJGU1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzYW1wbGVTaXplOyBpKyspIHtcbiAgICAgICAgQkZTKHNhbXBsZXNDb2x1bW5baV0sIGksIHNhbXBsaW5nTWV0aG9kLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNhbXBsZSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG5vZGVTaXplKTtcbiAgICAgIGZpcnN0U2FtcGxlID0gc2FtcGxlO1xuXG4gICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBub2RlU2l6ZTsgX2k0KyspIHtcbiAgICAgICAgbWluRGlzdGFuY2VzQ29sdW1uW19pNF0gPSBpbmZpbml0eTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgc2FtcGxlU2l6ZTsgX2k1KyspIHtcbiAgICAgICAgc2FtcGxlc0NvbHVtbltfaTVdID0gc2FtcGxlO1xuICAgICAgICBzYW1wbGUgPSBCRlMoc2FtcGxlLCBfaTUsIHNhbXBsaW5nTWV0aG9kKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmb3JtIHRoZSBzcXVhcmVkIGRpc3RhbmNlcyBmb3IgQ1xuICAgIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IG5vZGVTaXplOyBfaTYrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzYW1wbGVTaXplOyBqKyspIHtcbiAgICAgICAgQ1tfaTZdW2pdICo9IENbX2k2XVtqXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmb3JtIFBISVxuICAgIGZvciAodmFyIF9pNyA9IDA7IF9pNyA8IHNhbXBsZVNpemU7IF9pNysrKSB7XG4gICAgICBQSElbX2k3XSA9IFtdO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9pOCA9IDA7IF9pOCA8IHNhbXBsZVNpemU7IF9pOCsrKSB7XG4gICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgc2FtcGxlU2l6ZTsgX2orKykge1xuICAgICAgICBQSElbX2k4XVtfal0gPSBDW3NhbXBsZXNDb2x1bW5bX2pdXVtfaThdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBwZXJmb3JtIHRoZSBTVkQgYWxnb3JpdGhtIGFuZCBhcHBseSBhIHJlZ3VsYXJpemF0aW9uIHN0ZXBcbiAgdmFyIHNhbXBsZSA9IGZ1bmN0aW9uIHNhbXBsZSgpIHtcblxuICAgIHZhciBTVkRSZXN1bHQgPSBTVkQuc3ZkKFBISSk7XG5cbiAgICB2YXIgYV9xID0gU1ZEUmVzdWx0LlM7XG4gICAgdmFyIGFfdSA9IFNWRFJlc3VsdC5VO1xuICAgIHZhciBhX3YgPSBTVkRSZXN1bHQuVjtcblxuICAgIHZhciBtYXhfcyA9IGFfcVswXSAqIGFfcVswXSAqIGFfcVswXTtcblxuICAgIHZhciBhX1NpZyA9IFtdO1xuXG4gICAgLy8gIHJlZ3VsYXJpemF0aW9uXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzYW1wbGVTaXplOyBpKyspIHtcbiAgICAgIGFfU2lnW2ldID0gW107XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNhbXBsZVNpemU7IGorKykge1xuICAgICAgICBhX1NpZ1tpXVtqXSA9IDA7XG4gICAgICAgIGlmIChpID09IGopIHtcbiAgICAgICAgICBhX1NpZ1tpXVtqXSA9IGFfcVtpXSAvIChhX3FbaV0gKiBhX3FbaV0gKyBtYXhfcyAvIChhX3FbaV0gKiBhX3FbaV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIElOViA9IE1hdHJpeC5tdWx0TWF0KE1hdHJpeC5tdWx0TWF0KGFfdiwgYV9TaWcpLCBNYXRyaXgudHJhbnNwb3NlKGFfdSkpO1xuICB9O1xuXG4gIC8vIGNhbGN1bGF0ZSBmaW5hbCBjb29yZGluYXRlcyBcbiAgdmFyIHBvd2VySXRlcmF0aW9uID0gZnVuY3Rpb24gcG93ZXJJdGVyYXRpb24oKSB7XG4gICAgLy8gdHdvIGxhcmdlc3QgZWlnZW52YWx1ZXNcbiAgICB2YXIgdGhldGExID0gdm9pZCAwO1xuICAgIHZhciB0aGV0YTIgPSB2b2lkIDA7XG5cbiAgICAvLyBpbml0aWFsIGd1ZXNzZXMgZm9yIGVpZ2VudmVjdG9yc1xuICAgIHZhciBZMSA9IFtdO1xuICAgIHZhciBZMiA9IFtdO1xuXG4gICAgdmFyIFYxID0gW107XG4gICAgdmFyIFYyID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVTaXplOyBpKyspIHtcbiAgICAgIFkxW2ldID0gTWF0aC5yYW5kb20oKTtcbiAgICAgIFkyW2ldID0gTWF0aC5yYW5kb20oKTtcbiAgICB9XG5cbiAgICBZMSA9IE1hdHJpeC5ub3JtYWxpemUoWTEpO1xuICAgIFkyID0gTWF0cml4Lm5vcm1hbGl6ZShZMik7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIC8vIHRvIGtlZXAgdHJhY2sgb2YgdGhlIGltcHJvdmVtZW50IHJhdGlvIGluIHBvd2VyIGl0ZXJhdGlvblxuICAgIHZhciBjdXJyZW50ID0gc21hbGw7XG4gICAgdmFyIHByZXZpb3VzID0gc21hbGw7XG5cbiAgICB2YXIgdGVtcCA9IHZvaWQgMDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb3VudCsrO1xuXG4gICAgICBmb3IgKHZhciBfaTkgPSAwOyBfaTkgPCBub2RlU2l6ZTsgX2k5KyspIHtcbiAgICAgICAgVjFbX2k5XSA9IFkxW19pOV07XG4gICAgICB9XG5cbiAgICAgIFkxID0gTWF0cml4Lm11bHRHYW1tYShNYXRyaXgubXVsdEwoTWF0cml4Lm11bHRHYW1tYShWMSksIEMsIElOVikpO1xuICAgICAgdGhldGExID0gTWF0cml4LmRvdFByb2R1Y3QoVjEsIFkxKTtcbiAgICAgIFkxID0gTWF0cml4Lm5vcm1hbGl6ZShZMSk7XG5cbiAgICAgIGN1cnJlbnQgPSBNYXRyaXguZG90UHJvZHVjdChWMSwgWTEpO1xuXG4gICAgICB0ZW1wID0gTWF0aC5hYnMoY3VycmVudCAvIHByZXZpb3VzKTtcblxuICAgICAgaWYgKHRlbXAgPD0gMSArIHBpVG9sICYmIHRlbXAgPj0gMSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgIH1cblxuICAgIGZvciAodmFyIF9pMTAgPSAwOyBfaTEwIDwgbm9kZVNpemU7IF9pMTArKykge1xuICAgICAgVjFbX2kxMF0gPSBZMVtfaTEwXTtcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmlvdXMgPSBzbWFsbDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY291bnQrKztcblxuICAgICAgZm9yICh2YXIgX2kxMSA9IDA7IF9pMTEgPCBub2RlU2l6ZTsgX2kxMSsrKSB7XG4gICAgICAgIFYyW19pMTFdID0gWTJbX2kxMV07XG4gICAgICB9XG5cbiAgICAgIFYyID0gTWF0cml4Lm1pbnVzT3AoVjIsIE1hdHJpeC5tdWx0Q29ucyhWMSwgTWF0cml4LmRvdFByb2R1Y3QoVjEsIFYyKSkpO1xuICAgICAgWTIgPSBNYXRyaXgubXVsdEdhbW1hKE1hdHJpeC5tdWx0TChNYXRyaXgubXVsdEdhbW1hKFYyKSwgQywgSU5WKSk7XG4gICAgICB0aGV0YTIgPSBNYXRyaXguZG90UHJvZHVjdChWMiwgWTIpO1xuICAgICAgWTIgPSBNYXRyaXgubm9ybWFsaXplKFkyKTtcblxuICAgICAgY3VycmVudCA9IE1hdHJpeC5kb3RQcm9kdWN0KFYyLCBZMik7XG5cbiAgICAgIHRlbXAgPSBNYXRoLmFicyhjdXJyZW50IC8gcHJldmlvdXMpO1xuXG4gICAgICBpZiAodGVtcCA8PSAxICsgcGlUb2wgJiYgdGVtcCA+PSAxKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kxMiA9IDA7IF9pMTIgPCBub2RlU2l6ZTsgX2kxMisrKSB7XG4gICAgICBWMltfaTEyXSA9IFkyW19pMTJdO1xuICAgIH1cblxuICAgIC8vIHRoZXRhMSBub3cgY29udGFpbnMgZG9taW5hbnQgZWlnZW52YWx1ZVxuICAgIC8vIHRoZXRhMiBub3cgY29udGFpbnMgdGhlIHNlY29uZC1sYXJnZXN0IGVpZ2VudmFsdWVcbiAgICAvLyBWMSBub3cgY29udGFpbnMgdGhldGExJ3MgZWlnZW52ZWN0b3JcbiAgICAvLyBWMiBub3cgY29udGFpbnMgdGhldGEyJ3MgZWlnZW52ZWN0b3JcblxuICAgIC8vcG9wdWxhdGUgdGhlIHR3byB2ZWN0b3JzXG4gICAgeENvb3JkcyA9IE1hdHJpeC5tdWx0Q29ucyhWMSwgTWF0aC5zcXJ0KE1hdGguYWJzKHRoZXRhMSkpKTtcbiAgICB5Q29vcmRzID0gTWF0cml4Lm11bHRDb25zKFYyLCBNYXRoLnNxcnQoTWF0aC5hYnModGhldGEyKSkpO1xuICB9O1xuXG4gIC8qKioqIFByZXBhcmF0aW9uIGZvciBzcGVjdHJhbCBsYXlvdXQgKFByZXByb2Nlc3NpbmcpICoqKiovXG5cbiAgLy8gY29ubmVjdCBkaXNjb25uZWN0ZWQgY29tcG9uZW50cyAoZmlyc3QgdG9wIGxldmVsLCB0aGVuIGluc2lkZSBvZiBlYWNoIGNvbXBvdW5kIG5vZGUpXG4gIGF1eC5jb25uZWN0Q29tcG9uZW50cyhjeSwgZWxlcywgYXV4LmdldFRvcE1vc3ROb2Rlcyhub2RlcyksIGR1bW15Tm9kZXMpO1xuXG4gIHBhcmVudE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgIGF1eC5jb25uZWN0Q29tcG9uZW50cyhjeSwgZWxlcywgYXV4LmdldFRvcE1vc3ROb2RlcyhlbGUuZGVzY2VuZGFudHMoKS5pbnRlcnNlY3Rpb24oZWxlcykpLCBkdW1teU5vZGVzKTtcbiAgfSk7XG5cbiAgLy8gYXNzaWduIGluZGV4ZXMgdG8gbm9kZXMgKGZpcnN0IHJlYWwsIHRoZW4gZHVtbXkgbm9kZXMpXG4gIHZhciBpbmRleCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIW5vZGVzW2ldLmlzUGFyZW50KCkpIHtcbiAgICAgIG5vZGVJbmRleGVzLnNldChub2Rlc1tpXS5pZCgpLCBpbmRleCsrKTtcbiAgICB9XG4gIH1cblxuICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBkdW1teU5vZGVzLmtleXMoKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgIHZhciBrZXkgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgbm9kZUluZGV4ZXMuc2V0KGtleSwgaW5kZXgrKyk7XG4gICAgfVxuXG4gICAgLy8gaW5zdGFudGlhdGUgdGhlIG5laWdoYm9yaG9vZCBtYXRyaXhcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBfaTEzID0gMDsgX2kxMyA8IG5vZGVJbmRleGVzLnNpemU7IF9pMTMrKykge1xuICAgIGFsbE5vZGVzTmVpZ2hib3Job29kW19pMTNdID0gW107XG4gIH1cblxuICAvLyBmb3JtIGEgcGFyZW50LWNoaWxkIG1hcCB0byBrZWVwIHJlcHJlc2VudGF0aXZlIG5vZGUgb2YgZWFjaCBjb21wb3VuZCBub2RlICBcbiAgcGFyZW50Tm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gZWxlLmNoaWxkcmVuKCkuaW50ZXJzZWN0aW9uKGVsZXMpO1xuXG4gICAgLy8gICAgICBsZXQgcmFuZG9tID0gMDtcbiAgICB3aGlsZSAoY2hpbGRyZW4ubm9kZXMoXCI6Y2hpbGRsZXNzXCIpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAvLyAgICAgICAgcmFuZG9tID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hpbGRyZW4ubm9kZXMoKS5sZW5ndGgpOyAvLyBpZiBhbGwgY2hpbGRyZW4gYXJlIGNvbXBvdW5kIHRoZW4gcHJvY2VlZCByYW5kb21seVxuICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5ub2RlcygpWzBdLmNoaWxkcmVuKCkuaW50ZXJzZWN0aW9uKGVsZXMpO1xuICAgIH1cbiAgICAvLyAgc2VsZWN0IHRoZSByZXByZXNlbnRhdGl2ZSBub2RlIC0gd2UgY2FuIGFwcGx5IGRpZmZlcmVudCBtZXRob2RzIGhlcmVcbiAgICAvLyAgICAgIHJhbmRvbSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoaWxkcmVuLm5vZGVzKFwiOmNoaWxkbGVzc1wiKS5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIG1pbiA9IGNoaWxkcmVuLm5vZGVzKFwiOmNoaWxkbGVzc1wiKVswXS5jb25uZWN0ZWRFZGdlcygpLmxlbmd0aDtcbiAgICBjaGlsZHJlbi5ub2RlcyhcIjpjaGlsZGxlc3NcIikuZm9yRWFjaChmdW5jdGlvbiAoZWxlMiwgaSkge1xuICAgICAgaWYgKGVsZTIuY29ubmVjdGVkRWRnZXMoKS5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgbWluID0gZWxlMi5jb25uZWN0ZWRFZGdlcygpLmxlbmd0aDtcbiAgICAgICAgaW5kZXggPSBpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHBhcmVudENoaWxkTWFwLnNldChlbGUuaWQoKSwgY2hpbGRyZW4ubm9kZXMoXCI6Y2hpbGRsZXNzXCIpW2luZGV4XS5pZCgpKTtcbiAgfSk7XG5cbiAgLy8gYWRkIG5laWdoYm9yaG9vZCByZWxhdGlvbnMgKGZpcnN0IHJlYWwsIHRoZW4gZHVtbXkgbm9kZXMpXG4gIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgIHZhciBlbGVJbmRleCA9IHZvaWQgMDtcblxuICAgIGlmIChlbGUuaXNQYXJlbnQoKSkgZWxlSW5kZXggPSBub2RlSW5kZXhlcy5nZXQocGFyZW50Q2hpbGRNYXAuZ2V0KGVsZS5pZCgpKSk7ZWxzZSBlbGVJbmRleCA9IG5vZGVJbmRleGVzLmdldChlbGUuaWQoKSk7XG5cbiAgICBlbGUubmVpZ2hib3Job29kKCkubm9kZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBpZiAoZWxlcy5pbnRlcnNlY3Rpb24oZWxlLmVkZ2VzV2l0aChub2RlKSkubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAobm9kZS5pc1BhcmVudCgpKSBhbGxOb2Rlc05laWdoYm9yaG9vZFtlbGVJbmRleF0ucHVzaChwYXJlbnRDaGlsZE1hcC5nZXQobm9kZS5pZCgpKSk7ZWxzZSBhbGxOb2Rlc05laWdoYm9yaG9vZFtlbGVJbmRleF0ucHVzaChub2RlLmlkKCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfa2V5KSB7XG4gICAgdmFyIGVsZUluZGV4ID0gbm9kZUluZGV4ZXMuZ2V0KF9rZXkpO1xuICAgIHZhciBkaXNjb25uZWN0ZWRJZCA9IHZvaWQgMDtcbiAgICBkdW1teU5vZGVzLmdldChfa2V5KS5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgICAgaWYgKGN5LmdldEVsZW1lbnRCeUlkKGlkKS5pc1BhcmVudCgpKSBkaXNjb25uZWN0ZWRJZCA9IHBhcmVudENoaWxkTWFwLmdldChpZCk7ZWxzZSBkaXNjb25uZWN0ZWRJZCA9IGlkO1xuXG4gICAgICBhbGxOb2Rlc05laWdoYm9yaG9vZFtlbGVJbmRleF0ucHVzaChkaXNjb25uZWN0ZWRJZCk7XG4gICAgICBhbGxOb2Rlc05laWdoYm9yaG9vZFtub2RlSW5kZXhlcy5nZXQoZGlzY29ubmVjdGVkSWQpXS5wdXNoKF9rZXkpO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBkdW1teU5vZGVzLmtleXMoKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgdmFyIF9rZXkgPSBfc3RlcDIudmFsdWU7XG5cbiAgICAgIF9sb29wKF9rZXkpO1xuICAgIH1cblxuICAgIC8vIG5vZGVTaXplIG5vdyBvbmx5IGNvbnNpZGVycyB0aGUgc2l6ZSBvZiB0cmFuc2Zvcm1lZCBncmFwaFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZGlkSXRlcmF0b3JFcnJvcjIgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yMiA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybikge1xuICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBub2RlU2l6ZSA9IG5vZGVJbmRleGVzLnNpemU7XG5cbiAgdmFyIHNwZWN0cmFsUmVzdWx0ID0gdm9pZCAwO1xuXG4gIC8vIElmIG51bWJlciBvZiBub2RlcyBpbiB0cmFuc2Zvcm1lZCBncmFwaCBpcyAxIG9yIDIsIGVpdGhlciBTVkQgb3IgcG93ZXJJdGVyYXRpb24gY2F1c2VzIHByb2JsZW1cbiAgLy8gU28gc2tpcCBzcGVjdHJhbCBhbmQgbGF5b3V0IHRoZSBncmFwaCB3aXRoIGNvc2VcbiAgaWYgKG5vZGVTaXplID4gMikge1xuICAgIC8vIGlmICMgb2Ygbm9kZXMgaW4gdHJhbnNmb3JtZWQgZ3JhcGggaXMgc21hbGxlciB0aGFuIHNhbXBsZSBzaXplLFxuICAgIC8vIHRoZW4gdXNlICMgb2Ygbm9kZXMgYXMgc2FtcGxlIHNpemVcbiAgICBzYW1wbGVTaXplID0gbm9kZVNpemUgPCBvcHRpb25zLnNhbXBsZVNpemUgPyBub2RlU2l6ZSA6IG9wdGlvbnMuc2FtcGxlU2l6ZTtcblxuICAgIC8vIGluc3RhbnRpYXRlcyB0aGUgcGFydGlhbCBtYXRyaWNlcyB0aGF0IHdpbGwgYmUgdXNlZCBpbiBzcGVjdHJhbCBsYXlvdXRcbiAgICBmb3IgKHZhciBfaTE0ID0gMDsgX2kxNCA8IG5vZGVTaXplOyBfaTE0KyspIHtcbiAgICAgIENbX2kxNF0gPSBbXTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2kxNSA9IDA7IF9pMTUgPCBzYW1wbGVTaXplOyBfaTE1KyspIHtcbiAgICAgIElOVltfaTE1XSA9IFtdO1xuICAgIH1cblxuICAgIC8qKioqIEFwcGx5IHNwZWN0cmFsIGxheW91dCAqKioqL1xuXG4gICAgaWYgKG9wdGlvbnMucXVhbGl0eSA9PSBcImRyYWZ0XCIgfHwgb3B0aW9ucy5zdGVwID09IFwiYWxsXCIpIHtcbiAgICAgIGFsbEJGUyhzYW1wbGluZ1R5cGUpO1xuICAgICAgc2FtcGxlKCk7XG4gICAgICBwb3dlckl0ZXJhdGlvbigpO1xuXG4gICAgICBzcGVjdHJhbFJlc3VsdCA9IHsgbm9kZUluZGV4ZXM6IG5vZGVJbmRleGVzLCB4Q29vcmRzOiB4Q29vcmRzLCB5Q29vcmRzOiB5Q29vcmRzIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVJbmRleGVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgeENvb3Jkcy5wdXNoKGN5LmdldEVsZW1lbnRCeUlkKGtleSkucG9zaXRpb24oXCJ4XCIpKTtcbiAgICAgICAgeUNvb3Jkcy5wdXNoKGN5LmdldEVsZW1lbnRCeUlkKGtleSkucG9zaXRpb24oXCJ5XCIpKTtcbiAgICAgIH0pO1xuICAgICAgc3BlY3RyYWxSZXN1bHQgPSB7IG5vZGVJbmRleGVzOiBub2RlSW5kZXhlcywgeENvb3JkczogeENvb3JkcywgeUNvb3JkczogeUNvb3JkcyB9O1xuICAgIH1cbiAgICByZXR1cm4gc3BlY3RyYWxSZXN1bHQ7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yID0gbm9kZUluZGV4ZXMua2V5cygpO1xuICAgIHZhciBmaXJzdE5vZGUgPSBjeS5nZXRFbGVtZW50QnlJZChpdGVyYXRvci5uZXh0KCkudmFsdWUpO1xuICAgIHZhciBmaXJzdE5vZGVQb3MgPSBmaXJzdE5vZGUucG9zaXRpb24oKTtcbiAgICB2YXIgZmlyc3ROb2RlV2lkdGggPSBmaXJzdE5vZGUub3V0ZXJXaWR0aCgpO1xuICAgIHhDb29yZHMucHVzaChmaXJzdE5vZGVQb3MueCk7XG4gICAgeUNvb3Jkcy5wdXNoKGZpcnN0Tm9kZVBvcy55KTtcbiAgICBpZiAobm9kZVNpemUgPT0gMikge1xuICAgICAgdmFyIHNlY29uZE5vZGUgPSBjeS5nZXRFbGVtZW50QnlJZChpdGVyYXRvci5uZXh0KCkudmFsdWUpO1xuICAgICAgdmFyIHNlY29uZE5vZGVXaWR0aCA9IHNlY29uZE5vZGUub3V0ZXJXaWR0aCgpO1xuICAgICAgeENvb3Jkcy5wdXNoKGZpcnN0Tm9kZVBvcy54ICsgZmlyc3ROb2RlV2lkdGggLyAyICsgc2Vjb25kTm9kZVdpZHRoIC8gMiArIG9wdGlvbnMuaWRlYWxFZGdlTGVuZ3RoKTtcbiAgICAgIHlDb29yZHMucHVzaChmaXJzdE5vZGVQb3MueSk7XG4gICAgfVxuXG4gICAgc3BlY3RyYWxSZXN1bHQgPSB7IG5vZGVJbmRleGVzOiBub2RlSW5kZXhlcywgeENvb3JkczogeENvb3JkcywgeUNvb3JkczogeUNvb3JkcyB9O1xuICAgIHJldHVybiBzcGVjdHJhbFJlc3VsdDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7IHNwZWN0cmFsTGF5b3V0OiBzcGVjdHJhbExheW91dCB9O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNTc5OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxudmFyIGltcGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxMik7XG5cbi8vIHJlZ2lzdGVycyB0aGUgZXh0ZW5zaW9uIG9uIGEgY3l0b3NjYXBlIGxpYiByZWZcbnZhciByZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKGN5dG9zY2FwZSkge1xuICBpZiAoIWN5dG9zY2FwZSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBjYW4ndCByZWdpc3RlciBpZiBjeXRvc2NhcGUgdW5zcGVjaWZpZWRcblxuICBjeXRvc2NhcGUoJ2xheW91dCcsICdmY29zZScsIGltcGwpOyAvLyByZWdpc3RlciB3aXRoIGN5dG9zY2FwZS5qc1xufTtcblxuaWYgKHR5cGVvZiBjeXRvc2NhcGUgIT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIGV4cG9zZSB0byBnbG9iYWwgY3l0b3NjYXBlIChpLmUuIHdpbmRvdy5jeXRvc2NhcGUpXG4gIHJlZ2lzdGVyKGN5dG9zY2FwZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVnaXN0ZXI7XG5cbi8qKiovIH0pLFxuXG4vKioqLyAxNDA6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzE0MF9fO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0Ly8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3OSk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pOyJdLCJuYW1lcyI6WyJ3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsInJvb3QiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsInJlcXVpcmUiLCJkZWZpbmUiLCJhbWQiLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18xNDBfXyIsIl9fd2VicGFja19tb2R1bGVzX18iLCJPYmplY3QiLCJhc3NpZ24iLCJiaW5kIiwidGd0IiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNyY3MiLCJBcnJheSIsIl9rZXkiLCJmb3JFYWNoIiwic3JjIiwia2V5cyIsImsiLCJfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwiX3NsaWNlZFRvQXJyYXkiLCJzbGljZUl0ZXJhdG9yIiwiYXJyIiwiaSIsIl9hcnIiLCJfbiIsIl9kIiwiX2UiLCJ1bmRlZmluZWQiLCJfaSIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiX3MiLCJuZXh0IiwiZG9uZSIsInB1c2giLCJ2YWx1ZSIsImVyciIsImlzQXJyYXkiLCJUeXBlRXJyb3IiLCJMaW5rZWRMaXN0IiwibGF5b3V0QmFzZSIsImF1eGlsaWFyeSIsImdldFRvcE1vc3ROb2RlcyIsIm5vZGVzIiwibm9kZXNNYXAiLCJpZCIsInJvb3RzIiwiZmlsdGVyIiwiZWxlIiwicGFyZW50IiwiY29ubmVjdENvbXBvbmVudHMiLCJjeSIsImVsZXMiLCJ0b3BNb3N0Tm9kZXMiLCJkdW1teU5vZGVzIiwicXVldWUiLCJ2aXNpdGVkIiwiU2V0IiwidmlzaXRlZFRvcE1vc3ROb2RlcyIsImN1cnJlbnROZWlnaGJvciIsIm1pbkRlZ3JlZU5vZGUiLCJtaW5EZWdyZWUiLCJpc0Nvbm5lY3RlZCIsImNvdW50Iiwibm9kZXNDb25uZWN0ZWRUb0R1bW15IiwiY29tcG9uZW50cyIsIl9sb29wIiwiY21wdCIsImNvbGxlY3Rpb24iLCJjdXJyZW50Tm9kZSIsImNoaWxkcmVuT2ZDdXJyZW50Tm9kZSIsIm1lcmdlIiwiZGVzY2VuZGFudHMiLCJpbnRlcnNlY3Rpb24iLCJub2RlIiwiYWRkIiwiX2xvb3AyIiwic2hpZnQiLCJuZWlnaGJvck5vZGVzIiwibmVpZ2hib3Job29kIiwiZWRnZXNXaXRoIiwibmVpZ2hib3JOb2RlIiwidW5pb24iLCJhbmNlc3RvcnMiLCJoYXMiLCJjaGlsZHJlbk9mTmVpZ2hib3IiLCJjb25uZWN0ZWRFZGdlcyIsImUiLCJzb3VyY2UiLCJ0YXJnZXQiLCJ0ZW1wIiwiZGlmZmVyZW5jZSIsInNldCIsInNpemUiLCJyZWxvY2F0ZUNvbXBvbmVudCIsIm9yaWdpbmFsQ2VudGVyIiwiY29tcG9uZW50UmVzdWx0Iiwib3B0aW9ucyIsImZpeGVkTm9kZUNvbnN0cmFpbnQiLCJtaW5YQ29vcmQiLCJOdW1iZXIiLCJQT1NJVElWRV9JTkZJTklUWSIsIm1heFhDb29yZCIsIk5FR0FUSVZFX0lORklOSVRZIiwibWluWUNvb3JkIiwibWF4WUNvb3JkIiwicXVhbGl0eSIsIl9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24iLCJfZGlkSXRlcmF0b3JFcnJvciIsIl9pdGVyYXRvckVycm9yIiwiX2l0ZXJhdG9yIiwibm9kZUluZGV4ZXMiLCJfc3RlcCIsIl9yZWYiLCJfcmVmMiIsImtleSIsImN5Tm9kZSIsImdldEVsZW1lbnRCeUlkIiwibm9kZUJCIiwiYm91bmRpbmdCb3giLCJsZWZ0WCIsInhDb29yZHMiLCJ3IiwicmlnaHRYIiwidG9wWSIsInlDb29yZHMiLCJoIiwiYm90dG9tWSIsInJldHVybiIsImRpZmZPblgiLCJ4IiwiZGlmZk9uWSIsInkiLCJtYXAiLCJpdGVtIiwiZ2V0UmVjdCIsIndpZHRoIiwiaGVpZ2h0IiwiX2RpZmZPblgiLCJfZGlmZk9uWSIsInNldENlbnRlciIsImdldENlbnRlclgiLCJnZXRDZW50ZXJZIiwiY2FsY0JvdW5kaW5nQm94IiwicGFyZW50Tm9kZSIsImxlZnQiLCJNQVhfU0FGRV9JTlRFR0VSIiwicmlnaHQiLCJNSU5fU0FGRV9JTlRFR0VSIiwidG9wIiwiYm90dG9tIiwibm9kZUxlZnQiLCJub2RlUmlnaHQiLCJub2RlVG9wIiwibm9kZUJvdHRvbSIsIm5vdCIsInMiLCJnZXQiLCJ0b3BMZWZ0WCIsInRvcExlZnRZIiwiY2FsY1BhcmVudHNXaXRob3V0Q2hpbGRyZW4iLCJwYXJlbnRzV2l0aG91dENoaWxkcmVuIiwiY2hlY2siLCJjaGlsZHJlbiIsImNoaWxkIiwiY3NzIiwiYXV4IiwiQ29TRUxheW91dCIsIkNvU0VOb2RlIiwiUG9pbnREIiwiRGltZW5zaW9uRCIsIkxheW91dENvbnN0YW50cyIsIkZETGF5b3V0Q29uc3RhbnRzIiwiQ29TRUNvbnN0YW50cyIsImNvc2VMYXlvdXQiLCJzcGVjdHJhbFJlc3VsdCIsImVkZ2VzIiwiaWRUb0xOb2RlIiwicmFuZG9taXplIiwiaXNGbiIsImZuIiwib3B0Rm4iLCJvcHQiLCJwcm9jZXNzQ2hpbGRyZW5MaXN0IiwibGF5b3V0IiwidGhlQ2hpbGQiLCJjaGlsZHJlbl9vZl9jaGlsZHJlbiIsInRoZU5vZGUiLCJkaW1lbnNpb25zIiwibGF5b3V0RGltZW5zaW9ucyIsIm5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVscyIsIm91dGVyV2lkdGgiLCJvdXRlckhlaWdodCIsImlzUGFyZW50IiwiZ3JhcGhNYW5hZ2VyIiwicGFyc2VGbG9hdCIsInBhcmVudEluZm8iLCJwb3NpdGlvbiIsImRhdGEiLCJub2RlUmVwdWxzaW9uIiwicGFkZGluZ0xlZnQiLCJwYXJzZUludCIsInBhZGRpbmdUb3AiLCJwYWRkaW5nUmlnaHQiLCJwYWRkaW5nQm90dG9tIiwibGFiZWxXaWR0aCIsImluY2x1ZGVMYWJlbHMiLCJpbmNsdWRlTm9kZXMiLCJpbmNsdWRlT3ZlcmxheXMiLCJsYWJlbEhlaWdodCIsImxhYmVsUG9zVmVydGljYWwiLCJsYWJlbFBvc0hvcml6b250YWwiLCJpc05hTiIsInJlY3QiLCJ0aGVOZXdHcmFwaCIsImdldEdyYXBoTWFuYWdlciIsIm5ld0dyYXBoIiwicHJvY2Vzc0VkZ2VzIiwiZ20iLCJpZGVhbExlbmd0aFRvdGFsIiwiZWRnZUNvdW50IiwiZWRnZSIsInNvdXJjZU5vZGUiLCJ0YXJnZXROb2RlIiwiZ2V0RWRnZXNCZXR3ZWVuIiwiZTEiLCJuZXdFZGdlIiwiaWRlYWxMZW5ndGgiLCJpZGVhbEVkZ2VMZW5ndGgiLCJlZGdlRWxhc3RpY2l0eSIsIkRFRkFVTFRfRURHRV9MRU5HVEgiLCJNSU5fUkVQVUxTSU9OX0RJU1QiLCJERUZBVUxUX1JBRElBTF9TRVBBUkFUSU9OIiwicHJvY2Vzc0NvbnN0cmFpbnRzIiwiY29uc3RyYWludHMiLCJhbGlnbm1lbnRDb25zdHJhaW50IiwicmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50IiwibmVzdGluZ0ZhY3RvciIsIlBFUl9MRVZFTF9JREVBTF9FREdFX0xFTkdUSF9GQUNUT1IiLCJncmF2aXR5IiwiREVGQVVMVF9HUkFWSVRZX1NUUkVOR1RIIiwibnVtSXRlciIsIk1BWF9JVEVSQVRJT05TIiwiZ3Jhdml0eVJhbmdlIiwiREVGQVVMVF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUiIsImdyYXZpdHlDb21wb3VuZCIsIkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9TVFJFTkdUSCIsImdyYXZpdHlSYW5nZUNvbXBvdW5kIiwiREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUiIsImluaXRpYWxFbmVyZ3lPbkluY3JlbWVudGFsIiwiREVGQVVMVF9DT09MSU5HX0ZBQ1RPUl9JTkNSRU1FTlRBTCIsInRpbGluZ0NvbXBhcmVCeSIsIlRJTElOR19DT01QQVJFX0JZIiwiUVVBTElUWSIsIk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUyIsIkRFRkFVTFRfSU5DUkVNRU5UQUwiLCJBTklNQVRFIiwiYW5pbWF0ZSIsIlRJTEUiLCJ0aWxlIiwiVElMSU5HX1BBRERJTkdfVkVSVElDQUwiLCJ0aWxpbmdQYWRkaW5nVmVydGljYWwiLCJjYWxsIiwiVElMSU5HX1BBRERJTkdfSE9SSVpPTlRBTCIsInRpbGluZ1BhZGRpbmdIb3Jpem9udGFsIiwiUFVSRV9JTkNSRU1FTlRBTCIsIkRFRkFVTFRfVU5JRk9STV9MRUFGX05PREVfU0laRVMiLCJ1bmlmb3JtTm9kZURpbWVuc2lvbnMiLCJzdGVwIiwiVFJBTlNGT1JNX09OX0NPTlNUUkFJTlRfSEFORExJTkciLCJFTkZPUkNFX0NPTlNUUkFJTlRTIiwiQVBQTFlfTEFZT1VUIiwiVFJFRV9SRURVQ1RJT05fT05fSU5DUkVNRU5UQUwiLCJuZXdHcmFwaE1hbmFnZXIiLCJhZGRSb290IiwicnVuTGF5b3V0IiwiX2NyZWF0ZUNsYXNzIiwiZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnR5IiwiQ29uc3RydWN0b3IiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJwcm90b3R5cGUiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIl9yZXF1aXJlIiwic3BlY3RyYWxMYXlvdXQiLCJfcmVxdWlyZTIiLCJkZWZhdWx0cyIsImZyZWV6ZSIsImFuaW1hdGlvbkR1cmF0aW9uIiwiYW5pbWF0aW9uRWFzaW5nIiwiZml0IiwicGFkZGluZyIsInBhY2tDb21wb25lbnRzIiwic2FtcGxpbmdUeXBlIiwic2FtcGxlU2l6ZSIsIm5vZGVTZXBhcmF0aW9uIiwicGlUb2wiLCJyZWFkeSIsInN0b3AiLCJMYXlvdXQiLCJydW4iLCJjb3NlUmVzdWx0IiwiY29tcG9uZW50Q2VudGVycyIsInZlcnRpY2FsIiwiaG9yaXpvbnRhbCIsImNvbnN0cmFpbnRFeGlzdCIsImxheVV0aWwiLCJwYWNraW5nRW5hYmxlZCIsImxheW91dFV0aWxpdGllcyIsIngxIiwieTEiLCJyZXN1bHQiLCJjb21wb25lbnQiLCJ0b0JlVGlsZWROb2RlcyIsIk1hcCIsIl94Q29vcmRzIiwiX3lDb29yZHMiLCJ0ZW1wU3BlY3RyYWxSZXN1bHQiLCJpbmRleGVzVG9CZURlbGV0ZWQiLCJpbmRleCIsIl9ib3VuZGluZ0JveCIsInNwbGljZSIsImNvbXBvbmVudHNFdmFsdWF0ZWQiLCJzdWJncmFwaHMiLCJoaWRkZW5FbGVzIiwic3ViZ3JhcGgiLCJub2RlSW5kZXgiLCJib3VuZGluZ2JveCIsImdldExlZnQiLCJnZXRUb3AiLCJnZXRXaWR0aCIsImdldEhlaWdodCIsInNvdXJjZU5vZGVJbmRleCIsInRhcmdldE5vZGVJbmRleCIsInNvdXJjZUNlbnRlciIsInRhcmdldENlbnRlciIsIl9wYXJlbnRJbmZvIiwic3RhcnRYIiwic3RhcnRZIiwiZW5kWCIsImVuZFkiLCJzaGlmdFJlc3VsdCIsInNoaWZ0cyIsIm5ld1hDb29yZHMiLCJkeCIsIm5ld1lDb29yZHMiLCJkeSIsIl9jb3VudCIsIm5vZGVSZWN0YW5nbGUiLCJnZXRQb3NpdGlvbnMiLCJwb3MiLCJ0aGVJZCIsIl9wb3MiLCJfaGlkZGVuRWxlcyIsImxheW91dFBvc2l0aW9ucyIsImNvbnNvbGUiLCJsb2ciLCJNYXRyaXgiLCJTVkQiLCJwYXJlbnROb2RlcyIsInBhcmVudENoaWxkTWFwIiwiYWxsTm9kZXNOZWlnaGJvcmhvb2QiLCJzYW1wbGVzQ29sdW1uIiwibWluRGlzdGFuY2VzQ29sdW1uIiwiQyIsIlBISSIsIklOViIsImZpcnN0U2FtcGxlIiwibm9kZVNpemUiLCJpbmZpbml0eSIsInNtYWxsIiwicmFuZG9tU2FtcGxlQ1IiLCJzYW1wbGUiLCJmbGFnIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwiQkZTIiwicGl2b3QiLCJzYW1wbGluZ01ldGhvZCIsInBhdGgiLCJmcm9udCIsImJhY2siLCJjdXJyZW50IiwiZGlzdGFuY2UiLCJtYXhfZGlzdCIsIm1heF9pbmQiLCJuZWlnaGJvcnMiLCJfaTIiLCJfaTMiLCJhbGxCRlMiLCJfaTQiLCJfaTUiLCJfaTYiLCJqIiwiX2k3IiwiX2k4IiwiX2oiLCJTVkRSZXN1bHQiLCJzdmQiLCJhX3EiLCJTIiwiYV91IiwiVSIsImFfdiIsIlYiLCJtYXhfcyIsImFfU2lnIiwibXVsdE1hdCIsInRyYW5zcG9zZSIsInBvd2VySXRlcmF0aW9uIiwidGhldGExIiwidGhldGEyIiwiWTEiLCJZMiIsIlYxIiwiVjIiLCJub3JtYWxpemUiLCJwcmV2aW91cyIsIl9pOSIsIm11bHRHYW1tYSIsIm11bHRMIiwiZG90UHJvZHVjdCIsImFicyIsIl9pMTAiLCJfaTExIiwibWludXNPcCIsIm11bHRDb25zIiwiX2kxMiIsInNxcnQiLCJfaTEzIiwibWluIiwiZWxlMiIsImVsZUluZGV4IiwiZGlzY29ubmVjdGVkSWQiLCJfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiIsIl9kaWRJdGVyYXRvckVycm9yMiIsIl9pdGVyYXRvckVycm9yMiIsIl9pdGVyYXRvcjIiLCJfc3RlcDIiLCJfaTE0IiwiX2kxNSIsImZpcnN0Tm9kZSIsImZpcnN0Tm9kZVBvcyIsImZpcnN0Tm9kZVdpZHRoIiwic2Vjb25kTm9kZSIsInNlY29uZE5vZGVXaWR0aCIsImltcGwiLCJyZWdpc3RlciIsImN5dG9zY2FwZSIsIl9fd2VicGFja19tb2R1bGVfY2FjaGVfXyIsIm1vZHVsZUlkIiwiY2FjaGVkTW9kdWxlIiwiX193ZWJwYWNrX2V4cG9ydHNfXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cytoscape-fcose/cytoscape-fcose.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/cytoscape-fcose/node_modules/cose-base/cose-base.js":
/*!**************************************************************************!*\
  !*** ./node_modules/cytoscape-fcose/node_modules/cose-base/cose-base.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n(function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory(__webpack_require__(/*! layout-base */ \"(ssr)/./node_modules/cytoscape-fcose/node_modules/layout-base/layout-base.js\"));\n    else {}\n})(void 0, function(__WEBPACK_EXTERNAL_MODULE__551__) {\n    return /******/ (()=>{\n        /******/ \"use strict\";\n        /******/ var __webpack_modules__ = {\n            /***/ 45: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_673__)=>{\n                var coseBase = {};\n                coseBase.layoutBase = __nested_webpack_require_673__(551);\n                coseBase.CoSEConstants = __nested_webpack_require_673__(806);\n                coseBase.CoSEEdge = __nested_webpack_require_673__(767);\n                coseBase.CoSEGraph = __nested_webpack_require_673__(880);\n                coseBase.CoSEGraphManager = __nested_webpack_require_673__(578);\n                coseBase.CoSELayout = __nested_webpack_require_673__(765);\n                coseBase.CoSENode = __nested_webpack_require_673__(991);\n                coseBase.ConstraintHandler = __nested_webpack_require_673__(902);\n                module1.exports = coseBase;\n            /***/ },\n            /***/ 806: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_1385__)=>{\n                var FDLayoutConstants = __nested_webpack_require_1385__(551).FDLayoutConstants;\n                function CoSEConstants() {}\n                //CoSEConstants inherits static props in FDLayoutConstants\n                for(var prop in FDLayoutConstants){\n                    CoSEConstants[prop] = FDLayoutConstants[prop];\n                }\n                CoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;\n                CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n                CoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;\n                CoSEConstants.TILE = true;\n                CoSEConstants.TILING_PADDING_VERTICAL = 10;\n                CoSEConstants.TILING_PADDING_HORIZONTAL = 10;\n                CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;\n                CoSEConstants.ENFORCE_CONSTRAINTS = true;\n                CoSEConstants.APPLY_LAYOUT = true;\n                CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS = true;\n                CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true; // this should be set to false if there will be a constraint\n                // This constant is for differentiating whether actual layout algorithm that uses cose-base wants to apply only incremental layout or \n                // an incremental layout on top of a randomized layout. If it is only incremental layout, then this constant should be true.\n                CoSEConstants.PURE_INCREMENTAL = CoSEConstants.DEFAULT_INCREMENTAL;\n                module1.exports = CoSEConstants;\n            /***/ },\n            /***/ 767: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_3035__)=>{\n                var FDLayoutEdge = __nested_webpack_require_3035__(551).FDLayoutEdge;\n                function CoSEEdge(source, target, vEdge) {\n                    FDLayoutEdge.call(this, source, target, vEdge);\n                }\n                CoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);\n                for(var prop in FDLayoutEdge){\n                    CoSEEdge[prop] = FDLayoutEdge[prop];\n                }\n                module1.exports = CoSEEdge;\n            /***/ },\n            /***/ 880: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_3606__)=>{\n                var LGraph = __nested_webpack_require_3606__(551).LGraph;\n                function CoSEGraph(parent, graphMgr, vGraph) {\n                    LGraph.call(this, parent, graphMgr, vGraph);\n                }\n                CoSEGraph.prototype = Object.create(LGraph.prototype);\n                for(var prop in LGraph){\n                    CoSEGraph[prop] = LGraph[prop];\n                }\n                module1.exports = CoSEGraph;\n            /***/ },\n            /***/ 578: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_4151__)=>{\n                var LGraphManager = __nested_webpack_require_4151__(551).LGraphManager;\n                function CoSEGraphManager(layout) {\n                    LGraphManager.call(this, layout);\n                }\n                CoSEGraphManager.prototype = Object.create(LGraphManager.prototype);\n                for(var prop in LGraphManager){\n                    CoSEGraphManager[prop] = LGraphManager[prop];\n                }\n                module1.exports = CoSEGraphManager;\n            /***/ },\n            /***/ 765: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_4730__)=>{\n                var FDLayout = __nested_webpack_require_4730__(551).FDLayout;\n                var CoSEGraphManager = __nested_webpack_require_4730__(578);\n                var CoSEGraph = __nested_webpack_require_4730__(880);\n                var CoSENode = __nested_webpack_require_4730__(991);\n                var CoSEEdge = __nested_webpack_require_4730__(767);\n                var CoSEConstants = __nested_webpack_require_4730__(806);\n                var ConstraintHandler = __nested_webpack_require_4730__(902);\n                var FDLayoutConstants = __nested_webpack_require_4730__(551).FDLayoutConstants;\n                var LayoutConstants = __nested_webpack_require_4730__(551).LayoutConstants;\n                var Point = __nested_webpack_require_4730__(551).Point;\n                var PointD = __nested_webpack_require_4730__(551).PointD;\n                var DimensionD = __nested_webpack_require_4730__(551).DimensionD;\n                var Layout = __nested_webpack_require_4730__(551).Layout;\n                var Integer = __nested_webpack_require_4730__(551).Integer;\n                var IGeometry = __nested_webpack_require_4730__(551).IGeometry;\n                var LGraph = __nested_webpack_require_4730__(551).LGraph;\n                var Transform = __nested_webpack_require_4730__(551).Transform;\n                var LinkedList = __nested_webpack_require_4730__(551).LinkedList;\n                function CoSELayout() {\n                    FDLayout.call(this);\n                    this.toBeTiled = {}; // Memorize if a node is to be tiled or is tiled\n                    this.constraints = {}; // keep layout constraints\n                }\n                CoSELayout.prototype = Object.create(FDLayout.prototype);\n                for(var prop in FDLayout){\n                    CoSELayout[prop] = FDLayout[prop];\n                }\n                CoSELayout.prototype.newGraphManager = function() {\n                    var gm = new CoSEGraphManager(this);\n                    this.graphManager = gm;\n                    return gm;\n                };\n                CoSELayout.prototype.newGraph = function(vGraph) {\n                    return new CoSEGraph(null, this.graphManager, vGraph);\n                };\n                CoSELayout.prototype.newNode = function(vNode) {\n                    return new CoSENode(this.graphManager, vNode);\n                };\n                CoSELayout.prototype.newEdge = function(vEdge) {\n                    return new CoSEEdge(null, null, vEdge);\n                };\n                CoSELayout.prototype.initParameters = function() {\n                    FDLayout.prototype.initParameters.call(this, arguments);\n                    if (!this.isSubLayout) {\n                        if (CoSEConstants.DEFAULT_EDGE_LENGTH < 10) {\n                            this.idealEdgeLength = 10;\n                        } else {\n                            this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;\n                        }\n                        this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n                        this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n                        this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n                        this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n                        this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n                        // variables for tree reduction support\n                        this.prunedNodesAll = [];\n                        this.growTreeIterations = 0;\n                        this.afterGrowthIterations = 0;\n                        this.isTreeGrowing = false;\n                        this.isGrowthFinished = false;\n                    }\n                };\n                // This method is used to set CoSE related parameters used by spring embedder.\n                CoSELayout.prototype.initSpringEmbedder = function() {\n                    FDLayout.prototype.initSpringEmbedder.call(this);\n                    // variables for cooling\n                    this.coolingCycle = 0;\n                    this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;\n                    this.finalTemperature = 0.04;\n                    this.coolingAdjuster = 1;\n                };\n                CoSELayout.prototype.layout = function() {\n                    var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n                    if (createBendsAsNeeded) {\n                        this.createBendpoints();\n                        this.graphManager.resetAllEdges();\n                    }\n                    this.level = 0;\n                    return this.classicLayout();\n                };\n                CoSELayout.prototype.classicLayout = function() {\n                    this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();\n                    this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);\n                    this.calcNoOfChildrenForAllNodes();\n                    this.graphManager.calcLowestCommonAncestors();\n                    this.graphManager.calcInclusionTreeDepths();\n                    this.graphManager.getRoot().calcEstimatedSize();\n                    this.calcIdealEdgeLengths();\n                    if (!this.incremental) {\n                        var forest = this.getFlatForest();\n                        // The graph associated with this layout is flat and a forest\n                        if (forest.length > 0) {\n                            this.positionNodesRadially(forest);\n                        } else {\n                            // Reduce the trees when incremental mode is not enabled and graph is not a forest \n                            this.reduceTrees();\n                            // Update nodes that gravity will be applied\n                            this.graphManager.resetAllNodesToApplyGravitation();\n                            var allNodes = new Set(this.getAllNodes());\n                            var intersection = this.nodesWithGravity.filter(function(x) {\n                                return allNodes.has(x);\n                            });\n                            this.graphManager.setAllNodesToApplyGravitation(intersection);\n                            this.positionNodesRandomly();\n                        }\n                    } else {\n                        if (CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL) {\n                            // Reduce the trees in incremental mode if only this constant is set to true \n                            this.reduceTrees();\n                            // Update nodes that gravity will be applied\n                            this.graphManager.resetAllNodesToApplyGravitation();\n                            var allNodes = new Set(this.getAllNodes());\n                            var intersection = this.nodesWithGravity.filter(function(x) {\n                                return allNodes.has(x);\n                            });\n                            this.graphManager.setAllNodesToApplyGravitation(intersection);\n                        }\n                    }\n                    if (Object.keys(this.constraints).length > 0) {\n                        ConstraintHandler.handleConstraints(this);\n                        this.initConstraintVariables();\n                    }\n                    this.initSpringEmbedder();\n                    if (CoSEConstants.APPLY_LAYOUT) {\n                        this.runSpringEmbedder();\n                    }\n                    return true;\n                };\n                CoSELayout.prototype.tick = function() {\n                    this.totalIterations++;\n                    if (this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) {\n                        if (this.prunedNodesAll.length > 0) {\n                            this.isTreeGrowing = true;\n                        } else {\n                            return true;\n                        }\n                    }\n                    if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {\n                        if (this.isConverged()) {\n                            if (this.prunedNodesAll.length > 0) {\n                                this.isTreeGrowing = true;\n                            } else {\n                                return true;\n                            }\n                        }\n                        this.coolingCycle++;\n                        if (this.layoutQuality == 0) {\n                            // quality - \"draft\"\n                            this.coolingAdjuster = this.coolingCycle;\n                        } else if (this.layoutQuality == 1) {\n                            // quality - \"default\"\n                            this.coolingAdjuster = this.coolingCycle / 3;\n                        }\n                        // cooling schedule is based on http://www.btluke.com/simanf1.html -> cooling schedule 3\n                        this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);\n                        this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));\n                    }\n                    // Operations while tree is growing again \n                    if (this.isTreeGrowing) {\n                        if (this.growTreeIterations % 10 == 0) {\n                            if (this.prunedNodesAll.length > 0) {\n                                this.graphManager.updateBounds();\n                                this.updateGrid();\n                                this.growTree(this.prunedNodesAll);\n                                // Update nodes that gravity will be applied\n                                this.graphManager.resetAllNodesToApplyGravitation();\n                                var allNodes = new Set(this.getAllNodes());\n                                var intersection = this.nodesWithGravity.filter(function(x) {\n                                    return allNodes.has(x);\n                                });\n                                this.graphManager.setAllNodesToApplyGravitation(intersection);\n                                this.graphManager.updateBounds();\n                                this.updateGrid();\n                                if (CoSEConstants.PURE_INCREMENTAL) this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2;\n                                else this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n                            } else {\n                                this.isTreeGrowing = false;\n                                this.isGrowthFinished = true;\n                            }\n                        }\n                        this.growTreeIterations++;\n                    }\n                    // Operations after growth is finished\n                    if (this.isGrowthFinished) {\n                        if (this.isConverged()) {\n                            return true;\n                        }\n                        if (this.afterGrowthIterations % 10 == 0) {\n                            this.graphManager.updateBounds();\n                            this.updateGrid();\n                        }\n                        if (CoSEConstants.PURE_INCREMENTAL) this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2 * ((100 - this.afterGrowthIterations) / 100);\n                        else this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);\n                        this.afterGrowthIterations++;\n                    }\n                    var gridUpdateAllowed = !this.isTreeGrowing && !this.isGrowthFinished;\n                    var forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;\n                    this.totalDisplacement = 0;\n                    this.graphManager.updateBounds();\n                    this.calcSpringForces();\n                    this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);\n                    this.calcGravitationalForces();\n                    this.moveNodes();\n                    this.animate();\n                    return false; // Layout is not ended yet return false\n                };\n                CoSELayout.prototype.getPositionsData = function() {\n                    var allNodes = this.graphManager.getAllNodes();\n                    var pData = {};\n                    for(var i = 0; i < allNodes.length; i++){\n                        var rect = allNodes[i].rect;\n                        var id = allNodes[i].id;\n                        pData[id] = {\n                            id: id,\n                            x: rect.getCenterX(),\n                            y: rect.getCenterY(),\n                            w: rect.width,\n                            h: rect.height\n                        };\n                    }\n                    return pData;\n                };\n                CoSELayout.prototype.runSpringEmbedder = function() {\n                    this.initialAnimationPeriod = 25;\n                    this.animationPeriod = this.initialAnimationPeriod;\n                    var layoutEnded = false;\n                    // If aminate option is 'during' signal that layout is supposed to start iterating\n                    if (FDLayoutConstants.ANIMATE === \"during\") {\n                        this.emit(\"layoutstarted\");\n                    } else {\n                        // If aminate option is 'during' tick() function will be called on index.js\n                        while(!layoutEnded){\n                            layoutEnded = this.tick();\n                        }\n                        this.graphManager.updateBounds();\n                    }\n                };\n                // overrides moveNodes method in FDLayout\n                CoSELayout.prototype.moveNodes = function() {\n                    var lNodes = this.getAllNodes();\n                    var node;\n                    // calculate displacement for each node \n                    for(var i = 0; i < lNodes.length; i++){\n                        node = lNodes[i];\n                        node.calculateDisplacement();\n                    }\n                    if (Object.keys(this.constraints).length > 0) {\n                        this.updateDisplacements();\n                    }\n                    // move each node\n                    for(var i = 0; i < lNodes.length; i++){\n                        node = lNodes[i];\n                        node.move();\n                    }\n                };\n                // constraint related methods: initConstraintVariables and updateDisplacements\n                // initialize constraint related variables\n                CoSELayout.prototype.initConstraintVariables = function() {\n                    var self = this;\n                    this.idToNodeMap = new Map();\n                    this.fixedNodeSet = new Set();\n                    var allNodes = this.graphManager.getAllNodes();\n                    // fill idToNodeMap\n                    for(var i = 0; i < allNodes.length; i++){\n                        var node = allNodes[i];\n                        this.idToNodeMap.set(node.id, node);\n                    }\n                    // calculate fixed node weight for given compound node\n                    var calculateCompoundWeight = function calculateCompoundWeight(compoundNode) {\n                        var nodes = compoundNode.getChild().getNodes();\n                        var node;\n                        var fixedNodeWeight = 0;\n                        for(var i = 0; i < nodes.length; i++){\n                            node = nodes[i];\n                            if (node.getChild() == null) {\n                                if (self.fixedNodeSet.has(node.id)) {\n                                    fixedNodeWeight += 100;\n                                }\n                            } else {\n                                fixedNodeWeight += calculateCompoundWeight(node);\n                            }\n                        }\n                        return fixedNodeWeight;\n                    };\n                    if (this.constraints.fixedNodeConstraint) {\n                        // fill fixedNodeSet\n                        this.constraints.fixedNodeConstraint.forEach(function(nodeData) {\n                            self.fixedNodeSet.add(nodeData.nodeId);\n                        });\n                        // assign fixed node weights to compounds if they contain fixed nodes\n                        var allNodes = this.graphManager.getAllNodes();\n                        var node;\n                        for(var i = 0; i < allNodes.length; i++){\n                            node = allNodes[i];\n                            if (node.getChild() != null) {\n                                var fixedNodeWeight = calculateCompoundWeight(node);\n                                if (fixedNodeWeight > 0) {\n                                    node.fixedNodeWeight = fixedNodeWeight;\n                                }\n                            }\n                        }\n                    }\n                    if (this.constraints.relativePlacementConstraint) {\n                        var nodeToDummyForVerticalAlignment = new Map();\n                        var nodeToDummyForHorizontalAlignment = new Map();\n                        this.dummyToNodeForVerticalAlignment = new Map();\n                        this.dummyToNodeForHorizontalAlignment = new Map();\n                        this.fixedNodesOnHorizontal = new Set();\n                        this.fixedNodesOnVertical = new Set();\n                        // fill maps and sets\n                        this.fixedNodeSet.forEach(function(nodeId) {\n                            self.fixedNodesOnHorizontal.add(nodeId);\n                            self.fixedNodesOnVertical.add(nodeId);\n                        });\n                        if (this.constraints.alignmentConstraint) {\n                            if (this.constraints.alignmentConstraint.vertical) {\n                                var verticalAlignment = this.constraints.alignmentConstraint.vertical;\n                                for(var i = 0; i < verticalAlignment.length; i++){\n                                    this.dummyToNodeForVerticalAlignment.set(\"dummy\" + i, []);\n                                    verticalAlignment[i].forEach(function(nodeId) {\n                                        nodeToDummyForVerticalAlignment.set(nodeId, \"dummy\" + i);\n                                        self.dummyToNodeForVerticalAlignment.get(\"dummy\" + i).push(nodeId);\n                                        if (self.fixedNodeSet.has(nodeId)) {\n                                            self.fixedNodesOnHorizontal.add(\"dummy\" + i);\n                                        }\n                                    });\n                                }\n                            }\n                            if (this.constraints.alignmentConstraint.horizontal) {\n                                var horizontalAlignment = this.constraints.alignmentConstraint.horizontal;\n                                for(var i = 0; i < horizontalAlignment.length; i++){\n                                    this.dummyToNodeForHorizontalAlignment.set(\"dummy\" + i, []);\n                                    horizontalAlignment[i].forEach(function(nodeId) {\n                                        nodeToDummyForHorizontalAlignment.set(nodeId, \"dummy\" + i);\n                                        self.dummyToNodeForHorizontalAlignment.get(\"dummy\" + i).push(nodeId);\n                                        if (self.fixedNodeSet.has(nodeId)) {\n                                            self.fixedNodesOnVertical.add(\"dummy\" + i);\n                                        }\n                                    });\n                                }\n                            }\n                        }\n                        if (CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS) {\n                            this.shuffle = function(array) {\n                                var j, x, i;\n                                for(i = array.length - 1; i >= 2 * array.length / 3; i--){\n                                    j = Math.floor(Math.random() * (i + 1));\n                                    x = array[i];\n                                    array[i] = array[j];\n                                    array[j] = x;\n                                }\n                                return array;\n                            };\n                            this.nodesInRelativeHorizontal = [];\n                            this.nodesInRelativeVertical = [];\n                            this.nodeToRelativeConstraintMapHorizontal = new Map();\n                            this.nodeToRelativeConstraintMapVertical = new Map();\n                            this.nodeToTempPositionMapHorizontal = new Map();\n                            this.nodeToTempPositionMapVertical = new Map();\n                            // fill arrays and maps\n                            this.constraints.relativePlacementConstraint.forEach(function(constraint) {\n                                if (constraint.left) {\n                                    var nodeIdLeft = nodeToDummyForVerticalAlignment.has(constraint.left) ? nodeToDummyForVerticalAlignment.get(constraint.left) : constraint.left;\n                                    var nodeIdRight = nodeToDummyForVerticalAlignment.has(constraint.right) ? nodeToDummyForVerticalAlignment.get(constraint.right) : constraint.right;\n                                    if (!self.nodesInRelativeHorizontal.includes(nodeIdLeft)) {\n                                        self.nodesInRelativeHorizontal.push(nodeIdLeft);\n                                        self.nodeToRelativeConstraintMapHorizontal.set(nodeIdLeft, []);\n                                        if (self.dummyToNodeForVerticalAlignment.has(nodeIdLeft)) {\n                                            self.nodeToTempPositionMapHorizontal.set(nodeIdLeft, self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeIdLeft)[0]).getCenterX());\n                                        } else {\n                                            self.nodeToTempPositionMapHorizontal.set(nodeIdLeft, self.idToNodeMap.get(nodeIdLeft).getCenterX());\n                                        }\n                                    }\n                                    if (!self.nodesInRelativeHorizontal.includes(nodeIdRight)) {\n                                        self.nodesInRelativeHorizontal.push(nodeIdRight);\n                                        self.nodeToRelativeConstraintMapHorizontal.set(nodeIdRight, []);\n                                        if (self.dummyToNodeForVerticalAlignment.has(nodeIdRight)) {\n                                            self.nodeToTempPositionMapHorizontal.set(nodeIdRight, self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeIdRight)[0]).getCenterX());\n                                        } else {\n                                            self.nodeToTempPositionMapHorizontal.set(nodeIdRight, self.idToNodeMap.get(nodeIdRight).getCenterX());\n                                        }\n                                    }\n                                    self.nodeToRelativeConstraintMapHorizontal.get(nodeIdLeft).push({\n                                        right: nodeIdRight,\n                                        gap: constraint.gap\n                                    });\n                                    self.nodeToRelativeConstraintMapHorizontal.get(nodeIdRight).push({\n                                        left: nodeIdLeft,\n                                        gap: constraint.gap\n                                    });\n                                } else {\n                                    var nodeIdTop = nodeToDummyForHorizontalAlignment.has(constraint.top) ? nodeToDummyForHorizontalAlignment.get(constraint.top) : constraint.top;\n                                    var nodeIdBottom = nodeToDummyForHorizontalAlignment.has(constraint.bottom) ? nodeToDummyForHorizontalAlignment.get(constraint.bottom) : constraint.bottom;\n                                    if (!self.nodesInRelativeVertical.includes(nodeIdTop)) {\n                                        self.nodesInRelativeVertical.push(nodeIdTop);\n                                        self.nodeToRelativeConstraintMapVertical.set(nodeIdTop, []);\n                                        if (self.dummyToNodeForHorizontalAlignment.has(nodeIdTop)) {\n                                            self.nodeToTempPositionMapVertical.set(nodeIdTop, self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeIdTop)[0]).getCenterY());\n                                        } else {\n                                            self.nodeToTempPositionMapVertical.set(nodeIdTop, self.idToNodeMap.get(nodeIdTop).getCenterY());\n                                        }\n                                    }\n                                    if (!self.nodesInRelativeVertical.includes(nodeIdBottom)) {\n                                        self.nodesInRelativeVertical.push(nodeIdBottom);\n                                        self.nodeToRelativeConstraintMapVertical.set(nodeIdBottom, []);\n                                        if (self.dummyToNodeForHorizontalAlignment.has(nodeIdBottom)) {\n                                            self.nodeToTempPositionMapVertical.set(nodeIdBottom, self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeIdBottom)[0]).getCenterY());\n                                        } else {\n                                            self.nodeToTempPositionMapVertical.set(nodeIdBottom, self.idToNodeMap.get(nodeIdBottom).getCenterY());\n                                        }\n                                    }\n                                    self.nodeToRelativeConstraintMapVertical.get(nodeIdTop).push({\n                                        bottom: nodeIdBottom,\n                                        gap: constraint.gap\n                                    });\n                                    self.nodeToRelativeConstraintMapVertical.get(nodeIdBottom).push({\n                                        top: nodeIdTop,\n                                        gap: constraint.gap\n                                    });\n                                }\n                            });\n                        } else {\n                            var subGraphOnHorizontal = new Map(); // subgraph from vertical RP constraints\n                            var subGraphOnVertical = new Map(); // subgraph from vertical RP constraints\n                            // construct subgraphs from relative placement constraints \n                            this.constraints.relativePlacementConstraint.forEach(function(constraint) {\n                                if (constraint.left) {\n                                    var left = nodeToDummyForVerticalAlignment.has(constraint.left) ? nodeToDummyForVerticalAlignment.get(constraint.left) : constraint.left;\n                                    var right = nodeToDummyForVerticalAlignment.has(constraint.right) ? nodeToDummyForVerticalAlignment.get(constraint.right) : constraint.right;\n                                    if (subGraphOnHorizontal.has(left)) {\n                                        subGraphOnHorizontal.get(left).push(right);\n                                    } else {\n                                        subGraphOnHorizontal.set(left, [\n                                            right\n                                        ]);\n                                    }\n                                    if (subGraphOnHorizontal.has(right)) {\n                                        subGraphOnHorizontal.get(right).push(left);\n                                    } else {\n                                        subGraphOnHorizontal.set(right, [\n                                            left\n                                        ]);\n                                    }\n                                } else {\n                                    var top = nodeToDummyForHorizontalAlignment.has(constraint.top) ? nodeToDummyForHorizontalAlignment.get(constraint.top) : constraint.top;\n                                    var bottom = nodeToDummyForHorizontalAlignment.has(constraint.bottom) ? nodeToDummyForHorizontalAlignment.get(constraint.bottom) : constraint.bottom;\n                                    if (subGraphOnVertical.has(top)) {\n                                        subGraphOnVertical.get(top).push(bottom);\n                                    } else {\n                                        subGraphOnVertical.set(top, [\n                                            bottom\n                                        ]);\n                                    }\n                                    if (subGraphOnVertical.has(bottom)) {\n                                        subGraphOnVertical.get(bottom).push(top);\n                                    } else {\n                                        subGraphOnVertical.set(bottom, [\n                                            top\n                                        ]);\n                                    }\n                                }\n                            });\n                            // function to construct components from a given graph \n                            // also returns an array that keeps whether each component contains fixed node\n                            var constructComponents = function constructComponents(graph, fixedNodes) {\n                                var components = [];\n                                var isFixed = [];\n                                var queue = new LinkedList();\n                                var visited = new Set();\n                                var count = 0;\n                                graph.forEach(function(value, key) {\n                                    if (!visited.has(key)) {\n                                        components[count] = [];\n                                        isFixed[count] = false;\n                                        var currentNode = key;\n                                        queue.push(currentNode);\n                                        visited.add(currentNode);\n                                        components[count].push(currentNode);\n                                        while(queue.length != 0){\n                                            currentNode = queue.shift();\n                                            if (fixedNodes.has(currentNode)) {\n                                                isFixed[count] = true;\n                                            }\n                                            var neighbors = graph.get(currentNode);\n                                            neighbors.forEach(function(neighbor) {\n                                                if (!visited.has(neighbor)) {\n                                                    queue.push(neighbor);\n                                                    visited.add(neighbor);\n                                                    components[count].push(neighbor);\n                                                }\n                                            });\n                                        }\n                                        count++;\n                                    }\n                                });\n                                return {\n                                    components: components,\n                                    isFixed: isFixed\n                                };\n                            };\n                            var resultOnHorizontal = constructComponents(subGraphOnHorizontal, self.fixedNodesOnHorizontal);\n                            this.componentsOnHorizontal = resultOnHorizontal.components;\n                            this.fixedComponentsOnHorizontal = resultOnHorizontal.isFixed;\n                            var resultOnVertical = constructComponents(subGraphOnVertical, self.fixedNodesOnVertical);\n                            this.componentsOnVertical = resultOnVertical.components;\n                            this.fixedComponentsOnVertical = resultOnVertical.isFixed;\n                        }\n                    }\n                };\n                // updates node displacements based on constraints\n                CoSELayout.prototype.updateDisplacements = function() {\n                    var self = this;\n                    if (this.constraints.fixedNodeConstraint) {\n                        this.constraints.fixedNodeConstraint.forEach(function(nodeData) {\n                            var fixedNode = self.idToNodeMap.get(nodeData.nodeId);\n                            fixedNode.displacementX = 0;\n                            fixedNode.displacementY = 0;\n                        });\n                    }\n                    if (this.constraints.alignmentConstraint) {\n                        if (this.constraints.alignmentConstraint.vertical) {\n                            var allVerticalAlignments = this.constraints.alignmentConstraint.vertical;\n                            for(var i = 0; i < allVerticalAlignments.length; i++){\n                                var totalDisplacementX = 0;\n                                for(var j = 0; j < allVerticalAlignments[i].length; j++){\n                                    if (this.fixedNodeSet.has(allVerticalAlignments[i][j])) {\n                                        totalDisplacementX = 0;\n                                        break;\n                                    }\n                                    totalDisplacementX += this.idToNodeMap.get(allVerticalAlignments[i][j]).displacementX;\n                                }\n                                var averageDisplacementX = totalDisplacementX / allVerticalAlignments[i].length;\n                                for(var j = 0; j < allVerticalAlignments[i].length; j++){\n                                    this.idToNodeMap.get(allVerticalAlignments[i][j]).displacementX = averageDisplacementX;\n                                }\n                            }\n                        }\n                        if (this.constraints.alignmentConstraint.horizontal) {\n                            var allHorizontalAlignments = this.constraints.alignmentConstraint.horizontal;\n                            for(var i = 0; i < allHorizontalAlignments.length; i++){\n                                var totalDisplacementY = 0;\n                                for(var j = 0; j < allHorizontalAlignments[i].length; j++){\n                                    if (this.fixedNodeSet.has(allHorizontalAlignments[i][j])) {\n                                        totalDisplacementY = 0;\n                                        break;\n                                    }\n                                    totalDisplacementY += this.idToNodeMap.get(allHorizontalAlignments[i][j]).displacementY;\n                                }\n                                var averageDisplacementY = totalDisplacementY / allHorizontalAlignments[i].length;\n                                for(var j = 0; j < allHorizontalAlignments[i].length; j++){\n                                    this.idToNodeMap.get(allHorizontalAlignments[i][j]).displacementY = averageDisplacementY;\n                                }\n                            }\n                        }\n                    }\n                    if (this.constraints.relativePlacementConstraint) {\n                        if (CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS) {\n                            // shuffle array to randomize node processing order\n                            if (this.totalIterations % 10 == 0) {\n                                this.shuffle(this.nodesInRelativeHorizontal);\n                                this.shuffle(this.nodesInRelativeVertical);\n                            }\n                            this.nodesInRelativeHorizontal.forEach(function(nodeId) {\n                                if (!self.fixedNodesOnHorizontal.has(nodeId)) {\n                                    var displacement = 0;\n                                    if (self.dummyToNodeForVerticalAlignment.has(nodeId)) {\n                                        displacement = self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeId)[0]).displacementX;\n                                    } else {\n                                        displacement = self.idToNodeMap.get(nodeId).displacementX;\n                                    }\n                                    self.nodeToRelativeConstraintMapHorizontal.get(nodeId).forEach(function(constraint) {\n                                        if (constraint.right) {\n                                            var diff = self.nodeToTempPositionMapHorizontal.get(constraint.right) - self.nodeToTempPositionMapHorizontal.get(nodeId) - displacement;\n                                            if (diff < constraint.gap) {\n                                                displacement -= constraint.gap - diff;\n                                            }\n                                        } else {\n                                            var diff = self.nodeToTempPositionMapHorizontal.get(nodeId) - self.nodeToTempPositionMapHorizontal.get(constraint.left) + displacement;\n                                            if (diff < constraint.gap) {\n                                                displacement += constraint.gap - diff;\n                                            }\n                                        }\n                                    });\n                                    self.nodeToTempPositionMapHorizontal.set(nodeId, self.nodeToTempPositionMapHorizontal.get(nodeId) + displacement);\n                                    if (self.dummyToNodeForVerticalAlignment.has(nodeId)) {\n                                        self.dummyToNodeForVerticalAlignment.get(nodeId).forEach(function(nodeId) {\n                                            self.idToNodeMap.get(nodeId).displacementX = displacement;\n                                        });\n                                    } else {\n                                        self.idToNodeMap.get(nodeId).displacementX = displacement;\n                                    }\n                                }\n                            });\n                            this.nodesInRelativeVertical.forEach(function(nodeId) {\n                                if (!self.fixedNodesOnHorizontal.has(nodeId)) {\n                                    var displacement = 0;\n                                    if (self.dummyToNodeForHorizontalAlignment.has(nodeId)) {\n                                        displacement = self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeId)[0]).displacementY;\n                                    } else {\n                                        displacement = self.idToNodeMap.get(nodeId).displacementY;\n                                    }\n                                    self.nodeToRelativeConstraintMapVertical.get(nodeId).forEach(function(constraint) {\n                                        if (constraint.bottom) {\n                                            var diff = self.nodeToTempPositionMapVertical.get(constraint.bottom) - self.nodeToTempPositionMapVertical.get(nodeId) - displacement;\n                                            if (diff < constraint.gap) {\n                                                displacement -= constraint.gap - diff;\n                                            }\n                                        } else {\n                                            var diff = self.nodeToTempPositionMapVertical.get(nodeId) - self.nodeToTempPositionMapVertical.get(constraint.top) + displacement;\n                                            if (diff < constraint.gap) {\n                                                displacement += constraint.gap - diff;\n                                            }\n                                        }\n                                    });\n                                    self.nodeToTempPositionMapVertical.set(nodeId, self.nodeToTempPositionMapVertical.get(nodeId) + displacement);\n                                    if (self.dummyToNodeForHorizontalAlignment.has(nodeId)) {\n                                        self.dummyToNodeForHorizontalAlignment.get(nodeId).forEach(function(nodeId) {\n                                            self.idToNodeMap.get(nodeId).displacementY = displacement;\n                                        });\n                                    } else {\n                                        self.idToNodeMap.get(nodeId).displacementY = displacement;\n                                    }\n                                }\n                            });\n                        } else {\n                            for(var i = 0; i < this.componentsOnHorizontal.length; i++){\n                                var component = this.componentsOnHorizontal[i];\n                                if (this.fixedComponentsOnHorizontal[i]) {\n                                    for(var j = 0; j < component.length; j++){\n                                        if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n                                            this.dummyToNodeForVerticalAlignment.get(component[j]).forEach(function(nodeId) {\n                                                self.idToNodeMap.get(nodeId).displacementX = 0;\n                                            });\n                                        } else {\n                                            this.idToNodeMap.get(component[j]).displacementX = 0;\n                                        }\n                                    }\n                                } else {\n                                    var sum = 0;\n                                    var count = 0;\n                                    for(var j = 0; j < component.length; j++){\n                                        if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n                                            var actualNodes = this.dummyToNodeForVerticalAlignment.get(component[j]);\n                                            sum += actualNodes.length * this.idToNodeMap.get(actualNodes[0]).displacementX;\n                                            count += actualNodes.length;\n                                        } else {\n                                            sum += this.idToNodeMap.get(component[j]).displacementX;\n                                            count++;\n                                        }\n                                    }\n                                    var averageDisplacement = sum / count;\n                                    for(var j = 0; j < component.length; j++){\n                                        if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n                                            this.dummyToNodeForVerticalAlignment.get(component[j]).forEach(function(nodeId) {\n                                                self.idToNodeMap.get(nodeId).displacementX = averageDisplacement;\n                                            });\n                                        } else {\n                                            this.idToNodeMap.get(component[j]).displacementX = averageDisplacement;\n                                        }\n                                    }\n                                }\n                            }\n                            for(var i = 0; i < this.componentsOnVertical.length; i++){\n                                var component = this.componentsOnVertical[i];\n                                if (this.fixedComponentsOnVertical[i]) {\n                                    for(var j = 0; j < component.length; j++){\n                                        if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n                                            this.dummyToNodeForHorizontalAlignment.get(component[j]).forEach(function(nodeId) {\n                                                self.idToNodeMap.get(nodeId).displacementY = 0;\n                                            });\n                                        } else {\n                                            this.idToNodeMap.get(component[j]).displacementY = 0;\n                                        }\n                                    }\n                                } else {\n                                    var sum = 0;\n                                    var count = 0;\n                                    for(var j = 0; j < component.length; j++){\n                                        if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n                                            var actualNodes = this.dummyToNodeForHorizontalAlignment.get(component[j]);\n                                            sum += actualNodes.length * this.idToNodeMap.get(actualNodes[0]).displacementY;\n                                            count += actualNodes.length;\n                                        } else {\n                                            sum += this.idToNodeMap.get(component[j]).displacementY;\n                                            count++;\n                                        }\n                                    }\n                                    var averageDisplacement = sum / count;\n                                    for(var j = 0; j < component.length; j++){\n                                        if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n                                            this.dummyToNodeForHorizontalAlignment.get(component[j]).forEach(function(nodeId) {\n                                                self.idToNodeMap.get(nodeId).displacementY = averageDisplacement;\n                                            });\n                                        } else {\n                                            this.idToNodeMap.get(component[j]).displacementY = averageDisplacement;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                };\n                CoSELayout.prototype.calculateNodesToApplyGravitationTo = function() {\n                    var nodeList = [];\n                    var graph;\n                    var graphs = this.graphManager.getGraphs();\n                    var size = graphs.length;\n                    var i;\n                    for(i = 0; i < size; i++){\n                        graph = graphs[i];\n                        graph.updateConnected();\n                        if (!graph.isConnected) {\n                            nodeList = nodeList.concat(graph.getNodes());\n                        }\n                    }\n                    return nodeList;\n                };\n                CoSELayout.prototype.createBendpoints = function() {\n                    var edges = [];\n                    edges = edges.concat(this.graphManager.getAllEdges());\n                    var visited = new Set();\n                    var i;\n                    for(i = 0; i < edges.length; i++){\n                        var edge = edges[i];\n                        if (!visited.has(edge)) {\n                            var source = edge.getSource();\n                            var target = edge.getTarget();\n                            if (source == target) {\n                                edge.getBendpoints().push(new PointD());\n                                edge.getBendpoints().push(new PointD());\n                                this.createDummyNodesForBendpoints(edge);\n                                visited.add(edge);\n                            } else {\n                                var edgeList = [];\n                                edgeList = edgeList.concat(source.getEdgeListToNode(target));\n                                edgeList = edgeList.concat(target.getEdgeListToNode(source));\n                                if (!visited.has(edgeList[0])) {\n                                    if (edgeList.length > 1) {\n                                        var k;\n                                        for(k = 0; k < edgeList.length; k++){\n                                            var multiEdge = edgeList[k];\n                                            multiEdge.getBendpoints().push(new PointD());\n                                            this.createDummyNodesForBendpoints(multiEdge);\n                                        }\n                                    }\n                                    edgeList.forEach(function(edge) {\n                                        visited.add(edge);\n                                    });\n                                }\n                            }\n                        }\n                        if (visited.size == edges.length) {\n                            break;\n                        }\n                    }\n                };\n                CoSELayout.prototype.positionNodesRadially = function(forest) {\n                    // We tile the trees to a grid row by row; first tree starts at (0,0)\n                    var currentStartingPoint = new Point(0, 0);\n                    var numberOfColumns = Math.ceil(Math.sqrt(forest.length));\n                    var height = 0;\n                    var currentY = 0;\n                    var currentX = 0;\n                    var point = new PointD(0, 0);\n                    for(var i = 0; i < forest.length; i++){\n                        if (i % numberOfColumns == 0) {\n                            // Start of a new row, make the x coordinate 0, increment the\n                            // y coordinate with the max height of the previous row\n                            currentX = 0;\n                            currentY = height;\n                            if (i != 0) {\n                                currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;\n                            }\n                            height = 0;\n                        }\n                        var tree = forest[i];\n                        // Find the center of the tree\n                        var centerNode = Layout.findCenterOfTree(tree);\n                        // Set the staring point of the next tree\n                        currentStartingPoint.x = currentX;\n                        currentStartingPoint.y = currentY;\n                        // Do a radial layout starting with the center\n                        point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);\n                        if (point.y > height) {\n                            height = Math.floor(point.y);\n                        }\n                        currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);\n                    }\n                    this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));\n                };\n                CoSELayout.radialLayout = function(tree, centerNode, startingPoint) {\n                    var radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);\n                    CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);\n                    var bounds = LGraph.calculateBounds(tree);\n                    var transform = new Transform();\n                    transform.setDeviceOrgX(bounds.getMinX());\n                    transform.setDeviceOrgY(bounds.getMinY());\n                    transform.setWorldOrgX(startingPoint.x);\n                    transform.setWorldOrgY(startingPoint.y);\n                    for(var i = 0; i < tree.length; i++){\n                        var node = tree[i];\n                        node.transform(transform);\n                    }\n                    var bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());\n                    return transform.inverseTransformPoint(bottomRight);\n                };\n                CoSELayout.branchRadialLayout = function(node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {\n                    // First, position this node by finding its angle.\n                    var halfInterval = (endAngle - startAngle + 1) / 2;\n                    if (halfInterval < 0) {\n                        halfInterval += 180;\n                    }\n                    var nodeAngle = (halfInterval + startAngle) % 360;\n                    var teta = nodeAngle * IGeometry.TWO_PI / 360;\n                    // Make polar to java cordinate conversion.\n                    var cos_teta = Math.cos(teta);\n                    var x_ = distance * Math.cos(teta);\n                    var y_ = distance * Math.sin(teta);\n                    node.setCenter(x_, y_);\n                    // Traverse all neighbors of this node and recursively call this\n                    // function.\n                    var neighborEdges = [];\n                    neighborEdges = neighborEdges.concat(node.getEdges());\n                    var childCount = neighborEdges.length;\n                    if (parentOfNode != null) {\n                        childCount--;\n                    }\n                    var branchCount = 0;\n                    var incEdgesCount = neighborEdges.length;\n                    var startIndex;\n                    var edges = node.getEdgesBetween(parentOfNode);\n                    // If there are multiple edges, prune them until there remains only one\n                    // edge.\n                    while(edges.length > 1){\n                        //neighborEdges.remove(edges.remove(0));\n                        var temp = edges[0];\n                        edges.splice(0, 1);\n                        var index = neighborEdges.indexOf(temp);\n                        if (index >= 0) {\n                            neighborEdges.splice(index, 1);\n                        }\n                        incEdgesCount--;\n                        childCount--;\n                    }\n                    if (parentOfNode != null) {\n                        //assert edges.length == 1;\n                        startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;\n                    } else {\n                        startIndex = 0;\n                    }\n                    var stepAngle = Math.abs(endAngle - startAngle) / childCount;\n                    for(var i = startIndex; branchCount != childCount; i = ++i % incEdgesCount){\n                        var currentNeighbor = neighborEdges[i].getOtherEnd(node);\n                        // Don't back traverse to root node in current tree.\n                        if (currentNeighbor == parentOfNode) {\n                            continue;\n                        }\n                        var childStartAngle = (startAngle + branchCount * stepAngle) % 360;\n                        var childEndAngle = (childStartAngle + stepAngle) % 360;\n                        CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);\n                        branchCount++;\n                    }\n                };\n                CoSELayout.maxDiagonalInTree = function(tree) {\n                    var maxDiagonal = Integer.MIN_VALUE;\n                    for(var i = 0; i < tree.length; i++){\n                        var node = tree[i];\n                        var diagonal = node.getDiagonal();\n                        if (diagonal > maxDiagonal) {\n                            maxDiagonal = diagonal;\n                        }\n                    }\n                    return maxDiagonal;\n                };\n                CoSELayout.prototype.calcRepulsionRange = function() {\n                    // formula is 2 x (level + 1) x idealEdgeLength\n                    return 2 * (this.level + 1) * this.idealEdgeLength;\n                };\n                // Tiling methods\n                // Group zero degree members whose parents are not to be tiled, create dummy parents where needed and fill memberGroups by their dummp parent id's\n                CoSELayout.prototype.groupZeroDegreeMembers = function() {\n                    var self = this;\n                    // array of [parent_id x oneDegreeNode_id]\n                    var tempMemberGroups = {}; // A temporary map of parent node and its zero degree members\n                    this.memberGroups = {}; // A map of dummy parent node and its zero degree members whose parents are not to be tiled\n                    this.idToDummyNode = {}; // A map of id to dummy node \n                    var zeroDegree = []; // List of zero degree nodes whose parents are not to be tiled\n                    var allNodes = this.graphManager.getAllNodes();\n                    // Fill zero degree list\n                    for(var i = 0; i < allNodes.length; i++){\n                        var node = allNodes[i];\n                        var parent = node.getParent();\n                        // If a node has zero degree and its parent is not to be tiled if exists add that node to zeroDegres list\n                        if (this.getNodeDegreeWithChildren(node) === 0 && (parent.id == undefined || !this.getToBeTiled(parent))) {\n                            zeroDegree.push(node);\n                        }\n                    }\n                    // Create a map of parent node and its zero degree members\n                    for(var i = 0; i < zeroDegree.length; i++){\n                        var node = zeroDegree[i]; // Zero degree node itself\n                        var p_id = node.getParent().id; // Parent id\n                        if (typeof tempMemberGroups[p_id] === \"undefined\") tempMemberGroups[p_id] = [];\n                        tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node); // Push node to the list belongs to its parent in tempMemberGroups\n                    }\n                    // If there are at least two nodes at a level, create a dummy compound for them\n                    Object.keys(tempMemberGroups).forEach(function(p_id) {\n                        if (tempMemberGroups[p_id].length > 1) {\n                            var dummyCompoundId = \"DummyCompound_\" + p_id; // The id of dummy compound which will be created soon\n                            self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id]; // Add dummy compound to memberGroups\n                            var parent = tempMemberGroups[p_id][0].getParent(); // The parent of zero degree nodes will be the parent of new dummy compound\n                            // Create a dummy compound with calculated id\n                            var dummyCompound = new CoSENode(self.graphManager);\n                            dummyCompound.id = dummyCompoundId;\n                            dummyCompound.paddingLeft = parent.paddingLeft || 0;\n                            dummyCompound.paddingRight = parent.paddingRight || 0;\n                            dummyCompound.paddingBottom = parent.paddingBottom || 0;\n                            dummyCompound.paddingTop = parent.paddingTop || 0;\n                            self.idToDummyNode[dummyCompoundId] = dummyCompound;\n                            var dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);\n                            var parentGraph = parent.getChild();\n                            // Add dummy compound to parent the graph\n                            parentGraph.add(dummyCompound);\n                            // For each zero degree node in this level remove it from its parent graph and add it to the graph of dummy parent\n                            for(var i = 0; i < tempMemberGroups[p_id].length; i++){\n                                var node = tempMemberGroups[p_id][i];\n                                parentGraph.remove(node);\n                                dummyParentGraph.add(node);\n                            }\n                        }\n                    });\n                };\n                CoSELayout.prototype.clearCompounds = function() {\n                    var childGraphMap = {};\n                    var idToNode = {};\n                    // Get compound ordering by finding the inner one first\n                    this.performDFSOnCompounds();\n                    for(var i = 0; i < this.compoundOrder.length; i++){\n                        idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];\n                        childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes());\n                        // Remove children of compounds\n                        this.graphManager.remove(this.compoundOrder[i].getChild());\n                        this.compoundOrder[i].child = null;\n                    }\n                    this.graphManager.resetAllNodes();\n                    // Tile the removed children\n                    this.tileCompoundMembers(childGraphMap, idToNode);\n                };\n                CoSELayout.prototype.clearZeroDegreeMembers = function() {\n                    var self = this;\n                    var tiledZeroDegreePack = this.tiledZeroDegreePack = [];\n                    Object.keys(this.memberGroups).forEach(function(id) {\n                        var compoundNode = self.idToDummyNode[id]; // Get the dummy compound\n                        tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n                        // Set the width and height of the dummy compound as calculated\n                        compoundNode.rect.width = tiledZeroDegreePack[id].width;\n                        compoundNode.rect.height = tiledZeroDegreePack[id].height;\n                        compoundNode.setCenter(tiledZeroDegreePack[id].centerX, tiledZeroDegreePack[id].centerY);\n                        // compound left and top margings for labels\n                        // when node labels are included, these values may be set to different values below and are used in tilingPostLayout,\n                        // otherwise they stay as zero\n                        compoundNode.labelMarginLeft = 0;\n                        compoundNode.labelMarginTop = 0;\n                        // Update compound bounds considering its label properties and set label margins for left and top\n                        if (CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n                            var width = compoundNode.rect.width;\n                            var height = compoundNode.rect.height;\n                            if (compoundNode.labelWidth) {\n                                if (compoundNode.labelPosHorizontal == \"left\") {\n                                    compoundNode.rect.x -= compoundNode.labelWidth;\n                                    compoundNode.setWidth(width + compoundNode.labelWidth);\n                                    compoundNode.labelMarginLeft = compoundNode.labelWidth;\n                                } else if (compoundNode.labelPosHorizontal == \"center\" && compoundNode.labelWidth > width) {\n                                    compoundNode.rect.x -= (compoundNode.labelWidth - width) / 2;\n                                    compoundNode.setWidth(compoundNode.labelWidth);\n                                    compoundNode.labelMarginLeft = (compoundNode.labelWidth - width) / 2;\n                                } else if (compoundNode.labelPosHorizontal == \"right\") {\n                                    compoundNode.setWidth(width + compoundNode.labelWidth);\n                                }\n                            }\n                            if (compoundNode.labelHeight) {\n                                if (compoundNode.labelPosVertical == \"top\") {\n                                    compoundNode.rect.y -= compoundNode.labelHeight;\n                                    compoundNode.setHeight(height + compoundNode.labelHeight);\n                                    compoundNode.labelMarginTop = compoundNode.labelHeight;\n                                } else if (compoundNode.labelPosVertical == \"center\" && compoundNode.labelHeight > height) {\n                                    compoundNode.rect.y -= (compoundNode.labelHeight - height) / 2;\n                                    compoundNode.setHeight(compoundNode.labelHeight);\n                                    compoundNode.labelMarginTop = (compoundNode.labelHeight - height) / 2;\n                                } else if (compoundNode.labelPosVertical == \"bottom\") {\n                                    compoundNode.setHeight(height + compoundNode.labelHeight);\n                                }\n                            }\n                        }\n                    });\n                };\n                CoSELayout.prototype.repopulateCompounds = function() {\n                    for(var i = this.compoundOrder.length - 1; i >= 0; i--){\n                        var lCompoundNode = this.compoundOrder[i];\n                        var id = lCompoundNode.id;\n                        var horizontalMargin = lCompoundNode.paddingLeft;\n                        var verticalMargin = lCompoundNode.paddingTop;\n                        var labelMarginLeft = lCompoundNode.labelMarginLeft;\n                        var labelMarginTop = lCompoundNode.labelMarginTop;\n                        this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin, labelMarginLeft, labelMarginTop);\n                    }\n                };\n                CoSELayout.prototype.repopulateZeroDegreeMembers = function() {\n                    var self = this;\n                    var tiledPack = this.tiledZeroDegreePack;\n                    Object.keys(tiledPack).forEach(function(id) {\n                        var compoundNode = self.idToDummyNode[id]; // Get the dummy compound by its id\n                        var horizontalMargin = compoundNode.paddingLeft;\n                        var verticalMargin = compoundNode.paddingTop;\n                        var labelMarginLeft = compoundNode.labelMarginLeft;\n                        var labelMarginTop = compoundNode.labelMarginTop;\n                        // Adjust the positions of nodes wrt its compound\n                        self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin, labelMarginLeft, labelMarginTop);\n                    });\n                };\n                CoSELayout.prototype.getToBeTiled = function(node) {\n                    var id = node.id;\n                    //firstly check the previous results\n                    if (this.toBeTiled[id] != null) {\n                        return this.toBeTiled[id];\n                    }\n                    //only compound nodes are to be tiled\n                    var childGraph = node.getChild();\n                    if (childGraph == null) {\n                        this.toBeTiled[id] = false;\n                        return false;\n                    }\n                    var children = childGraph.getNodes(); // Get the children nodes\n                    //a compound node is not to be tiled if all of its compound children are not to be tiled\n                    for(var i = 0; i < children.length; i++){\n                        var theChild = children[i];\n                        if (this.getNodeDegree(theChild) > 0) {\n                            this.toBeTiled[id] = false;\n                            return false;\n                        }\n                        //pass the children not having the compound structure\n                        if (theChild.getChild() == null) {\n                            this.toBeTiled[theChild.id] = false;\n                            continue;\n                        }\n                        if (!this.getToBeTiled(theChild)) {\n                            this.toBeTiled[id] = false;\n                            return false;\n                        }\n                    }\n                    this.toBeTiled[id] = true;\n                    return true;\n                };\n                // Get degree of a node depending of its edges and independent of its children\n                CoSELayout.prototype.getNodeDegree = function(node) {\n                    var id = node.id;\n                    var edges = node.getEdges();\n                    var degree = 0;\n                    // For the edges connected\n                    for(var i = 0; i < edges.length; i++){\n                        var edge = edges[i];\n                        if (edge.getSource().id !== edge.getTarget().id) {\n                            degree = degree + 1;\n                        }\n                    }\n                    return degree;\n                };\n                // Get degree of a node with its children\n                CoSELayout.prototype.getNodeDegreeWithChildren = function(node) {\n                    var degree = this.getNodeDegree(node);\n                    if (node.getChild() == null) {\n                        return degree;\n                    }\n                    var children = node.getChild().getNodes();\n                    for(var i = 0; i < children.length; i++){\n                        var child = children[i];\n                        degree += this.getNodeDegreeWithChildren(child);\n                    }\n                    return degree;\n                };\n                CoSELayout.prototype.performDFSOnCompounds = function() {\n                    this.compoundOrder = [];\n                    this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());\n                };\n                CoSELayout.prototype.fillCompexOrderByDFS = function(children) {\n                    for(var i = 0; i < children.length; i++){\n                        var child = children[i];\n                        if (child.getChild() != null) {\n                            this.fillCompexOrderByDFS(child.getChild().getNodes());\n                        }\n                        if (this.getToBeTiled(child)) {\n                            this.compoundOrder.push(child);\n                        }\n                    }\n                };\n                /**\n* This method places each zero degree member wrt given (x,y) coordinates (top left).\n*/ CoSELayout.prototype.adjustLocations = function(organization, x, y, compoundHorizontalMargin, compoundVerticalMargin, compoundLabelMarginLeft, compoundLabelMarginTop) {\n                    x += compoundHorizontalMargin + compoundLabelMarginLeft;\n                    y += compoundVerticalMargin + compoundLabelMarginTop;\n                    var left = x;\n                    for(var i = 0; i < organization.rows.length; i++){\n                        var row = organization.rows[i];\n                        x = left;\n                        var maxHeight = 0;\n                        for(var j = 0; j < row.length; j++){\n                            var lnode = row[j];\n                            lnode.rect.x = x; // + lnode.rect.width / 2;\n                            lnode.rect.y = y; // + lnode.rect.height / 2;\n                            x += lnode.rect.width + organization.horizontalPadding;\n                            if (lnode.rect.height > maxHeight) maxHeight = lnode.rect.height;\n                        }\n                        y += maxHeight + organization.verticalPadding;\n                    }\n                };\n                CoSELayout.prototype.tileCompoundMembers = function(childGraphMap, idToNode) {\n                    var self = this;\n                    this.tiledMemberPack = [];\n                    Object.keys(childGraphMap).forEach(function(id) {\n                        // Get the compound node\n                        var compoundNode = idToNode[id];\n                        self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n                        compoundNode.rect.width = self.tiledMemberPack[id].width;\n                        compoundNode.rect.height = self.tiledMemberPack[id].height;\n                        compoundNode.setCenter(self.tiledMemberPack[id].centerX, self.tiledMemberPack[id].centerY);\n                        // compound left and top margings for labels\n                        // when node labels are included, these values may be set to different values below and are used in tilingPostLayout,\n                        // otherwise they stay as zero\n                        compoundNode.labelMarginLeft = 0;\n                        compoundNode.labelMarginTop = 0;\n                        // Update compound bounds considering its label properties and set label margins for left and top\n                        if (CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n                            var width = compoundNode.rect.width;\n                            var height = compoundNode.rect.height;\n                            if (compoundNode.labelWidth) {\n                                if (compoundNode.labelPosHorizontal == \"left\") {\n                                    compoundNode.rect.x -= compoundNode.labelWidth;\n                                    compoundNode.setWidth(width + compoundNode.labelWidth);\n                                    compoundNode.labelMarginLeft = compoundNode.labelWidth;\n                                } else if (compoundNode.labelPosHorizontal == \"center\" && compoundNode.labelWidth > width) {\n                                    compoundNode.rect.x -= (compoundNode.labelWidth - width) / 2;\n                                    compoundNode.setWidth(compoundNode.labelWidth);\n                                    compoundNode.labelMarginLeft = (compoundNode.labelWidth - width) / 2;\n                                } else if (compoundNode.labelPosHorizontal == \"right\") {\n                                    compoundNode.setWidth(width + compoundNode.labelWidth);\n                                }\n                            }\n                            if (compoundNode.labelHeight) {\n                                if (compoundNode.labelPosVertical == \"top\") {\n                                    compoundNode.rect.y -= compoundNode.labelHeight;\n                                    compoundNode.setHeight(height + compoundNode.labelHeight);\n                                    compoundNode.labelMarginTop = compoundNode.labelHeight;\n                                } else if (compoundNode.labelPosVertical == \"center\" && compoundNode.labelHeight > height) {\n                                    compoundNode.rect.y -= (compoundNode.labelHeight - height) / 2;\n                                    compoundNode.setHeight(compoundNode.labelHeight);\n                                    compoundNode.labelMarginTop = (compoundNode.labelHeight - height) / 2;\n                                } else if (compoundNode.labelPosVertical == \"bottom\") {\n                                    compoundNode.setHeight(height + compoundNode.labelHeight);\n                                }\n                            }\n                        }\n                    });\n                };\n                CoSELayout.prototype.tileNodes = function(nodes, minWidth) {\n                    var horizontalOrg = this.tileNodesByFavoringDim(nodes, minWidth, true);\n                    var verticalOrg = this.tileNodesByFavoringDim(nodes, minWidth, false);\n                    var horizontalRatio = this.getOrgRatio(horizontalOrg);\n                    var verticalRatio = this.getOrgRatio(verticalOrg);\n                    var bestOrg;\n                    // the best ratio is the one that is closer to 1 since the ratios are already normalized\n                    // and the best organization is the one that has the best ratio\n                    if (verticalRatio < horizontalRatio) {\n                        bestOrg = verticalOrg;\n                    } else {\n                        bestOrg = horizontalOrg;\n                    }\n                    return bestOrg;\n                };\n                // get the width/height ratio of the organization that is normalized so that it will not be less than 1\n                CoSELayout.prototype.getOrgRatio = function(organization) {\n                    // get dimensions and calculate the initial ratio\n                    var width = organization.width;\n                    var height = organization.height;\n                    var ratio = width / height;\n                    // if the initial ratio is less then 1 then inverse it\n                    if (ratio < 1) {\n                        ratio = 1 / ratio;\n                    }\n                    // return the normalized ratio\n                    return ratio;\n                };\n                /*\n * Calculates the ideal width for the rows. This method assumes that\n * each node has the same sizes and calculates the ideal row width that\n * approximates a square shaped complex accordingly. However, since nodes would\n * have different sizes some rows would have different sizes and the resulting\n * shape would not be an exact square.\n */ CoSELayout.prototype.calcIdealRowWidth = function(members, favorHorizontalDim) {\n                    // To approximate a square shaped complex we need to make complex width equal to complex height.\n                    // To achieve this we need to solve the following equation system for hc:\n                    // (x + bx) * hc - bx = (y + by) * vc - by, hc * vc = n\n                    // where x is the avarage width of the nodes, y is the avarage height of nodes\n                    // bx and by are the buffer sizes in horizontal and vertical dimensions accordingly,\n                    // hc and vc are the number of rows in horizontal and vertical dimensions\n                    // n is number of members.\n                    var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n                    var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n                    // number of members\n                    var membersSize = members.length;\n                    // sum of the width of all members\n                    var totalWidth = 0;\n                    // sum of the height of all members\n                    var totalHeight = 0;\n                    var maxWidth = 0;\n                    // traverse all members to calculate total width and total height and get the maximum members width\n                    members.forEach(function(node) {\n                        totalWidth += node.getWidth();\n                        totalHeight += node.getHeight();\n                        if (node.getWidth() > maxWidth) {\n                            maxWidth = node.getWidth();\n                        }\n                    });\n                    // average width of the members\n                    var averageWidth = totalWidth / membersSize;\n                    // average height of the members\n                    var averageHeight = totalHeight / membersSize;\n                    // solving the initial equation system for the hc yields the following second degree equation:\n                    // hc^2 * (x+bx) + hc * (by - bx) - n * (y + by) = 0\n                    // the delta value to solve the equation above for hc\n                    var delta = Math.pow(verticalPadding - horizontalPadding, 2) + 4 * (averageWidth + horizontalPadding) * (averageHeight + verticalPadding) * membersSize;\n                    // solve the equation using delta value to calculate the horizontal count\n                    // that represents the number of nodes in an ideal row\n                    var horizontalCountDouble = (horizontalPadding - verticalPadding + Math.sqrt(delta)) / (2 * (averageWidth + horizontalPadding));\n                    // round the calculated horizontal count up or down according to the favored dimension\n                    var horizontalCount;\n                    if (favorHorizontalDim) {\n                        horizontalCount = Math.ceil(horizontalCountDouble);\n                        // if horizontalCount count is not a float value then both of rounding to floor and ceil\n                        // will yield the same values. Instead of repeating the same calculation try going up\n                        // while favoring horizontal dimension in such cases\n                        if (horizontalCount == horizontalCountDouble) {\n                            horizontalCount++;\n                        }\n                    } else {\n                        horizontalCount = Math.floor(horizontalCountDouble);\n                    }\n                    // ideal width to be calculated\n                    var idealWidth = horizontalCount * (averageWidth + horizontalPadding) - horizontalPadding;\n                    // if max width is bigger than calculated ideal width reset ideal width to it\n                    if (maxWidth > idealWidth) {\n                        idealWidth = maxWidth;\n                    }\n                    // add the left-right margins to the ideal row width\n                    idealWidth += horizontalPadding * 2;\n                    // return the ideal row width1\n                    return idealWidth;\n                };\n                CoSELayout.prototype.tileNodesByFavoringDim = function(nodes, minWidth, favorHorizontalDim) {\n                    var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n                    var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n                    var tilingCompareBy = CoSEConstants.TILING_COMPARE_BY;\n                    var organization = {\n                        rows: [],\n                        rowWidth: [],\n                        rowHeight: [],\n                        width: 0,\n                        height: minWidth,\n                        verticalPadding: verticalPadding,\n                        horizontalPadding: horizontalPadding,\n                        centerX: 0,\n                        centerY: 0\n                    };\n                    if (tilingCompareBy) {\n                        organization.idealRowWidth = this.calcIdealRowWidth(nodes, favorHorizontalDim);\n                    }\n                    var getNodeArea = function getNodeArea(n) {\n                        return n.rect.width * n.rect.height;\n                    };\n                    var areaCompareFcn = function areaCompareFcn(n1, n2) {\n                        return getNodeArea(n2) - getNodeArea(n1);\n                    };\n                    // Sort the nodes in descending order of their areas\n                    nodes.sort(function(n1, n2) {\n                        var cmpBy = areaCompareFcn;\n                        if (organization.idealRowWidth) {\n                            cmpBy = tilingCompareBy;\n                            return cmpBy(n1.id, n2.id);\n                        }\n                        return cmpBy(n1, n2);\n                    });\n                    // Create the organization -> calculate compound center\n                    var sumCenterX = 0;\n                    var sumCenterY = 0;\n                    for(var i = 0; i < nodes.length; i++){\n                        var lNode = nodes[i];\n                        sumCenterX += lNode.getCenterX();\n                        sumCenterY += lNode.getCenterY();\n                    }\n                    organization.centerX = sumCenterX / nodes.length;\n                    organization.centerY = sumCenterY / nodes.length;\n                    // Create the organization -> tile members\n                    for(var i = 0; i < nodes.length; i++){\n                        var lNode = nodes[i];\n                        if (organization.rows.length == 0) {\n                            this.insertNodeToRow(organization, lNode, 0, minWidth);\n                        } else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {\n                            var rowIndex = organization.rows.length - 1;\n                            if (!organization.idealRowWidth) {\n                                rowIndex = this.getShortestRowIndex(organization);\n                            }\n                            this.insertNodeToRow(organization, lNode, rowIndex, minWidth);\n                        } else {\n                            this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);\n                        }\n                        this.shiftToLastRow(organization);\n                    }\n                    return organization;\n                };\n                CoSELayout.prototype.insertNodeToRow = function(organization, node, rowIndex, minWidth) {\n                    var minCompoundSize = minWidth;\n                    // Add new row if needed\n                    if (rowIndex == organization.rows.length) {\n                        var secondDimension = [];\n                        organization.rows.push(secondDimension);\n                        organization.rowWidth.push(minCompoundSize);\n                        organization.rowHeight.push(0);\n                    }\n                    // Update row width\n                    var w = organization.rowWidth[rowIndex] + node.rect.width;\n                    if (organization.rows[rowIndex].length > 0) {\n                        w += organization.horizontalPadding;\n                    }\n                    organization.rowWidth[rowIndex] = w;\n                    // Update compound width\n                    if (organization.width < w) {\n                        organization.width = w;\n                    }\n                    // Update height\n                    var h = node.rect.height;\n                    if (rowIndex > 0) h += organization.verticalPadding;\n                    var extraHeight = 0;\n                    if (h > organization.rowHeight[rowIndex]) {\n                        extraHeight = organization.rowHeight[rowIndex];\n                        organization.rowHeight[rowIndex] = h;\n                        extraHeight = organization.rowHeight[rowIndex] - extraHeight;\n                    }\n                    organization.height += extraHeight;\n                    // Insert node\n                    organization.rows[rowIndex].push(node);\n                };\n                //Scans the rows of an organization and returns the one with the min width\n                CoSELayout.prototype.getShortestRowIndex = function(organization) {\n                    var r = -1;\n                    var min = Number.MAX_VALUE;\n                    for(var i = 0; i < organization.rows.length; i++){\n                        if (organization.rowWidth[i] < min) {\n                            r = i;\n                            min = organization.rowWidth[i];\n                        }\n                    }\n                    return r;\n                };\n                //Scans the rows of an organization and returns the one with the max width\n                CoSELayout.prototype.getLongestRowIndex = function(organization) {\n                    var r = -1;\n                    var max = Number.MIN_VALUE;\n                    for(var i = 0; i < organization.rows.length; i++){\n                        if (organization.rowWidth[i] > max) {\n                            r = i;\n                            max = organization.rowWidth[i];\n                        }\n                    }\n                    return r;\n                };\n                /**\n* This method checks whether adding extra width to the organization violates\n* the aspect ratio(1) or not.\n*/ CoSELayout.prototype.canAddHorizontal = function(organization, extraWidth, extraHeight) {\n                    // if there is an ideal row width specified use it instead of checking the aspect ratio\n                    if (organization.idealRowWidth) {\n                        var lastRowIndex = organization.rows.length - 1;\n                        var lastRowWidth = organization.rowWidth[lastRowIndex];\n                        // check and return if ideal row width will be exceed if the node is added to the row\n                        return lastRowWidth + extraWidth + organization.horizontalPadding <= organization.idealRowWidth;\n                    }\n                    var sri = this.getShortestRowIndex(organization);\n                    if (sri < 0) {\n                        return true;\n                    }\n                    var min = organization.rowWidth[sri];\n                    if (min + organization.horizontalPadding + extraWidth <= organization.width) return true;\n                    var hDiff = 0;\n                    // Adding to an existing row\n                    if (organization.rowHeight[sri] < extraHeight) {\n                        if (sri > 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];\n                    }\n                    var add_to_row_ratio;\n                    if (organization.width - min >= extraWidth + organization.horizontalPadding) {\n                        add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);\n                    } else {\n                        add_to_row_ratio = (organization.height + hDiff) / organization.width;\n                    }\n                    // Adding a new row for this node\n                    hDiff = extraHeight + organization.verticalPadding;\n                    var add_new_row_ratio;\n                    if (organization.width < extraWidth) {\n                        add_new_row_ratio = (organization.height + hDiff) / extraWidth;\n                    } else {\n                        add_new_row_ratio = (organization.height + hDiff) / organization.width;\n                    }\n                    if (add_new_row_ratio < 1) add_new_row_ratio = 1 / add_new_row_ratio;\n                    if (add_to_row_ratio < 1) add_to_row_ratio = 1 / add_to_row_ratio;\n                    return add_to_row_ratio < add_new_row_ratio;\n                };\n                //If moving the last node from the longest row and adding it to the last\n                //row makes the bounding box smaller, do it.\n                CoSELayout.prototype.shiftToLastRow = function(organization) {\n                    var longest = this.getLongestRowIndex(organization);\n                    var last = organization.rowWidth.length - 1;\n                    var row = organization.rows[longest];\n                    var node = row[row.length - 1];\n                    var diff = node.width + organization.horizontalPadding;\n                    // Check if there is enough space on the last row\n                    if (organization.width - organization.rowWidth[last] > diff && longest != last) {\n                        // Remove the last element of the longest row\n                        row.splice(-1, 1);\n                        // Push it to the last row\n                        organization.rows[last].push(node);\n                        organization.rowWidth[longest] = organization.rowWidth[longest] - diff;\n                        organization.rowWidth[last] = organization.rowWidth[last] + diff;\n                        organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)];\n                        // Update heights of the organization\n                        var maxHeight = Number.MIN_VALUE;\n                        for(var i = 0; i < row.length; i++){\n                            if (row[i].height > maxHeight) maxHeight = row[i].height;\n                        }\n                        if (longest > 0) maxHeight += organization.verticalPadding;\n                        var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n                        organization.rowHeight[longest] = maxHeight;\n                        if (organization.rowHeight[last] < node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;\n                        var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n                        organization.height += finalTotal - prevTotal;\n                        this.shiftToLastRow(organization);\n                    }\n                };\n                CoSELayout.prototype.tilingPreLayout = function() {\n                    if (CoSEConstants.TILE) {\n                        // Find zero degree nodes and create a compound for each level\n                        this.groupZeroDegreeMembers();\n                        // Tile and clear children of each compound\n                        this.clearCompounds();\n                        // Separately tile and clear zero degree nodes for each level\n                        this.clearZeroDegreeMembers();\n                    }\n                };\n                CoSELayout.prototype.tilingPostLayout = function() {\n                    if (CoSEConstants.TILE) {\n                        this.repopulateZeroDegreeMembers();\n                        this.repopulateCompounds();\n                    }\n                };\n                // -----------------------------------------------------------------------------\n                // Section: Tree Reduction methods\n                // -----------------------------------------------------------------------------\n                // Reduce trees \n                CoSELayout.prototype.reduceTrees = function() {\n                    var prunedNodesAll = [];\n                    var containsLeaf = true;\n                    var node;\n                    while(containsLeaf){\n                        var allNodes = this.graphManager.getAllNodes();\n                        var prunedNodesInStepTemp = [];\n                        containsLeaf = false;\n                        for(var i = 0; i < allNodes.length; i++){\n                            node = allNodes[i];\n                            if (node.getEdges().length == 1 && !node.getEdges()[0].isInterGraph && node.getChild() == null) {\n                                if (CoSEConstants.PURE_INCREMENTAL) {\n                                    var otherEnd = node.getEdges()[0].getOtherEnd(node);\n                                    var relativePosition = new DimensionD(node.getCenterX() - otherEnd.getCenterX(), node.getCenterY() - otherEnd.getCenterY());\n                                    prunedNodesInStepTemp.push([\n                                        node,\n                                        node.getEdges()[0],\n                                        node.getOwner(),\n                                        relativePosition\n                                    ]);\n                                } else {\n                                    prunedNodesInStepTemp.push([\n                                        node,\n                                        node.getEdges()[0],\n                                        node.getOwner()\n                                    ]);\n                                }\n                                containsLeaf = true;\n                            }\n                        }\n                        if (containsLeaf == true) {\n                            var prunedNodesInStep = [];\n                            for(var j = 0; j < prunedNodesInStepTemp.length; j++){\n                                if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {\n                                    prunedNodesInStep.push(prunedNodesInStepTemp[j]);\n                                    prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);\n                                }\n                            }\n                            prunedNodesAll.push(prunedNodesInStep);\n                            this.graphManager.resetAllNodes();\n                            this.graphManager.resetAllEdges();\n                        }\n                    }\n                    this.prunedNodesAll = prunedNodesAll;\n                };\n                // Grow tree one step \n                CoSELayout.prototype.growTree = function(prunedNodesAll) {\n                    var lengthOfPrunedNodesInStep = prunedNodesAll.length;\n                    var prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];\n                    var nodeData;\n                    for(var i = 0; i < prunedNodesInStep.length; i++){\n                        nodeData = prunedNodesInStep[i];\n                        this.findPlaceforPrunedNode(nodeData);\n                        nodeData[2].add(nodeData[0]);\n                        nodeData[2].add(nodeData[1], nodeData[1].source, nodeData[1].target);\n                    }\n                    prunedNodesAll.splice(prunedNodesAll.length - 1, 1);\n                    this.graphManager.resetAllNodes();\n                    this.graphManager.resetAllEdges();\n                };\n                // Find an appropriate position to replace pruned node, this method can be improved\n                CoSELayout.prototype.findPlaceforPrunedNode = function(nodeData) {\n                    var gridForPrunedNode;\n                    var nodeToConnect;\n                    var prunedNode = nodeData[0];\n                    if (prunedNode == nodeData[1].source) {\n                        nodeToConnect = nodeData[1].target;\n                    } else {\n                        nodeToConnect = nodeData[1].source;\n                    }\n                    if (CoSEConstants.PURE_INCREMENTAL) {\n                        prunedNode.setCenter(nodeToConnect.getCenterX() + nodeData[3].getWidth(), nodeToConnect.getCenterY() + nodeData[3].getHeight());\n                    } else {\n                        var startGridX = nodeToConnect.startX;\n                        var finishGridX = nodeToConnect.finishX;\n                        var startGridY = nodeToConnect.startY;\n                        var finishGridY = nodeToConnect.finishY;\n                        var upNodeCount = 0;\n                        var downNodeCount = 0;\n                        var rightNodeCount = 0;\n                        var leftNodeCount = 0;\n                        var controlRegions = [\n                            upNodeCount,\n                            rightNodeCount,\n                            downNodeCount,\n                            leftNodeCount\n                        ];\n                        if (startGridY > 0) {\n                            for(var i = startGridX; i <= finishGridX; i++){\n                                controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;\n                            }\n                        }\n                        if (finishGridX < this.grid.length - 1) {\n                            for(var i = startGridY; i <= finishGridY; i++){\n                                controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;\n                            }\n                        }\n                        if (finishGridY < this.grid[0].length - 1) {\n                            for(var i = startGridX; i <= finishGridX; i++){\n                                controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;\n                            }\n                        }\n                        if (startGridX > 0) {\n                            for(var i = startGridY; i <= finishGridY; i++){\n                                controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;\n                            }\n                        }\n                        var min = Integer.MAX_VALUE;\n                        var minCount;\n                        var minIndex;\n                        for(var j = 0; j < controlRegions.length; j++){\n                            if (controlRegions[j] < min) {\n                                min = controlRegions[j];\n                                minCount = 1;\n                                minIndex = j;\n                            } else if (controlRegions[j] == min) {\n                                minCount++;\n                            }\n                        }\n                        if (minCount == 3 && min == 0) {\n                            if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[2] == 0) {\n                                gridForPrunedNode = 1;\n                            } else if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[3] == 0) {\n                                gridForPrunedNode = 0;\n                            } else if (controlRegions[0] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n                                gridForPrunedNode = 3;\n                            } else if (controlRegions[1] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n                                gridForPrunedNode = 2;\n                            }\n                        } else if (minCount == 2 && min == 0) {\n                            var random = Math.floor(Math.random() * 2);\n                            if (controlRegions[0] == 0 && controlRegions[1] == 0) {\n                                ;\n                                if (random == 0) {\n                                    gridForPrunedNode = 0;\n                                } else {\n                                    gridForPrunedNode = 1;\n                                }\n                            } else if (controlRegions[0] == 0 && controlRegions[2] == 0) {\n                                if (random == 0) {\n                                    gridForPrunedNode = 0;\n                                } else {\n                                    gridForPrunedNode = 2;\n                                }\n                            } else if (controlRegions[0] == 0 && controlRegions[3] == 0) {\n                                if (random == 0) {\n                                    gridForPrunedNode = 0;\n                                } else {\n                                    gridForPrunedNode = 3;\n                                }\n                            } else if (controlRegions[1] == 0 && controlRegions[2] == 0) {\n                                if (random == 0) {\n                                    gridForPrunedNode = 1;\n                                } else {\n                                    gridForPrunedNode = 2;\n                                }\n                            } else if (controlRegions[1] == 0 && controlRegions[3] == 0) {\n                                if (random == 0) {\n                                    gridForPrunedNode = 1;\n                                } else {\n                                    gridForPrunedNode = 3;\n                                }\n                            } else {\n                                if (random == 0) {\n                                    gridForPrunedNode = 2;\n                                } else {\n                                    gridForPrunedNode = 3;\n                                }\n                            }\n                        } else if (minCount == 4 && min == 0) {\n                            var random = Math.floor(Math.random() * 4);\n                            gridForPrunedNode = random;\n                        } else {\n                            gridForPrunedNode = minIndex;\n                        }\n                        if (gridForPrunedNode == 0) {\n                            prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);\n                        } else if (gridForPrunedNode == 1) {\n                            prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n                        } else if (gridForPrunedNode == 2) {\n                            prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);\n                        } else {\n                            prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n                        }\n                    }\n                };\n                module1.exports = CoSELayout;\n            /***/ },\n            /***/ 991: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_109987__)=>{\n                var FDLayoutNode = __nested_webpack_require_109987__(551).FDLayoutNode;\n                var IMath = __nested_webpack_require_109987__(551).IMath;\n                function CoSENode(gm, loc, size, vNode) {\n                    FDLayoutNode.call(this, gm, loc, size, vNode);\n                }\n                CoSENode.prototype = Object.create(FDLayoutNode.prototype);\n                for(var prop in FDLayoutNode){\n                    CoSENode[prop] = FDLayoutNode[prop];\n                }\n                CoSENode.prototype.calculateDisplacement = function() {\n                    var layout = this.graphManager.getLayout();\n                    // this check is for compound nodes that contain fixed nodes\n                    if (this.getChild() != null && this.fixedNodeWeight) {\n                        this.displacementX += layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.fixedNodeWeight;\n                        this.displacementY += layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.fixedNodeWeight;\n                    } else {\n                        this.displacementX += layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;\n                        this.displacementY += layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;\n                    }\n                    if (Math.abs(this.displacementX) > layout.coolingFactor * layout.maxNodeDisplacement) {\n                        this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);\n                    }\n                    if (Math.abs(this.displacementY) > layout.coolingFactor * layout.maxNodeDisplacement) {\n                        this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);\n                    }\n                    // non-empty compound node, propogate movement to children as well\n                    if (this.child && this.child.getNodes().length > 0) {\n                        this.propogateDisplacementToChildren(this.displacementX, this.displacementY);\n                    }\n                };\n                CoSENode.prototype.propogateDisplacementToChildren = function(dX, dY) {\n                    var nodes = this.getChild().getNodes();\n                    var node;\n                    for(var i = 0; i < nodes.length; i++){\n                        node = nodes[i];\n                        if (node.getChild() == null) {\n                            node.displacementX += dX;\n                            node.displacementY += dY;\n                        } else {\n                            node.propogateDisplacementToChildren(dX, dY);\n                        }\n                    }\n                };\n                CoSENode.prototype.move = function() {\n                    var layout = this.graphManager.getLayout();\n                    // a simple node or an empty compound node, move it\n                    if (this.child == null || this.child.getNodes().length == 0) {\n                        this.moveBy(this.displacementX, this.displacementY);\n                        layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);\n                    }\n                    this.springForceX = 0;\n                    this.springForceY = 0;\n                    this.repulsionForceX = 0;\n                    this.repulsionForceY = 0;\n                    this.gravitationForceX = 0;\n                    this.gravitationForceY = 0;\n                    this.displacementX = 0;\n                    this.displacementY = 0;\n                };\n                CoSENode.prototype.setPred1 = function(pred11) {\n                    this.pred1 = pred11;\n                };\n                CoSENode.prototype.getPred1 = function() {\n                    return pred1;\n                };\n                CoSENode.prototype.getPred2 = function() {\n                    return pred2;\n                };\n                CoSENode.prototype.setNext = function(next1) {\n                    this.next = next1;\n                };\n                CoSENode.prototype.getNext = function() {\n                    return next;\n                };\n                CoSENode.prototype.setProcessed = function(processed1) {\n                    this.processed = processed1;\n                };\n                CoSENode.prototype.isProcessed = function() {\n                    return processed;\n                };\n                module1.exports = CoSENode;\n            /***/ },\n            /***/ 902: /***/ (module1, __unused_webpack_exports, __nested_webpack_require_114741__)=>{\n                function _toConsumableArray(arr) {\n                    if (Array.isArray(arr)) {\n                        for(var i = 0, arr2 = Array(arr.length); i < arr.length; i++){\n                            arr2[i] = arr[i];\n                        }\n                        return arr2;\n                    } else {\n                        return Array.from(arr);\n                    }\n                }\n                var CoSEConstants = __nested_webpack_require_114741__(806);\n                var LinkedList = __nested_webpack_require_114741__(551).LinkedList;\n                var Matrix = __nested_webpack_require_114741__(551).Matrix;\n                var SVD = __nested_webpack_require_114741__(551).SVD;\n                function ConstraintHandler() {}\n                ConstraintHandler.handleConstraints = function(layout) {\n                    //  let layout = this.graphManager.getLayout();\n                    // get constraints from layout\n                    var constraints = {};\n                    constraints.fixedNodeConstraint = layout.constraints.fixedNodeConstraint;\n                    constraints.alignmentConstraint = layout.constraints.alignmentConstraint;\n                    constraints.relativePlacementConstraint = layout.constraints.relativePlacementConstraint;\n                    var idToNodeMap = new Map();\n                    var nodeIndexes = new Map();\n                    var xCoords = [];\n                    var yCoords = [];\n                    var allNodes = layout.getAllNodes();\n                    var index = 0;\n                    // fill index map and coordinates\n                    for(var i = 0; i < allNodes.length; i++){\n                        var node = allNodes[i];\n                        if (node.getChild() == null) {\n                            nodeIndexes.set(node.id, index++);\n                            xCoords.push(node.getCenterX());\n                            yCoords.push(node.getCenterY());\n                            idToNodeMap.set(node.id, node);\n                        }\n                    }\n                    // if there exists relative placement constraint without gap value, set it to default \n                    if (constraints.relativePlacementConstraint) {\n                        constraints.relativePlacementConstraint.forEach(function(constraint) {\n                            if (!constraint.gap && constraint.gap != 0) {\n                                if (constraint.left) {\n                                    constraint.gap = CoSEConstants.DEFAULT_EDGE_LENGTH + idToNodeMap.get(constraint.left).getWidth() / 2 + idToNodeMap.get(constraint.right).getWidth() / 2;\n                                } else {\n                                    constraint.gap = CoSEConstants.DEFAULT_EDGE_LENGTH + idToNodeMap.get(constraint.top).getHeight() / 2 + idToNodeMap.get(constraint.bottom).getHeight() / 2;\n                                }\n                            }\n                        });\n                    }\n                    /* auxiliary functions */ // calculate difference between two position objects\n                    var calculatePositionDiff = function calculatePositionDiff(pos1, pos2) {\n                        return {\n                            x: pos1.x - pos2.x,\n                            y: pos1.y - pos2.y\n                        };\n                    };\n                    // calculate average position of the nodes\n                    var calculateAvgPosition = function calculateAvgPosition(nodeIdSet) {\n                        var xPosSum = 0;\n                        var yPosSum = 0;\n                        nodeIdSet.forEach(function(nodeId) {\n                            xPosSum += xCoords[nodeIndexes.get(nodeId)];\n                            yPosSum += yCoords[nodeIndexes.get(nodeId)];\n                        });\n                        return {\n                            x: xPosSum / nodeIdSet.size,\n                            y: yPosSum / nodeIdSet.size\n                        };\n                    };\n                    // find an appropriate positioning for the nodes in a given graph according to relative placement constraints\n                    // this function also takes the fixed nodes and alignment constraints into account\n                    // graph: dag to be evaluated, direction: \"horizontal\" or \"vertical\", \n                    // fixedNodes: set of fixed nodes to consider during evaluation, dummyPositions: appropriate coordinates of the dummy nodes  \n                    var findAppropriatePositionForRelativePlacement = function findAppropriatePositionForRelativePlacement(graph, direction, fixedNodes, dummyPositions, componentSources) {\n                        // find union of two sets\n                        function setUnion(setA, setB) {\n                            var union = new Set(setA);\n                            var _iteratorNormalCompletion = true;\n                            var _didIteratorError = false;\n                            var _iteratorError = undefined;\n                            try {\n                                for(var _iterator = setB[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                                    var elem = _step.value;\n                                    union.add(elem);\n                                }\n                            } catch (err) {\n                                _didIteratorError = true;\n                                _iteratorError = err;\n                            } finally{\n                                try {\n                                    if (!_iteratorNormalCompletion && _iterator.return) {\n                                        _iterator.return();\n                                    }\n                                } finally{\n                                    if (_didIteratorError) {\n                                        throw _iteratorError;\n                                    }\n                                }\n                            }\n                            return union;\n                        }\n                        // find indegree count for each node\n                        var inDegrees = new Map();\n                        graph.forEach(function(value, key) {\n                            inDegrees.set(key, 0);\n                        });\n                        graph.forEach(function(value, key) {\n                            value.forEach(function(adjacent) {\n                                inDegrees.set(adjacent.id, inDegrees.get(adjacent.id) + 1);\n                            });\n                        });\n                        var positionMap = new Map(); // keeps the position for each node\n                        var pastMap = new Map(); // keeps the predecessors(past) of a node\n                        var queue = new LinkedList();\n                        inDegrees.forEach(function(value, key) {\n                            if (value == 0) {\n                                queue.push(key);\n                                if (!fixedNodes) {\n                                    if (direction == \"horizontal\") {\n                                        positionMap.set(key, nodeIndexes.has(key) ? xCoords[nodeIndexes.get(key)] : dummyPositions.get(key));\n                                    } else {\n                                        positionMap.set(key, nodeIndexes.has(key) ? yCoords[nodeIndexes.get(key)] : dummyPositions.get(key));\n                                    }\n                                }\n                            } else {\n                                positionMap.set(key, Number.NEGATIVE_INFINITY);\n                            }\n                            if (fixedNodes) {\n                                pastMap.set(key, new Set([\n                                    key\n                                ]));\n                            }\n                        });\n                        // align sources of each component in enforcement phase\n                        if (fixedNodes) {\n                            componentSources.forEach(function(component) {\n                                var fixedIds = [];\n                                component.forEach(function(nodeId) {\n                                    if (fixedNodes.has(nodeId)) {\n                                        fixedIds.push(nodeId);\n                                    }\n                                });\n                                if (fixedIds.length > 0) {\n                                    var position = 0;\n                                    fixedIds.forEach(function(fixedId) {\n                                        if (direction == \"horizontal\") {\n                                            positionMap.set(fixedId, nodeIndexes.has(fixedId) ? xCoords[nodeIndexes.get(fixedId)] : dummyPositions.get(fixedId));\n                                            position += positionMap.get(fixedId);\n                                        } else {\n                                            positionMap.set(fixedId, nodeIndexes.has(fixedId) ? yCoords[nodeIndexes.get(fixedId)] : dummyPositions.get(fixedId));\n                                            position += positionMap.get(fixedId);\n                                        }\n                                    });\n                                    position = position / fixedIds.length;\n                                    component.forEach(function(nodeId) {\n                                        if (!fixedNodes.has(nodeId)) {\n                                            positionMap.set(nodeId, position);\n                                        }\n                                    });\n                                } else {\n                                    var _position = 0;\n                                    component.forEach(function(nodeId) {\n                                        if (direction == \"horizontal\") {\n                                            _position += nodeIndexes.has(nodeId) ? xCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n                                        } else {\n                                            _position += nodeIndexes.has(nodeId) ? yCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n                                        }\n                                    });\n                                    _position = _position / component.length;\n                                    component.forEach(function(nodeId) {\n                                        positionMap.set(nodeId, _position);\n                                    });\n                                }\n                            });\n                        }\n                        // calculate positions of the nodes\n                        var _loop = function _loop() {\n                            var currentNode = queue.shift();\n                            var neighbors = graph.get(currentNode);\n                            neighbors.forEach(function(neighbor) {\n                                if (positionMap.get(neighbor.id) < positionMap.get(currentNode) + neighbor.gap) {\n                                    if (fixedNodes && fixedNodes.has(neighbor.id)) {\n                                        var fixedPosition = void 0;\n                                        if (direction == \"horizontal\") {\n                                            fixedPosition = nodeIndexes.has(neighbor.id) ? xCoords[nodeIndexes.get(neighbor.id)] : dummyPositions.get(neighbor.id);\n                                        } else {\n                                            fixedPosition = nodeIndexes.has(neighbor.id) ? yCoords[nodeIndexes.get(neighbor.id)] : dummyPositions.get(neighbor.id);\n                                        }\n                                        positionMap.set(neighbor.id, fixedPosition); // TODO: may do unnecessary work\n                                        if (fixedPosition < positionMap.get(currentNode) + neighbor.gap) {\n                                            var diff = positionMap.get(currentNode) + neighbor.gap - fixedPosition;\n                                            pastMap.get(currentNode).forEach(function(nodeId) {\n                                                positionMap.set(nodeId, positionMap.get(nodeId) - diff);\n                                            });\n                                        }\n                                    } else {\n                                        positionMap.set(neighbor.id, positionMap.get(currentNode) + neighbor.gap);\n                                    }\n                                }\n                                inDegrees.set(neighbor.id, inDegrees.get(neighbor.id) - 1);\n                                if (inDegrees.get(neighbor.id) == 0) {\n                                    queue.push(neighbor.id);\n                                }\n                                if (fixedNodes) {\n                                    pastMap.set(neighbor.id, setUnion(pastMap.get(currentNode), pastMap.get(neighbor.id)));\n                                }\n                            });\n                        };\n                        while(queue.length != 0){\n                            _loop();\n                        }\n                        // readjust position of the nodes after enforcement\n                        if (fixedNodes) {\n                            // find indegree count for each node\n                            var sinkNodes = new Set();\n                            graph.forEach(function(value, key) {\n                                if (value.length == 0) {\n                                    sinkNodes.add(key);\n                                }\n                            });\n                            var _components = [];\n                            pastMap.forEach(function(value, key) {\n                                if (sinkNodes.has(key)) {\n                                    var isFixedComponent = false;\n                                    var _iteratorNormalCompletion2 = true;\n                                    var _didIteratorError2 = false;\n                                    var _iteratorError2 = undefined;\n                                    try {\n                                        for(var _iterator2 = value[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){\n                                            var nodeId = _step2.value;\n                                            if (fixedNodes.has(nodeId)) {\n                                                isFixedComponent = true;\n                                            }\n                                        }\n                                    } catch (err) {\n                                        _didIteratorError2 = true;\n                                        _iteratorError2 = err;\n                                    } finally{\n                                        try {\n                                            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                                                _iterator2.return();\n                                            }\n                                        } finally{\n                                            if (_didIteratorError2) {\n                                                throw _iteratorError2;\n                                            }\n                                        }\n                                    }\n                                    if (!isFixedComponent) {\n                                        var isExist = false;\n                                        var existAt = void 0;\n                                        _components.forEach(function(component, index) {\n                                            if (component.has([].concat(_toConsumableArray(value))[0])) {\n                                                isExist = true;\n                                                existAt = index;\n                                            }\n                                        });\n                                        if (!isExist) {\n                                            _components.push(new Set(value));\n                                        } else {\n                                            value.forEach(function(ele) {\n                                                _components[existAt].add(ele);\n                                            });\n                                        }\n                                    }\n                                }\n                            });\n                            _components.forEach(function(component, index) {\n                                var minBefore = Number.POSITIVE_INFINITY;\n                                var minAfter = Number.POSITIVE_INFINITY;\n                                var maxBefore = Number.NEGATIVE_INFINITY;\n                                var maxAfter = Number.NEGATIVE_INFINITY;\n                                var _iteratorNormalCompletion3 = true;\n                                var _didIteratorError3 = false;\n                                var _iteratorError3 = undefined;\n                                try {\n                                    for(var _iterator3 = component[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true){\n                                        var nodeId = _step3.value;\n                                        var posBefore = void 0;\n                                        if (direction == \"horizontal\") {\n                                            posBefore = nodeIndexes.has(nodeId) ? xCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n                                        } else {\n                                            posBefore = nodeIndexes.has(nodeId) ? yCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n                                        }\n                                        var posAfter = positionMap.get(nodeId);\n                                        if (posBefore < minBefore) {\n                                            minBefore = posBefore;\n                                        }\n                                        if (posBefore > maxBefore) {\n                                            maxBefore = posBefore;\n                                        }\n                                        if (posAfter < minAfter) {\n                                            minAfter = posAfter;\n                                        }\n                                        if (posAfter > maxAfter) {\n                                            maxAfter = posAfter;\n                                        }\n                                    }\n                                } catch (err) {\n                                    _didIteratorError3 = true;\n                                    _iteratorError3 = err;\n                                } finally{\n                                    try {\n                                        if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                                            _iterator3.return();\n                                        }\n                                    } finally{\n                                        if (_didIteratorError3) {\n                                            throw _iteratorError3;\n                                        }\n                                    }\n                                }\n                                var diff = (minBefore + maxBefore) / 2 - (minAfter + maxAfter) / 2;\n                                var _iteratorNormalCompletion4 = true;\n                                var _didIteratorError4 = false;\n                                var _iteratorError4 = undefined;\n                                try {\n                                    for(var _iterator4 = component[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true){\n                                        var _nodeId = _step4.value;\n                                        positionMap.set(_nodeId, positionMap.get(_nodeId) + diff);\n                                    }\n                                } catch (err) {\n                                    _didIteratorError4 = true;\n                                    _iteratorError4 = err;\n                                } finally{\n                                    try {\n                                        if (!_iteratorNormalCompletion4 && _iterator4.return) {\n                                            _iterator4.return();\n                                        }\n                                    } finally{\n                                        if (_didIteratorError4) {\n                                            throw _iteratorError4;\n                                        }\n                                    }\n                                }\n                            });\n                        }\n                        return positionMap;\n                    };\n                    // find transformation based on rel. placement constraints if there are both alignment and rel. placement constraints\n                    // or if there are only rel. placement contraints where the largest component isn't sufficiently large\n                    var applyReflectionForRelativePlacement = function applyReflectionForRelativePlacement(relativePlacementConstraints) {\n                        // variables to count votes\n                        var reflectOnY = 0, notReflectOnY = 0;\n                        var reflectOnX = 0, notReflectOnX = 0;\n                        relativePlacementConstraints.forEach(function(constraint) {\n                            if (constraint.left) {\n                                xCoords[nodeIndexes.get(constraint.left)] - xCoords[nodeIndexes.get(constraint.right)] >= 0 ? reflectOnY++ : notReflectOnY++;\n                            } else {\n                                yCoords[nodeIndexes.get(constraint.top)] - yCoords[nodeIndexes.get(constraint.bottom)] >= 0 ? reflectOnX++ : notReflectOnX++;\n                            }\n                        });\n                        if (reflectOnY > notReflectOnY && reflectOnX > notReflectOnX) {\n                            for(var _i = 0; _i < nodeIndexes.size; _i++){\n                                xCoords[_i] = -1 * xCoords[_i];\n                                yCoords[_i] = -1 * yCoords[_i];\n                            }\n                        } else if (reflectOnY > notReflectOnY) {\n                            for(var _i2 = 0; _i2 < nodeIndexes.size; _i2++){\n                                xCoords[_i2] = -1 * xCoords[_i2];\n                            }\n                        } else if (reflectOnX > notReflectOnX) {\n                            for(var _i3 = 0; _i3 < nodeIndexes.size; _i3++){\n                                yCoords[_i3] = -1 * yCoords[_i3];\n                            }\n                        }\n                    };\n                    // find weakly connected components in undirected graph\n                    var findComponents = function findComponents(graph) {\n                        // find weakly connected components in dag\n                        var components = [];\n                        var queue = new LinkedList();\n                        var visited = new Set();\n                        var count = 0;\n                        graph.forEach(function(value, key) {\n                            if (!visited.has(key)) {\n                                components[count] = [];\n                                var _currentNode = key;\n                                queue.push(_currentNode);\n                                visited.add(_currentNode);\n                                components[count].push(_currentNode);\n                                while(queue.length != 0){\n                                    _currentNode = queue.shift();\n                                    var neighbors = graph.get(_currentNode);\n                                    neighbors.forEach(function(neighbor) {\n                                        if (!visited.has(neighbor.id)) {\n                                            queue.push(neighbor.id);\n                                            visited.add(neighbor.id);\n                                            components[count].push(neighbor.id);\n                                        }\n                                    });\n                                }\n                                count++;\n                            }\n                        });\n                        return components;\n                    };\n                    // return undirected version of given dag\n                    var dagToUndirected = function dagToUndirected(dag) {\n                        var undirected = new Map();\n                        dag.forEach(function(value, key) {\n                            undirected.set(key, []);\n                        });\n                        dag.forEach(function(value, key) {\n                            value.forEach(function(adjacent) {\n                                undirected.get(key).push(adjacent);\n                                undirected.get(adjacent.id).push({\n                                    id: key,\n                                    gap: adjacent.gap,\n                                    direction: adjacent.direction\n                                });\n                            });\n                        });\n                        return undirected;\n                    };\n                    // return reversed (directions inverted) version of given dag\n                    var dagToReversed = function dagToReversed(dag) {\n                        var reversed = new Map();\n                        dag.forEach(function(value, key) {\n                            reversed.set(key, []);\n                        });\n                        dag.forEach(function(value, key) {\n                            value.forEach(function(adjacent) {\n                                reversed.get(adjacent.id).push({\n                                    id: key,\n                                    gap: adjacent.gap,\n                                    direction: adjacent.direction\n                                });\n                            });\n                        });\n                        return reversed;\n                    };\n                    /****  apply transformation to the initial draft layout to better align with constrained nodes ****/ // solve the Orthogonal Procrustean Problem to rotate and/or reflect initial draft layout\n                    // here we follow the solution in Chapter 20.2 of Borg, I. & Groenen, P. (2005) Modern Multidimensional Scaling: Theory and Applications \n                    /* construct source and target configurations */ var targetMatrix = []; // A - target configuration\n                    var sourceMatrix = []; // B - source configuration \n                    var standardTransformation = false; // false for no transformation, true for standart (Procrustes) transformation (rotation and/or reflection)\n                    var reflectionType = false; // false/true for reflection check, 'reflectOnX', 'reflectOnY' or 'reflectOnBoth' for reflection type if necessary\n                    var fixedNodes = new Set();\n                    var dag = new Map(); // adjacency list to keep directed acyclic graph (dag) that consists of relative placement constraints\n                    var dagUndirected = new Map(); // undirected version of the dag\n                    var components = []; // weakly connected components\n                    // fill fixedNodes collection to use later\n                    if (constraints.fixedNodeConstraint) {\n                        constraints.fixedNodeConstraint.forEach(function(nodeData) {\n                            fixedNodes.add(nodeData.nodeId);\n                        });\n                    }\n                    // construct dag from relative placement constraints \n                    if (constraints.relativePlacementConstraint) {\n                        // construct both directed and undirected version of the dag\n                        constraints.relativePlacementConstraint.forEach(function(constraint) {\n                            if (constraint.left) {\n                                if (dag.has(constraint.left)) {\n                                    dag.get(constraint.left).push({\n                                        id: constraint.right,\n                                        gap: constraint.gap,\n                                        direction: \"horizontal\"\n                                    });\n                                } else {\n                                    dag.set(constraint.left, [\n                                        {\n                                            id: constraint.right,\n                                            gap: constraint.gap,\n                                            direction: \"horizontal\"\n                                        }\n                                    ]);\n                                }\n                                if (!dag.has(constraint.right)) {\n                                    dag.set(constraint.right, []);\n                                }\n                            } else {\n                                if (dag.has(constraint.top)) {\n                                    dag.get(constraint.top).push({\n                                        id: constraint.bottom,\n                                        gap: constraint.gap,\n                                        direction: \"vertical\"\n                                    });\n                                } else {\n                                    dag.set(constraint.top, [\n                                        {\n                                            id: constraint.bottom,\n                                            gap: constraint.gap,\n                                            direction: \"vertical\"\n                                        }\n                                    ]);\n                                }\n                                if (!dag.has(constraint.bottom)) {\n                                    dag.set(constraint.bottom, []);\n                                }\n                            }\n                        });\n                        dagUndirected = dagToUndirected(dag);\n                        components = findComponents(dagUndirected);\n                    }\n                    if (CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING) {\n                        // first check fixed node constraint\n                        if (constraints.fixedNodeConstraint && constraints.fixedNodeConstraint.length > 1) {\n                            constraints.fixedNodeConstraint.forEach(function(nodeData, i) {\n                                targetMatrix[i] = [\n                                    nodeData.position.x,\n                                    nodeData.position.y\n                                ];\n                                sourceMatrix[i] = [\n                                    xCoords[nodeIndexes.get(nodeData.nodeId)],\n                                    yCoords[nodeIndexes.get(nodeData.nodeId)]\n                                ];\n                            });\n                            standardTransformation = true;\n                        } else if (constraints.alignmentConstraint) {\n                            (function() {\n                                // then check alignment constraint\n                                var count = 0;\n                                if (constraints.alignmentConstraint.vertical) {\n                                    var verticalAlign = constraints.alignmentConstraint.vertical;\n                                    var _loop2 = function _loop2(_i4) {\n                                        var alignmentSet = new Set();\n                                        verticalAlign[_i4].forEach(function(nodeId) {\n                                            alignmentSet.add(nodeId);\n                                        });\n                                        var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function(x) {\n                                            return fixedNodes.has(x);\n                                        }));\n                                        var xPos = void 0;\n                                        if (intersection.size > 0) xPos = xCoords[nodeIndexes.get(intersection.values().next().value)];\n                                        else xPos = calculateAvgPosition(alignmentSet).x;\n                                        verticalAlign[_i4].forEach(function(nodeId) {\n                                            targetMatrix[count] = [\n                                                xPos,\n                                                yCoords[nodeIndexes.get(nodeId)]\n                                            ];\n                                            sourceMatrix[count] = [\n                                                xCoords[nodeIndexes.get(nodeId)],\n                                                yCoords[nodeIndexes.get(nodeId)]\n                                            ];\n                                            count++;\n                                        });\n                                    };\n                                    for(var _i4 = 0; _i4 < verticalAlign.length; _i4++){\n                                        _loop2(_i4);\n                                    }\n                                    standardTransformation = true;\n                                }\n                                if (constraints.alignmentConstraint.horizontal) {\n                                    var horizontalAlign = constraints.alignmentConstraint.horizontal;\n                                    var _loop3 = function _loop3(_i5) {\n                                        var alignmentSet = new Set();\n                                        horizontalAlign[_i5].forEach(function(nodeId) {\n                                            alignmentSet.add(nodeId);\n                                        });\n                                        var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function(x) {\n                                            return fixedNodes.has(x);\n                                        }));\n                                        var yPos = void 0;\n                                        if (intersection.size > 0) yPos = xCoords[nodeIndexes.get(intersection.values().next().value)];\n                                        else yPos = calculateAvgPosition(alignmentSet).y;\n                                        horizontalAlign[_i5].forEach(function(nodeId) {\n                                            targetMatrix[count] = [\n                                                xCoords[nodeIndexes.get(nodeId)],\n                                                yPos\n                                            ];\n                                            sourceMatrix[count] = [\n                                                xCoords[nodeIndexes.get(nodeId)],\n                                                yCoords[nodeIndexes.get(nodeId)]\n                                            ];\n                                            count++;\n                                        });\n                                    };\n                                    for(var _i5 = 0; _i5 < horizontalAlign.length; _i5++){\n                                        _loop3(_i5);\n                                    }\n                                    standardTransformation = true;\n                                }\n                                if (constraints.relativePlacementConstraint) {\n                                    reflectionType = true;\n                                }\n                            })();\n                        } else if (constraints.relativePlacementConstraint) {\n                            // finally check relative placement constraint\n                            // find largest component in dag\n                            var largestComponentSize = 0;\n                            var largestComponentIndex = 0;\n                            for(var _i6 = 0; _i6 < components.length; _i6++){\n                                if (components[_i6].length > largestComponentSize) {\n                                    largestComponentSize = components[_i6].length;\n                                    largestComponentIndex = _i6;\n                                }\n                            }\n                            // if largest component isn't dominant, then take the votes for reflection\n                            if (largestComponentSize < dagUndirected.size / 2) {\n                                applyReflectionForRelativePlacement(constraints.relativePlacementConstraint);\n                                standardTransformation = false;\n                                reflectionType = false;\n                            } else {\n                                // use largest component for transformation\n                                // construct horizontal and vertical subgraphs in the largest component\n                                var subGraphOnHorizontal = new Map();\n                                var subGraphOnVertical = new Map();\n                                var constraintsInlargestComponent = [];\n                                components[largestComponentIndex].forEach(function(nodeId) {\n                                    dag.get(nodeId).forEach(function(adjacent) {\n                                        if (adjacent.direction == \"horizontal\") {\n                                            if (subGraphOnHorizontal.has(nodeId)) {\n                                                subGraphOnHorizontal.get(nodeId).push(adjacent);\n                                            } else {\n                                                subGraphOnHorizontal.set(nodeId, [\n                                                    adjacent\n                                                ]);\n                                            }\n                                            if (!subGraphOnHorizontal.has(adjacent.id)) {\n                                                subGraphOnHorizontal.set(adjacent.id, []);\n                                            }\n                                            constraintsInlargestComponent.push({\n                                                left: nodeId,\n                                                right: adjacent.id\n                                            });\n                                        } else {\n                                            if (subGraphOnVertical.has(nodeId)) {\n                                                subGraphOnVertical.get(nodeId).push(adjacent);\n                                            } else {\n                                                subGraphOnVertical.set(nodeId, [\n                                                    adjacent\n                                                ]);\n                                            }\n                                            if (!subGraphOnVertical.has(adjacent.id)) {\n                                                subGraphOnVertical.set(adjacent.id, []);\n                                            }\n                                            constraintsInlargestComponent.push({\n                                                top: nodeId,\n                                                bottom: adjacent.id\n                                            });\n                                        }\n                                    });\n                                });\n                                applyReflectionForRelativePlacement(constraintsInlargestComponent);\n                                reflectionType = false;\n                                // calculate appropriate positioning for subgraphs\n                                var positionMapHorizontal = findAppropriatePositionForRelativePlacement(subGraphOnHorizontal, \"horizontal\");\n                                var positionMapVertical = findAppropriatePositionForRelativePlacement(subGraphOnVertical, \"vertical\");\n                                // construct source and target configuration\n                                components[largestComponentIndex].forEach(function(nodeId, i) {\n                                    sourceMatrix[i] = [\n                                        xCoords[nodeIndexes.get(nodeId)],\n                                        yCoords[nodeIndexes.get(nodeId)]\n                                    ];\n                                    targetMatrix[i] = [];\n                                    if (positionMapHorizontal.has(nodeId)) {\n                                        targetMatrix[i][0] = positionMapHorizontal.get(nodeId);\n                                    } else {\n                                        targetMatrix[i][0] = xCoords[nodeIndexes.get(nodeId)];\n                                    }\n                                    if (positionMapVertical.has(nodeId)) {\n                                        targetMatrix[i][1] = positionMapVertical.get(nodeId);\n                                    } else {\n                                        targetMatrix[i][1] = yCoords[nodeIndexes.get(nodeId)];\n                                    }\n                                });\n                                standardTransformation = true;\n                            }\n                        }\n                        // if transformation is required, then calculate and apply transformation matrix\n                        if (standardTransformation) {\n                            /* calculate transformation matrix */ var transformationMatrix = void 0;\n                            var targetMatrixTranspose = Matrix.transpose(targetMatrix); // A'\n                            var sourceMatrixTranspose = Matrix.transpose(sourceMatrix); // B'\n                            // centralize transpose matrices\n                            for(var _i7 = 0; _i7 < targetMatrixTranspose.length; _i7++){\n                                targetMatrixTranspose[_i7] = Matrix.multGamma(targetMatrixTranspose[_i7]);\n                                sourceMatrixTranspose[_i7] = Matrix.multGamma(sourceMatrixTranspose[_i7]);\n                            }\n                            // do actual calculation for transformation matrix\n                            var tempMatrix = Matrix.multMat(targetMatrixTranspose, Matrix.transpose(sourceMatrixTranspose)); // tempMatrix = A'B\n                            var SVDResult = SVD.svd(tempMatrix); // SVD(A'B) = USV', svd function returns U, S and V \n                            transformationMatrix = Matrix.multMat(SVDResult.V, Matrix.transpose(SVDResult.U)); // transformationMatrix = T = VU'\n                            /* apply found transformation matrix to obtain final draft layout */ for(var _i8 = 0; _i8 < nodeIndexes.size; _i8++){\n                                var temp1 = [\n                                    xCoords[_i8],\n                                    yCoords[_i8]\n                                ];\n                                var temp2 = [\n                                    transformationMatrix[0][0],\n                                    transformationMatrix[1][0]\n                                ];\n                                var temp3 = [\n                                    transformationMatrix[0][1],\n                                    transformationMatrix[1][1]\n                                ];\n                                xCoords[_i8] = Matrix.dotProduct(temp1, temp2);\n                                yCoords[_i8] = Matrix.dotProduct(temp1, temp3);\n                            }\n                            // applied only both alignment and rel. placement constraints exist\n                            if (reflectionType) {\n                                applyReflectionForRelativePlacement(constraints.relativePlacementConstraint);\n                            }\n                        }\n                    }\n                    if (CoSEConstants.ENFORCE_CONSTRAINTS) {\n                        /****  enforce constraints on the transformed draft layout ****/ /* first enforce fixed node constraint */ if (constraints.fixedNodeConstraint && constraints.fixedNodeConstraint.length > 0) {\n                            var translationAmount = {\n                                x: 0,\n                                y: 0\n                            };\n                            constraints.fixedNodeConstraint.forEach(function(nodeData, i) {\n                                var posInTheory = {\n                                    x: xCoords[nodeIndexes.get(nodeData.nodeId)],\n                                    y: yCoords[nodeIndexes.get(nodeData.nodeId)]\n                                };\n                                var posDesired = nodeData.position;\n                                var posDiff = calculatePositionDiff(posDesired, posInTheory);\n                                translationAmount.x += posDiff.x;\n                                translationAmount.y += posDiff.y;\n                            });\n                            translationAmount.x /= constraints.fixedNodeConstraint.length;\n                            translationAmount.y /= constraints.fixedNodeConstraint.length;\n                            xCoords.forEach(function(value, i) {\n                                xCoords[i] += translationAmount.x;\n                            });\n                            yCoords.forEach(function(value, i) {\n                                yCoords[i] += translationAmount.y;\n                            });\n                            constraints.fixedNodeConstraint.forEach(function(nodeData) {\n                                xCoords[nodeIndexes.get(nodeData.nodeId)] = nodeData.position.x;\n                                yCoords[nodeIndexes.get(nodeData.nodeId)] = nodeData.position.y;\n                            });\n                        }\n                        /* then enforce alignment constraint */ if (constraints.alignmentConstraint) {\n                            if (constraints.alignmentConstraint.vertical) {\n                                var xAlign = constraints.alignmentConstraint.vertical;\n                                var _loop4 = function _loop4(_i9) {\n                                    var alignmentSet = new Set();\n                                    xAlign[_i9].forEach(function(nodeId) {\n                                        alignmentSet.add(nodeId);\n                                    });\n                                    var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function(x) {\n                                        return fixedNodes.has(x);\n                                    }));\n                                    var xPos = void 0;\n                                    if (intersection.size > 0) xPos = xCoords[nodeIndexes.get(intersection.values().next().value)];\n                                    else xPos = calculateAvgPosition(alignmentSet).x;\n                                    alignmentSet.forEach(function(nodeId) {\n                                        if (!fixedNodes.has(nodeId)) xCoords[nodeIndexes.get(nodeId)] = xPos;\n                                    });\n                                };\n                                for(var _i9 = 0; _i9 < xAlign.length; _i9++){\n                                    _loop4(_i9);\n                                }\n                            }\n                            if (constraints.alignmentConstraint.horizontal) {\n                                var yAlign = constraints.alignmentConstraint.horizontal;\n                                var _loop5 = function _loop5(_i10) {\n                                    var alignmentSet = new Set();\n                                    yAlign[_i10].forEach(function(nodeId) {\n                                        alignmentSet.add(nodeId);\n                                    });\n                                    var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function(x) {\n                                        return fixedNodes.has(x);\n                                    }));\n                                    var yPos = void 0;\n                                    if (intersection.size > 0) yPos = yCoords[nodeIndexes.get(intersection.values().next().value)];\n                                    else yPos = calculateAvgPosition(alignmentSet).y;\n                                    alignmentSet.forEach(function(nodeId) {\n                                        if (!fixedNodes.has(nodeId)) yCoords[nodeIndexes.get(nodeId)] = yPos;\n                                    });\n                                };\n                                for(var _i10 = 0; _i10 < yAlign.length; _i10++){\n                                    _loop5(_i10);\n                                }\n                            }\n                        }\n                        /* finally enforce relative placement constraint */ if (constraints.relativePlacementConstraint) {\n                            (function() {\n                                var nodeToDummyForVerticalAlignment = new Map();\n                                var nodeToDummyForHorizontalAlignment = new Map();\n                                var dummyToNodeForVerticalAlignment = new Map();\n                                var dummyToNodeForHorizontalAlignment = new Map();\n                                var dummyPositionsForVerticalAlignment = new Map();\n                                var dummyPositionsForHorizontalAlignment = new Map();\n                                var fixedNodesOnHorizontal = new Set();\n                                var fixedNodesOnVertical = new Set();\n                                // fill maps and sets      \n                                fixedNodes.forEach(function(nodeId) {\n                                    fixedNodesOnHorizontal.add(nodeId);\n                                    fixedNodesOnVertical.add(nodeId);\n                                });\n                                if (constraints.alignmentConstraint) {\n                                    if (constraints.alignmentConstraint.vertical) {\n                                        var verticalAlignment = constraints.alignmentConstraint.vertical;\n                                        var _loop6 = function _loop6(_i11) {\n                                            dummyToNodeForVerticalAlignment.set(\"dummy\" + _i11, []);\n                                            verticalAlignment[_i11].forEach(function(nodeId) {\n                                                nodeToDummyForVerticalAlignment.set(nodeId, \"dummy\" + _i11);\n                                                dummyToNodeForVerticalAlignment.get(\"dummy\" + _i11).push(nodeId);\n                                                if (fixedNodes.has(nodeId)) {\n                                                    fixedNodesOnHorizontal.add(\"dummy\" + _i11);\n                                                }\n                                            });\n                                            dummyPositionsForVerticalAlignment.set(\"dummy\" + _i11, xCoords[nodeIndexes.get(verticalAlignment[_i11][0])]);\n                                        };\n                                        for(var _i11 = 0; _i11 < verticalAlignment.length; _i11++){\n                                            _loop6(_i11);\n                                        }\n                                    }\n                                    if (constraints.alignmentConstraint.horizontal) {\n                                        var horizontalAlignment = constraints.alignmentConstraint.horizontal;\n                                        var _loop7 = function _loop7(_i12) {\n                                            dummyToNodeForHorizontalAlignment.set(\"dummy\" + _i12, []);\n                                            horizontalAlignment[_i12].forEach(function(nodeId) {\n                                                nodeToDummyForHorizontalAlignment.set(nodeId, \"dummy\" + _i12);\n                                                dummyToNodeForHorizontalAlignment.get(\"dummy\" + _i12).push(nodeId);\n                                                if (fixedNodes.has(nodeId)) {\n                                                    fixedNodesOnVertical.add(\"dummy\" + _i12);\n                                                }\n                                            });\n                                            dummyPositionsForHorizontalAlignment.set(\"dummy\" + _i12, yCoords[nodeIndexes.get(horizontalAlignment[_i12][0])]);\n                                        };\n                                        for(var _i12 = 0; _i12 < horizontalAlignment.length; _i12++){\n                                            _loop7(_i12);\n                                        }\n                                    }\n                                }\n                                // construct horizontal and vertical dags (subgraphs) from overall dag\n                                var dagOnHorizontal = new Map();\n                                var dagOnVertical = new Map();\n                                var _loop8 = function _loop8(nodeId) {\n                                    dag.get(nodeId).forEach(function(adjacent) {\n                                        var sourceId = void 0;\n                                        var targetNode = void 0;\n                                        if (adjacent[\"direction\"] == \"horizontal\") {\n                                            sourceId = nodeToDummyForVerticalAlignment.get(nodeId) ? nodeToDummyForVerticalAlignment.get(nodeId) : nodeId;\n                                            if (nodeToDummyForVerticalAlignment.get(adjacent.id)) {\n                                                targetNode = {\n                                                    id: nodeToDummyForVerticalAlignment.get(adjacent.id),\n                                                    gap: adjacent.gap,\n                                                    direction: adjacent.direction\n                                                };\n                                            } else {\n                                                targetNode = adjacent;\n                                            }\n                                            if (dagOnHorizontal.has(sourceId)) {\n                                                dagOnHorizontal.get(sourceId).push(targetNode);\n                                            } else {\n                                                dagOnHorizontal.set(sourceId, [\n                                                    targetNode\n                                                ]);\n                                            }\n                                            if (!dagOnHorizontal.has(targetNode.id)) {\n                                                dagOnHorizontal.set(targetNode.id, []);\n                                            }\n                                        } else {\n                                            sourceId = nodeToDummyForHorizontalAlignment.get(nodeId) ? nodeToDummyForHorizontalAlignment.get(nodeId) : nodeId;\n                                            if (nodeToDummyForHorizontalAlignment.get(adjacent.id)) {\n                                                targetNode = {\n                                                    id: nodeToDummyForHorizontalAlignment.get(adjacent.id),\n                                                    gap: adjacent.gap,\n                                                    direction: adjacent.direction\n                                                };\n                                            } else {\n                                                targetNode = adjacent;\n                                            }\n                                            if (dagOnVertical.has(sourceId)) {\n                                                dagOnVertical.get(sourceId).push(targetNode);\n                                            } else {\n                                                dagOnVertical.set(sourceId, [\n                                                    targetNode\n                                                ]);\n                                            }\n                                            if (!dagOnVertical.has(targetNode.id)) {\n                                                dagOnVertical.set(targetNode.id, []);\n                                            }\n                                        }\n                                    });\n                                };\n                                var _iteratorNormalCompletion5 = true;\n                                var _didIteratorError5 = false;\n                                var _iteratorError5 = undefined;\n                                try {\n                                    for(var _iterator5 = dag.keys()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true){\n                                        var nodeId = _step5.value;\n                                        _loop8(nodeId);\n                                    }\n                                // find source nodes of each component in horizontal and vertical dags\n                                } catch (err) {\n                                    _didIteratorError5 = true;\n                                    _iteratorError5 = err;\n                                } finally{\n                                    try {\n                                        if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                                            _iterator5.return();\n                                        }\n                                    } finally{\n                                        if (_didIteratorError5) {\n                                            throw _iteratorError5;\n                                        }\n                                    }\n                                }\n                                var undirectedOnHorizontal = dagToUndirected(dagOnHorizontal);\n                                var undirectedOnVertical = dagToUndirected(dagOnVertical);\n                                var componentsOnHorizontal = findComponents(undirectedOnHorizontal);\n                                var componentsOnVertical = findComponents(undirectedOnVertical);\n                                var reversedDagOnHorizontal = dagToReversed(dagOnHorizontal);\n                                var reversedDagOnVertical = dagToReversed(dagOnVertical);\n                                var componentSourcesOnHorizontal = [];\n                                var componentSourcesOnVertical = [];\n                                componentsOnHorizontal.forEach(function(component, index) {\n                                    componentSourcesOnHorizontal[index] = [];\n                                    component.forEach(function(nodeId) {\n                                        if (reversedDagOnHorizontal.get(nodeId).length == 0) {\n                                            componentSourcesOnHorizontal[index].push(nodeId);\n                                        }\n                                    });\n                                });\n                                componentsOnVertical.forEach(function(component, index) {\n                                    componentSourcesOnVertical[index] = [];\n                                    component.forEach(function(nodeId) {\n                                        if (reversedDagOnVertical.get(nodeId).length == 0) {\n                                            componentSourcesOnVertical[index].push(nodeId);\n                                        }\n                                    });\n                                });\n                                // calculate appropriate positioning for subgraphs\n                                var positionMapHorizontal = findAppropriatePositionForRelativePlacement(dagOnHorizontal, \"horizontal\", fixedNodesOnHorizontal, dummyPositionsForVerticalAlignment, componentSourcesOnHorizontal);\n                                var positionMapVertical = findAppropriatePositionForRelativePlacement(dagOnVertical, \"vertical\", fixedNodesOnVertical, dummyPositionsForHorizontalAlignment, componentSourcesOnVertical);\n                                // update positions of the nodes based on relative placement constraints\n                                var _loop9 = function _loop9(key) {\n                                    if (dummyToNodeForVerticalAlignment.get(key)) {\n                                        dummyToNodeForVerticalAlignment.get(key).forEach(function(nodeId) {\n                                            xCoords[nodeIndexes.get(nodeId)] = positionMapHorizontal.get(key);\n                                        });\n                                    } else {\n                                        xCoords[nodeIndexes.get(key)] = positionMapHorizontal.get(key);\n                                    }\n                                };\n                                var _iteratorNormalCompletion6 = true;\n                                var _didIteratorError6 = false;\n                                var _iteratorError6 = undefined;\n                                try {\n                                    for(var _iterator6 = positionMapHorizontal.keys()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true){\n                                        var key = _step6.value;\n                                        _loop9(key);\n                                    }\n                                } catch (err) {\n                                    _didIteratorError6 = true;\n                                    _iteratorError6 = err;\n                                } finally{\n                                    try {\n                                        if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                                            _iterator6.return();\n                                        }\n                                    } finally{\n                                        if (_didIteratorError6) {\n                                            throw _iteratorError6;\n                                        }\n                                    }\n                                }\n                                var _loop10 = function _loop10(key) {\n                                    if (dummyToNodeForHorizontalAlignment.get(key)) {\n                                        dummyToNodeForHorizontalAlignment.get(key).forEach(function(nodeId) {\n                                            yCoords[nodeIndexes.get(nodeId)] = positionMapVertical.get(key);\n                                        });\n                                    } else {\n                                        yCoords[nodeIndexes.get(key)] = positionMapVertical.get(key);\n                                    }\n                                };\n                                var _iteratorNormalCompletion7 = true;\n                                var _didIteratorError7 = false;\n                                var _iteratorError7 = undefined;\n                                try {\n                                    for(var _iterator7 = positionMapVertical.keys()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true){\n                                        var key = _step7.value;\n                                        _loop10(key);\n                                    }\n                                } catch (err) {\n                                    _didIteratorError7 = true;\n                                    _iteratorError7 = err;\n                                } finally{\n                                    try {\n                                        if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                                            _iterator7.return();\n                                        }\n                                    } finally{\n                                        if (_didIteratorError7) {\n                                            throw _iteratorError7;\n                                        }\n                                    }\n                                }\n                            })();\n                        }\n                    }\n                    // assign new coordinates to nodes after constraint handling\n                    for(var _i13 = 0; _i13 < allNodes.length; _i13++){\n                        var _node = allNodes[_i13];\n                        if (_node.getChild() == null) {\n                            _node.setCenter(xCoords[nodeIndexes.get(_node.id)], yCoords[nodeIndexes.get(_node.id)]);\n                        }\n                    }\n                };\n                module1.exports = ConstraintHandler;\n            /***/ },\n            /***/ 551: /***/ (module1)=>{\n                module1.exports = __WEBPACK_EXTERNAL_MODULE__551__;\n            /***/ }\n        };\n        /************************************************************************/ /******/ // The module cache\n        /******/ var __webpack_module_cache__ = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_181016__(moduleId) {\n            /******/ // Check if module is in cache\n            /******/ var cachedModule = __webpack_module_cache__[moduleId];\n            /******/ if (cachedModule !== undefined) {\n                /******/ return cachedModule.exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = __webpack_module_cache__[moduleId] = {\n                /******/ // no module.id needed\n                /******/ // no module.loaded needed\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ __webpack_modules__[moduleId](module1, module1.exports, __nested_webpack_require_181016__);\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /************************************************************************/ /******/ /******/ // startup\n        /******/ // Load entry module and return exports\n        /******/ // This entry module is referenced by other modules so it can't be inlined\n        /******/ var __nested_webpack_exports__ = __nested_webpack_require_181016__(45);\n        /******/ /******/ return __nested_webpack_exports__;\n    /******/ })();\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlLWZjb3NlL25vZGVfbW9kdWxlcy9jb3NlLWJhc2UvY29zZS1iYXNlLmpzIiwibWFwcGluZ3MiOiI7QUFBQyxVQUFTQSxpQ0FBaUNDLElBQUksRUFBRUMsT0FBTztJQUN2RCxJQUFHLElBQWlELEVBQ25ERSxPQUFPRCxPQUFPLEdBQUdELFFBQVFHLG1CQUFPQSxDQUFDLGlHQUFhO1NBQzFDLEVBSzJDO0FBQ2pELEdBQUcsUUFBTSxTQUFTRyxnQ0FBZ0M7SUFDbEQsT0FBZ0IsTUFBSCxHQUFJO1FBQ2pCLE1BQU0sR0FBSTtRQUNWLE1BQU0sR0FBSSxJQUFJQyxzQkFBdUI7WUFFckMsR0FBRyxHQUFHLElBQ04sR0FBRyxHQUFJLENBQUNMLFNBQVFNLDBCQUEwQkMsOEJBQW1CQTtnQkFJN0QsSUFBSUMsV0FBVyxDQUFDO2dCQUVoQkEsU0FBU0MsVUFBVSxHQUFHRiw4QkFBbUJBLENBQUM7Z0JBQzFDQyxTQUFTRSxhQUFhLEdBQUdILDhCQUFtQkEsQ0FBQztnQkFDN0NDLFNBQVNHLFFBQVEsR0FBR0osOEJBQW1CQSxDQUFDO2dCQUN4Q0MsU0FBU0ksU0FBUyxHQUFHTCw4QkFBbUJBLENBQUM7Z0JBQ3pDQyxTQUFTSyxnQkFBZ0IsR0FBR04sOEJBQW1CQSxDQUFDO2dCQUNoREMsU0FBU00sVUFBVSxHQUFHUCw4QkFBbUJBLENBQUM7Z0JBQzFDQyxTQUFTTyxRQUFRLEdBQUdSLDhCQUFtQkEsQ0FBQztnQkFDeENDLFNBQVNRLGlCQUFpQixHQUFHVCw4QkFBbUJBLENBQUM7Z0JBRWpEUCxRQUFPRCxPQUFPLEdBQUdTO1lBRWpCLEdBQUcsR0FBRztZQUVOLEdBQUcsR0FBRyxLQUNOLEdBQUcsR0FBSSxDQUFDUixTQUFRTSwwQkFBMEJDLCtCQUFtQkE7Z0JBSTdELElBQUlVLG9CQUFvQlYsK0JBQW1CQSxDQUFDLEtBQUtVLGlCQUFpQjtnQkFFbEUsU0FBU1AsaUJBQWlCO2dCQUUxQiwwREFBMEQ7Z0JBQzFELElBQUssSUFB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LGlCQUFpQnpXLFdBQVc7Z0JBQzNDLE1BQU0sR0FBTSxPQUFPeVcsYUFBYXpzQixPQUFPO1lBQ3ZDLE1BQU0sR0FBSztZQUNYLE1BQU0sR0FBSyxrREFBa0Q7WUFDN0QsTUFBTSxHQUFLLElBQUlDLFVBQVNzc0Isd0JBQXdCLENBQUNDLFNBQVMsR0FBRztnQkFDN0QsTUFBTSxHQUFNLHNCQUFzQjtnQkFDbEMsTUFBTSxHQUFNLDBCQUEwQjtnQkFDdEMsTUFBTSxHQUFNeHNCLFNBQVMsQ0FBQztZQUNYO1lBQ1gsTUFBTSxHQUNOLE1BQU0sR0FBSyw4QkFBOEI7WUFDekMsTUFBTSxHQUFLTSxtQkFBbUIsQ0FBQ2tzQixTQUFTLENBQUN2c0IsU0FBUUEsUUFBT0QsT0FBTyxFQUFFUSxpQ0FBbUJBO1lBQ3BGLE1BQU0sR0FDTixNQUFNLEdBQUssbUNBQW1DO1lBQzlDLE1BQU0sR0FBSyxPQUFPUCxRQUFPRCxPQUFPO1FBQ2hDLE1BQU0sR0FBSTtRQUNWLE1BQU0sR0FDTix3RUFBd0UsR0FDeEUsTUFBTSxHQUNOLE1BQU0sR0FBSSxVQUFVO1FBQ3BCLE1BQU0sR0FBSSx1Q0FBdUM7UUFDakQsTUFBTSxHQUFJLDBFQUEwRTtRQUNwRixNQUFNLEdBQUksSUFBSTBzQiwwQkFBbUJBLEdBQUdsc0IsaUNBQW1CQSxDQUFDO1FBQ3hELE1BQU0sR0FDTixNQUFNLEdBQUksT0FBT2tzQiwwQkFBbUJBO0lBQ3BDLE1BQU0sR0FBRztBQUVUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktcG0tYWdlbnQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlLWZjb3NlL25vZGVfbW9kdWxlcy9jb3NlLWJhc2UvY29zZS1iYXNlLmpzPzIzMGYiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwibGF5b3V0LWJhc2VcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wibGF5b3V0LWJhc2VcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiY29zZUJhc2VcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJsYXlvdXQtYmFzZVwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiY29zZUJhc2VcIl0gPSBmYWN0b3J5KHJvb3RbXCJsYXlvdXRCYXNlXCJdKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzU1MV9fKSB7XG5yZXR1cm4gLyoqKioqKi8gKCgpID0+IHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHRcInVzZSBzdHJpY3RcIjtcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyA0NTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG5cbnZhciBjb3NlQmFzZSA9IHt9O1xuXG5jb3NlQmFzZS5sYXlvdXRCYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpO1xuY29zZUJhc2UuQ29TRUNvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oODA2KTtcbmNvc2VCYXNlLkNvU0VFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NjcpO1xuY29zZUJhc2UuQ29TRUdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4ODApO1xuY29zZUJhc2UuQ29TRUdyYXBoTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNTc4KTtcbmNvc2VCYXNlLkNvU0VMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2NSk7XG5jb3NlQmFzZS5Db1NFTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTkxKTtcbmNvc2VCYXNlLkNvbnN0cmFpbnRIYW5kbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MDIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvc2VCYXNlO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gODA2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxudmFyIEZETGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLkZETGF5b3V0Q29uc3RhbnRzO1xuXG5mdW5jdGlvbiBDb1NFQ29uc3RhbnRzKCkge31cblxuLy9Db1NFQ29uc3RhbnRzIGluaGVyaXRzIHN0YXRpYyBwcm9wcyBpbiBGRExheW91dENvbnN0YW50c1xuZm9yICh2YXIgcHJvcCBpbiBGRExheW91dENvbnN0YW50cykge1xuICBDb1NFQ29uc3RhbnRzW3Byb3BdID0gRkRMYXlvdXRDb25zdGFudHNbcHJvcF07XG59XG5cbkNvU0VDb25zdGFudHMuREVGQVVMVF9VU0VfTVVMVElfTEVWRUxfU0NBTElORyA9IGZhbHNlO1xuQ29TRUNvbnN0YW50cy5ERUZBVUxUX1JBRElBTF9TRVBBUkFUSU9OID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSDtcbkNvU0VDb25zdGFudHMuREVGQVVMVF9DT01QT05FTlRfU0VQRVJBVElPTiA9IDYwO1xuQ29TRUNvbnN0YW50cy5USUxFID0gdHJ1ZTtcbkNvU0VDb25zdGFudHMuVElMSU5HX1BBRERJTkdfVkVSVElDQUwgPSAxMDtcbkNvU0VDb25zdGFudHMuVElMSU5HX1BBRERJTkdfSE9SSVpPTlRBTCA9IDEwO1xuQ29TRUNvbnN0YW50cy5UUkFOU0ZPUk1fT05fQ09OU1RSQUlOVF9IQU5ETElORyA9IHRydWU7XG5Db1NFQ29uc3RhbnRzLkVORk9SQ0VfQ09OU1RSQUlOVFMgPSB0cnVlO1xuQ29TRUNvbnN0YW50cy5BUFBMWV9MQVlPVVQgPSB0cnVlO1xuQ29TRUNvbnN0YW50cy5SRUxBWF9NT1ZFTUVOVF9PTl9DT05TVFJBSU5UUyA9IHRydWU7XG5Db1NFQ29uc3RhbnRzLlRSRUVfUkVEVUNUSU9OX09OX0lOQ1JFTUVOVEFMID0gdHJ1ZTsgLy8gdGhpcyBzaG91bGQgYmUgc2V0IHRvIGZhbHNlIGlmIHRoZXJlIHdpbGwgYmUgYSBjb25zdHJhaW50XG4vLyBUaGlzIGNvbnN0YW50IGlzIGZvciBkaWZmZXJlbnRpYXRpbmcgd2hldGhlciBhY3R1YWwgbGF5b3V0IGFsZ29yaXRobSB0aGF0IHVzZXMgY29zZS1iYXNlIHdhbnRzIHRvIGFwcGx5IG9ubHkgaW5jcmVtZW50YWwgbGF5b3V0IG9yIFxuLy8gYW4gaW5jcmVtZW50YWwgbGF5b3V0IG9uIHRvcCBvZiBhIHJhbmRvbWl6ZWQgbGF5b3V0LiBJZiBpdCBpcyBvbmx5IGluY3JlbWVudGFsIGxheW91dCwgdGhlbiB0aGlzIGNvbnN0YW50IHNob3VsZCBiZSB0cnVlLlxuQ29TRUNvbnN0YW50cy5QVVJFX0lOQ1JFTUVOVEFMID0gQ29TRUNvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvU0VDb25zdGFudHM7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA3Njc6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG52YXIgRkRMYXlvdXRFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLkZETGF5b3V0RWRnZTtcblxuZnVuY3Rpb24gQ29TRUVkZ2Uoc291cmNlLCB0YXJnZXQsIHZFZGdlKSB7XG4gIEZETGF5b3V0RWRnZS5jYWxsKHRoaXMsIHNvdXJjZSwgdGFyZ2V0LCB2RWRnZSk7XG59XG5cbkNvU0VFZGdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRkRMYXlvdXRFZGdlLnByb3RvdHlwZSk7XG5mb3IgKHZhciBwcm9wIGluIEZETGF5b3V0RWRnZSkge1xuICBDb1NFRWRnZVtwcm9wXSA9IEZETGF5b3V0RWRnZVtwcm9wXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb1NFRWRnZTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDg4MDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG5cbnZhciBMR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuTEdyYXBoO1xuXG5mdW5jdGlvbiBDb1NFR3JhcGgocGFyZW50LCBncmFwaE1nciwgdkdyYXBoKSB7XG4gIExHcmFwaC5jYWxsKHRoaXMsIHBhcmVudCwgZ3JhcGhNZ3IsIHZHcmFwaCk7XG59XG5cbkNvU0VHcmFwaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExHcmFwaC5wcm90b3R5cGUpO1xuZm9yICh2YXIgcHJvcCBpbiBMR3JhcGgpIHtcbiAgQ29TRUdyYXBoW3Byb3BdID0gTEdyYXBoW3Byb3BdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvU0VHcmFwaDtcblxuLyoqKi8gfSksXG5cbi8qKiovIDU3ODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG5cbnZhciBMR3JhcGhNYW5hZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLkxHcmFwaE1hbmFnZXI7XG5cbmZ1bmN0aW9uIENvU0VHcmFwaE1hbmFnZXIobGF5b3V0KSB7XG4gIExHcmFwaE1hbmFnZXIuY2FsbCh0aGlzLCBsYXlvdXQpO1xufVxuXG5Db1NFR3JhcGhNYW5hZ2VyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTEdyYXBoTWFuYWdlci5wcm90b3R5cGUpO1xuZm9yICh2YXIgcHJvcCBpbiBMR3JhcGhNYW5hZ2VyKSB7XG4gIENvU0VHcmFwaE1hbmFnZXJbcHJvcF0gPSBMR3JhcGhNYW5hZ2VyW3Byb3BdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvU0VHcmFwaE1hbmFnZXI7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NjU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG52YXIgRkRMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuRkRMYXlvdXQ7XG52YXIgQ29TRUdyYXBoTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNTc4KTtcbnZhciBDb1NFR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg4MCk7XG52YXIgQ29TRU5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5MSk7XG52YXIgQ29TRUVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2Nyk7XG52YXIgQ29TRUNvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oODA2KTtcbnZhciBDb25zdHJhaW50SGFuZGxlciA9IF9fd2VicGFja19yZXF1aXJlX18oOTAyKTtcbnZhciBGRExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5GRExheW91dENvbnN0YW50cztcbnZhciBMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuTGF5b3V0Q29uc3RhbnRzO1xudmFyIFBvaW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLlBvaW50O1xudmFyIFBvaW50RCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5Qb2ludEQ7XG52YXIgRGltZW5zaW9uRCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5EaW1lbnNpb25EO1xudmFyIExheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5MYXlvdXQ7XG52YXIgSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5JbnRlZ2VyO1xudmFyIElHZW9tZXRyeSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5JR2VvbWV0cnk7XG52YXIgTEdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLkxHcmFwaDtcbnZhciBUcmFuc2Zvcm0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuVHJhbnNmb3JtO1xudmFyIExpbmtlZExpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuTGlua2VkTGlzdDtcblxuZnVuY3Rpb24gQ29TRUxheW91dCgpIHtcbiAgRkRMYXlvdXQuY2FsbCh0aGlzKTtcblxuICB0aGlzLnRvQmVUaWxlZCA9IHt9OyAvLyBNZW1vcml6ZSBpZiBhIG5vZGUgaXMgdG8gYmUgdGlsZWQgb3IgaXMgdGlsZWRcbiAgdGhpcy5jb25zdHJhaW50cyA9IHt9OyAvLyBrZWVwIGxheW91dCBjb25zdHJhaW50c1xufVxuXG5Db1NFTGF5b3V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRkRMYXlvdXQucHJvdG90eXBlKTtcblxuZm9yICh2YXIgcHJvcCBpbiBGRExheW91dCkge1xuICBDb1NFTGF5b3V0W3Byb3BdID0gRkRMYXlvdXRbcHJvcF07XG59XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLm5ld0dyYXBoTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGdtID0gbmV3IENvU0VHcmFwaE1hbmFnZXIodGhpcyk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyID0gZ207XG4gIHJldHVybiBnbTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLm5ld0dyYXBoID0gZnVuY3Rpb24gKHZHcmFwaCkge1xuICByZXR1cm4gbmV3IENvU0VHcmFwaChudWxsLCB0aGlzLmdyYXBoTWFuYWdlciwgdkdyYXBoKTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLm5ld05vZGUgPSBmdW5jdGlvbiAodk5vZGUpIHtcbiAgcmV0dXJuIG5ldyBDb1NFTm9kZSh0aGlzLmdyYXBoTWFuYWdlciwgdk5vZGUpO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUubmV3RWRnZSA9IGZ1bmN0aW9uICh2RWRnZSkge1xuICByZXR1cm4gbmV3IENvU0VFZGdlKG51bGwsIG51bGwsIHZFZGdlKTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmluaXRQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkge1xuICBGRExheW91dC5wcm90b3R5cGUuaW5pdFBhcmFtZXRlcnMuY2FsbCh0aGlzLCBhcmd1bWVudHMpO1xuICBpZiAoIXRoaXMuaXNTdWJMYXlvdXQpIHtcbiAgICBpZiAoQ29TRUNvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIIDwgMTApIHtcbiAgICAgIHRoaXMuaWRlYWxFZGdlTGVuZ3RoID0gMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaWRlYWxFZGdlTGVuZ3RoID0gQ29TRUNvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIO1xuICAgIH1cblxuICAgIHRoaXMudXNlU21hcnRJZGVhbEVkZ2VMZW5ndGhDYWxjdWxhdGlvbiA9IENvU0VDb25zdGFudHMuREVGQVVMVF9VU0VfU01BUlRfSURFQUxfRURHRV9MRU5HVEhfQ0FMQ1VMQVRJT047XG4gICAgdGhpcy5ncmF2aXR5Q29uc3RhbnQgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfU1RSRU5HVEg7XG4gICAgdGhpcy5jb21wb3VuZEdyYXZpdHlDb25zdGFudCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9TVFJFTkdUSDtcbiAgICB0aGlzLmdyYXZpdHlSYW5nZUZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9SQU5HRV9GQUNUT1I7XG4gICAgdGhpcy5jb21wb3VuZEdyYXZpdHlSYW5nZUZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9SQU5HRV9GQUNUT1I7XG5cbiAgICAvLyB2YXJpYWJsZXMgZm9yIHRyZWUgcmVkdWN0aW9uIHN1cHBvcnRcbiAgICB0aGlzLnBydW5lZE5vZGVzQWxsID0gW107XG4gICAgdGhpcy5ncm93VHJlZUl0ZXJhdGlvbnMgPSAwO1xuICAgIHRoaXMuYWZ0ZXJHcm93dGhJdGVyYXRpb25zID0gMDtcbiAgICB0aGlzLmlzVHJlZUdyb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmlzR3Jvd3RoRmluaXNoZWQgPSBmYWxzZTtcbiAgfVxufTtcblxuLy8gVGhpcyBtZXRob2QgaXMgdXNlZCB0byBzZXQgQ29TRSByZWxhdGVkIHBhcmFtZXRlcnMgdXNlZCBieSBzcHJpbmcgZW1iZWRkZXIuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5pbml0U3ByaW5nRW1iZWRkZXIgPSBmdW5jdGlvbiAoKSB7XG4gIEZETGF5b3V0LnByb3RvdHlwZS5pbml0U3ByaW5nRW1iZWRkZXIuY2FsbCh0aGlzKTtcblxuICAvLyB2YXJpYWJsZXMgZm9yIGNvb2xpbmdcbiAgdGhpcy5jb29saW5nQ3ljbGUgPSAwO1xuICB0aGlzLm1heENvb2xpbmdDeWNsZSA9IHRoaXMubWF4SXRlcmF0aW9ucyAvIEZETGF5b3V0Q29uc3RhbnRzLkNPTlZFUkdFTkNFX0NIRUNLX1BFUklPRDtcbiAgdGhpcy5maW5hbFRlbXBlcmF0dXJlID0gMC4wNDtcbiAgdGhpcy5jb29saW5nQWRqdXN0ZXIgPSAxO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUubGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY3JlYXRlQmVuZHNBc05lZWRlZCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0NSRUFURV9CRU5EU19BU19ORUVERUQ7XG4gIGlmIChjcmVhdGVCZW5kc0FzTmVlZGVkKSB7XG4gICAgdGhpcy5jcmVhdGVCZW5kcG9pbnRzKCk7XG4gICAgdGhpcy5ncmFwaE1hbmFnZXIucmVzZXRBbGxFZGdlcygpO1xuICB9XG5cbiAgdGhpcy5sZXZlbCA9IDA7XG4gIHJldHVybiB0aGlzLmNsYXNzaWNMYXlvdXQoKTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmNsYXNzaWNMYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubm9kZXNXaXRoR3Jhdml0eSA9IHRoaXMuY2FsY3VsYXRlTm9kZXNUb0FwcGx5R3Jhdml0YXRpb25UbygpO1xuICB0aGlzLmdyYXBoTWFuYWdlci5zZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbih0aGlzLm5vZGVzV2l0aEdyYXZpdHkpO1xuICB0aGlzLmNhbGNOb09mQ2hpbGRyZW5Gb3JBbGxOb2RlcygpO1xuICB0aGlzLmdyYXBoTWFuYWdlci5jYWxjTG93ZXN0Q29tbW9uQW5jZXN0b3JzKCk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLmNhbGNJbmNsdXNpb25UcmVlRGVwdGhzKCk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKS5jYWxjRXN0aW1hdGVkU2l6ZSgpO1xuICB0aGlzLmNhbGNJZGVhbEVkZ2VMZW5ndGhzKCk7XG5cbiAgaWYgKCF0aGlzLmluY3JlbWVudGFsKSB7XG4gICAgdmFyIGZvcmVzdCA9IHRoaXMuZ2V0RmxhdEZvcmVzdCgpO1xuXG4gICAgLy8gVGhlIGdyYXBoIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxheW91dCBpcyBmbGF0IGFuZCBhIGZvcmVzdFxuICAgIGlmIChmb3Jlc3QubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5wb3NpdGlvbk5vZGVzUmFkaWFsbHkoZm9yZXN0KTtcbiAgICB9XG4gICAgLy8gVGhlIGdyYXBoIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxheW91dCBpcyBub3QgZmxhdCBvciBhIGZvcmVzdFxuICAgIGVsc2Uge1xuICAgICAgICAvLyBSZWR1Y2UgdGhlIHRyZWVzIHdoZW4gaW5jcmVtZW50YWwgbW9kZSBpcyBub3QgZW5hYmxlZCBhbmQgZ3JhcGggaXMgbm90IGEgZm9yZXN0IFxuICAgICAgICB0aGlzLnJlZHVjZVRyZWVzKCk7XG4gICAgICAgIC8vIFVwZGF0ZSBub2RlcyB0aGF0IGdyYXZpdHkgd2lsbCBiZSBhcHBsaWVkXG4gICAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oKTtcbiAgICAgICAgdmFyIGFsbE5vZGVzID0gbmV3IFNldCh0aGlzLmdldEFsbE5vZGVzKCkpO1xuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gdGhpcy5ub2Rlc1dpdGhHcmF2aXR5LmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiBhbGxOb2Rlcy5oYXMoeCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdyYXBoTWFuYWdlci5zZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbihpbnRlcnNlY3Rpb24pO1xuXG4gICAgICAgIHRoaXMucG9zaXRpb25Ob2Rlc1JhbmRvbWx5KCk7XG4gICAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKENvU0VDb25zdGFudHMuVFJFRV9SRURVQ1RJT05fT05fSU5DUkVNRU5UQUwpIHtcbiAgICAgIC8vIFJlZHVjZSB0aGUgdHJlZXMgaW4gaW5jcmVtZW50YWwgbW9kZSBpZiBvbmx5IHRoaXMgY29uc3RhbnQgaXMgc2V0IHRvIHRydWUgXG4gICAgICB0aGlzLnJlZHVjZVRyZWVzKCk7XG4gICAgICAvLyBVcGRhdGUgbm9kZXMgdGhhdCBncmF2aXR5IHdpbGwgYmUgYXBwbGllZFxuICAgICAgdGhpcy5ncmFwaE1hbmFnZXIucmVzZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbigpO1xuICAgICAgdmFyIGFsbE5vZGVzID0gbmV3IFNldCh0aGlzLmdldEFsbE5vZGVzKCkpO1xuICAgICAgdmFyIGludGVyc2VjdGlvbiA9IHRoaXMubm9kZXNXaXRoR3Jhdml0eS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIGFsbE5vZGVzLmhhcyh4KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ncmFwaE1hbmFnZXIuc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oaW50ZXJzZWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXModGhpcy5jb25zdHJhaW50cykubGVuZ3RoID4gMCkge1xuICAgIENvbnN0cmFpbnRIYW5kbGVyLmhhbmRsZUNvbnN0cmFpbnRzKHRoaXMpO1xuICAgIHRoaXMuaW5pdENvbnN0cmFpbnRWYXJpYWJsZXMoKTtcbiAgfVxuXG4gIHRoaXMuaW5pdFNwcmluZ0VtYmVkZGVyKCk7XG4gIGlmIChDb1NFQ29uc3RhbnRzLkFQUExZX0xBWU9VVCkge1xuICAgIHRoaXMucnVuU3ByaW5nRW1iZWRkZXIoKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy50b3RhbEl0ZXJhdGlvbnMrKztcblxuICBpZiAodGhpcy50b3RhbEl0ZXJhdGlvbnMgPT09IHRoaXMubWF4SXRlcmF0aW9ucyAmJiAhdGhpcy5pc1RyZWVHcm93aW5nICYmICF0aGlzLmlzR3Jvd3RoRmluaXNoZWQpIHtcbiAgICBpZiAodGhpcy5wcnVuZWROb2Rlc0FsbC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmlzVHJlZUdyb3dpbmcgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy50b3RhbEl0ZXJhdGlvbnMgJSBGRExheW91dENvbnN0YW50cy5DT05WRVJHRU5DRV9DSEVDS19QRVJJT0QgPT0gMCAmJiAhdGhpcy5pc1RyZWVHcm93aW5nICYmICF0aGlzLmlzR3Jvd3RoRmluaXNoZWQpIHtcbiAgICBpZiAodGhpcy5pc0NvbnZlcmdlZCgpKSB7XG4gICAgICBpZiAodGhpcy5wcnVuZWROb2Rlc0FsbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuaXNUcmVlR3Jvd2luZyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNvb2xpbmdDeWNsZSsrO1xuXG4gICAgaWYgKHRoaXMubGF5b3V0UXVhbGl0eSA9PSAwKSB7XG4gICAgICAvLyBxdWFsaXR5IC0gXCJkcmFmdFwiXG4gICAgICB0aGlzLmNvb2xpbmdBZGp1c3RlciA9IHRoaXMuY29vbGluZ0N5Y2xlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sYXlvdXRRdWFsaXR5ID09IDEpIHtcbiAgICAgIC8vIHF1YWxpdHkgLSBcImRlZmF1bHRcIlxuICAgICAgdGhpcy5jb29saW5nQWRqdXN0ZXIgPSB0aGlzLmNvb2xpbmdDeWNsZSAvIDM7XG4gICAgfVxuXG4gICAgLy8gY29vbGluZyBzY2hlZHVsZSBpcyBiYXNlZCBvbiBodHRwOi8vd3d3LmJ0bHVrZS5jb20vc2ltYW5mMS5odG1sIC0+IGNvb2xpbmcgc2NoZWR1bGUgM1xuICAgIHRoaXMuY29vbGluZ0ZhY3RvciA9IE1hdGgubWF4KHRoaXMuaW5pdGlhbENvb2xpbmdGYWN0b3IgLSBNYXRoLnBvdyh0aGlzLmNvb2xpbmdDeWNsZSwgTWF0aC5sb2coMTAwICogKHRoaXMuaW5pdGlhbENvb2xpbmdGYWN0b3IgLSB0aGlzLmZpbmFsVGVtcGVyYXR1cmUpKSAvIE1hdGgubG9nKHRoaXMubWF4Q29vbGluZ0N5Y2xlKSkgLyAxMDAgKiB0aGlzLmNvb2xpbmdBZGp1c3RlciwgdGhpcy5maW5hbFRlbXBlcmF0dXJlKTtcbiAgICB0aGlzLmFuaW1hdGlvblBlcmlvZCA9IE1hdGguY2VpbCh0aGlzLmluaXRpYWxBbmltYXRpb25QZXJpb2QgKiBNYXRoLnNxcnQodGhpcy5jb29saW5nRmFjdG9yKSk7XG4gIH1cbiAgLy8gT3BlcmF0aW9ucyB3aGlsZSB0cmVlIGlzIGdyb3dpbmcgYWdhaW4gXG4gIGlmICh0aGlzLmlzVHJlZUdyb3dpbmcpIHtcbiAgICBpZiAodGhpcy5ncm93VHJlZUl0ZXJhdGlvbnMgJSAxMCA9PSAwKSB7XG4gICAgICBpZiAodGhpcy5wcnVuZWROb2Rlc0FsbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnVwZGF0ZUJvdW5kcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUdyaWQoKTtcbiAgICAgICAgdGhpcy5ncm93VHJlZSh0aGlzLnBydW5lZE5vZGVzQWxsKTtcbiAgICAgICAgLy8gVXBkYXRlIG5vZGVzIHRoYXQgZ3Jhdml0eSB3aWxsIGJlIGFwcGxpZWRcbiAgICAgICAgdGhpcy5ncmFwaE1hbmFnZXIucmVzZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbigpO1xuICAgICAgICB2YXIgYWxsTm9kZXMgPSBuZXcgU2V0KHRoaXMuZ2V0QWxsTm9kZXMoKSk7XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSB0aGlzLm5vZGVzV2l0aEdyYXZpdHkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIGFsbE5vZGVzLmhhcyh4KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uKGludGVyc2VjdGlvbik7XG5cbiAgICAgICAgdGhpcy5ncmFwaE1hbmFnZXIudXBkYXRlQm91bmRzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlR3JpZCgpO1xuICAgICAgICBpZiAoQ29TRUNvbnN0YW50cy5QVVJFX0lOQ1JFTUVOVEFMKSB0aGlzLmNvb2xpbmdGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMIC8gMjtlbHNlIHRoaXMuY29vbGluZ0ZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmlzVHJlZUdyb3dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0dyb3d0aEZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5ncm93VHJlZUl0ZXJhdGlvbnMrKztcbiAgfVxuICAvLyBPcGVyYXRpb25zIGFmdGVyIGdyb3d0aCBpcyBmaW5pc2hlZFxuICBpZiAodGhpcy5pc0dyb3d0aEZpbmlzaGVkKSB7XG4gICAgaWYgKHRoaXMuaXNDb252ZXJnZWQoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmFmdGVyR3Jvd3RoSXRlcmF0aW9ucyAlIDEwID09IDApIHtcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnVwZGF0ZUJvdW5kcygpO1xuICAgICAgdGhpcy51cGRhdGVHcmlkKCk7XG4gICAgfVxuICAgIGlmIChDb1NFQ29uc3RhbnRzLlBVUkVfSU5DUkVNRU5UQUwpIHRoaXMuY29vbGluZ0ZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUwgLyAyICogKCgxMDAgLSB0aGlzLmFmdGVyR3Jvd3RoSXRlcmF0aW9ucykgLyAxMDApO2Vsc2UgdGhpcy5jb29saW5nRmFjdG9yID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT09MSU5HX0ZBQ1RPUl9JTkNSRU1FTlRBTCAqICgoMTAwIC0gdGhpcy5hZnRlckdyb3d0aEl0ZXJhdGlvbnMpIC8gMTAwKTtcbiAgICB0aGlzLmFmdGVyR3Jvd3RoSXRlcmF0aW9ucysrO1xuICB9XG5cbiAgdmFyIGdyaWRVcGRhdGVBbGxvd2VkID0gIXRoaXMuaXNUcmVlR3Jvd2luZyAmJiAhdGhpcy5pc0dyb3d0aEZpbmlzaGVkO1xuICB2YXIgZm9yY2VUb05vZGVTdXJyb3VuZGluZ1VwZGF0ZSA9IHRoaXMuZ3Jvd1RyZWVJdGVyYXRpb25zICUgMTAgPT0gMSAmJiB0aGlzLmlzVHJlZUdyb3dpbmcgfHwgdGhpcy5hZnRlckdyb3d0aEl0ZXJhdGlvbnMgJSAxMCA9PSAxICYmIHRoaXMuaXNHcm93dGhGaW5pc2hlZDtcblxuICB0aGlzLnRvdGFsRGlzcGxhY2VtZW50ID0gMDtcbiAgdGhpcy5ncmFwaE1hbmFnZXIudXBkYXRlQm91bmRzKCk7XG4gIHRoaXMuY2FsY1NwcmluZ0ZvcmNlcygpO1xuICB0aGlzLmNhbGNSZXB1bHNpb25Gb3JjZXMoZ3JpZFVwZGF0ZUFsbG93ZWQsIGZvcmNlVG9Ob2RlU3Vycm91bmRpbmdVcGRhdGUpO1xuICB0aGlzLmNhbGNHcmF2aXRhdGlvbmFsRm9yY2VzKCk7XG4gIHRoaXMubW92ZU5vZGVzKCk7XG4gIHRoaXMuYW5pbWF0ZSgpO1xuXG4gIHJldHVybiBmYWxzZTsgLy8gTGF5b3V0IGlzIG5vdCBlbmRlZCB5ZXQgcmV0dXJuIGZhbHNlXG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5nZXRQb3NpdGlvbnNEYXRhID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYWxsTm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxOb2RlcygpO1xuICB2YXIgcERhdGEgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciByZWN0ID0gYWxsTm9kZXNbaV0ucmVjdDtcbiAgICB2YXIgaWQgPSBhbGxOb2Rlc1tpXS5pZDtcbiAgICBwRGF0YVtpZF0gPSB7XG4gICAgICBpZDogaWQsXG4gICAgICB4OiByZWN0LmdldENlbnRlclgoKSxcbiAgICAgIHk6IHJlY3QuZ2V0Q2VudGVyWSgpLFxuICAgICAgdzogcmVjdC53aWR0aCxcbiAgICAgIGg6IHJlY3QuaGVpZ2h0XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBwRGF0YTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnJ1blNwcmluZ0VtYmVkZGVyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmluaXRpYWxBbmltYXRpb25QZXJpb2QgPSAyNTtcbiAgdGhpcy5hbmltYXRpb25QZXJpb2QgPSB0aGlzLmluaXRpYWxBbmltYXRpb25QZXJpb2Q7XG4gIHZhciBsYXlvdXRFbmRlZCA9IGZhbHNlO1xuXG4gIC8vIElmIGFtaW5hdGUgb3B0aW9uIGlzICdkdXJpbmcnIHNpZ25hbCB0aGF0IGxheW91dCBpcyBzdXBwb3NlZCB0byBzdGFydCBpdGVyYXRpbmdcbiAgaWYgKEZETGF5b3V0Q29uc3RhbnRzLkFOSU1BVEUgPT09ICdkdXJpbmcnKSB7XG4gICAgdGhpcy5lbWl0KCdsYXlvdXRzdGFydGVkJyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgYW1pbmF0ZSBvcHRpb24gaXMgJ2R1cmluZycgdGljaygpIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIG9uIGluZGV4LmpzXG4gICAgd2hpbGUgKCFsYXlvdXRFbmRlZCkge1xuICAgICAgbGF5b3V0RW5kZWQgPSB0aGlzLnRpY2soKTtcbiAgICB9XG5cbiAgICB0aGlzLmdyYXBoTWFuYWdlci51cGRhdGVCb3VuZHMoKTtcbiAgfVxufTtcblxuLy8gb3ZlcnJpZGVzIG1vdmVOb2RlcyBtZXRob2QgaW4gRkRMYXlvdXRcbkNvU0VMYXlvdXQucHJvdG90eXBlLm1vdmVOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxOb2RlcyA9IHRoaXMuZ2V0QWxsTm9kZXMoKTtcbiAgdmFyIG5vZGU7XG5cbiAgLy8gY2FsY3VsYXRlIGRpc3BsYWNlbWVudCBmb3IgZWFjaCBub2RlIFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIG5vZGUgPSBsTm9kZXNbaV07XG4gICAgbm9kZS5jYWxjdWxhdGVEaXNwbGFjZW1lbnQoKTtcbiAgfVxuXG4gIGlmIChPYmplY3Qua2V5cyh0aGlzLmNvbnN0cmFpbnRzKS5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy51cGRhdGVEaXNwbGFjZW1lbnRzKCk7XG4gIH1cblxuICAvLyBtb3ZlIGVhY2ggbm9kZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIG5vZGUgPSBsTm9kZXNbaV07XG4gICAgbm9kZS5tb3ZlKCk7XG4gIH1cbn07XG5cbi8vIGNvbnN0cmFpbnQgcmVsYXRlZCBtZXRob2RzOiBpbml0Q29uc3RyYWludFZhcmlhYmxlcyBhbmQgdXBkYXRlRGlzcGxhY2VtZW50c1xuXG4vLyBpbml0aWFsaXplIGNvbnN0cmFpbnQgcmVsYXRlZCB2YXJpYWJsZXNcbkNvU0VMYXlvdXQucHJvdG90eXBlLmluaXRDb25zdHJhaW50VmFyaWFibGVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuaWRUb05vZGVNYXAgPSBuZXcgTWFwKCk7XG4gIHRoaXMuZml4ZWROb2RlU2V0ID0gbmV3IFNldCgpO1xuXG4gIHZhciBhbGxOb2RlcyA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbE5vZGVzKCk7XG5cbiAgLy8gZmlsbCBpZFRvTm9kZU1hcFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBhbGxOb2Rlc1tpXTtcbiAgICB0aGlzLmlkVG9Ob2RlTWFwLnNldChub2RlLmlkLCBub2RlKTtcbiAgfVxuXG4gIC8vIGNhbGN1bGF0ZSBmaXhlZCBub2RlIHdlaWdodCBmb3IgZ2l2ZW4gY29tcG91bmQgbm9kZVxuICB2YXIgY2FsY3VsYXRlQ29tcG91bmRXZWlnaHQgPSBmdW5jdGlvbiBjYWxjdWxhdGVDb21wb3VuZFdlaWdodChjb21wb3VuZE5vZGUpIHtcbiAgICB2YXIgbm9kZXMgPSBjb21wb3VuZE5vZGUuZ2V0Q2hpbGQoKS5nZXROb2RlcygpO1xuICAgIHZhciBub2RlO1xuICAgIHZhciBmaXhlZE5vZGVXZWlnaHQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGlmIChub2RlLmdldENoaWxkKCkgPT0gbnVsbCkge1xuICAgICAgICBpZiAoc2VsZi5maXhlZE5vZGVTZXQuaGFzKG5vZGUuaWQpKSB7XG4gICAgICAgICAgZml4ZWROb2RlV2VpZ2h0ICs9IDEwMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZml4ZWROb2RlV2VpZ2h0ICs9IGNhbGN1bGF0ZUNvbXBvdW5kV2VpZ2h0KG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZml4ZWROb2RlV2VpZ2h0O1xuICB9O1xuXG4gIGlmICh0aGlzLmNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQpIHtcbiAgICAvLyBmaWxsIGZpeGVkTm9kZVNldFxuICAgIHRoaXMuY29uc3RyYWludHMuZml4ZWROb2RlQ29uc3RyYWludC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlRGF0YSkge1xuICAgICAgc2VsZi5maXhlZE5vZGVTZXQuYWRkKG5vZGVEYXRhLm5vZGVJZCk7XG4gICAgfSk7XG5cbiAgICAvLyBhc3NpZ24gZml4ZWQgbm9kZSB3ZWlnaHRzIHRvIGNvbXBvdW5kcyBpZiB0aGV5IGNvbnRhaW4gZml4ZWQgbm9kZXNcbiAgICB2YXIgYWxsTm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxOb2RlcygpO1xuICAgIHZhciBub2RlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbm9kZSA9IGFsbE5vZGVzW2ldO1xuICAgICAgaWYgKG5vZGUuZ2V0Q2hpbGQoKSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBmaXhlZE5vZGVXZWlnaHQgPSBjYWxjdWxhdGVDb21wb3VuZFdlaWdodChub2RlKTtcbiAgICAgICAgaWYgKGZpeGVkTm9kZVdlaWdodCA+IDApIHtcbiAgICAgICAgICBub2RlLmZpeGVkTm9kZVdlaWdodCA9IGZpeGVkTm9kZVdlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLmNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCkge1xuICAgIHZhciBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50ID0gbmV3IE1hcCgpO1xuICAgIHZhciBub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50ID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50ID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZml4ZWROb2Rlc09uSG9yaXpvbnRhbCA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmZpeGVkTm9kZXNPblZlcnRpY2FsID0gbmV3IFNldCgpO1xuXG4gICAgLy8gZmlsbCBtYXBzIGFuZCBzZXRzXG4gICAgdGhpcy5maXhlZE5vZGVTZXQuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICBzZWxmLmZpeGVkTm9kZXNPbkhvcml6b250YWwuYWRkKG5vZGVJZCk7XG4gICAgICBzZWxmLmZpeGVkTm9kZXNPblZlcnRpY2FsLmFkZChub2RlSWQpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludCkge1xuICAgICAgaWYgKHRoaXMuY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC52ZXJ0aWNhbCkge1xuICAgICAgICB2YXIgdmVydGljYWxBbGlnbm1lbnQgPSB0aGlzLmNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljYWxBbGlnbm1lbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuc2V0KFwiZHVtbXlcIiArIGksIFtdKTtcbiAgICAgICAgICB2ZXJ0aWNhbEFsaWdubWVudFtpXS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIG5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQuc2V0KG5vZGVJZCwgXCJkdW1teVwiICsgaSk7XG4gICAgICAgICAgICBzZWxmLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KFwiZHVtbXlcIiArIGkpLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmZpeGVkTm9kZVNldC5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgICBzZWxmLmZpeGVkTm9kZXNPbkhvcml6b250YWwuYWRkKFwiZHVtbXlcIiArIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50Lmhvcml6b250YWwpIHtcbiAgICAgICAgdmFyIGhvcml6b250YWxBbGlnbm1lbnQgPSB0aGlzLmNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQuaG9yaXpvbnRhbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3Jpem9udGFsQWxpZ25tZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5kdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuc2V0KFwiZHVtbXlcIiArIGksIFtdKTtcbiAgICAgICAgICBob3Jpem9udGFsQWxpZ25tZW50W2ldLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50LnNldChub2RlSWQsIFwiZHVtbXlcIiArIGkpO1xuICAgICAgICAgICAgc2VsZi5kdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KFwiZHVtbXlcIiArIGkpLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmZpeGVkTm9kZVNldC5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgICBzZWxmLmZpeGVkTm9kZXNPblZlcnRpY2FsLmFkZChcImR1bW15XCIgKyBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChDb1NFQ29uc3RhbnRzLlJFTEFYX01PVkVNRU5UX09OX0NPTlNUUkFJTlRTKSB7XG5cbiAgICAgIHRoaXMuc2h1ZmZsZSA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICB2YXIgaiwgeCwgaTtcbiAgICAgICAgZm9yIChpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAyICogYXJyYXkubGVuZ3RoIC8gMzsgaS0tKSB7XG4gICAgICAgICAgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xuICAgICAgICAgIHggPSBhcnJheVtpXTtcbiAgICAgICAgICBhcnJheVtpXSA9IGFycmF5W2pdO1xuICAgICAgICAgIGFycmF5W2pdID0geDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLm5vZGVzSW5SZWxhdGl2ZUhvcml6b250YWwgPSBbXTtcbiAgICAgIHRoaXMubm9kZXNJblJlbGF0aXZlVmVydGljYWwgPSBbXTtcbiAgICAgIHRoaXMubm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwSG9yaXpvbnRhbCA9IG5ldyBNYXAoKTtcbiAgICAgIHRoaXMubm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwVmVydGljYWwgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLm5vZGVUb1RlbXBQb3NpdGlvbk1hcEhvcml6b250YWwgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLm5vZGVUb1RlbXBQb3NpdGlvbk1hcFZlcnRpY2FsID0gbmV3IE1hcCgpO1xuXG4gICAgICAvLyBmaWxsIGFycmF5cyBhbmQgbWFwc1xuICAgICAgdGhpcy5jb25zdHJhaW50cy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQuZm9yRWFjaChmdW5jdGlvbiAoY29uc3RyYWludCkge1xuICAgICAgICBpZiAoY29uc3RyYWludC5sZWZ0KSB7XG4gICAgICAgICAgdmFyIG5vZGVJZExlZnQgPSBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50Lmhhcyhjb25zdHJhaW50LmxlZnQpID8gbm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudC5nZXQoY29uc3RyYWludC5sZWZ0KSA6IGNvbnN0cmFpbnQubGVmdDtcbiAgICAgICAgICB2YXIgbm9kZUlkUmlnaHQgPSBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50Lmhhcyhjb25zdHJhaW50LnJpZ2h0KSA/IG5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KGNvbnN0cmFpbnQucmlnaHQpIDogY29uc3RyYWludC5yaWdodDtcblxuICAgICAgICAgIGlmICghc2VsZi5ub2Rlc0luUmVsYXRpdmVIb3Jpem9udGFsLmluY2x1ZGVzKG5vZGVJZExlZnQpKSB7XG4gICAgICAgICAgICBzZWxmLm5vZGVzSW5SZWxhdGl2ZUhvcml6b250YWwucHVzaChub2RlSWRMZWZ0KTtcbiAgICAgICAgICAgIHNlbGYubm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwSG9yaXpvbnRhbC5zZXQobm9kZUlkTGVmdCwgW10pO1xuICAgICAgICAgICAgaWYgKHNlbGYuZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudC5oYXMobm9kZUlkTGVmdCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBIb3Jpem9udGFsLnNldChub2RlSWRMZWZ0LCBzZWxmLmlkVG9Ob2RlTWFwLmdldChzZWxmLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KG5vZGVJZExlZnQpWzBdKS5nZXRDZW50ZXJYKCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBIb3Jpem9udGFsLnNldChub2RlSWRMZWZ0LCBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWRMZWZ0KS5nZXRDZW50ZXJYKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXNlbGYubm9kZXNJblJlbGF0aXZlSG9yaXpvbnRhbC5pbmNsdWRlcyhub2RlSWRSaWdodCkpIHtcbiAgICAgICAgICAgIHNlbGYubm9kZXNJblJlbGF0aXZlSG9yaXpvbnRhbC5wdXNoKG5vZGVJZFJpZ2h0KTtcbiAgICAgICAgICAgIHNlbGYubm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwSG9yaXpvbnRhbC5zZXQobm9kZUlkUmlnaHQsIFtdKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuaGFzKG5vZGVJZFJpZ2h0KSkge1xuICAgICAgICAgICAgICBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcEhvcml6b250YWwuc2V0KG5vZGVJZFJpZ2h0LCBzZWxmLmlkVG9Ob2RlTWFwLmdldChzZWxmLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KG5vZGVJZFJpZ2h0KVswXSkuZ2V0Q2VudGVyWCgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwSG9yaXpvbnRhbC5zZXQobm9kZUlkUmlnaHQsIHNlbGYuaWRUb05vZGVNYXAuZ2V0KG5vZGVJZFJpZ2h0KS5nZXRDZW50ZXJYKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYubm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwSG9yaXpvbnRhbC5nZXQobm9kZUlkTGVmdCkucHVzaCh7IHJpZ2h0OiBub2RlSWRSaWdodCwgZ2FwOiBjb25zdHJhaW50LmdhcCB9KTtcbiAgICAgICAgICBzZWxmLm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcEhvcml6b250YWwuZ2V0KG5vZGVJZFJpZ2h0KS5wdXNoKHsgbGVmdDogbm9kZUlkTGVmdCwgZ2FwOiBjb25zdHJhaW50LmdhcCB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbm9kZUlkVG9wID0gbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50Lmhhcyhjb25zdHJhaW50LnRvcCkgPyBub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KGNvbnN0cmFpbnQudG9wKSA6IGNvbnN0cmFpbnQudG9wO1xuICAgICAgICAgIHZhciBub2RlSWRCb3R0b20gPSBub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQuaGFzKGNvbnN0cmFpbnQuYm90dG9tKSA/IG5vZGVUb0R1bW15Rm9ySG9yaXpvbnRhbEFsaWdubWVudC5nZXQoY29uc3RyYWludC5ib3R0b20pIDogY29uc3RyYWludC5ib3R0b207XG5cbiAgICAgICAgICBpZiAoIXNlbGYubm9kZXNJblJlbGF0aXZlVmVydGljYWwuaW5jbHVkZXMobm9kZUlkVG9wKSkge1xuICAgICAgICAgICAgc2VsZi5ub2Rlc0luUmVsYXRpdmVWZXJ0aWNhbC5wdXNoKG5vZGVJZFRvcCk7XG4gICAgICAgICAgICBzZWxmLm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcFZlcnRpY2FsLnNldChub2RlSWRUb3AsIFtdKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5oYXMobm9kZUlkVG9wKSkge1xuICAgICAgICAgICAgICBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcFZlcnRpY2FsLnNldChub2RlSWRUb3AsIHNlbGYuaWRUb05vZGVNYXAuZ2V0KHNlbGYuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChub2RlSWRUb3ApWzBdKS5nZXRDZW50ZXJZKCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBWZXJ0aWNhbC5zZXQobm9kZUlkVG9wLCBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWRUb3ApLmdldENlbnRlclkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc2VsZi5ub2Rlc0luUmVsYXRpdmVWZXJ0aWNhbC5pbmNsdWRlcyhub2RlSWRCb3R0b20pKSB7XG4gICAgICAgICAgICBzZWxmLm5vZGVzSW5SZWxhdGl2ZVZlcnRpY2FsLnB1c2gobm9kZUlkQm90dG9tKTtcbiAgICAgICAgICAgIHNlbGYubm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwVmVydGljYWwuc2V0KG5vZGVJZEJvdHRvbSwgW10pO1xuICAgICAgICAgICAgaWYgKHNlbGYuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50Lmhhcyhub2RlSWRCb3R0b20pKSB7XG4gICAgICAgICAgICAgIHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwVmVydGljYWwuc2V0KG5vZGVJZEJvdHRvbSwgc2VsZi5pZFRvTm9kZU1hcC5nZXQoc2VsZi5kdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KG5vZGVJZEJvdHRvbSlbMF0pLmdldENlbnRlclkoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcFZlcnRpY2FsLnNldChub2RlSWRCb3R0b20sIHNlbGYuaWRUb05vZGVNYXAuZ2V0KG5vZGVJZEJvdHRvbSkuZ2V0Q2VudGVyWSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5ub2RlVG9SZWxhdGl2ZUNvbnN0cmFpbnRNYXBWZXJ0aWNhbC5nZXQobm9kZUlkVG9wKS5wdXNoKHsgYm90dG9tOiBub2RlSWRCb3R0b20sIGdhcDogY29uc3RyYWludC5nYXAgfSk7XG4gICAgICAgICAgc2VsZi5ub2RlVG9SZWxhdGl2ZUNvbnN0cmFpbnRNYXBWZXJ0aWNhbC5nZXQobm9kZUlkQm90dG9tKS5wdXNoKHsgdG9wOiBub2RlSWRUb3AsIGdhcDogY29uc3RyYWludC5nYXAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3ViR3JhcGhPbkhvcml6b250YWwgPSBuZXcgTWFwKCk7IC8vIHN1YmdyYXBoIGZyb20gdmVydGljYWwgUlAgY29uc3RyYWludHNcbiAgICAgIHZhciBzdWJHcmFwaE9uVmVydGljYWwgPSBuZXcgTWFwKCk7IC8vIHN1YmdyYXBoIGZyb20gdmVydGljYWwgUlAgY29uc3RyYWludHNcblxuICAgICAgLy8gY29uc3RydWN0IHN1YmdyYXBocyBmcm9tIHJlbGF0aXZlIHBsYWNlbWVudCBjb25zdHJhaW50cyBcbiAgICAgIHRoaXMuY29uc3RyYWludHMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50LmZvckVhY2goZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgaWYgKGNvbnN0cmFpbnQubGVmdCkge1xuICAgICAgICAgIHZhciBsZWZ0ID0gbm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudC5oYXMoY29uc3RyYWludC5sZWZ0KSA/IG5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KGNvbnN0cmFpbnQubGVmdCkgOiBjb25zdHJhaW50LmxlZnQ7XG4gICAgICAgICAgdmFyIHJpZ2h0ID0gbm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudC5oYXMoY29uc3RyYWludC5yaWdodCkgPyBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChjb25zdHJhaW50LnJpZ2h0KSA6IGNvbnN0cmFpbnQucmlnaHQ7XG4gICAgICAgICAgaWYgKHN1YkdyYXBoT25Ib3Jpem9udGFsLmhhcyhsZWZ0KSkge1xuICAgICAgICAgICAgc3ViR3JhcGhPbkhvcml6b250YWwuZ2V0KGxlZnQpLnB1c2gocmlnaHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJHcmFwaE9uSG9yaXpvbnRhbC5zZXQobGVmdCwgW3JpZ2h0XSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdWJHcmFwaE9uSG9yaXpvbnRhbC5oYXMocmlnaHQpKSB7XG4gICAgICAgICAgICBzdWJHcmFwaE9uSG9yaXpvbnRhbC5nZXQocmlnaHQpLnB1c2gobGVmdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YkdyYXBoT25Ib3Jpem9udGFsLnNldChyaWdodCwgW2xlZnRdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHRvcCA9IG5vZGVUb0R1bW15Rm9ySG9yaXpvbnRhbEFsaWdubWVudC5oYXMoY29uc3RyYWludC50b3ApID8gbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChjb25zdHJhaW50LnRvcCkgOiBjb25zdHJhaW50LnRvcDtcbiAgICAgICAgICB2YXIgYm90dG9tID0gbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50Lmhhcyhjb25zdHJhaW50LmJvdHRvbSkgPyBub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KGNvbnN0cmFpbnQuYm90dG9tKSA6IGNvbnN0cmFpbnQuYm90dG9tO1xuICAgICAgICAgIGlmIChzdWJHcmFwaE9uVmVydGljYWwuaGFzKHRvcCkpIHtcbiAgICAgICAgICAgIHN1YkdyYXBoT25WZXJ0aWNhbC5nZXQodG9wKS5wdXNoKGJvdHRvbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YkdyYXBoT25WZXJ0aWNhbC5zZXQodG9wLCBbYm90dG9tXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdWJHcmFwaE9uVmVydGljYWwuaGFzKGJvdHRvbSkpIHtcbiAgICAgICAgICAgIHN1YkdyYXBoT25WZXJ0aWNhbC5nZXQoYm90dG9tKS5wdXNoKHRvcCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YkdyYXBoT25WZXJ0aWNhbC5zZXQoYm90dG9tLCBbdG9wXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gZnVuY3Rpb24gdG8gY29uc3RydWN0IGNvbXBvbmVudHMgZnJvbSBhIGdpdmVuIGdyYXBoIFxuICAgICAgLy8gYWxzbyByZXR1cm5zIGFuIGFycmF5IHRoYXQga2VlcHMgd2hldGhlciBlYWNoIGNvbXBvbmVudCBjb250YWlucyBmaXhlZCBub2RlXG4gICAgICB2YXIgY29uc3RydWN0Q29tcG9uZW50cyA9IGZ1bmN0aW9uIGNvbnN0cnVjdENvbXBvbmVudHMoZ3JhcGgsIGZpeGVkTm9kZXMpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgdmFyIGlzRml4ZWQgPSBbXTtcbiAgICAgICAgdmFyIHF1ZXVlID0gbmV3IExpbmtlZExpc3QoKTtcbiAgICAgICAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICAgICAgZ3JhcGguZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgIGlmICghdmlzaXRlZC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgY29tcG9uZW50c1tjb3VudF0gPSBbXTtcbiAgICAgICAgICAgIGlzRml4ZWRbY291bnRdID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgY3VycmVudE5vZGUgPSBrZXk7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgIHZpc2l0ZWQuYWRkKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgIGNvbXBvbmVudHNbY291bnRdLnB1c2goY3VycmVudE5vZGUpO1xuXG4gICAgICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoICE9IDApIHtcbiAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICBpZiAoZml4ZWROb2Rlcy5oYXMoY3VycmVudE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgaXNGaXhlZFtjb3VudF0gPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBuZWlnaGJvcnMgPSBncmFwaC5nZXQoY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgICBuZWlnaGJvcnMuZm9yRWFjaChmdW5jdGlvbiAobmVpZ2hib3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWQuaGFzKG5laWdoYm9yKSkge1xuICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChuZWlnaGJvcik7XG4gICAgICAgICAgICAgICAgICB2aXNpdGVkLmFkZChuZWlnaGJvcik7XG4gICAgICAgICAgICAgICAgICBjb21wb25lbnRzW2NvdW50XS5wdXNoKG5laWdoYm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7IGNvbXBvbmVudHM6IGNvbXBvbmVudHMsIGlzRml4ZWQ6IGlzRml4ZWQgfTtcbiAgICAgIH07XG5cbiAgICAgIHZhciByZXN1bHRPbkhvcml6b250YWwgPSBjb25zdHJ1Y3RDb21wb25lbnRzKHN1YkdyYXBoT25Ib3Jpem9udGFsLCBzZWxmLmZpeGVkTm9kZXNPbkhvcml6b250YWwpO1xuICAgICAgdGhpcy5jb21wb25lbnRzT25Ib3Jpem9udGFsID0gcmVzdWx0T25Ib3Jpem9udGFsLmNvbXBvbmVudHM7XG4gICAgICB0aGlzLmZpeGVkQ29tcG9uZW50c09uSG9yaXpvbnRhbCA9IHJlc3VsdE9uSG9yaXpvbnRhbC5pc0ZpeGVkO1xuICAgICAgdmFyIHJlc3VsdE9uVmVydGljYWwgPSBjb25zdHJ1Y3RDb21wb25lbnRzKHN1YkdyYXBoT25WZXJ0aWNhbCwgc2VsZi5maXhlZE5vZGVzT25WZXJ0aWNhbCk7XG4gICAgICB0aGlzLmNvbXBvbmVudHNPblZlcnRpY2FsID0gcmVzdWx0T25WZXJ0aWNhbC5jb21wb25lbnRzO1xuICAgICAgdGhpcy5maXhlZENvbXBvbmVudHNPblZlcnRpY2FsID0gcmVzdWx0T25WZXJ0aWNhbC5pc0ZpeGVkO1xuICAgIH1cbiAgfVxufTtcblxuLy8gdXBkYXRlcyBub2RlIGRpc3BsYWNlbWVudHMgYmFzZWQgb24gY29uc3RyYWludHNcbkNvU0VMYXlvdXQucHJvdG90eXBlLnVwZGF0ZURpc3BsYWNlbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHRoaXMuY29uc3RyYWludHMuZml4ZWROb2RlQ29uc3RyYWludCkge1xuICAgIHRoaXMuY29uc3RyYWludHMuZml4ZWROb2RlQ29uc3RyYWludC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlRGF0YSkge1xuICAgICAgdmFyIGZpeGVkTm9kZSA9IHNlbGYuaWRUb05vZGVNYXAuZ2V0KG5vZGVEYXRhLm5vZGVJZCk7XG4gICAgICBmaXhlZE5vZGUuZGlzcGxhY2VtZW50WCA9IDA7XG4gICAgICBmaXhlZE5vZGUuZGlzcGxhY2VtZW50WSA9IDA7XG4gICAgfSk7XG4gIH1cblxuICBpZiAodGhpcy5jb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50KSB7XG4gICAgaWYgKHRoaXMuY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC52ZXJ0aWNhbCkge1xuICAgICAgdmFyIGFsbFZlcnRpY2FsQWxpZ25tZW50cyA9IHRoaXMuY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC52ZXJ0aWNhbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsVmVydGljYWxBbGlnbm1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0b3RhbERpc3BsYWNlbWVudFggPSAwO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFsbFZlcnRpY2FsQWxpZ25tZW50c1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmICh0aGlzLmZpeGVkTm9kZVNldC5oYXMoYWxsVmVydGljYWxBbGlnbm1lbnRzW2ldW2pdKSkge1xuICAgICAgICAgICAgdG90YWxEaXNwbGFjZW1lbnRYID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b3RhbERpc3BsYWNlbWVudFggKz0gdGhpcy5pZFRvTm9kZU1hcC5nZXQoYWxsVmVydGljYWxBbGlnbm1lbnRzW2ldW2pdKS5kaXNwbGFjZW1lbnRYO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdmVyYWdlRGlzcGxhY2VtZW50WCA9IHRvdGFsRGlzcGxhY2VtZW50WCAvIGFsbFZlcnRpY2FsQWxpZ25tZW50c1tpXS5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYWxsVmVydGljYWxBbGlnbm1lbnRzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdGhpcy5pZFRvTm9kZU1hcC5nZXQoYWxsVmVydGljYWxBbGlnbm1lbnRzW2ldW2pdKS5kaXNwbGFjZW1lbnRYID0gYXZlcmFnZURpc3BsYWNlbWVudFg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC5ob3Jpem9udGFsKSB7XG4gICAgICB2YXIgYWxsSG9yaXpvbnRhbEFsaWdubWVudHMgPSB0aGlzLmNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQuaG9yaXpvbnRhbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsSG9yaXpvbnRhbEFsaWdubWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRvdGFsRGlzcGxhY2VtZW50WSA9IDA7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYWxsSG9yaXpvbnRhbEFsaWdubWVudHNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5maXhlZE5vZGVTZXQuaGFzKGFsbEhvcml6b250YWxBbGlnbm1lbnRzW2ldW2pdKSkge1xuICAgICAgICAgICAgdG90YWxEaXNwbGFjZW1lbnRZID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b3RhbERpc3BsYWNlbWVudFkgKz0gdGhpcy5pZFRvTm9kZU1hcC5nZXQoYWxsSG9yaXpvbnRhbEFsaWdubWVudHNbaV1bal0pLmRpc3BsYWNlbWVudFk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF2ZXJhZ2VEaXNwbGFjZW1lbnRZID0gdG90YWxEaXNwbGFjZW1lbnRZIC8gYWxsSG9yaXpvbnRhbEFsaWdubWVudHNbaV0ubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFsbEhvcml6b250YWxBbGlnbm1lbnRzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdGhpcy5pZFRvTm9kZU1hcC5nZXQoYWxsSG9yaXpvbnRhbEFsaWdubWVudHNbaV1bal0pLmRpc3BsYWNlbWVudFkgPSBhdmVyYWdlRGlzcGxhY2VtZW50WTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLmNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCkge1xuXG4gICAgaWYgKENvU0VDb25zdGFudHMuUkVMQVhfTU9WRU1FTlRfT05fQ09OU1RSQUlOVFMpIHtcbiAgICAgIC8vIHNodWZmbGUgYXJyYXkgdG8gcmFuZG9taXplIG5vZGUgcHJvY2Vzc2luZyBvcmRlclxuICAgICAgaWYgKHRoaXMudG90YWxJdGVyYXRpb25zICUgMTAgPT0gMCkge1xuICAgICAgICB0aGlzLnNodWZmbGUodGhpcy5ub2Rlc0luUmVsYXRpdmVIb3Jpem9udGFsKTtcbiAgICAgICAgdGhpcy5zaHVmZmxlKHRoaXMubm9kZXNJblJlbGF0aXZlVmVydGljYWwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5vZGVzSW5SZWxhdGl2ZUhvcml6b250YWwuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgIGlmICghc2VsZi5maXhlZE5vZGVzT25Ib3Jpem9udGFsLmhhcyhub2RlSWQpKSB7XG4gICAgICAgICAgdmFyIGRpc3BsYWNlbWVudCA9IDA7XG4gICAgICAgICAgaWYgKHNlbGYuZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudC5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgZGlzcGxhY2VtZW50ID0gc2VsZi5pZFRvTm9kZU1hcC5nZXQoc2VsZi5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChub2RlSWQpWzBdKS5kaXNwbGFjZW1lbnRYO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXNwbGFjZW1lbnQgPSBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWQpLmRpc3BsYWNlbWVudFg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYubm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwSG9yaXpvbnRhbC5nZXQobm9kZUlkKS5mb3JFYWNoKGZ1bmN0aW9uIChjb25zdHJhaW50KSB7XG4gICAgICAgICAgICBpZiAoY29uc3RyYWludC5yaWdodCkge1xuICAgICAgICAgICAgICB2YXIgZGlmZiA9IHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwSG9yaXpvbnRhbC5nZXQoY29uc3RyYWludC5yaWdodCkgLSBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcEhvcml6b250YWwuZ2V0KG5vZGVJZCkgLSBkaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgIGlmIChkaWZmIDwgY29uc3RyYWludC5nYXApIHtcbiAgICAgICAgICAgICAgICBkaXNwbGFjZW1lbnQgLT0gY29uc3RyYWludC5nYXAgLSBkaWZmO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgZGlmZiA9IHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwSG9yaXpvbnRhbC5nZXQobm9kZUlkKSAtIHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwSG9yaXpvbnRhbC5nZXQoY29uc3RyYWludC5sZWZ0KSArIGRpc3BsYWNlbWVudDtcbiAgICAgICAgICAgICAgaWYgKGRpZmYgPCBjb25zdHJhaW50LmdhcCkge1xuICAgICAgICAgICAgICAgIGRpc3BsYWNlbWVudCArPSBjb25zdHJhaW50LmdhcCAtIGRpZmY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcEhvcml6b250YWwuc2V0KG5vZGVJZCwgc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBIb3Jpem9udGFsLmdldChub2RlSWQpICsgZGlzcGxhY2VtZW50KTtcbiAgICAgICAgICBpZiAoc2VsZi5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50Lmhhcyhub2RlSWQpKSB7XG4gICAgICAgICAgICBzZWxmLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KG5vZGVJZCkuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICAgIHNlbGYuaWRUb05vZGVNYXAuZ2V0KG5vZGVJZCkuZGlzcGxhY2VtZW50WCA9IGRpc3BsYWNlbWVudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWQpLmRpc3BsYWNlbWVudFggPSBkaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5ub2Rlc0luUmVsYXRpdmVWZXJ0aWNhbC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgaWYgKCFzZWxmLmZpeGVkTm9kZXNPbkhvcml6b250YWwuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICB2YXIgZGlzcGxhY2VtZW50ID0gMDtcbiAgICAgICAgICBpZiAoc2VsZi5kdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICAgIGRpc3BsYWNlbWVudCA9IHNlbGYuaWRUb05vZGVNYXAuZ2V0KHNlbGYuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChub2RlSWQpWzBdKS5kaXNwbGFjZW1lbnRZO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXNwbGFjZW1lbnQgPSBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWQpLmRpc3BsYWNlbWVudFk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYubm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwVmVydGljYWwuZ2V0KG5vZGVJZCkuZm9yRWFjaChmdW5jdGlvbiAoY29uc3RyYWludCkge1xuICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQuYm90dG9tKSB7XG4gICAgICAgICAgICAgIHZhciBkaWZmID0gc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBWZXJ0aWNhbC5nZXQoY29uc3RyYWludC5ib3R0b20pIC0gc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBWZXJ0aWNhbC5nZXQobm9kZUlkKSAtIGRpc3BsYWNlbWVudDtcbiAgICAgICAgICAgICAgaWYgKGRpZmYgPCBjb25zdHJhaW50LmdhcCkge1xuICAgICAgICAgICAgICAgIGRpc3BsYWNlbWVudCAtPSBjb25zdHJhaW50LmdhcCAtIGRpZmY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBkaWZmID0gc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBWZXJ0aWNhbC5nZXQobm9kZUlkKSAtIHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwVmVydGljYWwuZ2V0KGNvbnN0cmFpbnQudG9wKSArIGRpc3BsYWNlbWVudDtcbiAgICAgICAgICAgICAgaWYgKGRpZmYgPCBjb25zdHJhaW50LmdhcCkge1xuICAgICAgICAgICAgICAgIGRpc3BsYWNlbWVudCArPSBjb25zdHJhaW50LmdhcCAtIGRpZmY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcFZlcnRpY2FsLnNldChub2RlSWQsIHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwVmVydGljYWwuZ2V0KG5vZGVJZCkgKyBkaXNwbGFjZW1lbnQpO1xuICAgICAgICAgIGlmIChzZWxmLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgc2VsZi5kdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KG5vZGVJZCkuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICAgIHNlbGYuaWRUb05vZGVNYXAuZ2V0KG5vZGVJZCkuZGlzcGxhY2VtZW50WSA9IGRpc3BsYWNlbWVudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWQpLmRpc3BsYWNlbWVudFkgPSBkaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbXBvbmVudHNPbkhvcml6b250YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50c09uSG9yaXpvbnRhbFtpXTtcbiAgICAgICAgaWYgKHRoaXMuZml4ZWRDb21wb25lbnRzT25Ib3Jpem9udGFsW2ldKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb21wb25lbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuaGFzKGNvbXBvbmVudFtqXSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChjb21wb25lbnRbal0pLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICAgIHNlbGYuaWRUb05vZGVNYXAuZ2V0KG5vZGVJZCkuZGlzcGxhY2VtZW50WCA9IDA7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5pZFRvTm9kZU1hcC5nZXQoY29tcG9uZW50W2pdKS5kaXNwbGFjZW1lbnRYID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbXBvbmVudC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudC5oYXMoY29tcG9uZW50W2pdKSkge1xuICAgICAgICAgICAgICB2YXIgYWN0dWFsTm9kZXMgPSB0aGlzLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KGNvbXBvbmVudFtqXSk7XG4gICAgICAgICAgICAgIHN1bSArPSBhY3R1YWxOb2Rlcy5sZW5ndGggKiB0aGlzLmlkVG9Ob2RlTWFwLmdldChhY3R1YWxOb2Rlc1swXSkuZGlzcGxhY2VtZW50WDtcbiAgICAgICAgICAgICAgY291bnQgKz0gYWN0dWFsTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3VtICs9IHRoaXMuaWRUb05vZGVNYXAuZ2V0KGNvbXBvbmVudFtqXSkuZGlzcGxhY2VtZW50WDtcbiAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGF2ZXJhZ2VEaXNwbGFjZW1lbnQgPSBzdW0gLyBjb3VudDtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbXBvbmVudC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudC5oYXMoY29tcG9uZW50W2pdKSkge1xuICAgICAgICAgICAgICB0aGlzLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KGNvbXBvbmVudFtqXSkuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pZFRvTm9kZU1hcC5nZXQobm9kZUlkKS5kaXNwbGFjZW1lbnRYID0gYXZlcmFnZURpc3BsYWNlbWVudDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmlkVG9Ob2RlTWFwLmdldChjb21wb25lbnRbal0pLmRpc3BsYWNlbWVudFggPSBhdmVyYWdlRGlzcGxhY2VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29tcG9uZW50c09uVmVydGljYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50c09uVmVydGljYWxbaV07XG4gICAgICAgIGlmICh0aGlzLmZpeGVkQ29tcG9uZW50c09uVmVydGljYWxbaV0pIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbXBvbmVudC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50Lmhhcyhjb21wb25lbnRbal0pKSB7XG4gICAgICAgICAgICAgIHRoaXMuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChjb21wb25lbnRbal0pLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICAgIHNlbGYuaWRUb05vZGVNYXAuZ2V0KG5vZGVJZCkuZGlzcGxhY2VtZW50WSA9IDA7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5pZFRvTm9kZU1hcC5nZXQoY29tcG9uZW50W2pdKS5kaXNwbGFjZW1lbnRZID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbXBvbmVudC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50Lmhhcyhjb21wb25lbnRbal0pKSB7XG4gICAgICAgICAgICAgIHZhciBhY3R1YWxOb2RlcyA9IHRoaXMuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChjb21wb25lbnRbal0pO1xuICAgICAgICAgICAgICBzdW0gKz0gYWN0dWFsTm9kZXMubGVuZ3RoICogdGhpcy5pZFRvTm9kZU1hcC5nZXQoYWN0dWFsTm9kZXNbMF0pLmRpc3BsYWNlbWVudFk7XG4gICAgICAgICAgICAgIGNvdW50ICs9IGFjdHVhbE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN1bSArPSB0aGlzLmlkVG9Ob2RlTWFwLmdldChjb21wb25lbnRbal0pLmRpc3BsYWNlbWVudFk7XG4gICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhdmVyYWdlRGlzcGxhY2VtZW50ID0gc3VtIC8gY291bnQ7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb21wb25lbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5oYXMoY29tcG9uZW50W2pdKSkge1xuICAgICAgICAgICAgICB0aGlzLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5nZXQoY29tcG9uZW50W2pdKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWQpLmRpc3BsYWNlbWVudFkgPSBhdmVyYWdlRGlzcGxhY2VtZW50O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuaWRUb05vZGVNYXAuZ2V0KGNvbXBvbmVudFtqXSkuZGlzcGxhY2VtZW50WSA9IGF2ZXJhZ2VEaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jYWxjdWxhdGVOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvblRvID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZUxpc3QgPSBbXTtcbiAgdmFyIGdyYXBoO1xuXG4gIHZhciBncmFwaHMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRHcmFwaHMoKTtcbiAgdmFyIHNpemUgPSBncmFwaHMubGVuZ3RoO1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIGdyYXBoID0gZ3JhcGhzW2ldO1xuXG4gICAgZ3JhcGgudXBkYXRlQ29ubmVjdGVkKCk7XG5cbiAgICBpZiAoIWdyYXBoLmlzQ29ubmVjdGVkKSB7XG4gICAgICBub2RlTGlzdCA9IG5vZGVMaXN0LmNvbmNhdChncmFwaC5nZXROb2RlcygpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZUxpc3Q7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jcmVhdGVCZW5kcG9pbnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWRnZXMgPSBbXTtcbiAgZWRnZXMgPSBlZGdlcy5jb25jYXQodGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsRWRnZXMoKSk7XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcblxuICAgIGlmICghdmlzaXRlZC5oYXMoZWRnZSkpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBlZGdlLmdldFNvdXJjZSgpO1xuICAgICAgdmFyIHRhcmdldCA9IGVkZ2UuZ2V0VGFyZ2V0KCk7XG5cbiAgICAgIGlmIChzb3VyY2UgPT0gdGFyZ2V0KSB7XG4gICAgICAgIGVkZ2UuZ2V0QmVuZHBvaW50cygpLnB1c2gobmV3IFBvaW50RCgpKTtcbiAgICAgICAgZWRnZS5nZXRCZW5kcG9pbnRzKCkucHVzaChuZXcgUG9pbnREKCkpO1xuICAgICAgICB0aGlzLmNyZWF0ZUR1bW15Tm9kZXNGb3JCZW5kcG9pbnRzKGVkZ2UpO1xuICAgICAgICB2aXNpdGVkLmFkZChlZGdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlZGdlTGlzdCA9IFtdO1xuXG4gICAgICAgIGVkZ2VMaXN0ID0gZWRnZUxpc3QuY29uY2F0KHNvdXJjZS5nZXRFZGdlTGlzdFRvTm9kZSh0YXJnZXQpKTtcbiAgICAgICAgZWRnZUxpc3QgPSBlZGdlTGlzdC5jb25jYXQodGFyZ2V0LmdldEVkZ2VMaXN0VG9Ob2RlKHNvdXJjZSkpO1xuXG4gICAgICAgIGlmICghdmlzaXRlZC5oYXMoZWRnZUxpc3RbMF0pKSB7XG4gICAgICAgICAgaWYgKGVkZ2VMaXN0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGVkZ2VMaXN0Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgIHZhciBtdWx0aUVkZ2UgPSBlZGdlTGlzdFtrXTtcbiAgICAgICAgICAgICAgbXVsdGlFZGdlLmdldEJlbmRwb2ludHMoKS5wdXNoKG5ldyBQb2ludEQoKSk7XG4gICAgICAgICAgICAgIHRoaXMuY3JlYXRlRHVtbXlOb2Rlc0ZvckJlbmRwb2ludHMobXVsdGlFZGdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWRnZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgICAgdmlzaXRlZC5hZGQoZWRnZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmlzaXRlZC5zaXplID09IGVkZ2VzLmxlbmd0aCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5wb3NpdGlvbk5vZGVzUmFkaWFsbHkgPSBmdW5jdGlvbiAoZm9yZXN0KSB7XG4gIC8vIFdlIHRpbGUgdGhlIHRyZWVzIHRvIGEgZ3JpZCByb3cgYnkgcm93OyBmaXJzdCB0cmVlIHN0YXJ0cyBhdCAoMCwwKVxuICB2YXIgY3VycmVudFN0YXJ0aW5nUG9pbnQgPSBuZXcgUG9pbnQoMCwgMCk7XG4gIHZhciBudW1iZXJPZkNvbHVtbnMgPSBNYXRoLmNlaWwoTWF0aC5zcXJ0KGZvcmVzdC5sZW5ndGgpKTtcbiAgdmFyIGhlaWdodCA9IDA7XG4gIHZhciBjdXJyZW50WSA9IDA7XG4gIHZhciBjdXJyZW50WCA9IDA7XG4gIHZhciBwb2ludCA9IG5ldyBQb2ludEQoMCwgMCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3Jlc3QubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaSAlIG51bWJlck9mQ29sdW1ucyA9PSAwKSB7XG4gICAgICAvLyBTdGFydCBvZiBhIG5ldyByb3csIG1ha2UgdGhlIHggY29vcmRpbmF0ZSAwLCBpbmNyZW1lbnQgdGhlXG4gICAgICAvLyB5IGNvb3JkaW5hdGUgd2l0aCB0aGUgbWF4IGhlaWdodCBvZiB0aGUgcHJldmlvdXMgcm93XG4gICAgICBjdXJyZW50WCA9IDA7XG4gICAgICBjdXJyZW50WSA9IGhlaWdodDtcblxuICAgICAgaWYgKGkgIT0gMCkge1xuICAgICAgICBjdXJyZW50WSArPSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09NUE9ORU5UX1NFUEVSQVRJT047XG4gICAgICB9XG5cbiAgICAgIGhlaWdodCA9IDA7XG4gICAgfVxuXG4gICAgdmFyIHRyZWUgPSBmb3Jlc3RbaV07XG5cbiAgICAvLyBGaW5kIHRoZSBjZW50ZXIgb2YgdGhlIHRyZWVcbiAgICB2YXIgY2VudGVyTm9kZSA9IExheW91dC5maW5kQ2VudGVyT2ZUcmVlKHRyZWUpO1xuXG4gICAgLy8gU2V0IHRoZSBzdGFyaW5nIHBvaW50IG9mIHRoZSBuZXh0IHRyZWVcbiAgICBjdXJyZW50U3RhcnRpbmdQb2ludC54ID0gY3VycmVudFg7XG4gICAgY3VycmVudFN0YXJ0aW5nUG9pbnQueSA9IGN1cnJlbnRZO1xuXG4gICAgLy8gRG8gYSByYWRpYWwgbGF5b3V0IHN0YXJ0aW5nIHdpdGggdGhlIGNlbnRlclxuICAgIHBvaW50ID0gQ29TRUxheW91dC5yYWRpYWxMYXlvdXQodHJlZSwgY2VudGVyTm9kZSwgY3VycmVudFN0YXJ0aW5nUG9pbnQpO1xuXG4gICAgaWYgKHBvaW50LnkgPiBoZWlnaHQpIHtcbiAgICAgIGhlaWdodCA9IE1hdGguZmxvb3IocG9pbnQueSk7XG4gICAgfVxuXG4gICAgY3VycmVudFggPSBNYXRoLmZsb29yKHBvaW50LnggKyBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09NUE9ORU5UX1NFUEVSQVRJT04pO1xuICB9XG5cbiAgdGhpcy50cmFuc2Zvcm0obmV3IFBvaW50RChMYXlvdXRDb25zdGFudHMuV09STERfQ0VOVEVSX1ggLSBwb2ludC54IC8gMiwgTGF5b3V0Q29uc3RhbnRzLldPUkxEX0NFTlRFUl9ZIC0gcG9pbnQueSAvIDIpKTtcbn07XG5cbkNvU0VMYXlvdXQucmFkaWFsTGF5b3V0ID0gZnVuY3Rpb24gKHRyZWUsIGNlbnRlck5vZGUsIHN0YXJ0aW5nUG9pbnQpIHtcbiAgdmFyIHJhZGlhbFNlcCA9IE1hdGgubWF4KHRoaXMubWF4RGlhZ29uYWxJblRyZWUodHJlZSksIENvU0VDb25zdGFudHMuREVGQVVMVF9SQURJQUxfU0VQQVJBVElPTik7XG4gIENvU0VMYXlvdXQuYnJhbmNoUmFkaWFsTGF5b3V0KGNlbnRlck5vZGUsIG51bGwsIDAsIDM1OSwgMCwgcmFkaWFsU2VwKTtcbiAgdmFyIGJvdW5kcyA9IExHcmFwaC5jYWxjdWxhdGVCb3VuZHModHJlZSk7XG5cbiAgdmFyIHRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0oKTtcbiAgdHJhbnNmb3JtLnNldERldmljZU9yZ1goYm91bmRzLmdldE1pblgoKSk7XG4gIHRyYW5zZm9ybS5zZXREZXZpY2VPcmdZKGJvdW5kcy5nZXRNaW5ZKCkpO1xuICB0cmFuc2Zvcm0uc2V0V29ybGRPcmdYKHN0YXJ0aW5nUG9pbnQueCk7XG4gIHRyYW5zZm9ybS5zZXRXb3JsZE9yZ1koc3RhcnRpbmdQb2ludC55KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IHRyZWVbaV07XG4gICAgbm9kZS50cmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgfVxuXG4gIHZhciBib3R0b21SaWdodCA9IG5ldyBQb2ludEQoYm91bmRzLmdldE1heFgoKSwgYm91bmRzLmdldE1heFkoKSk7XG5cbiAgcmV0dXJuIHRyYW5zZm9ybS5pbnZlcnNlVHJhbnNmb3JtUG9pbnQoYm90dG9tUmlnaHQpO1xufTtcblxuQ29TRUxheW91dC5icmFuY2hSYWRpYWxMYXlvdXQgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50T2ZOb2RlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgZGlzdGFuY2UsIHJhZGlhbFNlcGFyYXRpb24pIHtcbiAgLy8gRmlyc3QsIHBvc2l0aW9uIHRoaXMgbm9kZSBieSBmaW5kaW5nIGl0cyBhbmdsZS5cbiAgdmFyIGhhbGZJbnRlcnZhbCA9IChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUgKyAxKSAvIDI7XG5cbiAgaWYgKGhhbGZJbnRlcnZhbCA8IDApIHtcbiAgICBoYWxmSW50ZXJ2YWwgKz0gMTgwO1xuICB9XG5cbiAgdmFyIG5vZGVBbmdsZSA9IChoYWxmSW50ZXJ2YWwgKyBzdGFydEFuZ2xlKSAlIDM2MDtcbiAgdmFyIHRldGEgPSBub2RlQW5nbGUgKiBJR2VvbWV0cnkuVFdPX1BJIC8gMzYwO1xuXG4gIC8vIE1ha2UgcG9sYXIgdG8gamF2YSBjb3JkaW5hdGUgY29udmVyc2lvbi5cbiAgdmFyIGNvc190ZXRhID0gTWF0aC5jb3ModGV0YSk7XG4gIHZhciB4XyA9IGRpc3RhbmNlICogTWF0aC5jb3ModGV0YSk7XG4gIHZhciB5XyA9IGRpc3RhbmNlICogTWF0aC5zaW4odGV0YSk7XG5cbiAgbm9kZS5zZXRDZW50ZXIoeF8sIHlfKTtcblxuICAvLyBUcmF2ZXJzZSBhbGwgbmVpZ2hib3JzIG9mIHRoaXMgbm9kZSBhbmQgcmVjdXJzaXZlbHkgY2FsbCB0aGlzXG4gIC8vIGZ1bmN0aW9uLlxuICB2YXIgbmVpZ2hib3JFZGdlcyA9IFtdO1xuICBuZWlnaGJvckVkZ2VzID0gbmVpZ2hib3JFZGdlcy5jb25jYXQobm9kZS5nZXRFZGdlcygpKTtcbiAgdmFyIGNoaWxkQ291bnQgPSBuZWlnaGJvckVkZ2VzLmxlbmd0aDtcblxuICBpZiAocGFyZW50T2ZOb2RlICE9IG51bGwpIHtcbiAgICBjaGlsZENvdW50LS07XG4gIH1cblxuICB2YXIgYnJhbmNoQ291bnQgPSAwO1xuXG4gIHZhciBpbmNFZGdlc0NvdW50ID0gbmVpZ2hib3JFZGdlcy5sZW5ndGg7XG4gIHZhciBzdGFydEluZGV4O1xuXG4gIHZhciBlZGdlcyA9IG5vZGUuZ2V0RWRnZXNCZXR3ZWVuKHBhcmVudE9mTm9kZSk7XG5cbiAgLy8gSWYgdGhlcmUgYXJlIG11bHRpcGxlIGVkZ2VzLCBwcnVuZSB0aGVtIHVudGlsIHRoZXJlIHJlbWFpbnMgb25seSBvbmVcbiAgLy8gZWRnZS5cbiAgd2hpbGUgKGVkZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAvL25laWdoYm9yRWRnZXMucmVtb3ZlKGVkZ2VzLnJlbW92ZSgwKSk7XG4gICAgdmFyIHRlbXAgPSBlZGdlc1swXTtcbiAgICBlZGdlcy5zcGxpY2UoMCwgMSk7XG4gICAgdmFyIGluZGV4ID0gbmVpZ2hib3JFZGdlcy5pbmRleE9mKHRlbXApO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBuZWlnaGJvckVkZ2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIGluY0VkZ2VzQ291bnQtLTtcbiAgICBjaGlsZENvdW50LS07XG4gIH1cblxuICBpZiAocGFyZW50T2ZOb2RlICE9IG51bGwpIHtcbiAgICAvL2Fzc2VydCBlZGdlcy5sZW5ndGggPT0gMTtcbiAgICBzdGFydEluZGV4ID0gKG5laWdoYm9yRWRnZXMuaW5kZXhPZihlZGdlc1swXSkgKyAxKSAlIGluY0VkZ2VzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRJbmRleCA9IDA7XG4gIH1cblxuICB2YXIgc3RlcEFuZ2xlID0gTWF0aC5hYnMoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSAvIGNoaWxkQ291bnQ7XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGJyYW5jaENvdW50ICE9IGNoaWxkQ291bnQ7IGkgPSArK2kgJSBpbmNFZGdlc0NvdW50KSB7XG4gICAgdmFyIGN1cnJlbnROZWlnaGJvciA9IG5laWdoYm9yRWRnZXNbaV0uZ2V0T3RoZXJFbmQobm9kZSk7XG5cbiAgICAvLyBEb24ndCBiYWNrIHRyYXZlcnNlIHRvIHJvb3Qgbm9kZSBpbiBjdXJyZW50IHRyZWUuXG4gICAgaWYgKGN1cnJlbnROZWlnaGJvciA9PSBwYXJlbnRPZk5vZGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBjaGlsZFN0YXJ0QW5nbGUgPSAoc3RhcnRBbmdsZSArIGJyYW5jaENvdW50ICogc3RlcEFuZ2xlKSAlIDM2MDtcbiAgICB2YXIgY2hpbGRFbmRBbmdsZSA9IChjaGlsZFN0YXJ0QW5nbGUgKyBzdGVwQW5nbGUpICUgMzYwO1xuXG4gICAgQ29TRUxheW91dC5icmFuY2hSYWRpYWxMYXlvdXQoY3VycmVudE5laWdoYm9yLCBub2RlLCBjaGlsZFN0YXJ0QW5nbGUsIGNoaWxkRW5kQW5nbGUsIGRpc3RhbmNlICsgcmFkaWFsU2VwYXJhdGlvbiwgcmFkaWFsU2VwYXJhdGlvbik7XG5cbiAgICBicmFuY2hDb3VudCsrO1xuICB9XG59O1xuXG5Db1NFTGF5b3V0Lm1heERpYWdvbmFsSW5UcmVlID0gZnVuY3Rpb24gKHRyZWUpIHtcbiAgdmFyIG1heERpYWdvbmFsID0gSW50ZWdlci5NSU5fVkFMVUU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSB0cmVlW2ldO1xuICAgIHZhciBkaWFnb25hbCA9IG5vZGUuZ2V0RGlhZ29uYWwoKTtcblxuICAgIGlmIChkaWFnb25hbCA+IG1heERpYWdvbmFsKSB7XG4gICAgICBtYXhEaWFnb25hbCA9IGRpYWdvbmFsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXhEaWFnb25hbDtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmNhbGNSZXB1bHNpb25SYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gZm9ybXVsYSBpcyAyIHggKGxldmVsICsgMSkgeCBpZGVhbEVkZ2VMZW5ndGhcbiAgcmV0dXJuIDIgKiAodGhpcy5sZXZlbCArIDEpICogdGhpcy5pZGVhbEVkZ2VMZW5ndGg7XG59O1xuXG4vLyBUaWxpbmcgbWV0aG9kc1xuXG4vLyBHcm91cCB6ZXJvIGRlZ3JlZSBtZW1iZXJzIHdob3NlIHBhcmVudHMgYXJlIG5vdCB0byBiZSB0aWxlZCwgY3JlYXRlIGR1bW15IHBhcmVudHMgd2hlcmUgbmVlZGVkIGFuZCBmaWxsIG1lbWJlckdyb3VwcyBieSB0aGVpciBkdW1tcCBwYXJlbnQgaWQnc1xuQ29TRUxheW91dC5wcm90b3R5cGUuZ3JvdXBaZXJvRGVncmVlTWVtYmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICAvLyBhcnJheSBvZiBbcGFyZW50X2lkIHggb25lRGVncmVlTm9kZV9pZF1cbiAgdmFyIHRlbXBNZW1iZXJHcm91cHMgPSB7fTsgLy8gQSB0ZW1wb3JhcnkgbWFwIG9mIHBhcmVudCBub2RlIGFuZCBpdHMgemVybyBkZWdyZWUgbWVtYmVyc1xuICB0aGlzLm1lbWJlckdyb3VwcyA9IHt9OyAvLyBBIG1hcCBvZiBkdW1teSBwYXJlbnQgbm9kZSBhbmQgaXRzIHplcm8gZGVncmVlIG1lbWJlcnMgd2hvc2UgcGFyZW50cyBhcmUgbm90IHRvIGJlIHRpbGVkXG4gIHRoaXMuaWRUb0R1bW15Tm9kZSA9IHt9OyAvLyBBIG1hcCBvZiBpZCB0byBkdW1teSBub2RlIFxuXG4gIHZhciB6ZXJvRGVncmVlID0gW107IC8vIExpc3Qgb2YgemVybyBkZWdyZWUgbm9kZXMgd2hvc2UgcGFyZW50cyBhcmUgbm90IHRvIGJlIHRpbGVkXG4gIHZhciBhbGxOb2RlcyA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbE5vZGVzKCk7XG5cbiAgLy8gRmlsbCB6ZXJvIGRlZ3JlZSBsaXN0XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IGFsbE5vZGVzW2ldO1xuICAgIHZhciBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICAgIC8vIElmIGEgbm9kZSBoYXMgemVybyBkZWdyZWUgYW5kIGl0cyBwYXJlbnQgaXMgbm90IHRvIGJlIHRpbGVkIGlmIGV4aXN0cyBhZGQgdGhhdCBub2RlIHRvIHplcm9EZWdyZXMgbGlzdFxuICAgIGlmICh0aGlzLmdldE5vZGVEZWdyZWVXaXRoQ2hpbGRyZW4obm9kZSkgPT09IDAgJiYgKHBhcmVudC5pZCA9PSB1bmRlZmluZWQgfHwgIXRoaXMuZ2V0VG9CZVRpbGVkKHBhcmVudCkpKSB7XG4gICAgICB6ZXJvRGVncmVlLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIGEgbWFwIG9mIHBhcmVudCBub2RlIGFuZCBpdHMgemVybyBkZWdyZWUgbWVtYmVyc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHplcm9EZWdyZWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IHplcm9EZWdyZWVbaV07IC8vIFplcm8gZGVncmVlIG5vZGUgaXRzZWxmXG4gICAgdmFyIHBfaWQgPSBub2RlLmdldFBhcmVudCgpLmlkOyAvLyBQYXJlbnQgaWRcblxuICAgIGlmICh0eXBlb2YgdGVtcE1lbWJlckdyb3Vwc1twX2lkXSA9PT0gXCJ1bmRlZmluZWRcIikgdGVtcE1lbWJlckdyb3Vwc1twX2lkXSA9IFtdO1xuXG4gICAgdGVtcE1lbWJlckdyb3Vwc1twX2lkXSA9IHRlbXBNZW1iZXJHcm91cHNbcF9pZF0uY29uY2F0KG5vZGUpOyAvLyBQdXNoIG5vZGUgdG8gdGhlIGxpc3QgYmVsb25ncyB0byBpdHMgcGFyZW50IGluIHRlbXBNZW1iZXJHcm91cHNcbiAgfVxuXG4gIC8vIElmIHRoZXJlIGFyZSBhdCBsZWFzdCB0d28gbm9kZXMgYXQgYSBsZXZlbCwgY3JlYXRlIGEgZHVtbXkgY29tcG91bmQgZm9yIHRoZW1cbiAgT2JqZWN0LmtleXModGVtcE1lbWJlckdyb3VwcykuZm9yRWFjaChmdW5jdGlvbiAocF9pZCkge1xuICAgIGlmICh0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdLmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBkdW1teUNvbXBvdW5kSWQgPSBcIkR1bW15Q29tcG91bmRfXCIgKyBwX2lkOyAvLyBUaGUgaWQgb2YgZHVtbXkgY29tcG91bmQgd2hpY2ggd2lsbCBiZSBjcmVhdGVkIHNvb25cbiAgICAgIHNlbGYubWVtYmVyR3JvdXBzW2R1bW15Q29tcG91bmRJZF0gPSB0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdOyAvLyBBZGQgZHVtbXkgY29tcG91bmQgdG8gbWVtYmVyR3JvdXBzXG5cbiAgICAgIHZhciBwYXJlbnQgPSB0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdWzBdLmdldFBhcmVudCgpOyAvLyBUaGUgcGFyZW50IG9mIHplcm8gZGVncmVlIG5vZGVzIHdpbGwgYmUgdGhlIHBhcmVudCBvZiBuZXcgZHVtbXkgY29tcG91bmRcblxuICAgICAgLy8gQ3JlYXRlIGEgZHVtbXkgY29tcG91bmQgd2l0aCBjYWxjdWxhdGVkIGlkXG4gICAgICB2YXIgZHVtbXlDb21wb3VuZCA9IG5ldyBDb1NFTm9kZShzZWxmLmdyYXBoTWFuYWdlcik7XG4gICAgICBkdW1teUNvbXBvdW5kLmlkID0gZHVtbXlDb21wb3VuZElkO1xuICAgICAgZHVtbXlDb21wb3VuZC5wYWRkaW5nTGVmdCA9IHBhcmVudC5wYWRkaW5nTGVmdCB8fCAwO1xuICAgICAgZHVtbXlDb21wb3VuZC5wYWRkaW5nUmlnaHQgPSBwYXJlbnQucGFkZGluZ1JpZ2h0IHx8IDA7XG4gICAgICBkdW1teUNvbXBvdW5kLnBhZGRpbmdCb3R0b20gPSBwYXJlbnQucGFkZGluZ0JvdHRvbSB8fCAwO1xuICAgICAgZHVtbXlDb21wb3VuZC5wYWRkaW5nVG9wID0gcGFyZW50LnBhZGRpbmdUb3AgfHwgMDtcblxuICAgICAgc2VsZi5pZFRvRHVtbXlOb2RlW2R1bW15Q29tcG91bmRJZF0gPSBkdW1teUNvbXBvdW5kO1xuXG4gICAgICB2YXIgZHVtbXlQYXJlbnRHcmFwaCA9IHNlbGYuZ2V0R3JhcGhNYW5hZ2VyKCkuYWRkKHNlbGYubmV3R3JhcGgoKSwgZHVtbXlDb21wb3VuZCk7XG4gICAgICB2YXIgcGFyZW50R3JhcGggPSBwYXJlbnQuZ2V0Q2hpbGQoKTtcblxuICAgICAgLy8gQWRkIGR1bW15IGNvbXBvdW5kIHRvIHBhcmVudCB0aGUgZ3JhcGhcbiAgICAgIHBhcmVudEdyYXBoLmFkZChkdW1teUNvbXBvdW5kKTtcblxuICAgICAgLy8gRm9yIGVhY2ggemVybyBkZWdyZWUgbm9kZSBpbiB0aGlzIGxldmVsIHJlbW92ZSBpdCBmcm9tIGl0cyBwYXJlbnQgZ3JhcGggYW5kIGFkZCBpdCB0byB0aGUgZ3JhcGggb2YgZHVtbXkgcGFyZW50XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlbXBNZW1iZXJHcm91cHNbcF9pZF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdW2ldO1xuXG4gICAgICAgIHBhcmVudEdyYXBoLnJlbW92ZShub2RlKTtcbiAgICAgICAgZHVtbXlQYXJlbnRHcmFwaC5hZGQobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmNsZWFyQ29tcG91bmRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2hpbGRHcmFwaE1hcCA9IHt9O1xuICB2YXIgaWRUb05vZGUgPSB7fTtcblxuICAvLyBHZXQgY29tcG91bmQgb3JkZXJpbmcgYnkgZmluZGluZyB0aGUgaW5uZXIgb25lIGZpcnN0XG4gIHRoaXMucGVyZm9ybURGU09uQ29tcG91bmRzKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbXBvdW5kT3JkZXIubGVuZ3RoOyBpKyspIHtcblxuICAgIGlkVG9Ob2RlW3RoaXMuY29tcG91bmRPcmRlcltpXS5pZF0gPSB0aGlzLmNvbXBvdW5kT3JkZXJbaV07XG4gICAgY2hpbGRHcmFwaE1hcFt0aGlzLmNvbXBvdW5kT3JkZXJbaV0uaWRdID0gW10uY29uY2F0KHRoaXMuY29tcG91bmRPcmRlcltpXS5nZXRDaGlsZCgpLmdldE5vZGVzKCkpO1xuXG4gICAgLy8gUmVtb3ZlIGNoaWxkcmVuIG9mIGNvbXBvdW5kc1xuICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlbW92ZSh0aGlzLmNvbXBvdW5kT3JkZXJbaV0uZ2V0Q2hpbGQoKSk7XG4gICAgdGhpcy5jb21wb3VuZE9yZGVyW2ldLmNoaWxkID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXMoKTtcblxuICAvLyBUaWxlIHRoZSByZW1vdmVkIGNoaWxkcmVuXG4gIHRoaXMudGlsZUNvbXBvdW5kTWVtYmVycyhjaGlsZEdyYXBoTWFwLCBpZFRvTm9kZSk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jbGVhclplcm9EZWdyZWVNZW1iZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0aWxlZFplcm9EZWdyZWVQYWNrID0gdGhpcy50aWxlZFplcm9EZWdyZWVQYWNrID0gW107XG5cbiAgT2JqZWN0LmtleXModGhpcy5tZW1iZXJHcm91cHMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGNvbXBvdW5kTm9kZSA9IHNlbGYuaWRUb0R1bW15Tm9kZVtpZF07IC8vIEdldCB0aGUgZHVtbXkgY29tcG91bmRcblxuICAgIHRpbGVkWmVyb0RlZ3JlZVBhY2tbaWRdID0gc2VsZi50aWxlTm9kZXMoc2VsZi5tZW1iZXJHcm91cHNbaWRdLCBjb21wb3VuZE5vZGUucGFkZGluZ0xlZnQgKyBjb21wb3VuZE5vZGUucGFkZGluZ1JpZ2h0KTtcblxuICAgIC8vIFNldCB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgZHVtbXkgY29tcG91bmQgYXMgY2FsY3VsYXRlZFxuICAgIGNvbXBvdW5kTm9kZS5yZWN0LndpZHRoID0gdGlsZWRaZXJvRGVncmVlUGFja1tpZF0ud2lkdGg7XG4gICAgY29tcG91bmROb2RlLnJlY3QuaGVpZ2h0ID0gdGlsZWRaZXJvRGVncmVlUGFja1tpZF0uaGVpZ2h0O1xuICAgIGNvbXBvdW5kTm9kZS5zZXRDZW50ZXIodGlsZWRaZXJvRGVncmVlUGFja1tpZF0uY2VudGVyWCwgdGlsZWRaZXJvRGVncmVlUGFja1tpZF0uY2VudGVyWSk7XG5cbiAgICAvLyBjb21wb3VuZCBsZWZ0IGFuZCB0b3AgbWFyZ2luZ3MgZm9yIGxhYmVsc1xuICAgIC8vIHdoZW4gbm9kZSBsYWJlbHMgYXJlIGluY2x1ZGVkLCB0aGVzZSB2YWx1ZXMgbWF5IGJlIHNldCB0byBkaWZmZXJlbnQgdmFsdWVzIGJlbG93IGFuZCBhcmUgdXNlZCBpbiB0aWxpbmdQb3N0TGF5b3V0LFxuICAgIC8vIG90aGVyd2lzZSB0aGV5IHN0YXkgYXMgemVyb1xuICAgIGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpbkxlZnQgPSAwO1xuICAgIGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpblRvcCA9IDA7XG5cbiAgICAvLyBVcGRhdGUgY29tcG91bmQgYm91bmRzIGNvbnNpZGVyaW5nIGl0cyBsYWJlbCBwcm9wZXJ0aWVzIGFuZCBzZXQgbGFiZWwgbWFyZ2lucyBmb3IgbGVmdCBhbmQgdG9wXG4gICAgaWYgKENvU0VDb25zdGFudHMuTk9ERV9ESU1FTlNJT05TX0lOQ0xVREVfTEFCRUxTKSB7XG5cbiAgICAgIHZhciB3aWR0aCA9IGNvbXBvdW5kTm9kZS5yZWN0LndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IGNvbXBvdW5kTm9kZS5yZWN0LmhlaWdodDtcblxuICAgICAgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFdpZHRoKSB7XG4gICAgICAgIGlmIChjb21wb3VuZE5vZGUubGFiZWxQb3NIb3Jpem9udGFsID09IFwibGVmdFwiKSB7XG4gICAgICAgICAgY29tcG91bmROb2RlLnJlY3QueCAtPSBjb21wb3VuZE5vZGUubGFiZWxXaWR0aDtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0V2lkdGgod2lkdGggKyBjb21wb3VuZE5vZGUubGFiZWxXaWR0aCk7XG4gICAgICAgICAgY29tcG91bmROb2RlLmxhYmVsTWFyZ2luTGVmdCA9IGNvbXBvdW5kTm9kZS5sYWJlbFdpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFBvc0hvcml6b250YWwgPT0gXCJjZW50ZXJcIiAmJiBjb21wb3VuZE5vZGUubGFiZWxXaWR0aCA+IHdpZHRoKSB7XG4gICAgICAgICAgY29tcG91bmROb2RlLnJlY3QueCAtPSAoY29tcG91bmROb2RlLmxhYmVsV2lkdGggLSB3aWR0aCkgLyAyO1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5zZXRXaWR0aChjb21wb3VuZE5vZGUubGFiZWxXaWR0aCk7XG4gICAgICAgICAgY29tcG91bmROb2RlLmxhYmVsTWFyZ2luTGVmdCA9IChjb21wb3VuZE5vZGUubGFiZWxXaWR0aCAtIHdpZHRoKSAvIDI7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcG91bmROb2RlLmxhYmVsUG9zSG9yaXpvbnRhbCA9PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0V2lkdGgod2lkdGggKyBjb21wb3VuZE5vZGUubGFiZWxXaWR0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodCkge1xuICAgICAgICBpZiAoY29tcG91bmROb2RlLmxhYmVsUG9zVmVydGljYWwgPT0gXCJ0b3BcIikge1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5yZWN0LnkgLT0gY29tcG91bmROb2RlLmxhYmVsSGVpZ2h0O1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5zZXRIZWlnaHQoaGVpZ2h0ICsgY29tcG91bmROb2RlLmxhYmVsSGVpZ2h0KTtcbiAgICAgICAgICBjb21wb3VuZE5vZGUubGFiZWxNYXJnaW5Ub3AgPSBjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcG91bmROb2RlLmxhYmVsUG9zVmVydGljYWwgPT0gXCJjZW50ZXJcIiAmJiBjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQgPiBoZWlnaHQpIHtcbiAgICAgICAgICBjb21wb3VuZE5vZGUucmVjdC55IC09IChjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQgLSBoZWlnaHQpIC8gMjtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0SGVpZ2h0KGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodCk7XG4gICAgICAgICAgY29tcG91bmROb2RlLmxhYmVsTWFyZ2luVG9wID0gKGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodCAtIGhlaWdodCkgLyAyO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFBvc1ZlcnRpY2FsID09IFwiYm90dG9tXCIpIHtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0SGVpZ2h0KGhlaWdodCArIGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUucmVwb3B1bGF0ZUNvbXBvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IHRoaXMuY29tcG91bmRPcmRlci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsQ29tcG91bmROb2RlID0gdGhpcy5jb21wb3VuZE9yZGVyW2ldO1xuICAgIHZhciBpZCA9IGxDb21wb3VuZE5vZGUuaWQ7XG4gICAgdmFyIGhvcml6b250YWxNYXJnaW4gPSBsQ29tcG91bmROb2RlLnBhZGRpbmdMZWZ0O1xuICAgIHZhciB2ZXJ0aWNhbE1hcmdpbiA9IGxDb21wb3VuZE5vZGUucGFkZGluZ1RvcDtcbiAgICB2YXIgbGFiZWxNYXJnaW5MZWZ0ID0gbENvbXBvdW5kTm9kZS5sYWJlbE1hcmdpbkxlZnQ7XG4gICAgdmFyIGxhYmVsTWFyZ2luVG9wID0gbENvbXBvdW5kTm9kZS5sYWJlbE1hcmdpblRvcDtcblxuICAgIHRoaXMuYWRqdXN0TG9jYXRpb25zKHRoaXMudGlsZWRNZW1iZXJQYWNrW2lkXSwgbENvbXBvdW5kTm9kZS5yZWN0LngsIGxDb21wb3VuZE5vZGUucmVjdC55LCBob3Jpem9udGFsTWFyZ2luLCB2ZXJ0aWNhbE1hcmdpbiwgbGFiZWxNYXJnaW5MZWZ0LCBsYWJlbE1hcmdpblRvcCk7XG4gIH1cbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnJlcG9wdWxhdGVaZXJvRGVncmVlTWVtYmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdGlsZWRQYWNrID0gdGhpcy50aWxlZFplcm9EZWdyZWVQYWNrO1xuXG4gIE9iamVjdC5rZXlzKHRpbGVkUGFjaykuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgY29tcG91bmROb2RlID0gc2VsZi5pZFRvRHVtbXlOb2RlW2lkXTsgLy8gR2V0IHRoZSBkdW1teSBjb21wb3VuZCBieSBpdHMgaWRcbiAgICB2YXIgaG9yaXpvbnRhbE1hcmdpbiA9IGNvbXBvdW5kTm9kZS5wYWRkaW5nTGVmdDtcbiAgICB2YXIgdmVydGljYWxNYXJnaW4gPSBjb21wb3VuZE5vZGUucGFkZGluZ1RvcDtcbiAgICB2YXIgbGFiZWxNYXJnaW5MZWZ0ID0gY29tcG91bmROb2RlLmxhYmVsTWFyZ2luTGVmdDtcbiAgICB2YXIgbGFiZWxNYXJnaW5Ub3AgPSBjb21wb3VuZE5vZGUubGFiZWxNYXJnaW5Ub3A7XG5cbiAgICAvLyBBZGp1c3QgdGhlIHBvc2l0aW9ucyBvZiBub2RlcyB3cnQgaXRzIGNvbXBvdW5kXG4gICAgc2VsZi5hZGp1c3RMb2NhdGlvbnModGlsZWRQYWNrW2lkXSwgY29tcG91bmROb2RlLnJlY3QueCwgY29tcG91bmROb2RlLnJlY3QueSwgaG9yaXpvbnRhbE1hcmdpbiwgdmVydGljYWxNYXJnaW4sIGxhYmVsTWFyZ2luTGVmdCwgbGFiZWxNYXJnaW5Ub3ApO1xuICB9KTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmdldFRvQmVUaWxlZCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBpZCA9IG5vZGUuaWQ7XG4gIC8vZmlyc3RseSBjaGVjayB0aGUgcHJldmlvdXMgcmVzdWx0c1xuICBpZiAodGhpcy50b0JlVGlsZWRbaWRdICE9IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy50b0JlVGlsZWRbaWRdO1xuICB9XG5cbiAgLy9vbmx5IGNvbXBvdW5kIG5vZGVzIGFyZSB0byBiZSB0aWxlZFxuICB2YXIgY2hpbGRHcmFwaCA9IG5vZGUuZ2V0Q2hpbGQoKTtcbiAgaWYgKGNoaWxkR3JhcGggPT0gbnVsbCkge1xuICAgIHRoaXMudG9CZVRpbGVkW2lkXSA9IGZhbHNlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBjaGlsZHJlbiA9IGNoaWxkR3JhcGguZ2V0Tm9kZXMoKTsgLy8gR2V0IHRoZSBjaGlsZHJlbiBub2Rlc1xuXG4gIC8vYSBjb21wb3VuZCBub2RlIGlzIG5vdCB0byBiZSB0aWxlZCBpZiBhbGwgb2YgaXRzIGNvbXBvdW5kIGNoaWxkcmVuIGFyZSBub3QgdG8gYmUgdGlsZWRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0aGVDaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgaWYgKHRoaXMuZ2V0Tm9kZURlZ3JlZSh0aGVDaGlsZCkgPiAwKSB7XG4gICAgICB0aGlzLnRvQmVUaWxlZFtpZF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvL3Bhc3MgdGhlIGNoaWxkcmVuIG5vdCBoYXZpbmcgdGhlIGNvbXBvdW5kIHN0cnVjdHVyZVxuICAgIGlmICh0aGVDaGlsZC5nZXRDaGlsZCgpID09IG51bGwpIHtcbiAgICAgIHRoaXMudG9CZVRpbGVkW3RoZUNoaWxkLmlkXSA9IGZhbHNlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmdldFRvQmVUaWxlZCh0aGVDaGlsZCkpIHtcbiAgICAgIHRoaXMudG9CZVRpbGVkW2lkXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB0aGlzLnRvQmVUaWxlZFtpZF0gPSB0cnVlO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIEdldCBkZWdyZWUgb2YgYSBub2RlIGRlcGVuZGluZyBvZiBpdHMgZWRnZXMgYW5kIGluZGVwZW5kZW50IG9mIGl0cyBjaGlsZHJlblxuQ29TRUxheW91dC5wcm90b3R5cGUuZ2V0Tm9kZURlZ3JlZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBpZCA9IG5vZGUuaWQ7XG4gIHZhciBlZGdlcyA9IG5vZGUuZ2V0RWRnZXMoKTtcbiAgdmFyIGRlZ3JlZSA9IDA7XG5cbiAgLy8gRm9yIHRoZSBlZGdlcyBjb25uZWN0ZWRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgaWYgKGVkZ2UuZ2V0U291cmNlKCkuaWQgIT09IGVkZ2UuZ2V0VGFyZ2V0KCkuaWQpIHtcbiAgICAgIGRlZ3JlZSA9IGRlZ3JlZSArIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWdyZWU7XG59O1xuXG4vLyBHZXQgZGVncmVlIG9mIGEgbm9kZSB3aXRoIGl0cyBjaGlsZHJlblxuQ29TRUxheW91dC5wcm90b3R5cGUuZ2V0Tm9kZURlZ3JlZVdpdGhDaGlsZHJlbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBkZWdyZWUgPSB0aGlzLmdldE5vZGVEZWdyZWUobm9kZSk7XG4gIGlmIChub2RlLmdldENoaWxkKCkgPT0gbnVsbCkge1xuICAgIHJldHVybiBkZWdyZWU7XG4gIH1cbiAgdmFyIGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZCgpLmdldE5vZGVzKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICBkZWdyZWUgKz0gdGhpcy5nZXROb2RlRGVncmVlV2l0aENoaWxkcmVuKGNoaWxkKTtcbiAgfVxuICByZXR1cm4gZGVncmVlO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUucGVyZm9ybURGU09uQ29tcG91bmRzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNvbXBvdW5kT3JkZXIgPSBbXTtcbiAgdGhpcy5maWxsQ29tcGV4T3JkZXJCeURGUyh0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuZ2V0Tm9kZXMoKSk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5maWxsQ29tcGV4T3JkZXJCeURGUyA9IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGNoaWxkLmdldENoaWxkKCkgIT0gbnVsbCkge1xuICAgICAgdGhpcy5maWxsQ29tcGV4T3JkZXJCeURGUyhjaGlsZC5nZXRDaGlsZCgpLmdldE5vZGVzKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5nZXRUb0JlVGlsZWQoY2hpbGQpKSB7XG4gICAgICB0aGlzLmNvbXBvdW5kT3JkZXIucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiogVGhpcyBtZXRob2QgcGxhY2VzIGVhY2ggemVybyBkZWdyZWUgbWVtYmVyIHdydCBnaXZlbiAoeCx5KSBjb29yZGluYXRlcyAodG9wIGxlZnQpLlxuKi9cbkNvU0VMYXlvdXQucHJvdG90eXBlLmFkanVzdExvY2F0aW9ucyA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24sIHgsIHksIGNvbXBvdW5kSG9yaXpvbnRhbE1hcmdpbiwgY29tcG91bmRWZXJ0aWNhbE1hcmdpbiwgY29tcG91bmRMYWJlbE1hcmdpbkxlZnQsIGNvbXBvdW5kTGFiZWxNYXJnaW5Ub3ApIHtcbiAgeCArPSBjb21wb3VuZEhvcml6b250YWxNYXJnaW4gKyBjb21wb3VuZExhYmVsTWFyZ2luTGVmdDtcbiAgeSArPSBjb21wb3VuZFZlcnRpY2FsTWFyZ2luICsgY29tcG91bmRMYWJlbE1hcmdpblRvcDtcblxuICB2YXIgbGVmdCA9IHg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmdhbml6YXRpb24ucm93cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciByb3cgPSBvcmdhbml6YXRpb24ucm93c1tpXTtcbiAgICB4ID0gbGVmdDtcbiAgICB2YXIgbWF4SGVpZ2h0ID0gMDtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcm93Lmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbG5vZGUgPSByb3dbal07XG5cbiAgICAgIGxub2RlLnJlY3QueCA9IHg7IC8vICsgbG5vZGUucmVjdC53aWR0aCAvIDI7XG4gICAgICBsbm9kZS5yZWN0LnkgPSB5OyAvLyArIGxub2RlLnJlY3QuaGVpZ2h0IC8gMjtcblxuICAgICAgeCArPSBsbm9kZS5yZWN0LndpZHRoICsgb3JnYW5pemF0aW9uLmhvcml6b250YWxQYWRkaW5nO1xuXG4gICAgICBpZiAobG5vZGUucmVjdC5oZWlnaHQgPiBtYXhIZWlnaHQpIG1heEhlaWdodCA9IGxub2RlLnJlY3QuaGVpZ2h0O1xuICAgIH1cblxuICAgIHkgKz0gbWF4SGVpZ2h0ICsgb3JnYW5pemF0aW9uLnZlcnRpY2FsUGFkZGluZztcbiAgfVxufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUudGlsZUNvbXBvdW5kTWVtYmVycyA9IGZ1bmN0aW9uIChjaGlsZEdyYXBoTWFwLCBpZFRvTm9kZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMudGlsZWRNZW1iZXJQYWNrID0gW107XG5cbiAgT2JqZWN0LmtleXMoY2hpbGRHcmFwaE1hcCkuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAvLyBHZXQgdGhlIGNvbXBvdW5kIG5vZGVcbiAgICB2YXIgY29tcG91bmROb2RlID0gaWRUb05vZGVbaWRdO1xuXG4gICAgc2VsZi50aWxlZE1lbWJlclBhY2tbaWRdID0gc2VsZi50aWxlTm9kZXMoY2hpbGRHcmFwaE1hcFtpZF0sIGNvbXBvdW5kTm9kZS5wYWRkaW5nTGVmdCArIGNvbXBvdW5kTm9kZS5wYWRkaW5nUmlnaHQpO1xuXG4gICAgY29tcG91bmROb2RlLnJlY3Qud2lkdGggPSBzZWxmLnRpbGVkTWVtYmVyUGFja1tpZF0ud2lkdGg7XG4gICAgY29tcG91bmROb2RlLnJlY3QuaGVpZ2h0ID0gc2VsZi50aWxlZE1lbWJlclBhY2tbaWRdLmhlaWdodDtcbiAgICBjb21wb3VuZE5vZGUuc2V0Q2VudGVyKHNlbGYudGlsZWRNZW1iZXJQYWNrW2lkXS5jZW50ZXJYLCBzZWxmLnRpbGVkTWVtYmVyUGFja1tpZF0uY2VudGVyWSk7XG5cbiAgICAvLyBjb21wb3VuZCBsZWZ0IGFuZCB0b3AgbWFyZ2luZ3MgZm9yIGxhYmVsc1xuICAgIC8vIHdoZW4gbm9kZSBsYWJlbHMgYXJlIGluY2x1ZGVkLCB0aGVzZSB2YWx1ZXMgbWF5IGJlIHNldCB0byBkaWZmZXJlbnQgdmFsdWVzIGJlbG93IGFuZCBhcmUgdXNlZCBpbiB0aWxpbmdQb3N0TGF5b3V0LFxuICAgIC8vIG90aGVyd2lzZSB0aGV5IHN0YXkgYXMgemVyb1xuICAgIGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpbkxlZnQgPSAwO1xuICAgIGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpblRvcCA9IDA7XG5cbiAgICAvLyBVcGRhdGUgY29tcG91bmQgYm91bmRzIGNvbnNpZGVyaW5nIGl0cyBsYWJlbCBwcm9wZXJ0aWVzIGFuZCBzZXQgbGFiZWwgbWFyZ2lucyBmb3IgbGVmdCBhbmQgdG9wXG4gICAgaWYgKENvU0VDb25zdGFudHMuTk9ERV9ESU1FTlNJT05TX0lOQ0xVREVfTEFCRUxTKSB7XG5cbiAgICAgIHZhciB3aWR0aCA9IGNvbXBvdW5kTm9kZS5yZWN0LndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IGNvbXBvdW5kTm9kZS5yZWN0LmhlaWdodDtcblxuICAgICAgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFdpZHRoKSB7XG4gICAgICAgIGlmIChjb21wb3VuZE5vZGUubGFiZWxQb3NIb3Jpem9udGFsID09IFwibGVmdFwiKSB7XG4gICAgICAgICAgY29tcG91bmROb2RlLnJlY3QueCAtPSBjb21wb3VuZE5vZGUubGFiZWxXaWR0aDtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0V2lkdGgod2lkdGggKyBjb21wb3VuZE5vZGUubGFiZWxXaWR0aCk7XG4gICAgICAgICAgY29tcG91bmROb2RlLmxhYmVsTWFyZ2luTGVmdCA9IGNvbXBvdW5kTm9kZS5sYWJlbFdpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFBvc0hvcml6b250YWwgPT0gXCJjZW50ZXJcIiAmJiBjb21wb3VuZE5vZGUubGFiZWxXaWR0aCA+IHdpZHRoKSB7XG4gICAgICAgICAgY29tcG91bmROb2RlLnJlY3QueCAtPSAoY29tcG91bmROb2RlLmxhYmVsV2lkdGggLSB3aWR0aCkgLyAyO1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5zZXRXaWR0aChjb21wb3VuZE5vZGUubGFiZWxXaWR0aCk7XG4gICAgICAgICAgY29tcG91bmROb2RlLmxhYmVsTWFyZ2luTGVmdCA9IChjb21wb3VuZE5vZGUubGFiZWxXaWR0aCAtIHdpZHRoKSAvIDI7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcG91bmROb2RlLmxhYmVsUG9zSG9yaXpvbnRhbCA9PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0V2lkdGgod2lkdGggKyBjb21wb3VuZE5vZGUubGFiZWxXaWR0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodCkge1xuICAgICAgICBpZiAoY29tcG91bmROb2RlLmxhYmVsUG9zVmVydGljYWwgPT0gXCJ0b3BcIikge1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5yZWN0LnkgLT0gY29tcG91bmROb2RlLmxhYmVsSGVpZ2h0O1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5zZXRIZWlnaHQoaGVpZ2h0ICsgY29tcG91bmROb2RlLmxhYmVsSGVpZ2h0KTtcbiAgICAgICAgICBjb21wb3VuZE5vZGUubGFiZWxNYXJnaW5Ub3AgPSBjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcG91bmROb2RlLmxhYmVsUG9zVmVydGljYWwgPT0gXCJjZW50ZXJcIiAmJiBjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQgPiBoZWlnaHQpIHtcbiAgICAgICAgICBjb21wb3VuZE5vZGUucmVjdC55IC09IChjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQgLSBoZWlnaHQpIC8gMjtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0SGVpZ2h0KGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodCk7XG4gICAgICAgICAgY29tcG91bmROb2RlLmxhYmVsTWFyZ2luVG9wID0gKGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodCAtIGhlaWdodCkgLyAyO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFBvc1ZlcnRpY2FsID09IFwiYm90dG9tXCIpIHtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0SGVpZ2h0KGhlaWdodCArIGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUudGlsZU5vZGVzID0gZnVuY3Rpb24gKG5vZGVzLCBtaW5XaWR0aCkge1xuICB2YXIgaG9yaXpvbnRhbE9yZyA9IHRoaXMudGlsZU5vZGVzQnlGYXZvcmluZ0RpbShub2RlcywgbWluV2lkdGgsIHRydWUpO1xuICB2YXIgdmVydGljYWxPcmcgPSB0aGlzLnRpbGVOb2Rlc0J5RmF2b3JpbmdEaW0obm9kZXMsIG1pbldpZHRoLCBmYWxzZSk7XG5cbiAgdmFyIGhvcml6b250YWxSYXRpbyA9IHRoaXMuZ2V0T3JnUmF0aW8oaG9yaXpvbnRhbE9yZyk7XG4gIHZhciB2ZXJ0aWNhbFJhdGlvID0gdGhpcy5nZXRPcmdSYXRpbyh2ZXJ0aWNhbE9yZyk7XG4gIHZhciBiZXN0T3JnO1xuXG4gIC8vIHRoZSBiZXN0IHJhdGlvIGlzIHRoZSBvbmUgdGhhdCBpcyBjbG9zZXIgdG8gMSBzaW5jZSB0aGUgcmF0aW9zIGFyZSBhbHJlYWR5IG5vcm1hbGl6ZWRcbiAgLy8gYW5kIHRoZSBiZXN0IG9yZ2FuaXphdGlvbiBpcyB0aGUgb25lIHRoYXQgaGFzIHRoZSBiZXN0IHJhdGlvXG4gIGlmICh2ZXJ0aWNhbFJhdGlvIDwgaG9yaXpvbnRhbFJhdGlvKSB7XG4gICAgYmVzdE9yZyA9IHZlcnRpY2FsT3JnO1xuICB9IGVsc2Uge1xuICAgIGJlc3RPcmcgPSBob3Jpem9udGFsT3JnO1xuICB9XG5cbiAgcmV0dXJuIGJlc3RPcmc7XG59O1xuXG4vLyBnZXQgdGhlIHdpZHRoL2hlaWdodCByYXRpbyBvZiB0aGUgb3JnYW5pemF0aW9uIHRoYXQgaXMgbm9ybWFsaXplZCBzbyB0aGF0IGl0IHdpbGwgbm90IGJlIGxlc3MgdGhhbiAxXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5nZXRPcmdSYXRpbyA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24pIHtcbiAgLy8gZ2V0IGRpbWVuc2lvbnMgYW5kIGNhbGN1bGF0ZSB0aGUgaW5pdGlhbCByYXRpb1xuICB2YXIgd2lkdGggPSBvcmdhbml6YXRpb24ud2lkdGg7XG4gIHZhciBoZWlnaHQgPSBvcmdhbml6YXRpb24uaGVpZ2h0O1xuICB2YXIgcmF0aW8gPSB3aWR0aCAvIGhlaWdodDtcblxuICAvLyBpZiB0aGUgaW5pdGlhbCByYXRpbyBpcyBsZXNzIHRoZW4gMSB0aGVuIGludmVyc2UgaXRcbiAgaWYgKHJhdGlvIDwgMSkge1xuICAgIHJhdGlvID0gMSAvIHJhdGlvO1xuICB9XG5cbiAgLy8gcmV0dXJuIHRoZSBub3JtYWxpemVkIHJhdGlvXG4gIHJldHVybiByYXRpbztcbn07XG5cbi8qXG4gKiBDYWxjdWxhdGVzIHRoZSBpZGVhbCB3aWR0aCBmb3IgdGhlIHJvd3MuIFRoaXMgbWV0aG9kIGFzc3VtZXMgdGhhdFxuICogZWFjaCBub2RlIGhhcyB0aGUgc2FtZSBzaXplcyBhbmQgY2FsY3VsYXRlcyB0aGUgaWRlYWwgcm93IHdpZHRoIHRoYXRcbiAqIGFwcHJveGltYXRlcyBhIHNxdWFyZSBzaGFwZWQgY29tcGxleCBhY2NvcmRpbmdseS4gSG93ZXZlciwgc2luY2Ugbm9kZXMgd291bGRcbiAqIGhhdmUgZGlmZmVyZW50IHNpemVzIHNvbWUgcm93cyB3b3VsZCBoYXZlIGRpZmZlcmVudCBzaXplcyBhbmQgdGhlIHJlc3VsdGluZ1xuICogc2hhcGUgd291bGQgbm90IGJlIGFuIGV4YWN0IHNxdWFyZS5cbiAqL1xuQ29TRUxheW91dC5wcm90b3R5cGUuY2FsY0lkZWFsUm93V2lkdGggPSBmdW5jdGlvbiAobWVtYmVycywgZmF2b3JIb3Jpem9udGFsRGltKSB7XG4gIC8vIFRvIGFwcHJveGltYXRlIGEgc3F1YXJlIHNoYXBlZCBjb21wbGV4IHdlIG5lZWQgdG8gbWFrZSBjb21wbGV4IHdpZHRoIGVxdWFsIHRvIGNvbXBsZXggaGVpZ2h0LlxuICAvLyBUbyBhY2hpZXZlIHRoaXMgd2UgbmVlZCB0byBzb2x2ZSB0aGUgZm9sbG93aW5nIGVxdWF0aW9uIHN5c3RlbSBmb3IgaGM6XG4gIC8vICh4ICsgYngpICogaGMgLSBieCA9ICh5ICsgYnkpICogdmMgLSBieSwgaGMgKiB2YyA9IG5cbiAgLy8gd2hlcmUgeCBpcyB0aGUgYXZhcmFnZSB3aWR0aCBvZiB0aGUgbm9kZXMsIHkgaXMgdGhlIGF2YXJhZ2UgaGVpZ2h0IG9mIG5vZGVzXG4gIC8vIGJ4IGFuZCBieSBhcmUgdGhlIGJ1ZmZlciBzaXplcyBpbiBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBkaW1lbnNpb25zIGFjY29yZGluZ2x5LFxuICAvLyBoYyBhbmQgdmMgYXJlIHRoZSBudW1iZXIgb2Ygcm93cyBpbiBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBkaW1lbnNpb25zXG4gIC8vIG4gaXMgbnVtYmVyIG9mIG1lbWJlcnMuXG5cbiAgdmFyIHZlcnRpY2FsUGFkZGluZyA9IENvU0VDb25zdGFudHMuVElMSU5HX1BBRERJTkdfVkVSVElDQUw7XG4gIHZhciBob3Jpem9udGFsUGFkZGluZyA9IENvU0VDb25zdGFudHMuVElMSU5HX1BBRERJTkdfSE9SSVpPTlRBTDtcblxuICAvLyBudW1iZXIgb2YgbWVtYmVyc1xuICB2YXIgbWVtYmVyc1NpemUgPSBtZW1iZXJzLmxlbmd0aDtcblxuICAvLyBzdW0gb2YgdGhlIHdpZHRoIG9mIGFsbCBtZW1iZXJzXG4gIHZhciB0b3RhbFdpZHRoID0gMDtcblxuICAvLyBzdW0gb2YgdGhlIGhlaWdodCBvZiBhbGwgbWVtYmVyc1xuICB2YXIgdG90YWxIZWlnaHQgPSAwO1xuXG4gIHZhciBtYXhXaWR0aCA9IDA7XG5cbiAgLy8gdHJhdmVyc2UgYWxsIG1lbWJlcnMgdG8gY2FsY3VsYXRlIHRvdGFsIHdpZHRoIGFuZCB0b3RhbCBoZWlnaHQgYW5kIGdldCB0aGUgbWF4aW11bSBtZW1iZXJzIHdpZHRoXG4gIG1lbWJlcnMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgIHRvdGFsV2lkdGggKz0gbm9kZS5nZXRXaWR0aCgpO1xuICAgIHRvdGFsSGVpZ2h0ICs9IG5vZGUuZ2V0SGVpZ2h0KCk7XG5cbiAgICBpZiAobm9kZS5nZXRXaWR0aCgpID4gbWF4V2lkdGgpIHtcbiAgICAgIG1heFdpZHRoID0gbm9kZS5nZXRXaWR0aCgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gYXZlcmFnZSB3aWR0aCBvZiB0aGUgbWVtYmVyc1xuICB2YXIgYXZlcmFnZVdpZHRoID0gdG90YWxXaWR0aCAvIG1lbWJlcnNTaXplO1xuXG4gIC8vIGF2ZXJhZ2UgaGVpZ2h0IG9mIHRoZSBtZW1iZXJzXG4gIHZhciBhdmVyYWdlSGVpZ2h0ID0gdG90YWxIZWlnaHQgLyBtZW1iZXJzU2l6ZTtcblxuICAvLyBzb2x2aW5nIHRoZSBpbml0aWFsIGVxdWF0aW9uIHN5c3RlbSBmb3IgdGhlIGhjIHlpZWxkcyB0aGUgZm9sbG93aW5nIHNlY29uZCBkZWdyZWUgZXF1YXRpb246XG4gIC8vIGhjXjIgKiAoeCtieCkgKyBoYyAqIChieSAtIGJ4KSAtIG4gKiAoeSArIGJ5KSA9IDBcblxuICAvLyB0aGUgZGVsdGEgdmFsdWUgdG8gc29sdmUgdGhlIGVxdWF0aW9uIGFib3ZlIGZvciBoY1xuICB2YXIgZGVsdGEgPSBNYXRoLnBvdyh2ZXJ0aWNhbFBhZGRpbmcgLSBob3Jpem9udGFsUGFkZGluZywgMikgKyA0ICogKGF2ZXJhZ2VXaWR0aCArIGhvcml6b250YWxQYWRkaW5nKSAqIChhdmVyYWdlSGVpZ2h0ICsgdmVydGljYWxQYWRkaW5nKSAqIG1lbWJlcnNTaXplO1xuXG4gIC8vIHNvbHZlIHRoZSBlcXVhdGlvbiB1c2luZyBkZWx0YSB2YWx1ZSB0byBjYWxjdWxhdGUgdGhlIGhvcml6b250YWwgY291bnRcbiAgLy8gdGhhdCByZXByZXNlbnRzIHRoZSBudW1iZXIgb2Ygbm9kZXMgaW4gYW4gaWRlYWwgcm93XG4gIHZhciBob3Jpem9udGFsQ291bnREb3VibGUgPSAoaG9yaXpvbnRhbFBhZGRpbmcgLSB2ZXJ0aWNhbFBhZGRpbmcgKyBNYXRoLnNxcnQoZGVsdGEpKSAvICgyICogKGF2ZXJhZ2VXaWR0aCArIGhvcml6b250YWxQYWRkaW5nKSk7XG4gIC8vIHJvdW5kIHRoZSBjYWxjdWxhdGVkIGhvcml6b250YWwgY291bnQgdXAgb3IgZG93biBhY2NvcmRpbmcgdG8gdGhlIGZhdm9yZWQgZGltZW5zaW9uXG4gIHZhciBob3Jpem9udGFsQ291bnQ7XG5cbiAgaWYgKGZhdm9ySG9yaXpvbnRhbERpbSkge1xuICAgIGhvcml6b250YWxDb3VudCA9IE1hdGguY2VpbChob3Jpem9udGFsQ291bnREb3VibGUpO1xuICAgIC8vIGlmIGhvcml6b250YWxDb3VudCBjb3VudCBpcyBub3QgYSBmbG9hdCB2YWx1ZSB0aGVuIGJvdGggb2Ygcm91bmRpbmcgdG8gZmxvb3IgYW5kIGNlaWxcbiAgICAvLyB3aWxsIHlpZWxkIHRoZSBzYW1lIHZhbHVlcy4gSW5zdGVhZCBvZiByZXBlYXRpbmcgdGhlIHNhbWUgY2FsY3VsYXRpb24gdHJ5IGdvaW5nIHVwXG4gICAgLy8gd2hpbGUgZmF2b3JpbmcgaG9yaXpvbnRhbCBkaW1lbnNpb24gaW4gc3VjaCBjYXNlc1xuICAgIGlmIChob3Jpem9udGFsQ291bnQgPT0gaG9yaXpvbnRhbENvdW50RG91YmxlKSB7XG4gICAgICBob3Jpem9udGFsQ291bnQrKztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaG9yaXpvbnRhbENvdW50ID0gTWF0aC5mbG9vcihob3Jpem9udGFsQ291bnREb3VibGUpO1xuICB9XG5cbiAgLy8gaWRlYWwgd2lkdGggdG8gYmUgY2FsY3VsYXRlZFxuICB2YXIgaWRlYWxXaWR0aCA9IGhvcml6b250YWxDb3VudCAqIChhdmVyYWdlV2lkdGggKyBob3Jpem9udGFsUGFkZGluZykgLSBob3Jpem9udGFsUGFkZGluZztcblxuICAvLyBpZiBtYXggd2lkdGggaXMgYmlnZ2VyIHRoYW4gY2FsY3VsYXRlZCBpZGVhbCB3aWR0aCByZXNldCBpZGVhbCB3aWR0aCB0byBpdFxuICBpZiAobWF4V2lkdGggPiBpZGVhbFdpZHRoKSB7XG4gICAgaWRlYWxXaWR0aCA9IG1heFdpZHRoO1xuICB9XG5cbiAgLy8gYWRkIHRoZSBsZWZ0LXJpZ2h0IG1hcmdpbnMgdG8gdGhlIGlkZWFsIHJvdyB3aWR0aFxuICBpZGVhbFdpZHRoICs9IGhvcml6b250YWxQYWRkaW5nICogMjtcblxuICAvLyByZXR1cm4gdGhlIGlkZWFsIHJvdyB3aWR0aDFcbiAgcmV0dXJuIGlkZWFsV2lkdGg7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS50aWxlTm9kZXNCeUZhdm9yaW5nRGltID0gZnVuY3Rpb24gKG5vZGVzLCBtaW5XaWR0aCwgZmF2b3JIb3Jpem9udGFsRGltKSB7XG4gIHZhciB2ZXJ0aWNhbFBhZGRpbmcgPSBDb1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX1ZFUlRJQ0FMO1xuICB2YXIgaG9yaXpvbnRhbFBhZGRpbmcgPSBDb1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX0hPUklaT05UQUw7XG4gIHZhciB0aWxpbmdDb21wYXJlQnkgPSBDb1NFQ29uc3RhbnRzLlRJTElOR19DT01QQVJFX0JZO1xuICB2YXIgb3JnYW5pemF0aW9uID0ge1xuICAgIHJvd3M6IFtdLFxuICAgIHJvd1dpZHRoOiBbXSxcbiAgICByb3dIZWlnaHQ6IFtdLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogbWluV2lkdGgsIC8vIGFzc3VtZSBtaW5IZWlnaHQgZXF1YWxzIHRvIG1pbldpZHRoXG4gICAgdmVydGljYWxQYWRkaW5nOiB2ZXJ0aWNhbFBhZGRpbmcsXG4gICAgaG9yaXpvbnRhbFBhZGRpbmc6IGhvcml6b250YWxQYWRkaW5nLFxuICAgIGNlbnRlclg6IDAsXG4gICAgY2VudGVyWTogMFxuICB9O1xuXG4gIGlmICh0aWxpbmdDb21wYXJlQnkpIHtcbiAgICBvcmdhbml6YXRpb24uaWRlYWxSb3dXaWR0aCA9IHRoaXMuY2FsY0lkZWFsUm93V2lkdGgobm9kZXMsIGZhdm9ySG9yaXpvbnRhbERpbSk7XG4gIH1cblxuICB2YXIgZ2V0Tm9kZUFyZWEgPSBmdW5jdGlvbiBnZXROb2RlQXJlYShuKSB7XG4gICAgcmV0dXJuIG4ucmVjdC53aWR0aCAqIG4ucmVjdC5oZWlnaHQ7XG4gIH07XG5cbiAgdmFyIGFyZWFDb21wYXJlRmNuID0gZnVuY3Rpb24gYXJlYUNvbXBhcmVGY24objEsIG4yKSB7XG4gICAgcmV0dXJuIGdldE5vZGVBcmVhKG4yKSAtIGdldE5vZGVBcmVhKG4xKTtcbiAgfTtcblxuICAvLyBTb3J0IHRoZSBub2RlcyBpbiBkZXNjZW5kaW5nIG9yZGVyIG9mIHRoZWlyIGFyZWFzXG4gIG5vZGVzLnNvcnQoZnVuY3Rpb24gKG4xLCBuMikge1xuICAgIHZhciBjbXBCeSA9IGFyZWFDb21wYXJlRmNuO1xuICAgIGlmIChvcmdhbml6YXRpb24uaWRlYWxSb3dXaWR0aCkge1xuICAgICAgY21wQnkgPSB0aWxpbmdDb21wYXJlQnk7XG4gICAgICByZXR1cm4gY21wQnkobjEuaWQsIG4yLmlkKTtcbiAgICB9XG4gICAgcmV0dXJuIGNtcEJ5KG4xLCBuMik7XG4gIH0pO1xuXG4gIC8vIENyZWF0ZSB0aGUgb3JnYW5pemF0aW9uIC0+IGNhbGN1bGF0ZSBjb21wb3VuZCBjZW50ZXJcbiAgdmFyIHN1bUNlbnRlclggPSAwO1xuICB2YXIgc3VtQ2VudGVyWSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbE5vZGUgPSBub2Rlc1tpXTtcblxuICAgIHN1bUNlbnRlclggKz0gbE5vZGUuZ2V0Q2VudGVyWCgpO1xuICAgIHN1bUNlbnRlclkgKz0gbE5vZGUuZ2V0Q2VudGVyWSgpO1xuICB9XG5cbiAgb3JnYW5pemF0aW9uLmNlbnRlclggPSBzdW1DZW50ZXJYIC8gbm9kZXMubGVuZ3RoO1xuICBvcmdhbml6YXRpb24uY2VudGVyWSA9IHN1bUNlbnRlclkgLyBub2Rlcy5sZW5ndGg7XG5cbiAgLy8gQ3JlYXRlIHRoZSBvcmdhbml6YXRpb24gLT4gdGlsZSBtZW1iZXJzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbE5vZGUgPSBub2Rlc1tpXTtcblxuICAgIGlmIChvcmdhbml6YXRpb24ucm93cy5sZW5ndGggPT0gMCkge1xuICAgICAgdGhpcy5pbnNlcnROb2RlVG9Sb3cob3JnYW5pemF0aW9uLCBsTm9kZSwgMCwgbWluV2lkdGgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jYW5BZGRIb3Jpem9udGFsKG9yZ2FuaXphdGlvbiwgbE5vZGUucmVjdC53aWR0aCwgbE5vZGUucmVjdC5oZWlnaHQpKSB7XG4gICAgICB2YXIgcm93SW5kZXggPSBvcmdhbml6YXRpb24ucm93cy5sZW5ndGggLSAxO1xuICAgICAgaWYgKCFvcmdhbml6YXRpb24uaWRlYWxSb3dXaWR0aCkge1xuICAgICAgICByb3dJbmRleCA9IHRoaXMuZ2V0U2hvcnRlc3RSb3dJbmRleChvcmdhbml6YXRpb24pO1xuICAgICAgfVxuICAgICAgdGhpcy5pbnNlcnROb2RlVG9Sb3cob3JnYW5pemF0aW9uLCBsTm9kZSwgcm93SW5kZXgsIG1pbldpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbnNlcnROb2RlVG9Sb3cob3JnYW5pemF0aW9uLCBsTm9kZSwgb3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoLCBtaW5XaWR0aCk7XG4gICAgfVxuXG4gICAgdGhpcy5zaGlmdFRvTGFzdFJvdyhvcmdhbml6YXRpb24pO1xuICB9XG5cbiAgcmV0dXJuIG9yZ2FuaXphdGlvbjtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmluc2VydE5vZGVUb1JvdyA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24sIG5vZGUsIHJvd0luZGV4LCBtaW5XaWR0aCkge1xuICB2YXIgbWluQ29tcG91bmRTaXplID0gbWluV2lkdGg7XG5cbiAgLy8gQWRkIG5ldyByb3cgaWYgbmVlZGVkXG4gIGlmIChyb3dJbmRleCA9PSBvcmdhbml6YXRpb24ucm93cy5sZW5ndGgpIHtcbiAgICB2YXIgc2Vjb25kRGltZW5zaW9uID0gW107XG5cbiAgICBvcmdhbml6YXRpb24ucm93cy5wdXNoKHNlY29uZERpbWVuc2lvbik7XG4gICAgb3JnYW5pemF0aW9uLnJvd1dpZHRoLnB1c2gobWluQ29tcG91bmRTaXplKTtcbiAgICBvcmdhbml6YXRpb24ucm93SGVpZ2h0LnB1c2goMCk7XG4gIH1cblxuICAvLyBVcGRhdGUgcm93IHdpZHRoXG4gIHZhciB3ID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW3Jvd0luZGV4XSArIG5vZGUucmVjdC53aWR0aDtcblxuICBpZiAob3JnYW5pemF0aW9uLnJvd3Nbcm93SW5kZXhdLmxlbmd0aCA+IDApIHtcbiAgICB3ICs9IG9yZ2FuaXphdGlvbi5ob3Jpem9udGFsUGFkZGluZztcbiAgfVxuXG4gIG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtyb3dJbmRleF0gPSB3O1xuICAvLyBVcGRhdGUgY29tcG91bmQgd2lkdGhcbiAgaWYgKG9yZ2FuaXphdGlvbi53aWR0aCA8IHcpIHtcbiAgICBvcmdhbml6YXRpb24ud2lkdGggPSB3O1xuICB9XG5cbiAgLy8gVXBkYXRlIGhlaWdodFxuICB2YXIgaCA9IG5vZGUucmVjdC5oZWlnaHQ7XG4gIGlmIChyb3dJbmRleCA+IDApIGggKz0gb3JnYW5pemF0aW9uLnZlcnRpY2FsUGFkZGluZztcblxuICB2YXIgZXh0cmFIZWlnaHQgPSAwO1xuICBpZiAoaCA+IG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbcm93SW5kZXhdKSB7XG4gICAgZXh0cmFIZWlnaHQgPSBvcmdhbml6YXRpb24ucm93SGVpZ2h0W3Jvd0luZGV4XTtcbiAgICBvcmdhbml6YXRpb24ucm93SGVpZ2h0W3Jvd0luZGV4XSA9IGg7XG4gICAgZXh0cmFIZWlnaHQgPSBvcmdhbml6YXRpb24ucm93SGVpZ2h0W3Jvd0luZGV4XSAtIGV4dHJhSGVpZ2h0O1xuICB9XG5cbiAgb3JnYW5pemF0aW9uLmhlaWdodCArPSBleHRyYUhlaWdodDtcblxuICAvLyBJbnNlcnQgbm9kZVxuICBvcmdhbml6YXRpb24ucm93c1tyb3dJbmRleF0ucHVzaChub2RlKTtcbn07XG5cbi8vU2NhbnMgdGhlIHJvd3Mgb2YgYW4gb3JnYW5pemF0aW9uIGFuZCByZXR1cm5zIHRoZSBvbmUgd2l0aCB0aGUgbWluIHdpZHRoXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5nZXRTaG9ydGVzdFJvd0luZGV4ID0gZnVuY3Rpb24gKG9yZ2FuaXphdGlvbikge1xuICB2YXIgciA9IC0xO1xuICB2YXIgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZ2FuaXphdGlvbi5yb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtpXSA8IG1pbikge1xuICAgICAgciA9IGk7XG4gICAgICBtaW4gPSBvcmdhbml6YXRpb24ucm93V2lkdGhbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiByO1xufTtcblxuLy9TY2FucyB0aGUgcm93cyBvZiBhbiBvcmdhbml6YXRpb24gYW5kIHJldHVybnMgdGhlIG9uZSB3aXRoIHRoZSBtYXggd2lkdGhcbkNvU0VMYXlvdXQucHJvdG90eXBlLmdldExvbmdlc3RSb3dJbmRleCA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24pIHtcbiAgdmFyIHIgPSAtMTtcbiAgdmFyIG1heCA9IE51bWJlci5NSU5fVkFMVUU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmdhbml6YXRpb24ucm93cy5sZW5ndGg7IGkrKykge1xuXG4gICAgaWYgKG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtpXSA+IG1heCkge1xuICAgICAgciA9IGk7XG4gICAgICBtYXggPSBvcmdhbml6YXRpb24ucm93V2lkdGhbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHI7XG59O1xuXG4vKipcbiogVGhpcyBtZXRob2QgY2hlY2tzIHdoZXRoZXIgYWRkaW5nIGV4dHJhIHdpZHRoIHRvIHRoZSBvcmdhbml6YXRpb24gdmlvbGF0ZXNcbiogdGhlIGFzcGVjdCByYXRpbygxKSBvciBub3QuXG4qL1xuQ29TRUxheW91dC5wcm90b3R5cGUuY2FuQWRkSG9yaXpvbnRhbCA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24sIGV4dHJhV2lkdGgsIGV4dHJhSGVpZ2h0KSB7XG5cbiAgLy8gaWYgdGhlcmUgaXMgYW4gaWRlYWwgcm93IHdpZHRoIHNwZWNpZmllZCB1c2UgaXQgaW5zdGVhZCBvZiBjaGVja2luZyB0aGUgYXNwZWN0IHJhdGlvXG4gIGlmIChvcmdhbml6YXRpb24uaWRlYWxSb3dXaWR0aCkge1xuICAgIHZhciBsYXN0Um93SW5kZXggPSBvcmdhbml6YXRpb24ucm93cy5sZW5ndGggLSAxO1xuICAgIHZhciBsYXN0Um93V2lkdGggPSBvcmdhbml6YXRpb24ucm93V2lkdGhbbGFzdFJvd0luZGV4XTtcblxuICAgIC8vIGNoZWNrIGFuZCByZXR1cm4gaWYgaWRlYWwgcm93IHdpZHRoIHdpbGwgYmUgZXhjZWVkIGlmIHRoZSBub2RlIGlzIGFkZGVkIHRvIHRoZSByb3dcbiAgICByZXR1cm4gbGFzdFJvd1dpZHRoICsgZXh0cmFXaWR0aCArIG9yZ2FuaXphdGlvbi5ob3Jpem9udGFsUGFkZGluZyA8PSBvcmdhbml6YXRpb24uaWRlYWxSb3dXaWR0aDtcbiAgfVxuXG4gIHZhciBzcmkgPSB0aGlzLmdldFNob3J0ZXN0Um93SW5kZXgob3JnYW5pemF0aW9uKTtcblxuICBpZiAoc3JpIDwgMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIG1pbiA9IG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtzcmldO1xuXG4gIGlmIChtaW4gKyBvcmdhbml6YXRpb24uaG9yaXpvbnRhbFBhZGRpbmcgKyBleHRyYVdpZHRoIDw9IG9yZ2FuaXphdGlvbi53aWR0aCkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIGhEaWZmID0gMDtcblxuICAvLyBBZGRpbmcgdG8gYW4gZXhpc3Rpbmcgcm93XG4gIGlmIChvcmdhbml6YXRpb24ucm93SGVpZ2h0W3NyaV0gPCBleHRyYUhlaWdodCkge1xuICAgIGlmIChzcmkgPiAwKSBoRGlmZiA9IGV4dHJhSGVpZ2h0ICsgb3JnYW5pemF0aW9uLnZlcnRpY2FsUGFkZGluZyAtIG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbc3JpXTtcbiAgfVxuXG4gIHZhciBhZGRfdG9fcm93X3JhdGlvO1xuICBpZiAob3JnYW5pemF0aW9uLndpZHRoIC0gbWluID49IGV4dHJhV2lkdGggKyBvcmdhbml6YXRpb24uaG9yaXpvbnRhbFBhZGRpbmcpIHtcbiAgICBhZGRfdG9fcm93X3JhdGlvID0gKG9yZ2FuaXphdGlvbi5oZWlnaHQgKyBoRGlmZikgLyAobWluICsgZXh0cmFXaWR0aCArIG9yZ2FuaXphdGlvbi5ob3Jpem9udGFsUGFkZGluZyk7XG4gIH0gZWxzZSB7XG4gICAgYWRkX3RvX3Jvd19yYXRpbyA9IChvcmdhbml6YXRpb24uaGVpZ2h0ICsgaERpZmYpIC8gb3JnYW5pemF0aW9uLndpZHRoO1xuICB9XG5cbiAgLy8gQWRkaW5nIGEgbmV3IHJvdyBmb3IgdGhpcyBub2RlXG4gIGhEaWZmID0gZXh0cmFIZWlnaHQgKyBvcmdhbml6YXRpb24udmVydGljYWxQYWRkaW5nO1xuICB2YXIgYWRkX25ld19yb3dfcmF0aW87XG4gIGlmIChvcmdhbml6YXRpb24ud2lkdGggPCBleHRyYVdpZHRoKSB7XG4gICAgYWRkX25ld19yb3dfcmF0aW8gPSAob3JnYW5pemF0aW9uLmhlaWdodCArIGhEaWZmKSAvIGV4dHJhV2lkdGg7XG4gIH0gZWxzZSB7XG4gICAgYWRkX25ld19yb3dfcmF0aW8gPSAob3JnYW5pemF0aW9uLmhlaWdodCArIGhEaWZmKSAvIG9yZ2FuaXphdGlvbi53aWR0aDtcbiAgfVxuXG4gIGlmIChhZGRfbmV3X3Jvd19yYXRpbyA8IDEpIGFkZF9uZXdfcm93X3JhdGlvID0gMSAvIGFkZF9uZXdfcm93X3JhdGlvO1xuXG4gIGlmIChhZGRfdG9fcm93X3JhdGlvIDwgMSkgYWRkX3RvX3Jvd19yYXRpbyA9IDEgLyBhZGRfdG9fcm93X3JhdGlvO1xuXG4gIHJldHVybiBhZGRfdG9fcm93X3JhdGlvIDwgYWRkX25ld19yb3dfcmF0aW87XG59O1xuXG4vL0lmIG1vdmluZyB0aGUgbGFzdCBub2RlIGZyb20gdGhlIGxvbmdlc3Qgcm93IGFuZCBhZGRpbmcgaXQgdG8gdGhlIGxhc3Rcbi8vcm93IG1ha2VzIHRoZSBib3VuZGluZyBib3ggc21hbGxlciwgZG8gaXQuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5zaGlmdFRvTGFzdFJvdyA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24pIHtcbiAgdmFyIGxvbmdlc3QgPSB0aGlzLmdldExvbmdlc3RSb3dJbmRleChvcmdhbml6YXRpb24pO1xuICB2YXIgbGFzdCA9IG9yZ2FuaXphdGlvbi5yb3dXaWR0aC5sZW5ndGggLSAxO1xuICB2YXIgcm93ID0gb3JnYW5pemF0aW9uLnJvd3NbbG9uZ2VzdF07XG4gIHZhciBub2RlID0gcm93W3Jvdy5sZW5ndGggLSAxXTtcblxuICB2YXIgZGlmZiA9IG5vZGUud2lkdGggKyBvcmdhbml6YXRpb24uaG9yaXpvbnRhbFBhZGRpbmc7XG5cbiAgLy8gQ2hlY2sgaWYgdGhlcmUgaXMgZW5vdWdoIHNwYWNlIG9uIHRoZSBsYXN0IHJvd1xuICBpZiAob3JnYW5pemF0aW9uLndpZHRoIC0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW2xhc3RdID4gZGlmZiAmJiBsb25nZXN0ICE9IGxhc3QpIHtcbiAgICAvLyBSZW1vdmUgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgbG9uZ2VzdCByb3dcbiAgICByb3cuc3BsaWNlKC0xLCAxKTtcblxuICAgIC8vIFB1c2ggaXQgdG8gdGhlIGxhc3Qgcm93XG4gICAgb3JnYW5pemF0aW9uLnJvd3NbbGFzdF0ucHVzaChub2RlKTtcblxuICAgIG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtsb25nZXN0XSA9IG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtsb25nZXN0XSAtIGRpZmY7XG4gICAgb3JnYW5pemF0aW9uLnJvd1dpZHRoW2xhc3RdID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW2xhc3RdICsgZGlmZjtcbiAgICBvcmdhbml6YXRpb24ud2lkdGggPSBvcmdhbml6YXRpb24ucm93V2lkdGhbaW5zdGFuY2UuZ2V0TG9uZ2VzdFJvd0luZGV4KG9yZ2FuaXphdGlvbildO1xuXG4gICAgLy8gVXBkYXRlIGhlaWdodHMgb2YgdGhlIG9yZ2FuaXphdGlvblxuICAgIHZhciBtYXhIZWlnaHQgPSBOdW1iZXIuTUlOX1ZBTFVFO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocm93W2ldLmhlaWdodCA+IG1heEhlaWdodCkgbWF4SGVpZ2h0ID0gcm93W2ldLmhlaWdodDtcbiAgICB9XG4gICAgaWYgKGxvbmdlc3QgPiAwKSBtYXhIZWlnaHQgKz0gb3JnYW5pemF0aW9uLnZlcnRpY2FsUGFkZGluZztcblxuICAgIHZhciBwcmV2VG90YWwgPSBvcmdhbml6YXRpb24ucm93SGVpZ2h0W2xvbmdlc3RdICsgb3JnYW5pemF0aW9uLnJvd0hlaWdodFtsYXN0XTtcblxuICAgIG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbbG9uZ2VzdF0gPSBtYXhIZWlnaHQ7XG4gICAgaWYgKG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbbGFzdF0gPCBub2RlLmhlaWdodCArIG9yZ2FuaXphdGlvbi52ZXJ0aWNhbFBhZGRpbmcpIG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbbGFzdF0gPSBub2RlLmhlaWdodCArIG9yZ2FuaXphdGlvbi52ZXJ0aWNhbFBhZGRpbmc7XG5cbiAgICB2YXIgZmluYWxUb3RhbCA9IG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbbG9uZ2VzdF0gKyBvcmdhbml6YXRpb24ucm93SGVpZ2h0W2xhc3RdO1xuICAgIG9yZ2FuaXphdGlvbi5oZWlnaHQgKz0gZmluYWxUb3RhbCAtIHByZXZUb3RhbDtcblxuICAgIHRoaXMuc2hpZnRUb0xhc3RSb3cob3JnYW5pemF0aW9uKTtcbiAgfVxufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUudGlsaW5nUHJlTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoQ29TRUNvbnN0YW50cy5USUxFKSB7XG4gICAgLy8gRmluZCB6ZXJvIGRlZ3JlZSBub2RlcyBhbmQgY3JlYXRlIGEgY29tcG91bmQgZm9yIGVhY2ggbGV2ZWxcbiAgICB0aGlzLmdyb3VwWmVyb0RlZ3JlZU1lbWJlcnMoKTtcbiAgICAvLyBUaWxlIGFuZCBjbGVhciBjaGlsZHJlbiBvZiBlYWNoIGNvbXBvdW5kXG4gICAgdGhpcy5jbGVhckNvbXBvdW5kcygpO1xuICAgIC8vIFNlcGFyYXRlbHkgdGlsZSBhbmQgY2xlYXIgemVybyBkZWdyZWUgbm9kZXMgZm9yIGVhY2ggbGV2ZWxcbiAgICB0aGlzLmNsZWFyWmVyb0RlZ3JlZU1lbWJlcnMoKTtcbiAgfVxufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUudGlsaW5nUG9zdExheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKENvU0VDb25zdGFudHMuVElMRSkge1xuICAgIHRoaXMucmVwb3B1bGF0ZVplcm9EZWdyZWVNZW1iZXJzKCk7XG4gICAgdGhpcy5yZXBvcHVsYXRlQ29tcG91bmRzKCk7XG4gIH1cbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBTZWN0aW9uOiBUcmVlIFJlZHVjdGlvbiBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUmVkdWNlIHRyZWVzIFxuQ29TRUxheW91dC5wcm90b3R5cGUucmVkdWNlVHJlZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwcnVuZWROb2Rlc0FsbCA9IFtdO1xuICB2YXIgY29udGFpbnNMZWFmID0gdHJ1ZTtcbiAgdmFyIG5vZGU7XG5cbiAgd2hpbGUgKGNvbnRhaW5zTGVhZikge1xuICAgIHZhciBhbGxOb2RlcyA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbE5vZGVzKCk7XG4gICAgdmFyIHBydW5lZE5vZGVzSW5TdGVwVGVtcCA9IFtdO1xuICAgIGNvbnRhaW5zTGVhZiA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbm9kZSA9IGFsbE5vZGVzW2ldO1xuICAgICAgaWYgKG5vZGUuZ2V0RWRnZXMoKS5sZW5ndGggPT0gMSAmJiAhbm9kZS5nZXRFZGdlcygpWzBdLmlzSW50ZXJHcmFwaCAmJiBub2RlLmdldENoaWxkKCkgPT0gbnVsbCkge1xuICAgICAgICBpZiAoQ29TRUNvbnN0YW50cy5QVVJFX0lOQ1JFTUVOVEFMKSB7XG4gICAgICAgICAgdmFyIG90aGVyRW5kID0gbm9kZS5nZXRFZGdlcygpWzBdLmdldE90aGVyRW5kKG5vZGUpO1xuICAgICAgICAgIHZhciByZWxhdGl2ZVBvc2l0aW9uID0gbmV3IERpbWVuc2lvbkQobm9kZS5nZXRDZW50ZXJYKCkgLSBvdGhlckVuZC5nZXRDZW50ZXJYKCksIG5vZGUuZ2V0Q2VudGVyWSgpIC0gb3RoZXJFbmQuZ2V0Q2VudGVyWSgpKTtcbiAgICAgICAgICBwcnVuZWROb2Rlc0luU3RlcFRlbXAucHVzaChbbm9kZSwgbm9kZS5nZXRFZGdlcygpWzBdLCBub2RlLmdldE93bmVyKCksIHJlbGF0aXZlUG9zaXRpb25dKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcnVuZWROb2Rlc0luU3RlcFRlbXAucHVzaChbbm9kZSwgbm9kZS5nZXRFZGdlcygpWzBdLCBub2RlLmdldE93bmVyKCldKTtcbiAgICAgICAgfVxuICAgICAgICBjb250YWluc0xlYWYgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGFpbnNMZWFmID09IHRydWUpIHtcbiAgICAgIHZhciBwcnVuZWROb2Rlc0luU3RlcCA9IFtdO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcnVuZWROb2Rlc0luU3RlcFRlbXAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHBydW5lZE5vZGVzSW5TdGVwVGVtcFtqXVswXS5nZXRFZGdlcygpLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgcHJ1bmVkTm9kZXNJblN0ZXAucHVzaChwcnVuZWROb2Rlc0luU3RlcFRlbXBbal0pO1xuICAgICAgICAgIHBydW5lZE5vZGVzSW5TdGVwVGVtcFtqXVswXS5nZXRPd25lcigpLnJlbW92ZShwcnVuZWROb2Rlc0luU3RlcFRlbXBbal1bMF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcnVuZWROb2Rlc0FsbC5wdXNoKHBydW5lZE5vZGVzSW5TdGVwKTtcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXMoKTtcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsRWRnZXMoKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5wcnVuZWROb2Rlc0FsbCA9IHBydW5lZE5vZGVzQWxsO1xufTtcblxuLy8gR3JvdyB0cmVlIG9uZSBzdGVwIFxuQ29TRUxheW91dC5wcm90b3R5cGUuZ3Jvd1RyZWUgPSBmdW5jdGlvbiAocHJ1bmVkTm9kZXNBbGwpIHtcbiAgdmFyIGxlbmd0aE9mUHJ1bmVkTm9kZXNJblN0ZXAgPSBwcnVuZWROb2Rlc0FsbC5sZW5ndGg7XG4gIHZhciBwcnVuZWROb2Rlc0luU3RlcCA9IHBydW5lZE5vZGVzQWxsW2xlbmd0aE9mUHJ1bmVkTm9kZXNJblN0ZXAgLSAxXTtcblxuICB2YXIgbm9kZURhdGE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJ1bmVkTm9kZXNJblN0ZXAubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlRGF0YSA9IHBydW5lZE5vZGVzSW5TdGVwW2ldO1xuXG4gICAgdGhpcy5maW5kUGxhY2Vmb3JQcnVuZWROb2RlKG5vZGVEYXRhKTtcblxuICAgIG5vZGVEYXRhWzJdLmFkZChub2RlRGF0YVswXSk7XG4gICAgbm9kZURhdGFbMl0uYWRkKG5vZGVEYXRhWzFdLCBub2RlRGF0YVsxXS5zb3VyY2UsIG5vZGVEYXRhWzFdLnRhcmdldCk7XG4gIH1cblxuICBwcnVuZWROb2Rlc0FsbC5zcGxpY2UocHJ1bmVkTm9kZXNBbGwubGVuZ3RoIC0gMSwgMSk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXMoKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIucmVzZXRBbGxFZGdlcygpO1xufTtcblxuLy8gRmluZCBhbiBhcHByb3ByaWF0ZSBwb3NpdGlvbiB0byByZXBsYWNlIHBydW5lZCBub2RlLCB0aGlzIG1ldGhvZCBjYW4gYmUgaW1wcm92ZWRcbkNvU0VMYXlvdXQucHJvdG90eXBlLmZpbmRQbGFjZWZvclBydW5lZE5vZGUgPSBmdW5jdGlvbiAobm9kZURhdGEpIHtcblxuICB2YXIgZ3JpZEZvclBydW5lZE5vZGU7XG4gIHZhciBub2RlVG9Db25uZWN0O1xuICB2YXIgcHJ1bmVkTm9kZSA9IG5vZGVEYXRhWzBdO1xuICBpZiAocHJ1bmVkTm9kZSA9PSBub2RlRGF0YVsxXS5zb3VyY2UpIHtcbiAgICBub2RlVG9Db25uZWN0ID0gbm9kZURhdGFbMV0udGFyZ2V0O1xuICB9IGVsc2Uge1xuICAgIG5vZGVUb0Nvbm5lY3QgPSBub2RlRGF0YVsxXS5zb3VyY2U7XG4gIH1cblxuICBpZiAoQ29TRUNvbnN0YW50cy5QVVJFX0lOQ1JFTUVOVEFMKSB7XG4gICAgcHJ1bmVkTm9kZS5zZXRDZW50ZXIobm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJYKCkgKyBub2RlRGF0YVszXS5nZXRXaWR0aCgpLCBub2RlVG9Db25uZWN0LmdldENlbnRlclkoKSArIG5vZGVEYXRhWzNdLmdldEhlaWdodCgpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3RhcnRHcmlkWCA9IG5vZGVUb0Nvbm5lY3Quc3RhcnRYO1xuICAgIHZhciBmaW5pc2hHcmlkWCA9IG5vZGVUb0Nvbm5lY3QuZmluaXNoWDtcbiAgICB2YXIgc3RhcnRHcmlkWSA9IG5vZGVUb0Nvbm5lY3Quc3RhcnRZO1xuICAgIHZhciBmaW5pc2hHcmlkWSA9IG5vZGVUb0Nvbm5lY3QuZmluaXNoWTtcblxuICAgIHZhciB1cE5vZGVDb3VudCA9IDA7XG4gICAgdmFyIGRvd25Ob2RlQ291bnQgPSAwO1xuICAgIHZhciByaWdodE5vZGVDb3VudCA9IDA7XG4gICAgdmFyIGxlZnROb2RlQ291bnQgPSAwO1xuICAgIHZhciBjb250cm9sUmVnaW9ucyA9IFt1cE5vZGVDb3VudCwgcmlnaHROb2RlQ291bnQsIGRvd25Ob2RlQ291bnQsIGxlZnROb2RlQ291bnRdO1xuXG4gICAgaWYgKHN0YXJ0R3JpZFkgPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRHcmlkWDsgaSA8PSBmaW5pc2hHcmlkWDsgaSsrKSB7XG4gICAgICAgIGNvbnRyb2xSZWdpb25zWzBdICs9IHRoaXMuZ3JpZFtpXVtzdGFydEdyaWRZIC0gMV0ubGVuZ3RoICsgdGhpcy5ncmlkW2ldW3N0YXJ0R3JpZFldLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmaW5pc2hHcmlkWCA8IHRoaXMuZ3JpZC5sZW5ndGggLSAxKSB7XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRHcmlkWTsgaSA8PSBmaW5pc2hHcmlkWTsgaSsrKSB7XG4gICAgICAgIGNvbnRyb2xSZWdpb25zWzFdICs9IHRoaXMuZ3JpZFtmaW5pc2hHcmlkWCArIDFdW2ldLmxlbmd0aCArIHRoaXMuZ3JpZFtmaW5pc2hHcmlkWF1baV0ubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZpbmlzaEdyaWRZIDwgdGhpcy5ncmlkWzBdLmxlbmd0aCAtIDEpIHtcbiAgICAgIGZvciAodmFyIGkgPSBzdGFydEdyaWRYOyBpIDw9IGZpbmlzaEdyaWRYOyBpKyspIHtcbiAgICAgICAgY29udHJvbFJlZ2lvbnNbMl0gKz0gdGhpcy5ncmlkW2ldW2ZpbmlzaEdyaWRZICsgMV0ubGVuZ3RoICsgdGhpcy5ncmlkW2ldW2ZpbmlzaEdyaWRZXS5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhcnRHcmlkWCA+IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSBzdGFydEdyaWRZOyBpIDw9IGZpbmlzaEdyaWRZOyBpKyspIHtcbiAgICAgICAgY29udHJvbFJlZ2lvbnNbM10gKz0gdGhpcy5ncmlkW3N0YXJ0R3JpZFggLSAxXVtpXS5sZW5ndGggKyB0aGlzLmdyaWRbc3RhcnRHcmlkWF1baV0ubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG1pbiA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICAgIHZhciBtaW5Db3VudDtcbiAgICB2YXIgbWluSW5kZXg7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb250cm9sUmVnaW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGNvbnRyb2xSZWdpb25zW2pdIDwgbWluKSB7XG4gICAgICAgIG1pbiA9IGNvbnRyb2xSZWdpb25zW2pdO1xuICAgICAgICBtaW5Db3VudCA9IDE7XG4gICAgICAgIG1pbkluZGV4ID0gajtcbiAgICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbal0gPT0gbWluKSB7XG4gICAgICAgIG1pbkNvdW50Kys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1pbkNvdW50ID09IDMgJiYgbWluID09IDApIHtcbiAgICAgIGlmIChjb250cm9sUmVnaW9uc1swXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzFdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbMl0gPT0gMCkge1xuICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDE7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRyb2xSZWdpb25zWzBdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbMV0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1szXSA9PSAwKSB7XG4gICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMF0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1syXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzNdID09IDApIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAzO1xuICAgICAgfSBlbHNlIGlmIChjb250cm9sUmVnaW9uc1sxXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzJdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbM10gPT0gMCkge1xuICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtaW5Db3VudCA9PSAyICYmIG1pbiA9PSAwKSB7XG4gICAgICB2YXIgcmFuZG9tID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMik7XG4gICAgICBpZiAoY29udHJvbFJlZ2lvbnNbMF0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1sxXSA9PSAwKSB7XG4gICAgICAgIDtcbiAgICAgICAgaWYgKHJhbmRvbSA9PSAwKSB7XG4gICAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb250cm9sUmVnaW9uc1swXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzJdID09IDApIHtcbiAgICAgICAgaWYgKHJhbmRvbSA9PSAwKSB7XG4gICAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb250cm9sUmVnaW9uc1swXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzNdID09IDApIHtcbiAgICAgICAgaWYgKHJhbmRvbSA9PSAwKSB7XG4gICAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb250cm9sUmVnaW9uc1sxXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzJdID09IDApIHtcbiAgICAgICAgaWYgKHJhbmRvbSA9PSAwKSB7XG4gICAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb250cm9sUmVnaW9uc1sxXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzNdID09IDApIHtcbiAgICAgICAgaWYgKHJhbmRvbSA9PSAwKSB7XG4gICAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJhbmRvbSA9PSAwKSB7XG4gICAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWluQ291bnQgPT0gNCAmJiBtaW4gPT0gMCkge1xuICAgICAgdmFyIHJhbmRvbSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDQpO1xuICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSByYW5kb207XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gbWluSW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKGdyaWRGb3JQcnVuZWROb2RlID09IDApIHtcbiAgICAgIHBydW5lZE5vZGUuc2V0Q2VudGVyKG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWCgpLCBub2RlVG9Db25uZWN0LmdldENlbnRlclkoKSAtIG5vZGVUb0Nvbm5lY3QuZ2V0SGVpZ2h0KCkgLyAyIC0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCAtIHBydW5lZE5vZGUuZ2V0SGVpZ2h0KCkgLyAyKTtcbiAgICB9IGVsc2UgaWYgKGdyaWRGb3JQcnVuZWROb2RlID09IDEpIHtcbiAgICAgIHBydW5lZE5vZGUuc2V0Q2VudGVyKG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWCgpICsgbm9kZVRvQ29ubmVjdC5nZXRXaWR0aCgpIC8gMiArIEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggKyBwcnVuZWROb2RlLmdldFdpZHRoKCkgLyAyLCBub2RlVG9Db25uZWN0LmdldENlbnRlclkoKSk7XG4gICAgfSBlbHNlIGlmIChncmlkRm9yUHJ1bmVkTm9kZSA9PSAyKSB7XG4gICAgICBwcnVuZWROb2RlLnNldENlbnRlcihub2RlVG9Db25uZWN0LmdldENlbnRlclgoKSwgbm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJZKCkgKyBub2RlVG9Db25uZWN0LmdldEhlaWdodCgpIC8gMiArIEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggKyBwcnVuZWROb2RlLmdldEhlaWdodCgpIC8gMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBydW5lZE5vZGUuc2V0Q2VudGVyKG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWCgpIC0gbm9kZVRvQ29ubmVjdC5nZXRXaWR0aCgpIC8gMiAtIEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggLSBwcnVuZWROb2RlLmdldFdpZHRoKCkgLyAyLCBub2RlVG9Db25uZWN0LmdldENlbnRlclkoKSk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvU0VMYXlvdXQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA5OTE6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG52YXIgRkRMYXlvdXROb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLkZETGF5b3V0Tm9kZTtcbnZhciBJTWF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5JTWF0aDtcblxuZnVuY3Rpb24gQ29TRU5vZGUoZ20sIGxvYywgc2l6ZSwgdk5vZGUpIHtcbiAgRkRMYXlvdXROb2RlLmNhbGwodGhpcywgZ20sIGxvYywgc2l6ZSwgdk5vZGUpO1xufVxuXG5Db1NFTm9kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZETGF5b3V0Tm9kZS5wcm90b3R5cGUpO1xuZm9yICh2YXIgcHJvcCBpbiBGRExheW91dE5vZGUpIHtcbiAgQ29TRU5vZGVbcHJvcF0gPSBGRExheW91dE5vZGVbcHJvcF07XG59XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5jYWxjdWxhdGVEaXNwbGFjZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsYXlvdXQgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRMYXlvdXQoKTtcbiAgLy8gdGhpcyBjaGVjayBpcyBmb3IgY29tcG91bmQgbm9kZXMgdGhhdCBjb250YWluIGZpeGVkIG5vZGVzXG4gIGlmICh0aGlzLmdldENoaWxkKCkgIT0gbnVsbCAmJiB0aGlzLmZpeGVkTm9kZVdlaWdodCkge1xuICAgIHRoaXMuZGlzcGxhY2VtZW50WCArPSBsYXlvdXQuY29vbGluZ0ZhY3RvciAqICh0aGlzLnNwcmluZ0ZvcmNlWCArIHRoaXMucmVwdWxzaW9uRm9yY2VYICsgdGhpcy5ncmF2aXRhdGlvbkZvcmNlWCkgLyB0aGlzLmZpeGVkTm9kZVdlaWdodDtcbiAgICB0aGlzLmRpc3BsYWNlbWVudFkgKz0gbGF5b3V0LmNvb2xpbmdGYWN0b3IgKiAodGhpcy5zcHJpbmdGb3JjZVkgKyB0aGlzLnJlcHVsc2lvbkZvcmNlWSArIHRoaXMuZ3Jhdml0YXRpb25Gb3JjZVkpIC8gdGhpcy5maXhlZE5vZGVXZWlnaHQ7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kaXNwbGFjZW1lbnRYICs9IGxheW91dC5jb29saW5nRmFjdG9yICogKHRoaXMuc3ByaW5nRm9yY2VYICsgdGhpcy5yZXB1bHNpb25Gb3JjZVggKyB0aGlzLmdyYXZpdGF0aW9uRm9yY2VYKSAvIHRoaXMubm9PZkNoaWxkcmVuO1xuICAgIHRoaXMuZGlzcGxhY2VtZW50WSArPSBsYXlvdXQuY29vbGluZ0ZhY3RvciAqICh0aGlzLnNwcmluZ0ZvcmNlWSArIHRoaXMucmVwdWxzaW9uRm9yY2VZICsgdGhpcy5ncmF2aXRhdGlvbkZvcmNlWSkgLyB0aGlzLm5vT2ZDaGlsZHJlbjtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyh0aGlzLmRpc3BsYWNlbWVudFgpID4gbGF5b3V0LmNvb2xpbmdGYWN0b3IgKiBsYXlvdXQubWF4Tm9kZURpc3BsYWNlbWVudCkge1xuICAgIHRoaXMuZGlzcGxhY2VtZW50WCA9IGxheW91dC5jb29saW5nRmFjdG9yICogbGF5b3V0Lm1heE5vZGVEaXNwbGFjZW1lbnQgKiBJTWF0aC5zaWduKHRoaXMuZGlzcGxhY2VtZW50WCk7XG4gIH1cblxuICBpZiAoTWF0aC5hYnModGhpcy5kaXNwbGFjZW1lbnRZKSA+IGxheW91dC5jb29saW5nRmFjdG9yICogbGF5b3V0Lm1heE5vZGVEaXNwbGFjZW1lbnQpIHtcbiAgICB0aGlzLmRpc3BsYWNlbWVudFkgPSBsYXlvdXQuY29vbGluZ0ZhY3RvciAqIGxheW91dC5tYXhOb2RlRGlzcGxhY2VtZW50ICogSU1hdGguc2lnbih0aGlzLmRpc3BsYWNlbWVudFkpO1xuICB9XG5cbiAgLy8gbm9uLWVtcHR5IGNvbXBvdW5kIG5vZGUsIHByb3BvZ2F0ZSBtb3ZlbWVudCB0byBjaGlsZHJlbiBhcyB3ZWxsXG4gIGlmICh0aGlzLmNoaWxkICYmIHRoaXMuY2hpbGQuZ2V0Tm9kZXMoKS5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5wcm9wb2dhdGVEaXNwbGFjZW1lbnRUb0NoaWxkcmVuKHRoaXMuZGlzcGxhY2VtZW50WCwgdGhpcy5kaXNwbGFjZW1lbnRZKTtcbiAgfVxufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLnByb3BvZ2F0ZURpc3BsYWNlbWVudFRvQ2hpbGRyZW4gPSBmdW5jdGlvbiAoZFgsIGRZKSB7XG4gIHZhciBub2RlcyA9IHRoaXMuZ2V0Q2hpbGQoKS5nZXROb2RlcygpO1xuICB2YXIgbm9kZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICBpZiAobm9kZS5nZXRDaGlsZCgpID09IG51bGwpIHtcbiAgICAgIG5vZGUuZGlzcGxhY2VtZW50WCArPSBkWDtcbiAgICAgIG5vZGUuZGlzcGxhY2VtZW50WSArPSBkWTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5wcm9wb2dhdGVEaXNwbGFjZW1lbnRUb0NoaWxkcmVuKGRYLCBkWSk7XG4gICAgfVxuICB9XG59O1xuXG5Db1NFTm9kZS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxheW91dCA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldExheW91dCgpO1xuXG4gIC8vIGEgc2ltcGxlIG5vZGUgb3IgYW4gZW1wdHkgY29tcG91bmQgbm9kZSwgbW92ZSBpdFxuICBpZiAodGhpcy5jaGlsZCA9PSBudWxsIHx8IHRoaXMuY2hpbGQuZ2V0Tm9kZXMoKS5sZW5ndGggPT0gMCkge1xuICAgIHRoaXMubW92ZUJ5KHRoaXMuZGlzcGxhY2VtZW50WCwgdGhpcy5kaXNwbGFjZW1lbnRZKTtcblxuICAgIGxheW91dC50b3RhbERpc3BsYWNlbWVudCArPSBNYXRoLmFicyh0aGlzLmRpc3BsYWNlbWVudFgpICsgTWF0aC5hYnModGhpcy5kaXNwbGFjZW1lbnRZKTtcbiAgfVxuXG4gIHRoaXMuc3ByaW5nRm9yY2VYID0gMDtcbiAgdGhpcy5zcHJpbmdGb3JjZVkgPSAwO1xuICB0aGlzLnJlcHVsc2lvbkZvcmNlWCA9IDA7XG4gIHRoaXMucmVwdWxzaW9uRm9yY2VZID0gMDtcbiAgdGhpcy5ncmF2aXRhdGlvbkZvcmNlWCA9IDA7XG4gIHRoaXMuZ3Jhdml0YXRpb25Gb3JjZVkgPSAwO1xuICB0aGlzLmRpc3BsYWNlbWVudFggPSAwO1xuICB0aGlzLmRpc3BsYWNlbWVudFkgPSAwO1xufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLnNldFByZWQxID0gZnVuY3Rpb24gKHByZWQxKSB7XG4gIHRoaXMucHJlZDEgPSBwcmVkMTtcbn07XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5nZXRQcmVkMSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHByZWQxO1xufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLmdldFByZWQyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcHJlZDI7XG59O1xuXG5Db1NFTm9kZS5wcm90b3R5cGUuc2V0TmV4dCA9IGZ1bmN0aW9uIChuZXh0KSB7XG4gIHRoaXMubmV4dCA9IG5leHQ7XG59O1xuXG5Db1NFTm9kZS5wcm90b3R5cGUuZ2V0TmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5leHQ7XG59O1xuXG5Db1NFTm9kZS5wcm90b3R5cGUuc2V0UHJvY2Vzc2VkID0gZnVuY3Rpb24gKHByb2Nlc3NlZCkge1xuICB0aGlzLnByb2Nlc3NlZCA9IHByb2Nlc3NlZDtcbn07XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5pc1Byb2Nlc3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHByb2Nlc3NlZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29TRU5vZGU7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA5MDI6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxudmFyIENvU0VDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwNik7XG52YXIgTGlua2VkTGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5MaW5rZWRMaXN0O1xudmFyIE1hdHJpeCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5NYXRyaXg7XG52YXIgU1ZEID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLlNWRDtcblxuZnVuY3Rpb24gQ29uc3RyYWludEhhbmRsZXIoKSB7fVxuXG5Db25zdHJhaW50SGFuZGxlci5oYW5kbGVDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChsYXlvdXQpIHtcbiAgLy8gIGxldCBsYXlvdXQgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRMYXlvdXQoKTtcblxuICAvLyBnZXQgY29uc3RyYWludHMgZnJvbSBsYXlvdXRcbiAgdmFyIGNvbnN0cmFpbnRzID0ge307XG4gIGNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQgPSBsYXlvdXQuY29uc3RyYWludHMuZml4ZWROb2RlQ29uc3RyYWludDtcbiAgY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludCA9IGxheW91dC5jb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50O1xuICBjb25zdHJhaW50cy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQgPSBsYXlvdXQuY29uc3RyYWludHMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50O1xuXG4gIHZhciBpZFRvTm9kZU1hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIG5vZGVJbmRleGVzID0gbmV3IE1hcCgpO1xuICB2YXIgeENvb3JkcyA9IFtdO1xuICB2YXIgeUNvb3JkcyA9IFtdO1xuXG4gIHZhciBhbGxOb2RlcyA9IGxheW91dC5nZXRBbGxOb2RlcygpO1xuICB2YXIgaW5kZXggPSAwO1xuICAvLyBmaWxsIGluZGV4IG1hcCBhbmQgY29vcmRpbmF0ZXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gYWxsTm9kZXNbaV07XG4gICAgaWYgKG5vZGUuZ2V0Q2hpbGQoKSA9PSBudWxsKSB7XG4gICAgICBub2RlSW5kZXhlcy5zZXQobm9kZS5pZCwgaW5kZXgrKyk7XG4gICAgICB4Q29vcmRzLnB1c2gobm9kZS5nZXRDZW50ZXJYKCkpO1xuICAgICAgeUNvb3Jkcy5wdXNoKG5vZGUuZ2V0Q2VudGVyWSgpKTtcbiAgICAgIGlkVG9Ob2RlTWFwLnNldChub2RlLmlkLCBub2RlKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGVyZSBleGlzdHMgcmVsYXRpdmUgcGxhY2VtZW50IGNvbnN0cmFpbnQgd2l0aG91dCBnYXAgdmFsdWUsIHNldCBpdCB0byBkZWZhdWx0IFxuICBpZiAoY29uc3RyYWludHMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50KSB7XG4gICAgY29uc3RyYWludHMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50LmZvckVhY2goZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgIGlmICghY29uc3RyYWludC5nYXAgJiYgY29uc3RyYWludC5nYXAgIT0gMCkge1xuICAgICAgICBpZiAoY29uc3RyYWludC5sZWZ0KSB7XG4gICAgICAgICAgY29uc3RyYWludC5nYXAgPSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggKyBpZFRvTm9kZU1hcC5nZXQoY29uc3RyYWludC5sZWZ0KS5nZXRXaWR0aCgpIC8gMiArIGlkVG9Ob2RlTWFwLmdldChjb25zdHJhaW50LnJpZ2h0KS5nZXRXaWR0aCgpIC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdHJhaW50LmdhcCA9IENvU0VDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCArIGlkVG9Ob2RlTWFwLmdldChjb25zdHJhaW50LnRvcCkuZ2V0SGVpZ2h0KCkgLyAyICsgaWRUb05vZGVNYXAuZ2V0KGNvbnN0cmFpbnQuYm90dG9tKS5nZXRIZWlnaHQoKSAvIDI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qIGF1eGlsaWFyeSBmdW5jdGlvbnMgKi9cblxuICAvLyBjYWxjdWxhdGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBwb3NpdGlvbiBvYmplY3RzXG4gIHZhciBjYWxjdWxhdGVQb3NpdGlvbkRpZmYgPSBmdW5jdGlvbiBjYWxjdWxhdGVQb3NpdGlvbkRpZmYocG9zMSwgcG9zMikge1xuICAgIHJldHVybiB7IHg6IHBvczEueCAtIHBvczIueCwgeTogcG9zMS55IC0gcG9zMi55IH07XG4gIH07XG5cbiAgLy8gY2FsY3VsYXRlIGF2ZXJhZ2UgcG9zaXRpb24gb2YgdGhlIG5vZGVzXG4gIHZhciBjYWxjdWxhdGVBdmdQb3NpdGlvbiA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUF2Z1Bvc2l0aW9uKG5vZGVJZFNldCkge1xuICAgIHZhciB4UG9zU3VtID0gMDtcbiAgICB2YXIgeVBvc1N1bSA9IDA7XG4gICAgbm9kZUlkU2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgeFBvc1N1bSArPSB4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXTtcbiAgICAgIHlQb3NTdW0gKz0geUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV07XG4gICAgfSk7XG5cbiAgICByZXR1cm4geyB4OiB4UG9zU3VtIC8gbm9kZUlkU2V0LnNpemUsIHk6IHlQb3NTdW0gLyBub2RlSWRTZXQuc2l6ZSB9O1xuICB9O1xuXG4gIC8vIGZpbmQgYW4gYXBwcm9wcmlhdGUgcG9zaXRpb25pbmcgZm9yIHRoZSBub2RlcyBpbiBhIGdpdmVuIGdyYXBoIGFjY29yZGluZyB0byByZWxhdGl2ZSBwbGFjZW1lbnQgY29uc3RyYWludHNcbiAgLy8gdGhpcyBmdW5jdGlvbiBhbHNvIHRha2VzIHRoZSBmaXhlZCBub2RlcyBhbmQgYWxpZ25tZW50IGNvbnN0cmFpbnRzIGludG8gYWNjb3VudFxuICAvLyBncmFwaDogZGFnIHRvIGJlIGV2YWx1YXRlZCwgZGlyZWN0aW9uOiBcImhvcml6b250YWxcIiBvciBcInZlcnRpY2FsXCIsIFxuICAvLyBmaXhlZE5vZGVzOiBzZXQgb2YgZml4ZWQgbm9kZXMgdG8gY29uc2lkZXIgZHVyaW5nIGV2YWx1YXRpb24sIGR1bW15UG9zaXRpb25zOiBhcHByb3ByaWF0ZSBjb29yZGluYXRlcyBvZiB0aGUgZHVtbXkgbm9kZXMgIFxuICB2YXIgZmluZEFwcHJvcHJpYXRlUG9zaXRpb25Gb3JSZWxhdGl2ZVBsYWNlbWVudCA9IGZ1bmN0aW9uIGZpbmRBcHByb3ByaWF0ZVBvc2l0aW9uRm9yUmVsYXRpdmVQbGFjZW1lbnQoZ3JhcGgsIGRpcmVjdGlvbiwgZml4ZWROb2RlcywgZHVtbXlQb3NpdGlvbnMsIGNvbXBvbmVudFNvdXJjZXMpIHtcblxuICAgIC8vIGZpbmQgdW5pb24gb2YgdHdvIHNldHNcbiAgICBmdW5jdGlvbiBzZXRVbmlvbihzZXRBLCBzZXRCKSB7XG4gICAgICB2YXIgdW5pb24gPSBuZXcgU2V0KHNldEEpO1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHNldEJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGVsZW0gPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIHVuaW9uLmFkZChlbGVtKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmlvbjtcbiAgICB9XG5cbiAgICAvLyBmaW5kIGluZGVncmVlIGNvdW50IGZvciBlYWNoIG5vZGVcbiAgICB2YXIgaW5EZWdyZWVzID0gbmV3IE1hcCgpO1xuXG4gICAgZ3JhcGguZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgaW5EZWdyZWVzLnNldChrZXksIDApO1xuICAgIH0pO1xuICAgIGdyYXBoLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKGFkamFjZW50KSB7XG4gICAgICAgIGluRGVncmVlcy5zZXQoYWRqYWNlbnQuaWQsIGluRGVncmVlcy5nZXQoYWRqYWNlbnQuaWQpICsgMSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHZhciBwb3NpdGlvbk1hcCA9IG5ldyBNYXAoKTsgLy8ga2VlcHMgdGhlIHBvc2l0aW9uIGZvciBlYWNoIG5vZGVcbiAgICB2YXIgcGFzdE1hcCA9IG5ldyBNYXAoKTsgLy8ga2VlcHMgdGhlIHByZWRlY2Vzc29ycyhwYXN0KSBvZiBhIG5vZGVcbiAgICB2YXIgcXVldWUgPSBuZXcgTGlua2VkTGlzdCgpO1xuICAgIGluRGVncmVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAodmFsdWUgPT0gMCkge1xuICAgICAgICBxdWV1ZS5wdXNoKGtleSk7XG4gICAgICAgIGlmICghZml4ZWROb2Rlcykge1xuICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChrZXksIG5vZGVJbmRleGVzLmhhcyhrZXkpID8geENvb3Jkc1tub2RlSW5kZXhlcy5nZXQoa2V5KV0gOiBkdW1teVBvc2l0aW9ucy5nZXQoa2V5KSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChrZXksIG5vZGVJbmRleGVzLmhhcyhrZXkpID8geUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQoa2V5KV0gOiBkdW1teVBvc2l0aW9ucy5nZXQoa2V5KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3NpdGlvbk1hcC5zZXQoa2V5LCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuICAgICAgfVxuICAgICAgaWYgKGZpeGVkTm9kZXMpIHtcbiAgICAgICAgcGFzdE1hcC5zZXQoa2V5LCBuZXcgU2V0KFtrZXldKSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBhbGlnbiBzb3VyY2VzIG9mIGVhY2ggY29tcG9uZW50IGluIGVuZm9yY2VtZW50IHBoYXNlXG4gICAgaWYgKGZpeGVkTm9kZXMpIHtcbiAgICAgIGNvbXBvbmVudFNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIHZhciBmaXhlZElkcyA9IFtdO1xuICAgICAgICBjb21wb25lbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgaWYgKGZpeGVkTm9kZXMuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICAgIGZpeGVkSWRzLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZml4ZWRJZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBwb3NpdGlvbiA9IDA7XG4gICAgICAgICAgZml4ZWRJZHMuZm9yRWFjaChmdW5jdGlvbiAoZml4ZWRJZCkge1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PSBcImhvcml6b250YWxcIikge1xuICAgICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQoZml4ZWRJZCwgbm9kZUluZGV4ZXMuaGFzKGZpeGVkSWQpID8geENvb3Jkc1tub2RlSW5kZXhlcy5nZXQoZml4ZWRJZCldIDogZHVtbXlQb3NpdGlvbnMuZ2V0KGZpeGVkSWQpKTtcbiAgICAgICAgICAgICAgcG9zaXRpb24gKz0gcG9zaXRpb25NYXAuZ2V0KGZpeGVkSWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcG9zaXRpb25NYXAuc2V0KGZpeGVkSWQsIG5vZGVJbmRleGVzLmhhcyhmaXhlZElkKSA/IHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KGZpeGVkSWQpXSA6IGR1bW15UG9zaXRpb25zLmdldChmaXhlZElkKSk7XG4gICAgICAgICAgICAgIHBvc2l0aW9uICs9IHBvc2l0aW9uTWFwLmdldChmaXhlZElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uIC8gZml4ZWRJZHMubGVuZ3RoO1xuICAgICAgICAgIGNvbXBvbmVudC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIGlmICghZml4ZWROb2Rlcy5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQobm9kZUlkLCBwb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9wb3NpdGlvbiA9IDA7XG4gICAgICAgICAgY29tcG9uZW50LmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PSBcImhvcml6b250YWxcIikge1xuICAgICAgICAgICAgICBfcG9zaXRpb24gKz0gbm9kZUluZGV4ZXMuaGFzKG5vZGVJZCkgPyB4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXSA6IGR1bW15UG9zaXRpb25zLmdldChub2RlSWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3Bvc2l0aW9uICs9IG5vZGVJbmRleGVzLmhhcyhub2RlSWQpID8geUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV0gOiBkdW1teVBvc2l0aW9ucy5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBfcG9zaXRpb24gPSBfcG9zaXRpb24gLyBjb21wb25lbnQubGVuZ3RoO1xuICAgICAgICAgIGNvbXBvbmVudC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChub2RlSWQsIF9wb3NpdGlvbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSBwb3NpdGlvbnMgb2YgdGhlIG5vZGVzXG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICB2YXIgbmVpZ2hib3JzID0gZ3JhcGguZ2V0KGN1cnJlbnROb2RlKTtcbiAgICAgIG5laWdoYm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChuZWlnaGJvcikge1xuICAgICAgICBpZiAocG9zaXRpb25NYXAuZ2V0KG5laWdoYm9yLmlkKSA8IHBvc2l0aW9uTWFwLmdldChjdXJyZW50Tm9kZSkgKyBuZWlnaGJvci5nYXApIHtcbiAgICAgICAgICBpZiAoZml4ZWROb2RlcyAmJiBmaXhlZE5vZGVzLmhhcyhuZWlnaGJvci5pZCkpIHtcbiAgICAgICAgICAgIHZhciBmaXhlZFBvc2l0aW9uID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PSBcImhvcml6b250YWxcIikge1xuICAgICAgICAgICAgICBmaXhlZFBvc2l0aW9uID0gbm9kZUluZGV4ZXMuaGFzKG5laWdoYm9yLmlkKSA/IHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5laWdoYm9yLmlkKV0gOiBkdW1teVBvc2l0aW9ucy5nZXQobmVpZ2hib3IuaWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZml4ZWRQb3NpdGlvbiA9IG5vZGVJbmRleGVzLmhhcyhuZWlnaGJvci5pZCkgPyB5Q29vcmRzW25vZGVJbmRleGVzLmdldChuZWlnaGJvci5pZCldIDogZHVtbXlQb3NpdGlvbnMuZ2V0KG5laWdoYm9yLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChuZWlnaGJvci5pZCwgZml4ZWRQb3NpdGlvbik7IC8vIFRPRE86IG1heSBkbyB1bm5lY2Vzc2FyeSB3b3JrXG4gICAgICAgICAgICBpZiAoZml4ZWRQb3NpdGlvbiA8IHBvc2l0aW9uTWFwLmdldChjdXJyZW50Tm9kZSkgKyBuZWlnaGJvci5nYXApIHtcbiAgICAgICAgICAgICAgdmFyIGRpZmYgPSBwb3NpdGlvbk1hcC5nZXQoY3VycmVudE5vZGUpICsgbmVpZ2hib3IuZ2FwIC0gZml4ZWRQb3NpdGlvbjtcbiAgICAgICAgICAgICAgcGFzdE1hcC5nZXQoY3VycmVudE5vZGUpLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChub2RlSWQsIHBvc2l0aW9uTWFwLmdldChub2RlSWQpIC0gZGlmZik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQobmVpZ2hib3IuaWQsIHBvc2l0aW9uTWFwLmdldChjdXJyZW50Tm9kZSkgKyBuZWlnaGJvci5nYXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbkRlZ3JlZXMuc2V0KG5laWdoYm9yLmlkLCBpbkRlZ3JlZXMuZ2V0KG5laWdoYm9yLmlkKSAtIDEpO1xuICAgICAgICBpZiAoaW5EZWdyZWVzLmdldChuZWlnaGJvci5pZCkgPT0gMCkge1xuICAgICAgICAgIHF1ZXVlLnB1c2gobmVpZ2hib3IuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXhlZE5vZGVzKSB7XG4gICAgICAgICAgcGFzdE1hcC5zZXQobmVpZ2hib3IuaWQsIHNldFVuaW9uKHBhc3RNYXAuZ2V0KGN1cnJlbnROb2RlKSwgcGFzdE1hcC5nZXQobmVpZ2hib3IuaWQpKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB3aGlsZSAocXVldWUubGVuZ3RoICE9IDApIHtcbiAgICAgIF9sb29wKCk7XG4gICAgfVxuXG4gICAgLy8gcmVhZGp1c3QgcG9zaXRpb24gb2YgdGhlIG5vZGVzIGFmdGVyIGVuZm9yY2VtZW50XG4gICAgaWYgKGZpeGVkTm9kZXMpIHtcbiAgICAgIC8vIGZpbmQgaW5kZWdyZWUgY291bnQgZm9yIGVhY2ggbm9kZVxuICAgICAgdmFyIHNpbmtOb2RlcyA9IG5ldyBTZXQoKTtcblxuICAgICAgZ3JhcGguZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09IDApIHtcbiAgICAgICAgICBzaW5rTm9kZXMuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgX2NvbXBvbmVudHMgPSBbXTtcbiAgICAgIHBhc3RNYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICBpZiAoc2lua05vZGVzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgdmFyIGlzRml4ZWRDb21wb25lbnQgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSB2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgICAgICAgICB2YXIgbm9kZUlkID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgICAgIGlmIChmaXhlZE5vZGVzLmhhcyhub2RlSWQpKSB7XG4gICAgICAgICAgICAgICAgaXNGaXhlZENvbXBvbmVudCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpc0ZpeGVkQ29tcG9uZW50KSB7XG4gICAgICAgICAgICB2YXIgaXNFeGlzdCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGV4aXN0QXQgPSB2b2lkIDA7XG4gICAgICAgICAgICBfY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgIGlmIChjb21wb25lbnQuaGFzKFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodmFsdWUpKVswXSkpIHtcbiAgICAgICAgICAgICAgICBpc0V4aXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBleGlzdEF0ID0gaW5kZXg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFpc0V4aXN0KSB7XG4gICAgICAgICAgICAgIF9jb21wb25lbnRzLnB1c2gobmV3IFNldCh2YWx1ZSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgICAgICAgX2NvbXBvbmVudHNbZXhpc3RBdF0uYWRkKGVsZSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIF9jb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIG1pbkJlZm9yZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgdmFyIG1pbkFmdGVyID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICB2YXIgbWF4QmVmb3JlID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgICB2YXIgbWF4QWZ0ZXIgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IzID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IGNvbXBvbmVudFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIG5vZGVJZCA9IF9zdGVwMy52YWx1ZTtcblxuICAgICAgICAgICAgdmFyIHBvc0JlZm9yZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgICAgcG9zQmVmb3JlID0gbm9kZUluZGV4ZXMuaGFzKG5vZGVJZCkgPyB4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXSA6IGR1bW15UG9zaXRpb25zLmdldChub2RlSWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcG9zQmVmb3JlID0gbm9kZUluZGV4ZXMuaGFzKG5vZGVJZCkgPyB5Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXSA6IGR1bW15UG9zaXRpb25zLmdldChub2RlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBvc0FmdGVyID0gcG9zaXRpb25NYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICBpZiAocG9zQmVmb3JlIDwgbWluQmVmb3JlKSB7XG4gICAgICAgICAgICAgIG1pbkJlZm9yZSA9IHBvc0JlZm9yZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3NCZWZvcmUgPiBtYXhCZWZvcmUpIHtcbiAgICAgICAgICAgICAgbWF4QmVmb3JlID0gcG9zQmVmb3JlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvc0FmdGVyIDwgbWluQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgbWluQWZ0ZXIgPSBwb3NBZnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3NBZnRlciA+IG1heEFmdGVyKSB7XG4gICAgICAgICAgICAgIG1heEFmdGVyID0gcG9zQWZ0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjMgPSB0cnVlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yMyA9IGVycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyAmJiBfaXRlcmF0b3IzLnJldHVybikge1xuICAgICAgICAgICAgICBfaXRlcmF0b3IzLnJldHVybigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7XG4gICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlmZiA9IChtaW5CZWZvcmUgKyBtYXhCZWZvcmUpIC8gMiAtIChtaW5BZnRlciArIG1heEFmdGVyKSAvIDI7XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNCA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I0ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNCA9IGNvbXBvbmVudFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IChfc3RlcDQgPSBfaXRlcmF0b3I0Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIF9ub2RlSWQgPSBfc3RlcDQudmFsdWU7XG5cbiAgICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChfbm9kZUlkLCBwb3NpdGlvbk1hcC5nZXQoX25vZGVJZCkgKyBkaWZmKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yNCA9IHRydWU7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3I0ID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ICYmIF9pdGVyYXRvcjQucmV0dXJuKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjQucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvc2l0aW9uTWFwO1xuICB9O1xuXG4gIC8vIGZpbmQgdHJhbnNmb3JtYXRpb24gYmFzZWQgb24gcmVsLiBwbGFjZW1lbnQgY29uc3RyYWludHMgaWYgdGhlcmUgYXJlIGJvdGggYWxpZ25tZW50IGFuZCByZWwuIHBsYWNlbWVudCBjb25zdHJhaW50c1xuICAvLyBvciBpZiB0aGVyZSBhcmUgb25seSByZWwuIHBsYWNlbWVudCBjb250cmFpbnRzIHdoZXJlIHRoZSBsYXJnZXN0IGNvbXBvbmVudCBpc24ndCBzdWZmaWNpZW50bHkgbGFyZ2VcbiAgdmFyIGFwcGx5UmVmbGVjdGlvbkZvclJlbGF0aXZlUGxhY2VtZW50ID0gZnVuY3Rpb24gYXBwbHlSZWZsZWN0aW9uRm9yUmVsYXRpdmVQbGFjZW1lbnQocmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50cykge1xuICAgIC8vIHZhcmlhYmxlcyB0byBjb3VudCB2b3Rlc1xuICAgIHZhciByZWZsZWN0T25ZID0gMCxcbiAgICAgICAgbm90UmVmbGVjdE9uWSA9IDA7XG4gICAgdmFyIHJlZmxlY3RPblggPSAwLFxuICAgICAgICBub3RSZWZsZWN0T25YID0gMDtcblxuICAgIHJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludHMuZm9yRWFjaChmdW5jdGlvbiAoY29uc3RyYWludCkge1xuICAgICAgaWYgKGNvbnN0cmFpbnQubGVmdCkge1xuICAgICAgICB4Q29vcmRzW25vZGVJbmRleGVzLmdldChjb25zdHJhaW50LmxlZnQpXSAtIHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KGNvbnN0cmFpbnQucmlnaHQpXSA+PSAwID8gcmVmbGVjdE9uWSsrIDogbm90UmVmbGVjdE9uWSsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQoY29uc3RyYWludC50b3ApXSAtIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KGNvbnN0cmFpbnQuYm90dG9tKV0gPj0gMCA/IHJlZmxlY3RPblgrKyA6IG5vdFJlZmxlY3RPblgrKztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChyZWZsZWN0T25ZID4gbm90UmVmbGVjdE9uWSAmJiByZWZsZWN0T25YID4gbm90UmVmbGVjdE9uWCkge1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5vZGVJbmRleGVzLnNpemU7IF9pKyspIHtcbiAgICAgICAgeENvb3Jkc1tfaV0gPSAtMSAqIHhDb29yZHNbX2ldO1xuICAgICAgICB5Q29vcmRzW19pXSA9IC0xICogeUNvb3Jkc1tfaV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWZsZWN0T25ZID4gbm90UmVmbGVjdE9uWSkge1xuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZUluZGV4ZXMuc2l6ZTsgX2kyKyspIHtcbiAgICAgICAgeENvb3Jkc1tfaTJdID0gLTEgKiB4Q29vcmRzW19pMl07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWZsZWN0T25YID4gbm90UmVmbGVjdE9uWCkge1xuICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbm9kZUluZGV4ZXMuc2l6ZTsgX2kzKyspIHtcbiAgICAgICAgeUNvb3Jkc1tfaTNdID0gLTEgKiB5Q29vcmRzW19pM107XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIGZpbmQgd2Vha2x5IGNvbm5lY3RlZCBjb21wb25lbnRzIGluIHVuZGlyZWN0ZWQgZ3JhcGhcbiAgdmFyIGZpbmRDb21wb25lbnRzID0gZnVuY3Rpb24gZmluZENvbXBvbmVudHMoZ3JhcGgpIHtcbiAgICAvLyBmaW5kIHdlYWtseSBjb25uZWN0ZWQgY29tcG9uZW50cyBpbiBkYWdcbiAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICAgIHZhciBxdWV1ZSA9IG5ldyBMaW5rZWRMaXN0KCk7XG4gICAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGNvdW50ID0gMDtcblxuICAgIGdyYXBoLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmICghdmlzaXRlZC5oYXMoa2V5KSkge1xuICAgICAgICBjb21wb25lbnRzW2NvdW50XSA9IFtdO1xuICAgICAgICB2YXIgX2N1cnJlbnROb2RlID0ga2V5O1xuICAgICAgICBxdWV1ZS5wdXNoKF9jdXJyZW50Tm9kZSk7XG4gICAgICAgIHZpc2l0ZWQuYWRkKF9jdXJyZW50Tm9kZSk7XG4gICAgICAgIGNvbXBvbmVudHNbY291bnRdLnB1c2goX2N1cnJlbnROb2RlKTtcblxuICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoICE9IDApIHtcbiAgICAgICAgICBfY3VycmVudE5vZGUgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgIHZhciBuZWlnaGJvcnMgPSBncmFwaC5nZXQoX2N1cnJlbnROb2RlKTtcbiAgICAgICAgICBuZWlnaGJvcnMuZm9yRWFjaChmdW5jdGlvbiAobmVpZ2hib3IpIHtcbiAgICAgICAgICAgIGlmICghdmlzaXRlZC5oYXMobmVpZ2hib3IuaWQpKSB7XG4gICAgICAgICAgICAgIHF1ZXVlLnB1c2gobmVpZ2hib3IuaWQpO1xuICAgICAgICAgICAgICB2aXNpdGVkLmFkZChuZWlnaGJvci5pZCk7XG4gICAgICAgICAgICAgIGNvbXBvbmVudHNbY291bnRdLnB1c2gobmVpZ2hib3IuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gIH07XG5cbiAgLy8gcmV0dXJuIHVuZGlyZWN0ZWQgdmVyc2lvbiBvZiBnaXZlbiBkYWdcbiAgdmFyIGRhZ1RvVW5kaXJlY3RlZCA9IGZ1bmN0aW9uIGRhZ1RvVW5kaXJlY3RlZChkYWcpIHtcbiAgICB2YXIgdW5kaXJlY3RlZCA9IG5ldyBNYXAoKTtcblxuICAgIGRhZy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICB1bmRpcmVjdGVkLnNldChrZXksIFtdKTtcbiAgICB9KTtcblxuICAgIGRhZy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChhZGphY2VudCkge1xuICAgICAgICB1bmRpcmVjdGVkLmdldChrZXkpLnB1c2goYWRqYWNlbnQpO1xuICAgICAgICB1bmRpcmVjdGVkLmdldChhZGphY2VudC5pZCkucHVzaCh7IGlkOiBrZXksIGdhcDogYWRqYWNlbnQuZ2FwLCBkaXJlY3Rpb246IGFkamFjZW50LmRpcmVjdGlvbiB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHVuZGlyZWN0ZWQ7XG4gIH07XG5cbiAgLy8gcmV0dXJuIHJldmVyc2VkIChkaXJlY3Rpb25zIGludmVydGVkKSB2ZXJzaW9uIG9mIGdpdmVuIGRhZ1xuICB2YXIgZGFnVG9SZXZlcnNlZCA9IGZ1bmN0aW9uIGRhZ1RvUmV2ZXJzZWQoZGFnKSB7XG4gICAgdmFyIHJldmVyc2VkID0gbmV3IE1hcCgpO1xuXG4gICAgZGFnLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIHJldmVyc2VkLnNldChrZXksIFtdKTtcbiAgICB9KTtcblxuICAgIGRhZy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChhZGphY2VudCkge1xuICAgICAgICByZXZlcnNlZC5nZXQoYWRqYWNlbnQuaWQpLnB1c2goeyBpZDoga2V5LCBnYXA6IGFkamFjZW50LmdhcCwgZGlyZWN0aW9uOiBhZGphY2VudC5kaXJlY3Rpb24gfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXZlcnNlZDtcbiAgfTtcblxuICAvKioqKiAgYXBwbHkgdHJhbnNmb3JtYXRpb24gdG8gdGhlIGluaXRpYWwgZHJhZnQgbGF5b3V0IHRvIGJldHRlciBhbGlnbiB3aXRoIGNvbnN0cmFpbmVkIG5vZGVzICoqKiovXG4gIC8vIHNvbHZlIHRoZSBPcnRob2dvbmFsIFByb2NydXN0ZWFuIFByb2JsZW0gdG8gcm90YXRlIGFuZC9vciByZWZsZWN0IGluaXRpYWwgZHJhZnQgbGF5b3V0XG4gIC8vIGhlcmUgd2UgZm9sbG93IHRoZSBzb2x1dGlvbiBpbiBDaGFwdGVyIDIwLjIgb2YgQm9yZywgSS4gJiBHcm9lbmVuLCBQLiAoMjAwNSkgTW9kZXJuIE11bHRpZGltZW5zaW9uYWwgU2NhbGluZzogVGhlb3J5IGFuZCBBcHBsaWNhdGlvbnMgXG5cbiAgLyogY29uc3RydWN0IHNvdXJjZSBhbmQgdGFyZ2V0IGNvbmZpZ3VyYXRpb25zICovXG5cbiAgdmFyIHRhcmdldE1hdHJpeCA9IFtdOyAvLyBBIC0gdGFyZ2V0IGNvbmZpZ3VyYXRpb25cbiAgdmFyIHNvdXJjZU1hdHJpeCA9IFtdOyAvLyBCIC0gc291cmNlIGNvbmZpZ3VyYXRpb24gXG4gIHZhciBzdGFuZGFyZFRyYW5zZm9ybWF0aW9uID0gZmFsc2U7IC8vIGZhbHNlIGZvciBubyB0cmFuc2Zvcm1hdGlvbiwgdHJ1ZSBmb3Igc3RhbmRhcnQgKFByb2NydXN0ZXMpIHRyYW5zZm9ybWF0aW9uIChyb3RhdGlvbiBhbmQvb3IgcmVmbGVjdGlvbilcbiAgdmFyIHJlZmxlY3Rpb25UeXBlID0gZmFsc2U7IC8vIGZhbHNlL3RydWUgZm9yIHJlZmxlY3Rpb24gY2hlY2ssICdyZWZsZWN0T25YJywgJ3JlZmxlY3RPblknIG9yICdyZWZsZWN0T25Cb3RoJyBmb3IgcmVmbGVjdGlvbiB0eXBlIGlmIG5lY2Vzc2FyeVxuICB2YXIgZml4ZWROb2RlcyA9IG5ldyBTZXQoKTtcbiAgdmFyIGRhZyA9IG5ldyBNYXAoKTsgLy8gYWRqYWNlbmN5IGxpc3QgdG8ga2VlcCBkaXJlY3RlZCBhY3ljbGljIGdyYXBoIChkYWcpIHRoYXQgY29uc2lzdHMgb2YgcmVsYXRpdmUgcGxhY2VtZW50IGNvbnN0cmFpbnRzXG4gIHZhciBkYWdVbmRpcmVjdGVkID0gbmV3IE1hcCgpOyAvLyB1bmRpcmVjdGVkIHZlcnNpb24gb2YgdGhlIGRhZ1xuICB2YXIgY29tcG9uZW50cyA9IFtdOyAvLyB3ZWFrbHkgY29ubmVjdGVkIGNvbXBvbmVudHNcblxuICAvLyBmaWxsIGZpeGVkTm9kZXMgY29sbGVjdGlvbiB0byB1c2UgbGF0ZXJcbiAgaWYgKGNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQpIHtcbiAgICBjb25zdHJhaW50cy5maXhlZE5vZGVDb25zdHJhaW50LmZvckVhY2goZnVuY3Rpb24gKG5vZGVEYXRhKSB7XG4gICAgICBmaXhlZE5vZGVzLmFkZChub2RlRGF0YS5ub2RlSWQpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gY29uc3RydWN0IGRhZyBmcm9tIHJlbGF0aXZlIHBsYWNlbWVudCBjb25zdHJhaW50cyBcbiAgaWYgKGNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCkge1xuICAgIC8vIGNvbnN0cnVjdCBib3RoIGRpcmVjdGVkIGFuZCB1bmRpcmVjdGVkIHZlcnNpb24gb2YgdGhlIGRhZ1xuICAgIGNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludC5mb3JFYWNoKGZ1bmN0aW9uIChjb25zdHJhaW50KSB7XG4gICAgICBpZiAoY29uc3RyYWludC5sZWZ0KSB7XG4gICAgICAgIGlmIChkYWcuaGFzKGNvbnN0cmFpbnQubGVmdCkpIHtcbiAgICAgICAgICBkYWcuZ2V0KGNvbnN0cmFpbnQubGVmdCkucHVzaCh7IGlkOiBjb25zdHJhaW50LnJpZ2h0LCBnYXA6IGNvbnN0cmFpbnQuZ2FwLCBkaXJlY3Rpb246IFwiaG9yaXpvbnRhbFwiIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhZy5zZXQoY29uc3RyYWludC5sZWZ0LCBbeyBpZDogY29uc3RyYWludC5yaWdodCwgZ2FwOiBjb25zdHJhaW50LmdhcCwgZGlyZWN0aW9uOiBcImhvcml6b250YWxcIiB9XSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYWcuaGFzKGNvbnN0cmFpbnQucmlnaHQpKSB7XG4gICAgICAgICAgZGFnLnNldChjb25zdHJhaW50LnJpZ2h0LCBbXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChkYWcuaGFzKGNvbnN0cmFpbnQudG9wKSkge1xuICAgICAgICAgIGRhZy5nZXQoY29uc3RyYWludC50b3ApLnB1c2goeyBpZDogY29uc3RyYWludC5ib3R0b20sIGdhcDogY29uc3RyYWludC5nYXAsIGRpcmVjdGlvbjogXCJ2ZXJ0aWNhbFwiIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhZy5zZXQoY29uc3RyYWludC50b3AsIFt7IGlkOiBjb25zdHJhaW50LmJvdHRvbSwgZ2FwOiBjb25zdHJhaW50LmdhcCwgZGlyZWN0aW9uOiBcInZlcnRpY2FsXCIgfV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGFnLmhhcyhjb25zdHJhaW50LmJvdHRvbSkpIHtcbiAgICAgICAgICBkYWcuc2V0KGNvbnN0cmFpbnQuYm90dG9tLCBbXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRhZ1VuZGlyZWN0ZWQgPSBkYWdUb1VuZGlyZWN0ZWQoZGFnKTtcbiAgICBjb21wb25lbnRzID0gZmluZENvbXBvbmVudHMoZGFnVW5kaXJlY3RlZCk7XG4gIH1cblxuICBpZiAoQ29TRUNvbnN0YW50cy5UUkFOU0ZPUk1fT05fQ09OU1RSQUlOVF9IQU5ETElORykge1xuICAgIC8vIGZpcnN0IGNoZWNrIGZpeGVkIG5vZGUgY29uc3RyYWludFxuICAgIGlmIChjb25zdHJhaW50cy5maXhlZE5vZGVDb25zdHJhaW50ICYmIGNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3RyYWludHMuZml4ZWROb2RlQ29uc3RyYWludC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlRGF0YSwgaSkge1xuICAgICAgICB0YXJnZXRNYXRyaXhbaV0gPSBbbm9kZURhdGEucG9zaXRpb24ueCwgbm9kZURhdGEucG9zaXRpb24ueV07XG4gICAgICAgIHNvdXJjZU1hdHJpeFtpXSA9IFt4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlRGF0YS5ub2RlSWQpXSwgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZURhdGEubm9kZUlkKV1dO1xuICAgICAgfSk7XG4gICAgICBzdGFuZGFyZFRyYW5zZm9ybWF0aW9uID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQpIHtcbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHRoZW4gY2hlY2sgYWxpZ25tZW50IGNvbnN0cmFpbnRcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgaWYgKGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWwpIHtcbiAgICAgICAgICB2YXIgdmVydGljYWxBbGlnbiA9IGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWw7XG5cbiAgICAgICAgICB2YXIgX2xvb3AyID0gZnVuY3Rpb24gX2xvb3AyKF9pNCkge1xuICAgICAgICAgICAgdmFyIGFsaWdubWVudFNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIHZlcnRpY2FsQWxpZ25bX2k0XS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgICAgYWxpZ25tZW50U2V0LmFkZChub2RlSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gbmV3IFNldChbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFsaWdubWVudFNldCkpLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICByZXR1cm4gZml4ZWROb2Rlcy5oYXMoeCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB2YXIgeFBvcyA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb24uc2l6ZSA+IDApIHhQb3MgPSB4Q29vcmRzW25vZGVJbmRleGVzLmdldChpbnRlcnNlY3Rpb24udmFsdWVzKCkubmV4dCgpLnZhbHVlKV07ZWxzZSB4UG9zID0gY2FsY3VsYXRlQXZnUG9zaXRpb24oYWxpZ25tZW50U2V0KS54O1xuXG4gICAgICAgICAgICB2ZXJ0aWNhbEFsaWduW19pNF0uZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICAgIHRhcmdldE1hdHJpeFtjb3VudF0gPSBbeFBvcywgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV1dO1xuICAgICAgICAgICAgICBzb3VyY2VNYXRyaXhbY291bnRdID0gW3hDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldLCB5Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXV07XG4gICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgdmVydGljYWxBbGlnbi5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICAgICAgICBfbG9vcDIoX2k0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhbmRhcmRUcmFuc2Zvcm1hdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQuaG9yaXpvbnRhbCkge1xuICAgICAgICAgIHZhciBob3Jpem9udGFsQWxpZ24gPSBjb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50Lmhvcml6b250YWw7XG5cbiAgICAgICAgICB2YXIgX2xvb3AzID0gZnVuY3Rpb24gX2xvb3AzKF9pNSkge1xuICAgICAgICAgICAgdmFyIGFsaWdubWVudFNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGhvcml6b250YWxBbGlnbltfaTVdLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICBhbGlnbm1lbnRTZXQuYWRkKG5vZGVJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBuZXcgU2V0KFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoYWxpZ25tZW50U2V0KSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmaXhlZE5vZGVzLmhhcyh4KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHZhciB5UG9zID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKGludGVyc2VjdGlvbi5zaXplID4gMCkgeVBvcyA9IHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KGludGVyc2VjdGlvbi52YWx1ZXMoKS5uZXh0KCkudmFsdWUpXTtlbHNlIHlQb3MgPSBjYWxjdWxhdGVBdmdQb3NpdGlvbihhbGlnbm1lbnRTZXQpLnk7XG5cbiAgICAgICAgICAgIGhvcml6b250YWxBbGlnbltfaTVdLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICB0YXJnZXRNYXRyaXhbY291bnRdID0gW3hDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldLCB5UG9zXTtcbiAgICAgICAgICAgICAgc291cmNlTWF0cml4W2NvdW50XSA9IFt4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXSwgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV1dO1xuICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IGhvcml6b250YWxBbGlnbi5sZW5ndGg7IF9pNSsrKSB7XG4gICAgICAgICAgICBfbG9vcDMoX2k1KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhbmRhcmRUcmFuc2Zvcm1hdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCkge1xuICAgICAgICAgIHJlZmxlY3Rpb25UeXBlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSkoKTtcbiAgICB9IGVsc2UgaWYgKGNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCkge1xuICAgICAgLy8gZmluYWxseSBjaGVjayByZWxhdGl2ZSBwbGFjZW1lbnQgY29uc3RyYWludFxuICAgICAgLy8gZmluZCBsYXJnZXN0IGNvbXBvbmVudCBpbiBkYWdcbiAgICAgIHZhciBsYXJnZXN0Q29tcG9uZW50U2l6ZSA9IDA7XG4gICAgICB2YXIgbGFyZ2VzdENvbXBvbmVudEluZGV4ID0gMDtcbiAgICAgIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IGNvbXBvbmVudHMubGVuZ3RoOyBfaTYrKykge1xuICAgICAgICBpZiAoY29tcG9uZW50c1tfaTZdLmxlbmd0aCA+IGxhcmdlc3RDb21wb25lbnRTaXplKSB7XG4gICAgICAgICAgbGFyZ2VzdENvbXBvbmVudFNpemUgPSBjb21wb25lbnRzW19pNl0ubGVuZ3RoO1xuICAgICAgICAgIGxhcmdlc3RDb21wb25lbnRJbmRleCA9IF9pNjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaWYgbGFyZ2VzdCBjb21wb25lbnQgaXNuJ3QgZG9taW5hbnQsIHRoZW4gdGFrZSB0aGUgdm90ZXMgZm9yIHJlZmxlY3Rpb25cbiAgICAgIGlmIChsYXJnZXN0Q29tcG9uZW50U2l6ZSA8IGRhZ1VuZGlyZWN0ZWQuc2l6ZSAvIDIpIHtcbiAgICAgICAgYXBwbHlSZWZsZWN0aW9uRm9yUmVsYXRpdmVQbGFjZW1lbnQoY29uc3RyYWludHMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50KTtcbiAgICAgICAgc3RhbmRhcmRUcmFuc2Zvcm1hdGlvbiA9IGZhbHNlO1xuICAgICAgICByZWZsZWN0aW9uVHlwZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXNlIGxhcmdlc3QgY29tcG9uZW50IGZvciB0cmFuc2Zvcm1hdGlvblxuICAgICAgICAvLyBjb25zdHJ1Y3QgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgc3ViZ3JhcGhzIGluIHRoZSBsYXJnZXN0IGNvbXBvbmVudFxuICAgICAgICB2YXIgc3ViR3JhcGhPbkhvcml6b250YWwgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBzdWJHcmFwaE9uVmVydGljYWwgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBjb25zdHJhaW50c0lubGFyZ2VzdENvbXBvbmVudCA9IFtdO1xuXG4gICAgICAgIGNvbXBvbmVudHNbbGFyZ2VzdENvbXBvbmVudEluZGV4XS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICBkYWcuZ2V0KG5vZGVJZCkuZm9yRWFjaChmdW5jdGlvbiAoYWRqYWNlbnQpIHtcbiAgICAgICAgICAgIGlmIChhZGphY2VudC5kaXJlY3Rpb24gPT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgICAgaWYgKHN1YkdyYXBoT25Ib3Jpem9udGFsLmhhcyhub2RlSWQpKSB7XG4gICAgICAgICAgICAgICAgc3ViR3JhcGhPbkhvcml6b250YWwuZ2V0KG5vZGVJZCkucHVzaChhZGphY2VudCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3ViR3JhcGhPbkhvcml6b250YWwuc2V0KG5vZGVJZCwgW2FkamFjZW50XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFzdWJHcmFwaE9uSG9yaXpvbnRhbC5oYXMoYWRqYWNlbnQuaWQpKSB7XG4gICAgICAgICAgICAgICAgc3ViR3JhcGhPbkhvcml6b250YWwuc2V0KGFkamFjZW50LmlkLCBbXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3RyYWludHNJbmxhcmdlc3RDb21wb25lbnQucHVzaCh7IGxlZnQ6IG5vZGVJZCwgcmlnaHQ6IGFkamFjZW50LmlkIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHN1YkdyYXBoT25WZXJ0aWNhbC5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgICAgIHN1YkdyYXBoT25WZXJ0aWNhbC5nZXQobm9kZUlkKS5wdXNoKGFkamFjZW50KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdWJHcmFwaE9uVmVydGljYWwuc2V0KG5vZGVJZCwgW2FkamFjZW50XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFzdWJHcmFwaE9uVmVydGljYWwuaGFzKGFkamFjZW50LmlkKSkge1xuICAgICAgICAgICAgICAgIHN1YkdyYXBoT25WZXJ0aWNhbC5zZXQoYWRqYWNlbnQuaWQsIFtdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdHJhaW50c0lubGFyZ2VzdENvbXBvbmVudC5wdXNoKHsgdG9wOiBub2RlSWQsIGJvdHRvbTogYWRqYWNlbnQuaWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFwcGx5UmVmbGVjdGlvbkZvclJlbGF0aXZlUGxhY2VtZW50KGNvbnN0cmFpbnRzSW5sYXJnZXN0Q29tcG9uZW50KTtcbiAgICAgICAgcmVmbGVjdGlvblR5cGUgPSBmYWxzZTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgYXBwcm9wcmlhdGUgcG9zaXRpb25pbmcgZm9yIHN1YmdyYXBoc1xuICAgICAgICB2YXIgcG9zaXRpb25NYXBIb3Jpem9udGFsID0gZmluZEFwcHJvcHJpYXRlUG9zaXRpb25Gb3JSZWxhdGl2ZVBsYWNlbWVudChzdWJHcmFwaE9uSG9yaXpvbnRhbCwgXCJob3Jpem9udGFsXCIpO1xuICAgICAgICB2YXIgcG9zaXRpb25NYXBWZXJ0aWNhbCA9IGZpbmRBcHByb3ByaWF0ZVBvc2l0aW9uRm9yUmVsYXRpdmVQbGFjZW1lbnQoc3ViR3JhcGhPblZlcnRpY2FsLCBcInZlcnRpY2FsXCIpO1xuXG4gICAgICAgIC8vIGNvbnN0cnVjdCBzb3VyY2UgYW5kIHRhcmdldCBjb25maWd1cmF0aW9uXG4gICAgICAgIGNvbXBvbmVudHNbbGFyZ2VzdENvbXBvbmVudEluZGV4XS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQsIGkpIHtcbiAgICAgICAgICBzb3VyY2VNYXRyaXhbaV0gPSBbeENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV0sIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldXTtcbiAgICAgICAgICB0YXJnZXRNYXRyaXhbaV0gPSBbXTtcbiAgICAgICAgICBpZiAocG9zaXRpb25NYXBIb3Jpem9udGFsLmhhcyhub2RlSWQpKSB7XG4gICAgICAgICAgICB0YXJnZXRNYXRyaXhbaV1bMF0gPSBwb3NpdGlvbk1hcEhvcml6b250YWwuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldE1hdHJpeFtpXVswXSA9IHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocG9zaXRpb25NYXBWZXJ0aWNhbC5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgdGFyZ2V0TWF0cml4W2ldWzFdID0gcG9zaXRpb25NYXBWZXJ0aWNhbC5nZXQobm9kZUlkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0TWF0cml4W2ldWzFdID0geUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBzdGFuZGFyZFRyYW5zZm9ybWF0aW9uID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB0cmFuc2Zvcm1hdGlvbiBpcyByZXF1aXJlZCwgdGhlbiBjYWxjdWxhdGUgYW5kIGFwcGx5IHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuICAgIGlmIChzdGFuZGFyZFRyYW5zZm9ybWF0aW9uKSB7XG4gICAgICAvKiBjYWxjdWxhdGUgdHJhbnNmb3JtYXRpb24gbWF0cml4ICovXG4gICAgICB2YXIgdHJhbnNmb3JtYXRpb25NYXRyaXggPSB2b2lkIDA7XG4gICAgICB2YXIgdGFyZ2V0TWF0cml4VHJhbnNwb3NlID0gTWF0cml4LnRyYW5zcG9zZSh0YXJnZXRNYXRyaXgpOyAvLyBBJ1xuICAgICAgdmFyIHNvdXJjZU1hdHJpeFRyYW5zcG9zZSA9IE1hdHJpeC50cmFuc3Bvc2Uoc291cmNlTWF0cml4KTsgLy8gQidcblxuICAgICAgLy8gY2VudHJhbGl6ZSB0cmFuc3Bvc2UgbWF0cmljZXNcbiAgICAgIGZvciAodmFyIF9pNyA9IDA7IF9pNyA8IHRhcmdldE1hdHJpeFRyYW5zcG9zZS5sZW5ndGg7IF9pNysrKSB7XG4gICAgICAgIHRhcmdldE1hdHJpeFRyYW5zcG9zZVtfaTddID0gTWF0cml4Lm11bHRHYW1tYSh0YXJnZXRNYXRyaXhUcmFuc3Bvc2VbX2k3XSk7XG4gICAgICAgIHNvdXJjZU1hdHJpeFRyYW5zcG9zZVtfaTddID0gTWF0cml4Lm11bHRHYW1tYShzb3VyY2VNYXRyaXhUcmFuc3Bvc2VbX2k3XSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGRvIGFjdHVhbCBjYWxjdWxhdGlvbiBmb3IgdHJhbnNmb3JtYXRpb24gbWF0cml4XG4gICAgICB2YXIgdGVtcE1hdHJpeCA9IE1hdHJpeC5tdWx0TWF0KHRhcmdldE1hdHJpeFRyYW5zcG9zZSwgTWF0cml4LnRyYW5zcG9zZShzb3VyY2VNYXRyaXhUcmFuc3Bvc2UpKTsgLy8gdGVtcE1hdHJpeCA9IEEnQlxuICAgICAgdmFyIFNWRFJlc3VsdCA9IFNWRC5zdmQodGVtcE1hdHJpeCk7IC8vIFNWRChBJ0IpID0gVVNWJywgc3ZkIGZ1bmN0aW9uIHJldHVybnMgVSwgUyBhbmQgViBcbiAgICAgIHRyYW5zZm9ybWF0aW9uTWF0cml4ID0gTWF0cml4Lm11bHRNYXQoU1ZEUmVzdWx0LlYsIE1hdHJpeC50cmFuc3Bvc2UoU1ZEUmVzdWx0LlUpKTsgLy8gdHJhbnNmb3JtYXRpb25NYXRyaXggPSBUID0gVlUnXG5cbiAgICAgIC8qIGFwcGx5IGZvdW5kIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCB0byBvYnRhaW4gZmluYWwgZHJhZnQgbGF5b3V0ICovXG4gICAgICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCBub2RlSW5kZXhlcy5zaXplOyBfaTgrKykge1xuICAgICAgICB2YXIgdGVtcDEgPSBbeENvb3Jkc1tfaThdLCB5Q29vcmRzW19pOF1dO1xuICAgICAgICB2YXIgdGVtcDIgPSBbdHJhbnNmb3JtYXRpb25NYXRyaXhbMF1bMF0sIHRyYW5zZm9ybWF0aW9uTWF0cml4WzFdWzBdXTtcbiAgICAgICAgdmFyIHRlbXAzID0gW3RyYW5zZm9ybWF0aW9uTWF0cml4WzBdWzFdLCB0cmFuc2Zvcm1hdGlvbk1hdHJpeFsxXVsxXV07XG4gICAgICAgIHhDb29yZHNbX2k4XSA9IE1hdHJpeC5kb3RQcm9kdWN0KHRlbXAxLCB0ZW1wMik7XG4gICAgICAgIHlDb29yZHNbX2k4XSA9IE1hdHJpeC5kb3RQcm9kdWN0KHRlbXAxLCB0ZW1wMyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGxpZWQgb25seSBib3RoIGFsaWdubWVudCBhbmQgcmVsLiBwbGFjZW1lbnQgY29uc3RyYWludHMgZXhpc3RcbiAgICAgIGlmIChyZWZsZWN0aW9uVHlwZSkge1xuICAgICAgICBhcHBseVJlZmxlY3Rpb25Gb3JSZWxhdGl2ZVBsYWNlbWVudChjb25zdHJhaW50cy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChDb1NFQ29uc3RhbnRzLkVORk9SQ0VfQ09OU1RSQUlOVFMpIHtcbiAgICAvKioqKiAgZW5mb3JjZSBjb25zdHJhaW50cyBvbiB0aGUgdHJhbnNmb3JtZWQgZHJhZnQgbGF5b3V0ICoqKiovXG5cbiAgICAvKiBmaXJzdCBlbmZvcmNlIGZpeGVkIG5vZGUgY29uc3RyYWludCAqL1xuXG4gICAgaWYgKGNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQgJiYgY29uc3RyYWludHMuZml4ZWROb2RlQ29uc3RyYWludC5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgdHJhbnNsYXRpb25BbW91bnQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgIGNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZURhdGEsIGkpIHtcbiAgICAgICAgdmFyIHBvc0luVGhlb3J5ID0geyB4OiB4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlRGF0YS5ub2RlSWQpXSwgeTogeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZURhdGEubm9kZUlkKV0gfTtcbiAgICAgICAgdmFyIHBvc0Rlc2lyZWQgPSBub2RlRGF0YS5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHBvc0RpZmYgPSBjYWxjdWxhdGVQb3NpdGlvbkRpZmYocG9zRGVzaXJlZCwgcG9zSW5UaGVvcnkpO1xuICAgICAgICB0cmFuc2xhdGlvbkFtb3VudC54ICs9IHBvc0RpZmYueDtcbiAgICAgICAgdHJhbnNsYXRpb25BbW91bnQueSArPSBwb3NEaWZmLnk7XG4gICAgICB9KTtcbiAgICAgIHRyYW5zbGF0aW9uQW1vdW50LnggLz0gY29uc3RyYWludHMuZml4ZWROb2RlQ29uc3RyYWludC5sZW5ndGg7XG4gICAgICB0cmFuc2xhdGlvbkFtb3VudC55IC89IGNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQubGVuZ3RoO1xuXG4gICAgICB4Q29vcmRzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgICAgIHhDb29yZHNbaV0gKz0gdHJhbnNsYXRpb25BbW91bnQueDtcbiAgICAgIH0pO1xuXG4gICAgICB5Q29vcmRzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgICAgIHlDb29yZHNbaV0gKz0gdHJhbnNsYXRpb25BbW91bnQueTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdHJhaW50cy5maXhlZE5vZGVDb25zdHJhaW50LmZvckVhY2goZnVuY3Rpb24gKG5vZGVEYXRhKSB7XG4gICAgICAgIHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVEYXRhLm5vZGVJZCldID0gbm9kZURhdGEucG9zaXRpb24ueDtcbiAgICAgICAgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZURhdGEubm9kZUlkKV0gPSBub2RlRGF0YS5wb3NpdGlvbi55O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyogdGhlbiBlbmZvcmNlIGFsaWdubWVudCBjb25zdHJhaW50ICovXG5cbiAgICBpZiAoY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludCkge1xuICAgICAgaWYgKGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWwpIHtcbiAgICAgICAgdmFyIHhBbGlnbiA9IGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWw7XG5cbiAgICAgICAgdmFyIF9sb29wNCA9IGZ1bmN0aW9uIF9sb29wNChfaTkpIHtcbiAgICAgICAgICB2YXIgYWxpZ25tZW50U2V0ID0gbmV3IFNldCgpO1xuICAgICAgICAgIHhBbGlnbltfaTldLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgYWxpZ25tZW50U2V0LmFkZChub2RlSWQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBuZXcgU2V0KFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoYWxpZ25tZW50U2V0KSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gZml4ZWROb2Rlcy5oYXMoeCk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHZhciB4UG9zID0gdm9pZCAwO1xuICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb24uc2l6ZSA+IDApIHhQb3MgPSB4Q29vcmRzW25vZGVJbmRleGVzLmdldChpbnRlcnNlY3Rpb24udmFsdWVzKCkubmV4dCgpLnZhbHVlKV07ZWxzZSB4UG9zID0gY2FsY3VsYXRlQXZnUG9zaXRpb24oYWxpZ25tZW50U2V0KS54O1xuXG4gICAgICAgICAgYWxpZ25tZW50U2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgaWYgKCFmaXhlZE5vZGVzLmhhcyhub2RlSWQpKSB4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXSA9IHhQb3M7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgX2k5ID0gMDsgX2k5IDwgeEFsaWduLmxlbmd0aDsgX2k5KyspIHtcbiAgICAgICAgICBfbG9vcDQoX2k5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQuaG9yaXpvbnRhbCkge1xuICAgICAgICB2YXIgeUFsaWduID0gY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC5ob3Jpem9udGFsO1xuXG4gICAgICAgIHZhciBfbG9vcDUgPSBmdW5jdGlvbiBfbG9vcDUoX2kxMCkge1xuICAgICAgICAgIHZhciBhbGlnbm1lbnRTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgeUFsaWduW19pMTBdLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgYWxpZ25tZW50U2V0LmFkZChub2RlSWQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBuZXcgU2V0KFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoYWxpZ25tZW50U2V0KSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gZml4ZWROb2Rlcy5oYXMoeCk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHZhciB5UG9zID0gdm9pZCAwO1xuICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb24uc2l6ZSA+IDApIHlQb3MgPSB5Q29vcmRzW25vZGVJbmRleGVzLmdldChpbnRlcnNlY3Rpb24udmFsdWVzKCkubmV4dCgpLnZhbHVlKV07ZWxzZSB5UG9zID0gY2FsY3VsYXRlQXZnUG9zaXRpb24oYWxpZ25tZW50U2V0KS55O1xuXG4gICAgICAgICAgYWxpZ25tZW50U2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgaWYgKCFmaXhlZE5vZGVzLmhhcyhub2RlSWQpKSB5Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXSA9IHlQb3M7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgX2kxMCA9IDA7IF9pMTAgPCB5QWxpZ24ubGVuZ3RoOyBfaTEwKyspIHtcbiAgICAgICAgICBfbG9vcDUoX2kxMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBmaW5hbGx5IGVuZm9yY2UgcmVsYXRpdmUgcGxhY2VtZW50IGNvbnN0cmFpbnQgKi9cblxuICAgIGlmIChjb25zdHJhaW50cy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpIHtcbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIGR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIGR1bW15UG9zaXRpb25zRm9yVmVydGljYWxBbGlnbm1lbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBkdW1teVBvc2l0aW9uc0Zvckhvcml6b250YWxBbGlnbm1lbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBmaXhlZE5vZGVzT25Ib3Jpem9udGFsID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgZml4ZWROb2Rlc09uVmVydGljYWwgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgLy8gZmlsbCBtYXBzIGFuZCBzZXRzICAgICAgXG4gICAgICAgIGZpeGVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgZml4ZWROb2Rlc09uSG9yaXpvbnRhbC5hZGQobm9kZUlkKTtcbiAgICAgICAgICBmaXhlZE5vZGVzT25WZXJ0aWNhbC5hZGQobm9kZUlkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQpIHtcbiAgICAgICAgICBpZiAoY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC52ZXJ0aWNhbCkge1xuICAgICAgICAgICAgdmFyIHZlcnRpY2FsQWxpZ25tZW50ID0gY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC52ZXJ0aWNhbDtcblxuICAgICAgICAgICAgdmFyIF9sb29wNiA9IGZ1bmN0aW9uIF9sb29wNihfaTExKSB7XG4gICAgICAgICAgICAgIGR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuc2V0KFwiZHVtbXlcIiArIF9pMTEsIFtdKTtcbiAgICAgICAgICAgICAgdmVydGljYWxBbGlnbm1lbnRbX2kxMV0uZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgbm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudC5zZXQobm9kZUlkLCBcImR1bW15XCIgKyBfaTExKTtcbiAgICAgICAgICAgICAgICBkdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChcImR1bW15XCIgKyBfaTExKS5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpeGVkTm9kZXMuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgICAgIGZpeGVkTm9kZXNPbkhvcml6b250YWwuYWRkKFwiZHVtbXlcIiArIF9pMTEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGR1bW15UG9zaXRpb25zRm9yVmVydGljYWxBbGlnbm1lbnQuc2V0KFwiZHVtbXlcIiArIF9pMTEsIHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KHZlcnRpY2FsQWxpZ25tZW50W19pMTFdWzBdKV0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2kxMSA9IDA7IF9pMTEgPCB2ZXJ0aWNhbEFsaWdubWVudC5sZW5ndGg7IF9pMTErKykge1xuICAgICAgICAgICAgICBfbG9vcDYoX2kxMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50Lmhvcml6b250YWwpIHtcbiAgICAgICAgICAgIHZhciBob3Jpem9udGFsQWxpZ25tZW50ID0gY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC5ob3Jpem9udGFsO1xuXG4gICAgICAgICAgICB2YXIgX2xvb3A3ID0gZnVuY3Rpb24gX2xvb3A3KF9pMTIpIHtcbiAgICAgICAgICAgICAgZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50LnNldChcImR1bW15XCIgKyBfaTEyLCBbXSk7XG4gICAgICAgICAgICAgIGhvcml6b250YWxBbGlnbm1lbnRbX2kxMl0uZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50LnNldChub2RlSWQsIFwiZHVtbXlcIiArIF9pMTIpO1xuICAgICAgICAgICAgICAgIGR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5nZXQoXCJkdW1teVwiICsgX2kxMikucHVzaChub2RlSWQpO1xuICAgICAgICAgICAgICAgIGlmIChmaXhlZE5vZGVzLmhhcyhub2RlSWQpKSB7XG4gICAgICAgICAgICAgICAgICBmaXhlZE5vZGVzT25WZXJ0aWNhbC5hZGQoXCJkdW1teVwiICsgX2kxMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgZHVtbXlQb3NpdGlvbnNGb3JIb3Jpem9udGFsQWxpZ25tZW50LnNldChcImR1bW15XCIgKyBfaTEyLCB5Q29vcmRzW25vZGVJbmRleGVzLmdldChob3Jpem9udGFsQWxpZ25tZW50W19pMTJdWzBdKV0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2kxMiA9IDA7IF9pMTIgPCBob3Jpem9udGFsQWxpZ25tZW50Lmxlbmd0aDsgX2kxMisrKSB7XG4gICAgICAgICAgICAgIF9sb29wNyhfaTEyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zdHJ1Y3QgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgZGFncyAoc3ViZ3JhcGhzKSBmcm9tIG92ZXJhbGwgZGFnXG4gICAgICAgIHZhciBkYWdPbkhvcml6b250YWwgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBkYWdPblZlcnRpY2FsID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIHZhciBfbG9vcDggPSBmdW5jdGlvbiBfbG9vcDgobm9kZUlkKSB7XG4gICAgICAgICAgZGFnLmdldChub2RlSWQpLmZvckVhY2goZnVuY3Rpb24gKGFkamFjZW50KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlSWQgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0Tm9kZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChhZGphY2VudFtcImRpcmVjdGlvblwiXSA9PSBcImhvcml6b250YWxcIikge1xuICAgICAgICAgICAgICBzb3VyY2VJZCA9IG5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KG5vZGVJZCkgPyBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChub2RlSWQpIDogbm9kZUlkO1xuICAgICAgICAgICAgICBpZiAobm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudC5nZXQoYWRqYWNlbnQuaWQpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IHsgaWQ6IG5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KGFkamFjZW50LmlkKSwgZ2FwOiBhZGphY2VudC5nYXAsIGRpcmVjdGlvbjogYWRqYWNlbnQuZGlyZWN0aW9uIH07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGFkamFjZW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkYWdPbkhvcml6b250YWwuaGFzKHNvdXJjZUlkKSkge1xuICAgICAgICAgICAgICAgIGRhZ09uSG9yaXpvbnRhbC5nZXQoc291cmNlSWQpLnB1c2godGFyZ2V0Tm9kZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGFnT25Ib3Jpem9udGFsLnNldChzb3VyY2VJZCwgW3RhcmdldE5vZGVdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWRhZ09uSG9yaXpvbnRhbC5oYXModGFyZ2V0Tm9kZS5pZCkpIHtcbiAgICAgICAgICAgICAgICBkYWdPbkhvcml6b250YWwuc2V0KHRhcmdldE5vZGUuaWQsIFtdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc291cmNlSWQgPSBub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KG5vZGVJZCkgPyBub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KG5vZGVJZCkgOiBub2RlSWQ7XG4gICAgICAgICAgICAgIGlmIChub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KGFkamFjZW50LmlkKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSB7IGlkOiBub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KGFkamFjZW50LmlkKSwgZ2FwOiBhZGphY2VudC5nYXAsIGRpcmVjdGlvbjogYWRqYWNlbnQuZGlyZWN0aW9uIH07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGFkamFjZW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkYWdPblZlcnRpY2FsLmhhcyhzb3VyY2VJZCkpIHtcbiAgICAgICAgICAgICAgICBkYWdPblZlcnRpY2FsLmdldChzb3VyY2VJZCkucHVzaCh0YXJnZXROb2RlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYWdPblZlcnRpY2FsLnNldChzb3VyY2VJZCwgW3RhcmdldE5vZGVdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWRhZ09uVmVydGljYWwuaGFzKHRhcmdldE5vZGUuaWQpKSB7XG4gICAgICAgICAgICAgICAgZGFnT25WZXJ0aWNhbC5zZXQodGFyZ2V0Tm9kZS5pZCwgW10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNSA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I1ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNSA9IGRhZy5rZXlzKClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDU7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSAoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBub2RlSWQgPSBfc3RlcDUudmFsdWU7XG5cbiAgICAgICAgICAgIF9sb29wOChub2RlSWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGZpbmQgc291cmNlIG5vZGVzIG9mIGVhY2ggY29tcG9uZW50IGluIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGRhZ3NcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I1ID0gdHJ1ZTtcbiAgICAgICAgICBfaXRlcmF0b3JFcnJvcjUgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgJiYgX2l0ZXJhdG9yNS5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yNS5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNSkge1xuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVuZGlyZWN0ZWRPbkhvcml6b250YWwgPSBkYWdUb1VuZGlyZWN0ZWQoZGFnT25Ib3Jpem9udGFsKTtcbiAgICAgICAgdmFyIHVuZGlyZWN0ZWRPblZlcnRpY2FsID0gZGFnVG9VbmRpcmVjdGVkKGRhZ09uVmVydGljYWwpO1xuICAgICAgICB2YXIgY29tcG9uZW50c09uSG9yaXpvbnRhbCA9IGZpbmRDb21wb25lbnRzKHVuZGlyZWN0ZWRPbkhvcml6b250YWwpO1xuICAgICAgICB2YXIgY29tcG9uZW50c09uVmVydGljYWwgPSBmaW5kQ29tcG9uZW50cyh1bmRpcmVjdGVkT25WZXJ0aWNhbCk7XG4gICAgICAgIHZhciByZXZlcnNlZERhZ09uSG9yaXpvbnRhbCA9IGRhZ1RvUmV2ZXJzZWQoZGFnT25Ib3Jpem9udGFsKTtcbiAgICAgICAgdmFyIHJldmVyc2VkRGFnT25WZXJ0aWNhbCA9IGRhZ1RvUmV2ZXJzZWQoZGFnT25WZXJ0aWNhbCk7XG4gICAgICAgIHZhciBjb21wb25lbnRTb3VyY2VzT25Ib3Jpem9udGFsID0gW107XG4gICAgICAgIHZhciBjb21wb25lbnRTb3VyY2VzT25WZXJ0aWNhbCA9IFtdO1xuXG4gICAgICAgIGNvbXBvbmVudHNPbkhvcml6b250YWwuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50LCBpbmRleCkge1xuICAgICAgICAgIGNvbXBvbmVudFNvdXJjZXNPbkhvcml6b250YWxbaW5kZXhdID0gW107XG4gICAgICAgICAgY29tcG9uZW50LmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgaWYgKHJldmVyc2VkRGFnT25Ib3Jpem9udGFsLmdldChub2RlSWQpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgIGNvbXBvbmVudFNvdXJjZXNPbkhvcml6b250YWxbaW5kZXhdLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29tcG9uZW50c09uVmVydGljYWwuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50LCBpbmRleCkge1xuICAgICAgICAgIGNvbXBvbmVudFNvdXJjZXNPblZlcnRpY2FsW2luZGV4XSA9IFtdO1xuICAgICAgICAgIGNvbXBvbmVudC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIGlmIChyZXZlcnNlZERhZ09uVmVydGljYWwuZ2V0KG5vZGVJZCkubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgY29tcG9uZW50U291cmNlc09uVmVydGljYWxbaW5kZXhdLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIGFwcHJvcHJpYXRlIHBvc2l0aW9uaW5nIGZvciBzdWJncmFwaHNcbiAgICAgICAgdmFyIHBvc2l0aW9uTWFwSG9yaXpvbnRhbCA9IGZpbmRBcHByb3ByaWF0ZVBvc2l0aW9uRm9yUmVsYXRpdmVQbGFjZW1lbnQoZGFnT25Ib3Jpem9udGFsLCBcImhvcml6b250YWxcIiwgZml4ZWROb2Rlc09uSG9yaXpvbnRhbCwgZHVtbXlQb3NpdGlvbnNGb3JWZXJ0aWNhbEFsaWdubWVudCwgY29tcG9uZW50U291cmNlc09uSG9yaXpvbnRhbCk7XG4gICAgICAgIHZhciBwb3NpdGlvbk1hcFZlcnRpY2FsID0gZmluZEFwcHJvcHJpYXRlUG9zaXRpb25Gb3JSZWxhdGl2ZVBsYWNlbWVudChkYWdPblZlcnRpY2FsLCBcInZlcnRpY2FsXCIsIGZpeGVkTm9kZXNPblZlcnRpY2FsLCBkdW1teVBvc2l0aW9uc0Zvckhvcml6b250YWxBbGlnbm1lbnQsIGNvbXBvbmVudFNvdXJjZXNPblZlcnRpY2FsKTtcblxuICAgICAgICAvLyB1cGRhdGUgcG9zaXRpb25zIG9mIHRoZSBub2RlcyBiYXNlZCBvbiByZWxhdGl2ZSBwbGFjZW1lbnQgY29uc3RyYWludHNcblxuICAgICAgICB2YXIgX2xvb3A5ID0gZnVuY3Rpb24gX2xvb3A5KGtleSkge1xuICAgICAgICAgIGlmIChkdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChrZXkpKSB7XG4gICAgICAgICAgICBkdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChrZXkpLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICB4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXSA9IHBvc2l0aW9uTWFwSG9yaXpvbnRhbC5nZXQoa2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4Q29vcmRzW25vZGVJbmRleGVzLmdldChrZXkpXSA9IHBvc2l0aW9uTWFwSG9yaXpvbnRhbC5nZXQoa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNiA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I2ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNiA9IHBvc2l0aW9uTWFwSG9yaXpvbnRhbC5rZXlzKClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDY7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgPSAoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBfc3RlcDYudmFsdWU7XG5cbiAgICAgICAgICAgIF9sb29wOShrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I2ID0gdHJ1ZTtcbiAgICAgICAgICBfaXRlcmF0b3JFcnJvcjYgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgJiYgX2l0ZXJhdG9yNi5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yNi5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNikge1xuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9sb29wMTAgPSBmdW5jdGlvbiBfbG9vcDEwKGtleSkge1xuICAgICAgICAgIGlmIChkdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KGtleSkpIHtcbiAgICAgICAgICAgIGR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5nZXQoa2V5KS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgICAgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV0gPSBwb3NpdGlvbk1hcFZlcnRpY2FsLmdldChrZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KGtleSldID0gcG9zaXRpb25NYXBWZXJ0aWNhbC5nZXQoa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNyA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I3ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNyA9IHBvc2l0aW9uTWFwVmVydGljYWwua2V5cygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA3OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ID0gKF9zdGVwNyA9IF9pdGVyYXRvcjcubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gX3N0ZXA3LnZhbHVlO1xuXG4gICAgICAgICAgICBfbG9vcDEwKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjcgPSB0cnVlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yNyA9IGVycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNyAmJiBfaXRlcmF0b3I3LnJldHVybikge1xuICAgICAgICAgICAgICBfaXRlcmF0b3I3LnJldHVybigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I3KSB7XG4gICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gYXNzaWduIG5ldyBjb29yZGluYXRlcyB0byBub2RlcyBhZnRlciBjb25zdHJhaW50IGhhbmRsaW5nXG4gIGZvciAodmFyIF9pMTMgPSAwOyBfaTEzIDwgYWxsTm9kZXMubGVuZ3RoOyBfaTEzKyspIHtcbiAgICB2YXIgX25vZGUgPSBhbGxOb2Rlc1tfaTEzXTtcbiAgICBpZiAoX25vZGUuZ2V0Q2hpbGQoKSA9PSBudWxsKSB7XG4gICAgICBfbm9kZS5zZXRDZW50ZXIoeENvb3Jkc1tub2RlSW5kZXhlcy5nZXQoX25vZGUuaWQpXSwgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQoX25vZGUuaWQpXSk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnN0cmFpbnRIYW5kbGVyO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNTUxOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX181NTFfXztcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdC8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pOyJdLCJuYW1lcyI6WyJ3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsInJvb3QiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsInJlcXVpcmUiLCJkZWZpbmUiLCJhbWQiLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX181NTFfXyIsIl9fd2VicGFja19tb2R1bGVzX18iLCJfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwiY29zZUJhc2UiLCJsYXlvdXRCYXNlIiwiQ29TRUNvbnN0YW50cyIsIkNvU0VFZGdlIiwiQ29TRUdyYXBoIiwiQ29TRUdyYXBoTWFuYWdlciIsIkNvU0VMYXlvdXQiLCJDb1NFTm9kZSIsIkNvbnN0cmFpbnRIYW5kbGVyIiwiRkRMYXlvdXRDb25zdGFudHMiLCJwcm9wIiwiREVGQVVMVF9VU0VfTVVMVElfTEVWRUxfU0NBTElORyIsIkRFRkFVTFRfUkFESUFMX1NFUEFSQVRJT04iLCJERUZBVUxUX0VER0VfTEVOR1RIIiwiREVGQVVMVF9DT01QT05FTlRfU0VQRVJBVElPTiIsIlRJTEUiLCJUSUxJTkdfUEFERElOR19WRVJUSUNBTCIsIlRJTElOR19QQURESU5HX0hPUklaT05UQUwiLCJUUkFOU0ZPUk1fT05fQ09OU1RSQUlOVF9IQU5ETElORyIsIkVORk9SQ0VfQ09OU1RSQUlOVFMiLCJBUFBMWV9MQVlPVVQiLCJSRUxBWF9NT1ZFTUVOVF9PTl9DT05TVFJBSU5UUyIsIlRSRUVfUkVEVUNUSU9OX09OX0lOQ1JFTUVOVEFMIiwiUFVSRV9JTkNSRU1FTlRBTCIsIkRFRkFVTFRfSU5DUkVNRU5UQUwiLCJGRExheW91dEVkZ2UiLCJzb3VyY2UiLCJ0YXJnZXQiLCJ2RWRnZSIsImNhbGwiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJMR3JhcGgiLCJwYXJlbnQiLCJncmFwaE1nciIsInZHcmFwaCIsIkxHcmFwaE1hbmFnZXIiLCJsYXlvdXQiLCJGRExheW91dCIsIkxheW91dENvbnN0YW50cyIsIlBvaW50IiwiUG9pbnREIiwiRGltZW5zaW9uRCIsIkxheW91dCIsIkludGVnZXIiLCJJR2VvbWV0cnkiLCJUcmFuc2Zvcm0iLCJMaW5rZWRMaXN0IiwidG9CZVRpbGVkIiwiY29uc3RyYWludHMiLCJuZXdHcmFwaE1hbmFnZXIiLCJnbSIsImdyYXBoTWFuYWdlciIsIm5ld0dyYXBoIiwibmV3Tm9kZSIsInZOb2RlIiwibmV3RWRnZSIsImluaXRQYXJhbWV0ZXJzIiwiYXJndW1lbnRzIiwiaXNTdWJMYXlvdXQiLCJpZGVhbEVkZ2VMZW5ndGgiLCJ1c2VTbWFydElkZWFsRWRnZUxlbmd0aENhbGN1bGF0aW9uIiwiREVGQVVMVF9VU0VfU01BUlRfSURFQUxfRURHRV9MRU5HVEhfQ0FMQ1VMQVRJT04iLCJncmF2aXR5Q29uc3RhbnQiLCJERUZBVUxUX0dSQVZJVFlfU1RSRU5HVEgiLCJjb21wb3VuZEdyYXZpdHlDb25zdGFudCIsIkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9TVFJFTkdUSCIsImdyYXZpdHlSYW5nZUZhY3RvciIsIkRFRkFVTFRfR1JBVklUWV9SQU5HRV9GQUNUT1IiLCJjb21wb3VuZEdyYXZpdHlSYW5nZUZhY3RvciIsIkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9SQU5HRV9GQUNUT1IiLCJwcnVuZWROb2Rlc0FsbCIsImdyb3dUcmVlSXRlcmF0aW9ucyIsImFmdGVyR3Jvd3RoSXRlcmF0aW9ucyIsImlzVHJlZUdyb3dpbmciLCJpc0dyb3d0aEZpbmlzaGVkIiwiaW5pdFNwcmluZ0VtYmVkZGVyIiwiY29vbGluZ0N5Y2xlIiwibWF4Q29vbGluZ0N5Y2xlIiwibWF4SXRlcmF0aW9ucyIsIkNPTlZFUkdFTkNFX0NIRUNLX1BFUklPRCIsImZpbmFsVGVtcGVyYXR1cmUiLCJjb29saW5nQWRqdXN0ZXIiLCJjcmVhdGVCZW5kc0FzTmVlZGVkIiwiREVGQVVMVF9DUkVBVEVfQkVORFNfQVNfTkVFREVEIiwiY3JlYXRlQmVuZHBvaW50cyIsInJlc2V0QWxsRWRnZXMiLCJsZXZlbCIsImNsYXNzaWNMYXlvdXQiLCJub2Rlc1dpdGhHcmF2aXR5IiwiY2FsY3VsYXRlTm9kZXNUb0FwcGx5R3Jhdml0YXRpb25UbyIsInNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uIiwiY2FsY05vT2ZDaGlsZHJlbkZvckFsbE5vZGVzIiwiY2FsY0xvd2VzdENvbW1vbkFuY2VzdG9ycyIsImNhbGNJbmNsdXNpb25UcmVlRGVwdGhzIiwiZ2V0Um9vdCIsImNhbGNFc3RpbWF0ZWRTaXplIiwiY2FsY0lkZWFsRWRnZUxlbmd0aHMiLCJpbmNyZW1lbnRhbCIsImZvcmVzdCIsImdldEZsYXRGb3Jlc3QiLCJsZW5ndGgiLCJwb3NpdGlvbk5vZGVzUmFkaWFsbHkiLCJyZWR1Y2VUcmVlcyIsInJlc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24iLCJhbGxOb2RlcyIsIlNldCIsImdldEFsbE5vZGVzIiwiaW50ZXJzZWN0aW9uIiwiZmlsdGVyIiwieCIsImhhcyIsInBvc2l0aW9uTm9kZXNSYW5kb21seSIsImtleXMiLCJoYW5kbGVDb25zdHJhaW50cyIsImluaXRDb25zdHJhaW50VmFyaWFibGVzIiwicnVuU3ByaW5nRW1iZWRkZXIiLCJ0aWNrIiwidG90YWxJdGVyYXRpb25zIiwiaXNDb252ZXJnZWQiLCJsYXlvdXRRdWFsaXR5IiwiY29vbGluZ0ZhY3RvciIsIk1hdGgiLCJtYXgiLCJpbml0aWFsQ29vbGluZ0ZhY3RvciIsInBvdyIsImxvZyIsImFuaW1hdGlvblBlcmlvZCIsImNlaWwiLCJpbml0aWFsQW5pbWF0aW9uUGVyaW9kIiwic3FydCIsInVwZGF0ZUJvdW5kcyIsInVwZGF0ZUdyaWQiLCJncm93VHJlZSIsIkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUwiLCJncmlkVXBkYXRlQWxsb3dlZCIsImZvcmNlVG9Ob2RlU3Vycm91bmRpbmdVcGRhdGUiLCJ0b3RhbERpc3BsYWNlbWVudCIsImNhbGNTcHJpbmdGb3JjZXMiLCJjYWxjUmVwdWxzaW9uRm9yY2VzIiwiY2FsY0dyYXZpdGF0aW9uYWxGb3JjZXMiLCJtb3ZlTm9kZXMiLCJhbmltYXRlIiwiZ2V0UG9zaXRpb25zRGF0YSIsInBEYXRhIiwiaSIsInJlY3QiLCJpZCIsImdldENlbnRlclgiLCJ5IiwiZ2V0Q2VudGVyWSIsInciLCJ3aWR0aCIsImgiLCJoZWlnaHQiLCJsYXlvdXRFbmRlZCIsIkFOSU1BVEUiLCJlbWl0IiwibE5vZGVzIiwibm9kZSIsImNhbGN1bGF0ZURpc3BsYWNlbWVudCIsInVwZGF0ZURpc3BsYWNlbWVudHMiLCJtb3ZlIiwic2VsZiIsImlkVG9Ob2RlTWFwIiwiTWFwIiwiZml4ZWROb2RlU2V0Iiwic2V0IiwiY2FsY3VsYXRlQ29tcG91bmRXZWlnaHQiLCJjb21wb3VuZE5vZGUiLCJub2RlcyIsImdldENoaWxkIiwiZ2V0Tm9kZXMiLCJmaXhlZE5vZGVXZWlnaHQiLCJmaXhlZE5vZGVDb25zdHJhaW50IiwiZm9yRWFjaCIsIm5vZGVEYXRhIiwiYWRkIiwibm9kZUlkIiwicmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50Iiwibm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudCIsIm5vZGVUb0R1bW15Rm9ySG9yaXpvbnRhbEFsaWdubWVudCIsImR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQiLCJkdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQiLCJmaXhlZE5vZGVzT25Ib3Jpem9udGFsIiwiZml4ZWROb2Rlc09uVmVydGljYWwiLCJhbGlnbm1lbnRDb25zdHJhaW50IiwidmVydGljYWwiLCJ2ZXJ0aWNhbEFsaWdubWVudCIsImdldCIsInB1c2giLCJob3Jpem9udGFsIiwiaG9yaXpvbnRhbEFsaWdubWVudCIsInNodWZmbGUiLCJhcnJheSIsImoiLCJmbG9vciIsInJhbmRvbSIsIm5vZGVzSW5SZWxhdGl2ZUhvcml6b250YWwiLCJub2Rlc0luUmVsYXRpdmVWZXJ0aWNhbCIsIm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcEhvcml6b250YWwiLCJub2RlVG9SZWxhdGl2ZUNvbnN0cmFpbnRNYXBWZXJ0aWNhbCIsIm5vZGVUb1RlbXBQb3NpdGlvbk1hcEhvcml6b250YWwiLCJub2RlVG9UZW1wUG9zaXRpb25NYXBWZXJ0aWNhbCIsImNvbnN0cmFpbnQiLCJsZWZ0Iiwibm9kZUlkTGVmdCIsIm5vZGVJZFJpZ2h0IiwicmlnaHQiLCJpbmNsdWRlcyIsImdhcCIsIm5vZGVJZFRvcCIsInRvcCIsIm5vZGVJZEJvdHRvbSIsImJvdHRvbSIsInN1YkdyYXBoT25Ib3Jpem9udGFsIiwic3ViR3JhcGhPblZlcnRpY2FsIiwiY29uc3RydWN0Q29tcG9uZW50cyIsImdyYXBoIiwiZml4ZWROb2RlcyIsImNvbXBvbmVudHMiLCJpc0ZpeGVkIiwicXVldWUiLCJ2aXNpdGVkIiwiY291bnQiLCJ2YWx1ZSIsImtleSIsImN1cnJlbnROb2RlIiwic2hpZnQiLCJuZWlnaGJvcnMiLCJuZWlnaGJvciIsInJlc3VsdE9uSG9yaXpvbnRhbCIsImNvbXBvbmVudHNPbkhvcml6b250YWwiLCJmaXhlZENvbXBvbmVudHNPbkhvcml6b250YWwiLCJyZXN1bHRPblZlcnRpY2FsIiwiY29tcG9uZW50c09uVmVydGljYWwiLCJmaXhlZENvbXBvbmVudHNPblZlcnRpY2FsIiwiZml4ZWROb2RlIiwiZGlzcGxhY2VtZW50WCIsImRpc3BsYWNlbWVudFkiLCJhbGxWZXJ0aWNhbEFsaWdubWVudHMiLCJ0b3RhbERpc3BsYWNlbWVudFgiLCJhdmVyYWdlRGlzcGxhY2VtZW50WCIsImFsbEhvcml6b250YWxBbGlnbm1lbnRzIiwidG90YWxEaXNwbGFjZW1lbnRZIiwiYXZlcmFnZURpc3BsYWNlbWVudFkiLCJkaXNwbGFjZW1lbnQiLCJkaWZmIiwiY29tcG9uZW50Iiwic3VtIiwiYWN0dWFsTm9kZXMiLCJhdmVyYWdlRGlzcGxhY2VtZW50Iiwibm9kZUxpc3QiLCJncmFwaHMiLCJnZXRHcmFwaHMiLCJzaXplIiwidXBkYXRlQ29ubmVjdGVkIiwiaXNDb25uZWN0ZWQiLCJjb25jYXQiLCJlZGdlcyIsImdldEFsbEVkZ2VzIiwiZWRnZSIsImdldFNvdXJjZSIsImdldFRhcmdldCIsImdldEJlbmRwb2ludHMiLCJjcmVhdGVEdW1teU5vZGVzRm9yQmVuZHBvaW50cyIsImVkZ2VMaXN0IiwiZ2V0RWRnZUxpc3RUb05vZGUiLCJrIiwibXVsdGlFZGdlIiwiY3VycmVudFN0YXJ0aW5nUG9pbnQiLCJudW1iZXJPZkNvbHVtbnMiLCJjdXJyZW50WSIsImN1cnJlbnRYIiwicG9pbnQiLCJ0cmVlIiwiY2VudGVyTm9kZSIsImZpbmRDZW50ZXJPZlRyZWUiLCJyYWRpYWxMYXlvdXQiLCJ0cmFuc2Zvcm0iLCJXT1JMRF9DRU5URVJfWCIsIldPUkxEX0NFTlRFUl9ZIiwic3RhcnRpbmdQb2ludCIsInJhZGlhbFNlcCIsIm1heERpYWdvbmFsSW5UcmVlIiwiYnJhbmNoUmFkaWFsTGF5b3V0IiwiYm91bmRzIiwiY2FsY3VsYXRlQm91bmRzIiwic2V0RGV2aWNlT3JnWCIsImdldE1pblgiLCJzZXREZXZpY2VPcmdZIiwiZ2V0TWluWSIsInNldFdvcmxkT3JnWCIsInNldFdvcmxkT3JnWSIsImJvdHRvbVJpZ2h0IiwiZ2V0TWF4WCIsImdldE1heFkiLCJpbnZlcnNlVHJhbnNmb3JtUG9pbnQiLCJwYXJlbnRPZk5vZGUiLCJzdGFydEFuZ2xlIiwiZW5kQW5nbGUiLCJkaXN0YW5jZSIsInJhZGlhbFNlcGFyYXRpb24iLCJoYWxmSW50ZXJ2YWwiLCJub2RlQW5nbGUiLCJ0ZXRhIiwiVFdPX1BJIiwiY29zX3RldGEiLCJjb3MiLCJ4XyIsInlfIiwic2luIiwic2V0Q2VudGVyIiwibmVpZ2hib3JFZGdlcyIsImdldEVkZ2VzIiwiY2hpbGRDb3VudCIsImJyYW5jaENvdW50IiwiaW5jRWRnZXNDb3VudCIsInN0YXJ0SW5kZXgiLCJnZXRFZGdlc0JldHdlZW4iLCJ0ZW1wIiwic3BsaWNlIiwiaW5kZXgiLCJpbmRleE9mIiwic3RlcEFuZ2xlIiwiYWJzIiwiY3VycmVudE5laWdoYm9yIiwiZ2V0T3RoZXJFbmQiLCJjaGlsZFN0YXJ0QW5nbGUiLCJjaGlsZEVuZEFuZ2xlIiwibWF4RGlhZ29uYWwiLCJNSU5fVkFMVUUiLCJkaWFnb25hbCIsImdldERpYWdvbmFsIiwiY2FsY1JlcHVsc2lvblJhbmdlIiwiZ3JvdXBaZXJvRGVncmVlTWVtYmVycyIsInRlbXBNZW1iZXJHcm91cHMiLCJtZW1iZXJHcm91cHMiLCJpZFRvRHVtbXlOb2RlIiwiemVyb0RlZ3JlZSIsImdldFBhcmVudCIsImdldE5vZGVEZWdyZWVXaXRoQ2hpbGRyZW4iLCJ1bmRlZmluZWQiLCJnZXRUb0JlVGlsZWQiLCJwX2lkIiwiZHVtbXlDb21wb3VuZElkIiwiZHVtbXlDb21wb3VuZCIsInBhZGRpbmdMZWZ0IiwicGFkZGluZ1JpZ2h0IiwicGFkZGluZ0JvdHRvbSIsInBhZGRpbmdUb3AiLCJkdW1teVBhcmVudEdyYXBoIiwiZ2V0R3JhcGhNYW5hZ2VyIiwicGFyZW50R3JhcGgiLCJyZW1vdmUiLCJjbGVhckNvbXBvdW5kcyIsImNoaWxkR3JhcGhNYXAiLCJpZFRvTm9kZSIsInBlcmZvcm1ERlNPbkNvbXBvdW5kcyIsImNvbXBvdW5kT3JkZXIiLCJjaGlsZCIsInJlc2V0QWxsTm9kZXMiLCJ0aWxlQ29tcG91bmRNZW1iZXJzIiwiY2xlYXJaZXJvRGVncmVlTWVtYmVycyIsInRpbGVkWmVyb0RlZ3JlZVBhY2siLCJ0aWxlTm9kZXMiLCJjZW50ZXJYIiwiY2VudGVyWSIsImxhYmVsTWFyZ2luTGVmdCIsImxhYmVsTWFyZ2luVG9wIiwiTk9ERV9ESU1FTlNJT05TX0lOQ0xVREVfTEFCRUxTIiwibGFiZWxXaWR0aCIsImxhYmVsUG9zSG9yaXpvbnRhbCIsInNldFdpZHRoIiwibGFiZWxIZWlnaHQiLCJsYWJlbFBvc1ZlcnRpY2FsIiwic2V0SGVpZ2h0IiwicmVwb3B1bGF0ZUNvbXBvdW5kcyIsImxDb21wb3VuZE5vZGUiLCJob3Jpem9udGFsTWFyZ2luIiwidmVydGljYWxNYXJnaW4iLCJhZGp1c3RMb2NhdGlvbnMiLCJ0aWxlZE1lbWJlclBhY2siLCJyZXBvcHVsYXRlWmVyb0RlZ3JlZU1lbWJlcnMiLCJ0aWxlZFBhY2siLCJjaGlsZEdyYXBoIiwiY2hpbGRyZW4iLCJ0aGVDaGlsZCIsImdldE5vZGVEZWdyZWUiLCJkZWdyZWUiLCJmaWxsQ29tcGV4T3JkZXJCeURGUyIsIm9yZ2FuaXphdGlvbiIsImNvbXBvdW5kSG9yaXpvbnRhbE1hcmdpbiIsImNvbXBvdW5kVmVydGljYWxNYXJnaW4iLCJjb21wb3VuZExhYmVsTWFyZ2luTGVmdCIsImNvbXBvdW5kTGFiZWxNYXJnaW5Ub3AiLCJyb3dzIiwicm93IiwibWF4SGVpZ2h0IiwibG5vZGUiLCJob3Jpem9udGFsUGFkZGluZyIsInZlcnRpY2FsUGFkZGluZyIsIm1pbldpZHRoIiwiaG9yaXpvbnRhbE9yZyIsInRpbGVOb2Rlc0J5RmF2b3JpbmdEaW0iLCJ2ZXJ0aWNhbE9yZyIsImhvcml6b250YWxSYXRpbyIsImdldE9yZ1JhdGlvIiwidmVydGljYWxSYXRpbyIsImJlc3RPcmciLCJyYXRpbyIsImNhbGNJZGVhbFJvd1dpZHRoIiwibWVtYmVycyIsImZhdm9ySG9yaXpvbnRhbERpbSIsIm1lbWJlcnNTaXplIiwidG90YWxXaWR0aCIsInRvdGFsSGVpZ2h0IiwibWF4V2lkdGgiLCJnZXRXaWR0aCIsImdldEhlaWdodCIsImF2ZXJhZ2VXaWR0aCIsImF2ZXJhZ2VIZWlnaHQiLCJkZWx0YSIsImhvcml6b250YWxDb3VudERvdWJsZSIsImhvcml6b250YWxDb3VudCIsImlkZWFsV2lkdGgiLCJ0aWxpbmdDb21wYXJlQnkiLCJUSUxJTkdfQ09NUEFSRV9CWSIsInJvd1dpZHRoIiwicm93SGVpZ2h0IiwiaWRlYWxSb3dXaWR0aCIsImdldE5vZGVBcmVhIiwibiIsImFyZWFDb21wYXJlRmNuIiwibjEiLCJuMiIsInNvcnQiLCJjbXBCeSIsInN1bUNlbnRlclgiLCJzdW1DZW50ZXJZIiwibE5vZGUiLCJpbnNlcnROb2RlVG9Sb3ciLCJjYW5BZGRIb3Jpem9udGFsIiwicm93SW5kZXgiLCJnZXRTaG9ydGVzdFJvd0luZGV4Iiwic2hpZnRUb0xhc3RSb3ciLCJtaW5Db21wb3VuZFNpemUiLCJzZWNvbmREaW1lbnNpb24iLCJleHRyYUhlaWdodCIsInIiLCJtaW4iLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJnZXRMb25nZXN0Um93SW5kZXgiLCJleHRyYVdpZHRoIiwibGFzdFJvd0luZGV4IiwibGFzdFJvd1dpZHRoIiwic3JpIiwiaERpZmYiLCJhZGRfdG9fcm93X3JhdGlvIiwiYWRkX25ld19yb3dfcmF0aW8iLCJsb25nZXN0IiwibGFzdCIsImluc3RhbmNlIiwicHJldlRvdGFsIiwiZmluYWxUb3RhbCIsInRpbGluZ1ByZUxheW91dCIsInRpbGluZ1Bvc3RMYXlvdXQiLCJjb250YWluc0xlYWYiLCJwcnVuZWROb2Rlc0luU3RlcFRlbXAiLCJpc0ludGVyR3JhcGgiLCJvdGhlckVuZCIsInJlbGF0aXZlUG9zaXRpb24iLCJnZXRPd25lciIsInBydW5lZE5vZGVzSW5TdGVwIiwibGVuZ3RoT2ZQcnVuZWROb2Rlc0luU3RlcCIsImZpbmRQbGFjZWZvclBydW5lZE5vZGUiLCJncmlkRm9yUHJ1bmVkTm9kZSIsIm5vZGVUb0Nvbm5lY3QiLCJwcnVuZWROb2RlIiwic3RhcnRHcmlkWCIsInN0YXJ0WCIsImZpbmlzaEdyaWRYIiwiZmluaXNoWCIsInN0YXJ0R3JpZFkiLCJzdGFydFkiLCJmaW5pc2hHcmlkWSIsImZpbmlzaFkiLCJ1cE5vZGVDb3VudCIsImRvd25Ob2RlQ291bnQiLCJyaWdodE5vZGVDb3VudCIsImxlZnROb2RlQ291bnQiLCJjb250cm9sUmVnaW9ucyIsImdyaWQiLCJtaW5Db3VudCIsIm1pbkluZGV4IiwiRkRMYXlvdXROb2RlIiwiSU1hdGgiLCJsb2MiLCJnZXRMYXlvdXQiLCJzcHJpbmdGb3JjZVgiLCJyZXB1bHNpb25Gb3JjZVgiLCJncmF2aXRhdGlvbkZvcmNlWCIsInNwcmluZ0ZvcmNlWSIsInJlcHVsc2lvbkZvcmNlWSIsImdyYXZpdGF0aW9uRm9yY2VZIiwibm9PZkNoaWxkcmVuIiwibWF4Tm9kZURpc3BsYWNlbWVudCIsInNpZ24iLCJwcm9wb2dhdGVEaXNwbGFjZW1lbnRUb0NoaWxkcmVuIiwiZFgiLCJkWSIsIm1vdmVCeSIsInNldFByZWQxIiwicHJlZDEiLCJnZXRQcmVkMSIsImdldFByZWQyIiwicHJlZDIiLCJzZXROZXh0IiwibmV4dCIsImdldE5leHQiLCJzZXRQcm9jZXNzZWQiLCJwcm9jZXNzZWQiLCJpc1Byb2Nlc3NlZCIsIl90b0NvbnN1bWFibGVBcnJheSIsImFyciIsIkFycmF5IiwiaXNBcnJheSIsImFycjIiLCJmcm9tIiwiTWF0cml4IiwiU1ZEIiwibm9kZUluZGV4ZXMiLCJ4Q29vcmRzIiwieUNvb3JkcyIsImNhbGN1bGF0ZVBvc2l0aW9uRGlmZiIsInBvczEiLCJwb3MyIiwiY2FsY3VsYXRlQXZnUG9zaXRpb24iLCJub2RlSWRTZXQiLCJ4UG9zU3VtIiwieVBvc1N1bSIsImZpbmRBcHByb3ByaWF0ZVBvc2l0aW9uRm9yUmVsYXRpdmVQbGFjZW1lbnQiLCJkaXJlY3Rpb24iLCJkdW1teVBvc2l0aW9ucyIsImNvbXBvbmVudFNvdXJjZXMiLCJzZXRVbmlvbiIsInNldEEiLCJzZXRCIiwidW5pb24iLCJfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uIiwiX2RpZEl0ZXJhdG9yRXJyb3IiLCJfaXRlcmF0b3JFcnJvciIsIl9pdGVyYXRvciIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiX3N0ZXAiLCJkb25lIiwiZWxlbSIsImVyciIsInJldHVybiIsImluRGVncmVlcyIsImFkamFjZW50IiwicG9zaXRpb25NYXAiLCJwYXN0TWFwIiwiTkVHQVRJVkVfSU5GSU5JVFkiLCJmaXhlZElkcyIsInBvc2l0aW9uIiwiZml4ZWRJZCIsIl9wb3NpdGlvbiIsIl9sb29wIiwiZml4ZWRQb3NpdGlvbiIsInNpbmtOb2RlcyIsIl9jb21wb25lbnRzIiwiaXNGaXhlZENvbXBvbmVudCIsIl9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yIiwiX2RpZEl0ZXJhdG9yRXJyb3IyIiwiX2l0ZXJhdG9yRXJyb3IyIiwiX2l0ZXJhdG9yMiIsIl9zdGVwMiIsImlzRXhpc3QiLCJleGlzdEF0IiwiZWxlIiwibWluQmVmb3JlIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJtaW5BZnRlciIsIm1heEJlZm9yZSIsIm1heEFmdGVyIiwiX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMiLCJfZGlkSXRlcmF0b3JFcnJvcjMiLCJfaXRlcmF0b3JFcnJvcjMiLCJfaXRlcmF0b3IzIiwiX3N0ZXAzIiwicG9zQmVmb3JlIiwicG9zQWZ0ZXIiLCJfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCIsIl9kaWRJdGVyYXRvckVycm9yNCIsIl9pdGVyYXRvckVycm9yNCIsIl9pdGVyYXRvcjQiLCJfc3RlcDQiLCJfbm9kZUlkIiwiYXBwbHlSZWZsZWN0aW9uRm9yUmVsYXRpdmVQbGFjZW1lbnQiLCJyZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnRzIiwicmVmbGVjdE9uWSIsIm5vdFJlZmxlY3RPblkiLCJyZWZsZWN0T25YIiwibm90UmVmbGVjdE9uWCIsIl9pIiwiX2kyIiwiX2kzIiwiZmluZENvbXBvbmVudHMiLCJfY3VycmVudE5vZGUiLCJkYWdUb1VuZGlyZWN0ZWQiLCJkYWciLCJ1bmRpcmVjdGVkIiwiZGFnVG9SZXZlcnNlZCIsInJldmVyc2VkIiwidGFyZ2V0TWF0cml4Iiwic291cmNlTWF0cml4Iiwic3RhbmRhcmRUcmFuc2Zvcm1hdGlvbiIsInJlZmxlY3Rpb25UeXBlIiwiZGFnVW5kaXJlY3RlZCIsInZlcnRpY2FsQWxpZ24iLCJfbG9vcDIiLCJfaTQiLCJhbGlnbm1lbnRTZXQiLCJ4UG9zIiwidmFsdWVzIiwiaG9yaXpvbnRhbEFsaWduIiwiX2xvb3AzIiwiX2k1IiwieVBvcyIsImxhcmdlc3RDb21wb25lbnRTaXplIiwibGFyZ2VzdENvbXBvbmVudEluZGV4IiwiX2k2IiwiY29uc3RyYWludHNJbmxhcmdlc3RDb21wb25lbnQiLCJwb3NpdGlvbk1hcEhvcml6b250YWwiLCJwb3NpdGlvbk1hcFZlcnRpY2FsIiwidHJhbnNmb3JtYXRpb25NYXRyaXgiLCJ0YXJnZXRNYXRyaXhUcmFuc3Bvc2UiLCJ0cmFuc3Bvc2UiLCJzb3VyY2VNYXRyaXhUcmFuc3Bvc2UiLCJfaTciLCJtdWx0R2FtbWEiLCJ0ZW1wTWF0cml4IiwibXVsdE1hdCIsIlNWRFJlc3VsdCIsInN2ZCIsIlYiLCJVIiwiX2k4IiwidGVtcDEiLCJ0ZW1wMiIsInRlbXAzIiwiZG90UHJvZHVjdCIsInRyYW5zbGF0aW9uQW1vdW50IiwicG9zSW5UaGVvcnkiLCJwb3NEZXNpcmVkIiwicG9zRGlmZiIsInhBbGlnbiIsIl9sb29wNCIsIl9pOSIsInlBbGlnbiIsIl9sb29wNSIsIl9pMTAiLCJkdW1teVBvc2l0aW9uc0ZvclZlcnRpY2FsQWxpZ25tZW50IiwiZHVtbXlQb3NpdGlvbnNGb3JIb3Jpem9udGFsQWxpZ25tZW50IiwiX2xvb3A2IiwiX2kxMSIsIl9sb29wNyIsIl9pMTIiLCJkYWdPbkhvcml6b250YWwiLCJkYWdPblZlcnRpY2FsIiwiX2xvb3A4Iiwic291cmNlSWQiLCJ0YXJnZXROb2RlIiwiX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUiLCJfZGlkSXRlcmF0b3JFcnJvcjUiLCJfaXRlcmF0b3JFcnJvcjUiLCJfaXRlcmF0b3I1IiwiX3N0ZXA1IiwidW5kaXJlY3RlZE9uSG9yaXpvbnRhbCIsInVuZGlyZWN0ZWRPblZlcnRpY2FsIiwicmV2ZXJzZWREYWdPbkhvcml6b250YWwiLCJyZXZlcnNlZERhZ09uVmVydGljYWwiLCJjb21wb25lbnRTb3VyY2VzT25Ib3Jpem9udGFsIiwiY29tcG9uZW50U291cmNlc09uVmVydGljYWwiLCJfbG9vcDkiLCJfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiIsIl9kaWRJdGVyYXRvckVycm9yNiIsIl9pdGVyYXRvckVycm9yNiIsIl9pdGVyYXRvcjYiLCJfc3RlcDYiLCJfbG9vcDEwIiwiX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjciLCJfZGlkSXRlcmF0b3JFcnJvcjciLCJfaXRlcmF0b3JFcnJvcjciLCJfaXRlcmF0b3I3IiwiX3N0ZXA3IiwiX2kxMyIsIl9ub2RlIiwiX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fIiwibW9kdWxlSWQiLCJjYWNoZWRNb2R1bGUiLCJfX3dlYnBhY2tfZXhwb3J0c19fIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cytoscape-fcose/node_modules/cose-base/cose-base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/cytoscape-fcose/node_modules/layout-base/layout-base.js":
/*!******************************************************************************!*\
  !*** ./node_modules/cytoscape-fcose/node_modules/layout-base/layout-base.js ***!
  \******************************************************************************/
/***/ ((module) => {

eval("\n(function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory();\n    else {}\n})(void 0, function() {\n    return /******/ function(modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_577__(moduleId) {\n            /******/ /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_577__);\n            /******/ /******/ // Flag the module as loaded\n            /******/ module1.l = true;\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n        /******/ __nested_webpack_require_577__.m = modules;\n        /******/ /******/ // expose the module cache\n        /******/ __nested_webpack_require_577__.c = installedModules;\n        /******/ /******/ // identity function for calling harmony imports with the correct context\n        /******/ __nested_webpack_require_577__.i = function(value) {\n            return value;\n        };\n        /******/ /******/ // define getter function for harmony exports\n        /******/ __nested_webpack_require_577__.d = function(exports1, name, getter) {\n            /******/ if (!__nested_webpack_require_577__.o(exports1, name)) {\n                /******/ Object.defineProperty(exports1, name, {\n                    /******/ configurable: false,\n                    /******/ enumerable: true,\n                    /******/ get: getter\n                });\n            /******/ }\n        /******/ };\n        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __nested_webpack_require_577__.n = function(module1) {\n            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {\n                return module1[\"default\"];\n            } : /******/ function getModuleExports() {\n                return module1;\n            };\n            /******/ __nested_webpack_require_577__.d(getter, \"a\", getter);\n            /******/ return getter;\n        /******/ };\n        /******/ /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __nested_webpack_require_577__.o = function(object, property) {\n            return Object.prototype.hasOwnProperty.call(object, property);\n        };\n        /******/ /******/ // __webpack_public_path__\n        /******/ __nested_webpack_require_577__.p = \"\";\n        /******/ /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_577__(__nested_webpack_require_577__.s = 28);\n    /******/ }([\n        /* 0 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function LayoutConstants() {}\n            /**\r\n * Layout Quality: 0:draft, 1:default, 2:proof\r\n */ LayoutConstants.QUALITY = 1;\n            /**\r\n * Default parameters\r\n */ LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED = false;\n            LayoutConstants.DEFAULT_INCREMENTAL = false;\n            LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT = true;\n            LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT = false;\n            LayoutConstants.DEFAULT_ANIMATION_PERIOD = 50;\n            LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = false;\n            // -----------------------------------------------------------------------------\n            // Section: General other constants\n            // -----------------------------------------------------------------------------\n            /*\r\n * Margins of a graph to be applied on bouding rectangle of its contents. We\r\n * assume margins on all four sides to be uniform.\r\n */ LayoutConstants.DEFAULT_GRAPH_MARGIN = 15;\n            /*\r\n * Whether to consider labels in node dimensions or not\r\n */ LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = false;\n            /*\r\n * Default dimension of a non-compound node.\r\n */ LayoutConstants.SIMPLE_NODE_SIZE = 40;\n            /*\r\n * Default dimension of a non-compound node.\r\n */ LayoutConstants.SIMPLE_NODE_HALF_SIZE = LayoutConstants.SIMPLE_NODE_SIZE / 2;\n            /*\r\n * Empty compound node size. When a compound node is empty, its both\r\n * dimensions should be of this value.\r\n */ LayoutConstants.EMPTY_COMPOUND_NODE_SIZE = 40;\n            /*\r\n * Minimum length that an edge should take during layout\r\n */ LayoutConstants.MIN_EDGE_LENGTH = 1;\n            /*\r\n * World boundaries that layout operates on\r\n */ LayoutConstants.WORLD_BOUNDARY = 1000000;\n            /*\r\n * World boundaries that random positioning can be performed with\r\n */ LayoutConstants.INITIAL_WORLD_BOUNDARY = LayoutConstants.WORLD_BOUNDARY / 1000;\n            /*\r\n * Coordinates of the world center\r\n */ LayoutConstants.WORLD_CENTER_X = 1200;\n            LayoutConstants.WORLD_CENTER_Y = 900;\n            module1.exports = LayoutConstants;\n        /***/ },\n        /* 1 */ /***/ function(module1, exports1, __nested_webpack_require_5702__) {\n            \"use strict\";\n            var LGraphObject = __nested_webpack_require_5702__(2);\n            var IGeometry = __nested_webpack_require_5702__(8);\n            var IMath = __nested_webpack_require_5702__(9);\n            function LEdge(source, target, vEdge) {\n                LGraphObject.call(this, vEdge);\n                this.isOverlapingSourceAndTarget = false;\n                this.vGraphObject = vEdge;\n                this.bendpoints = [];\n                this.source = source;\n                this.target = target;\n            }\n            LEdge.prototype = Object.create(LGraphObject.prototype);\n            for(var prop in LGraphObject){\n                LEdge[prop] = LGraphObject[prop];\n            }\n            LEdge.prototype.getSource = function() {\n                return this.source;\n            };\n            LEdge.prototype.getTarget = function() {\n                return this.target;\n            };\n            LEdge.prototype.isInterGraph = function() {\n                return this.isInterGraph;\n            };\n            LEdge.prototype.getLength = function() {\n                return this.length;\n            };\n            LEdge.prototype.isOverlapingSourceAndTarget = function() {\n                return this.isOverlapingSourceAndTarget;\n            };\n            LEdge.prototype.getBendpoints = function() {\n                return this.bendpoints;\n            };\n            LEdge.prototype.getLca = function() {\n                return this.lca;\n            };\n            LEdge.prototype.getSourceInLca = function() {\n                return this.sourceInLca;\n            };\n            LEdge.prototype.getTargetInLca = function() {\n                return this.targetInLca;\n            };\n            LEdge.prototype.getOtherEnd = function(node) {\n                if (this.source === node) {\n                    return this.target;\n                } else if (this.target === node) {\n                    return this.source;\n                } else {\n                    throw \"Node is not incident with this edge\";\n                }\n            };\n            LEdge.prototype.getOtherEndInGraph = function(node, graph) {\n                var otherEnd = this.getOtherEnd(node);\n                var root = graph.getGraphManager().getRoot();\n                while(true){\n                    if (otherEnd.getOwner() == graph) {\n                        return otherEnd;\n                    }\n                    if (otherEnd.getOwner() == root) {\n                        break;\n                    }\n                    otherEnd = otherEnd.getOwner().getParent();\n                }\n                return null;\n            };\n            LEdge.prototype.updateLength = function() {\n                var clipPointCoordinates = new Array(4);\n                this.isOverlapingSourceAndTarget = IGeometry.getIntersection(this.target.getRect(), this.source.getRect(), clipPointCoordinates);\n                if (!this.isOverlapingSourceAndTarget) {\n                    this.lengthX = clipPointCoordinates[0] - clipPointCoordinates[2];\n                    this.lengthY = clipPointCoordinates[1] - clipPointCoordinates[3];\n                    if (Math.abs(this.lengthX) < 1.0) {\n                        this.lengthX = IMath.sign(this.lengthX);\n                    }\n                    if (Math.abs(this.lengthY) < 1.0) {\n                        this.lengthY = IMath.sign(this.lengthY);\n                    }\n                    this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n                }\n            };\n            LEdge.prototype.updateLengthSimple = function() {\n                this.lengthX = this.target.getCenterX() - this.source.getCenterX();\n                this.lengthY = this.target.getCenterY() - this.source.getCenterY();\n                if (Math.abs(this.lengthX) < 1.0) {\n                    this.lengthX = IMath.sign(this.lengthX);\n                }\n                if (Math.abs(this.lengthY) < 1.0) {\n                    this.lengthY = IMath.sign(this.lengthY);\n                }\n                this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n            };\n            module1.exports = LEdge;\n        /***/ },\n        /* 2 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function LGraphObject(vGraphObject) {\n                this.vGraphObject = vGraphObject;\n            }\n            module1.exports = LGraphObject;\n        /***/ },\n        /* 3 */ /***/ function(module1, exports1, __nested_webpack_require_10242__) {\n            \"use strict\";\n            var LGraphObject = __nested_webpack_require_10242__(2);\n            var Integer = __nested_webpack_require_10242__(10);\n            var RectangleD = __nested_webpack_require_10242__(13);\n            var LayoutConstants = __nested_webpack_require_10242__(0);\n            var RandomSeed = __nested_webpack_require_10242__(16);\n            var PointD = __nested_webpack_require_10242__(5);\n            function LNode(gm, loc, size, vNode) {\n                //Alternative constructor 1 : LNode(LGraphManager gm, Point loc, Dimension size, Object vNode)\n                if (size == null && vNode == null) {\n                    vNode = loc;\n                }\n                LGraphObject.call(this, vNode);\n                //Alternative constructor 2 : LNode(Layout layout, Object vNode)\n                if (gm.graphManager != null) gm = gm.graphManager;\n                this.estimatedSize = Integer.MIN_VALUE;\n                this.inclusionTreeDepth = Integer.MAX_VALUE;\n                this.vGraphObject = vNode;\n                this.edges = [];\n                this.graphManager = gm;\n                if (size != null && loc != null) this.rect = new RectangleD(loc.x, loc.y, size.width, size.height);\n                else this.rect = new RectangleD();\n            }\n            LNode.prototype = Object.create(LGraphObject.prototype);\n            for(var prop in LGraphObject){\n                LNode[prop] = LGraphObject[prop];\n            }\n            LNode.prototype.getEdges = function() {\n                return this.edges;\n            };\n            LNode.prototype.getChild = function() {\n                return this.child;\n            };\n            LNode.prototype.getOwner = function() {\n                //  if (this.owner != null) {\n                //    if (!(this.owner == null || this.owner.getNodes().indexOf(this) > -1)) {\n                //      throw \"assert failed\";\n                //    }\n                //  }\n                return this.owner;\n            };\n            LNode.prototype.getWidth = function() {\n                return this.rect.width;\n            };\n            LNode.prototype.setWidth = function(width) {\n                this.rect.width = width;\n            };\n            LNode.prototype.getHeight = function() {\n                return this.rect.height;\n            };\n            LNode.prototype.setHeight = function(height) {\n                this.rect.height = height;\n            };\n            LNode.prototype.getCenterX = function() {\n                return this.rect.x + this.rect.width / 2;\n            };\n            LNode.prototype.getCenterY = function() {\n                return this.rect.y + this.rect.height / 2;\n            };\n            LNode.prototype.getCenter = function() {\n                return new PointD(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);\n            };\n            LNode.prototype.getLocation = function() {\n                return new PointD(this.rect.x, this.rect.y);\n            };\n            LNode.prototype.getRect = function() {\n                return this.rect;\n            };\n            LNode.prototype.getDiagonal = function() {\n                return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);\n            };\n            /**\n * This method returns half the diagonal length of this node.\n */ LNode.prototype.getHalfTheDiagonal = function() {\n                return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;\n            };\n            LNode.prototype.setRect = function(upperLeft, dimension) {\n                this.rect.x = upperLeft.x;\n                this.rect.y = upperLeft.y;\n                this.rect.width = dimension.width;\n                this.rect.height = dimension.height;\n            };\n            LNode.prototype.setCenter = function(cx, cy) {\n                this.rect.x = cx - this.rect.width / 2;\n                this.rect.y = cy - this.rect.height / 2;\n            };\n            LNode.prototype.setLocation = function(x, y) {\n                this.rect.x = x;\n                this.rect.y = y;\n            };\n            LNode.prototype.moveBy = function(dx, dy) {\n                this.rect.x += dx;\n                this.rect.y += dy;\n            };\n            LNode.prototype.getEdgeListToNode = function(to) {\n                var edgeList = [];\n                var edge;\n                var self = this;\n                self.edges.forEach(function(edge) {\n                    if (edge.target == to) {\n                        if (edge.source != self) throw \"Incorrect edge source!\";\n                        edgeList.push(edge);\n                    }\n                });\n                return edgeList;\n            };\n            LNode.prototype.getEdgesBetween = function(other) {\n                var edgeList = [];\n                var edge;\n                var self = this;\n                self.edges.forEach(function(edge) {\n                    if (!(edge.source == self || edge.target == self)) throw \"Incorrect edge source and/or target\";\n                    if (edge.target == other || edge.source == other) {\n                        edgeList.push(edge);\n                    }\n                });\n                return edgeList;\n            };\n            LNode.prototype.getNeighborsList = function() {\n                var neighbors = new Set();\n                var self = this;\n                self.edges.forEach(function(edge) {\n                    if (edge.source == self) {\n                        neighbors.add(edge.target);\n                    } else {\n                        if (edge.target != self) {\n                            throw \"Incorrect incidency!\";\n                        }\n                        neighbors.add(edge.source);\n                    }\n                });\n                return neighbors;\n            };\n            LNode.prototype.withChildren = function() {\n                var withNeighborsList = new Set();\n                var childNode;\n                var children;\n                withNeighborsList.add(this);\n                if (this.child != null) {\n                    var nodes = this.child.getNodes();\n                    for(var i = 0; i < nodes.length; i++){\n                        childNode = nodes[i];\n                        children = childNode.withChildren();\n                        children.forEach(function(node) {\n                            withNeighborsList.add(node);\n                        });\n                    }\n                }\n                return withNeighborsList;\n            };\n            LNode.prototype.getNoOfChildren = function() {\n                var noOfChildren = 0;\n                var childNode;\n                if (this.child == null) {\n                    noOfChildren = 1;\n                } else {\n                    var nodes = this.child.getNodes();\n                    for(var i = 0; i < nodes.length; i++){\n                        childNode = nodes[i];\n                        noOfChildren += childNode.getNoOfChildren();\n                    }\n                }\n                if (noOfChildren == 0) {\n                    noOfChildren = 1;\n                }\n                return noOfChildren;\n            };\n            LNode.prototype.getEstimatedSize = function() {\n                if (this.estimatedSize == Integer.MIN_VALUE) {\n                    throw \"assert failed\";\n                }\n                return this.estimatedSize;\n            };\n            LNode.prototype.calcEstimatedSize = function() {\n                if (this.child == null) {\n                    return this.estimatedSize = (this.rect.width + this.rect.height) / 2;\n                } else {\n                    this.estimatedSize = this.child.calcEstimatedSize();\n                    this.rect.width = this.estimatedSize;\n                    this.rect.height = this.estimatedSize;\n                    return this.estimatedSize;\n                }\n            };\n            LNode.prototype.scatter = function() {\n                var randomCenterX;\n                var randomCenterY;\n                var minX = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n                var maxX = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n                randomCenterX = LayoutConstants.WORLD_CENTER_X + RandomSeed.nextDouble() * (maxX - minX) + minX;\n                var minY = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n                var maxY = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n                randomCenterY = LayoutConstants.WORLD_CENTER_Y + RandomSeed.nextDouble() * (maxY - minY) + minY;\n                this.rect.x = randomCenterX;\n                this.rect.y = randomCenterY;\n            };\n            LNode.prototype.updateBounds = function() {\n                if (this.getChild() == null) {\n                    throw \"assert failed\";\n                }\n                if (this.getChild().getNodes().length != 0) {\n                    // wrap the children nodes by re-arranging the boundaries\n                    var childGraph = this.getChild();\n                    childGraph.updateBounds(true);\n                    this.rect.x = childGraph.getLeft();\n                    this.rect.y = childGraph.getTop();\n                    this.setWidth(childGraph.getRight() - childGraph.getLeft());\n                    this.setHeight(childGraph.getBottom() - childGraph.getTop());\n                    // Update compound bounds considering its label properties    \n                    if (LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n                        var width = childGraph.getRight() - childGraph.getLeft();\n                        var height = childGraph.getBottom() - childGraph.getTop();\n                        if (this.labelWidth) {\n                            if (this.labelPosHorizontal == \"left\") {\n                                this.rect.x -= this.labelWidth;\n                                this.setWidth(width + this.labelWidth);\n                            } else if (this.labelPosHorizontal == \"center\" && this.labelWidth > width) {\n                                this.rect.x -= (this.labelWidth - width) / 2;\n                                this.setWidth(this.labelWidth);\n                            } else if (this.labelPosHorizontal == \"right\") {\n                                this.setWidth(width + this.labelWidth);\n                            }\n                        }\n                        if (this.labelHeight) {\n                            if (this.labelPosVertical == \"top\") {\n                                this.rect.y -= this.labelHeight;\n                                this.setHeight(height + this.labelHeight);\n                            } else if (this.labelPosVertical == \"center\" && this.labelHeight > height) {\n                                this.rect.y -= (this.labelHeight - height) / 2;\n                                this.setHeight(this.labelHeight);\n                            } else if (this.labelPosVertical == \"bottom\") {\n                                this.setHeight(height + this.labelHeight);\n                            }\n                        }\n                    }\n                }\n            };\n            LNode.prototype.getInclusionTreeDepth = function() {\n                if (this.inclusionTreeDepth == Integer.MAX_VALUE) {\n                    throw \"assert failed\";\n                }\n                return this.inclusionTreeDepth;\n            };\n            LNode.prototype.transform = function(trans) {\n                var left = this.rect.x;\n                if (left > LayoutConstants.WORLD_BOUNDARY) {\n                    left = LayoutConstants.WORLD_BOUNDARY;\n                } else if (left < -LayoutConstants.WORLD_BOUNDARY) {\n                    left = -LayoutConstants.WORLD_BOUNDARY;\n                }\n                var top = this.rect.y;\n                if (top > LayoutConstants.WORLD_BOUNDARY) {\n                    top = LayoutConstants.WORLD_BOUNDARY;\n                } else if (top < -LayoutConstants.WORLD_BOUNDARY) {\n                    top = -LayoutConstants.WORLD_BOUNDARY;\n                }\n                var leftTop = new PointD(left, top);\n                var vLeftTop = trans.inverseTransformPoint(leftTop);\n                this.setLocation(vLeftTop.x, vLeftTop.y);\n            };\n            LNode.prototype.getLeft = function() {\n                return this.rect.x;\n            };\n            LNode.prototype.getRight = function() {\n                return this.rect.x + this.rect.width;\n            };\n            LNode.prototype.getTop = function() {\n                return this.rect.y;\n            };\n            LNode.prototype.getBottom = function() {\n                return this.rect.y + this.rect.height;\n            };\n            LNode.prototype.getParent = function() {\n                if (this.owner == null) {\n                    return null;\n                }\n                return this.owner.getParent();\n            };\n            module1.exports = LNode;\n        /***/ },\n        /* 4 */ /***/ function(module1, exports1, __nested_webpack_require_23259__) {\n            \"use strict\";\n            var LayoutConstants = __nested_webpack_require_23259__(0);\n            function FDLayoutConstants() {}\n            //FDLayoutConstants inherits static props in LayoutConstants\n            for(var prop in LayoutConstants){\n                FDLayoutConstants[prop] = LayoutConstants[prop];\n            }\n            FDLayoutConstants.MAX_ITERATIONS = 2500;\n            FDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\n            FDLayoutConstants.DEFAULT_SPRING_STRENGTH = 0.45;\n            FDLayoutConstants.DEFAULT_REPULSION_STRENGTH = 4500.0;\n            FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = 0.4;\n            FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1.0;\n            FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8;\n            FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5;\n            FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = true;\n            FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = true;\n            FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = 0.3;\n            FDLayoutConstants.COOLING_ADAPTATION_FACTOR = 0.33;\n            FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT = 1000;\n            FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT = 5000;\n            FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100.0;\n            FDLayoutConstants.MAX_NODE_DISPLACEMENT = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL * 3;\n            FDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\n            FDLayoutConstants.CONVERGENCE_CHECK_PERIOD = 100;\n            FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = 0.1;\n            FDLayoutConstants.MIN_EDGE_LENGTH = 1;\n            FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD = 10;\n            module1.exports = FDLayoutConstants;\n        /***/ },\n        /* 5 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function PointD(x, y) {\n                if (x == null && y == null) {\n                    this.x = 0;\n                    this.y = 0;\n                } else {\n                    this.x = x;\n                    this.y = y;\n                }\n            }\n            PointD.prototype.getX = function() {\n                return this.x;\n            };\n            PointD.prototype.getY = function() {\n                return this.y;\n            };\n            PointD.prototype.setX = function(x) {\n                this.x = x;\n            };\n            PointD.prototype.setY = function(y) {\n                this.y = y;\n            };\n            PointD.prototype.getDifference = function(pt) {\n                return new DimensionD(this.x - pt.x, this.y - pt.y);\n            };\n            PointD.prototype.getCopy = function() {\n                return new PointD(this.x, this.y);\n            };\n            PointD.prototype.translate = function(dim) {\n                this.x += dim.width;\n                this.y += dim.height;\n                return this;\n            };\n            module1.exports = PointD;\n        /***/ },\n        /* 6 */ /***/ function(module1, exports1, __nested_webpack_require_26441__) {\n            \"use strict\";\n            var LGraphObject = __nested_webpack_require_26441__(2);\n            var Integer = __nested_webpack_require_26441__(10);\n            var LayoutConstants = __nested_webpack_require_26441__(0);\n            var LGraphManager = __nested_webpack_require_26441__(7);\n            var LNode = __nested_webpack_require_26441__(3);\n            var LEdge = __nested_webpack_require_26441__(1);\n            var RectangleD = __nested_webpack_require_26441__(13);\n            var Point1 = __nested_webpack_require_26441__(12);\n            var LinkedList = __nested_webpack_require_26441__(11);\n            function LGraph(parent, obj2, vGraph) {\n                LGraphObject.call(this, vGraph);\n                this.estimatedSize = Integer.MIN_VALUE;\n                this.margin = LayoutConstants.DEFAULT_GRAPH_MARGIN;\n                this.edges = [];\n                this.nodes = [];\n                this.isConnected = false;\n                this.parent = parent;\n                if (obj2 != null && obj2 instanceof LGraphManager) {\n                    this.graphManager = obj2;\n                } else if (obj2 != null && obj2 instanceof Layout) {\n                    this.graphManager = obj2.graphManager;\n                }\n            }\n            LGraph.prototype = Object.create(LGraphObject.prototype);\n            for(var prop in LGraphObject){\n                LGraph[prop] = LGraphObject[prop];\n            }\n            LGraph.prototype.getNodes = function() {\n                return this.nodes;\n            };\n            LGraph.prototype.getEdges = function() {\n                return this.edges;\n            };\n            LGraph.prototype.getGraphManager = function() {\n                return this.graphManager;\n            };\n            LGraph.prototype.getParent = function() {\n                return this.parent;\n            };\n            LGraph.prototype.getLeft = function() {\n                return this.left;\n            };\n            LGraph.prototype.getRight = function() {\n                return this.right;\n            };\n            LGraph.prototype.getTop = function() {\n                return this.top;\n            };\n            LGraph.prototype.getBottom = function() {\n                return this.bottom;\n            };\n            LGraph.prototype.isConnected = function() {\n                return this.isConnected;\n            };\n            LGraph.prototype.add = function(obj1, sourceNode, targetNode) {\n                if (sourceNode == null && targetNode == null) {\n                    var newNode = obj1;\n                    if (this.graphManager == null) {\n                        throw \"Graph has no graph mgr!\";\n                    }\n                    if (this.getNodes().indexOf(newNode) > -1) {\n                        throw \"Node already in graph!\";\n                    }\n                    newNode.owner = this;\n                    this.getNodes().push(newNode);\n                    return newNode;\n                } else {\n                    var newEdge = obj1;\n                    if (!(this.getNodes().indexOf(sourceNode) > -1 && this.getNodes().indexOf(targetNode) > -1)) {\n                        throw \"Source or target not in graph!\";\n                    }\n                    if (!(sourceNode.owner == targetNode.owner && sourceNode.owner == this)) {\n                        throw \"Both owners must be this graph!\";\n                    }\n                    if (sourceNode.owner != targetNode.owner) {\n                        return null;\n                    }\n                    // set source and target\n                    newEdge.source = sourceNode;\n                    newEdge.target = targetNode;\n                    // set as intra-graph edge\n                    newEdge.isInterGraph = false;\n                    // add to graph edge list\n                    this.getEdges().push(newEdge);\n                    // add to incidency lists\n                    sourceNode.edges.push(newEdge);\n                    if (targetNode != sourceNode) {\n                        targetNode.edges.push(newEdge);\n                    }\n                    return newEdge;\n                }\n            };\n            LGraph.prototype.remove = function(obj) {\n                var node = obj;\n                if (obj instanceof LNode) {\n                    if (node == null) {\n                        throw \"Node is null!\";\n                    }\n                    if (!(node.owner != null && node.owner == this)) {\n                        throw \"Owner graph is invalid!\";\n                    }\n                    if (this.graphManager == null) {\n                        throw \"Owner graph manager is invalid!\";\n                    }\n                    // remove incident edges first (make a copy to do it safely)\n                    var edgesToBeRemoved = node.edges.slice();\n                    var edge;\n                    var s = edgesToBeRemoved.length;\n                    for(var i = 0; i < s; i++){\n                        edge = edgesToBeRemoved[i];\n                        if (edge.isInterGraph) {\n                            this.graphManager.remove(edge);\n                        } else {\n                            edge.source.owner.remove(edge);\n                        }\n                    }\n                    // now the node itself\n                    var index = this.nodes.indexOf(node);\n                    if (index == -1) {\n                        throw \"Node not in owner node list!\";\n                    }\n                    this.nodes.splice(index, 1);\n                } else if (obj instanceof LEdge) {\n                    var edge = obj;\n                    if (edge == null) {\n                        throw \"Edge is null!\";\n                    }\n                    if (!(edge.source != null && edge.target != null)) {\n                        throw \"Source and/or target is null!\";\n                    }\n                    if (!(edge.source.owner != null && edge.target.owner != null && edge.source.owner == this && edge.target.owner == this)) {\n                        throw \"Source and/or target owner is invalid!\";\n                    }\n                    var sourceIndex = edge.source.edges.indexOf(edge);\n                    var targetIndex = edge.target.edges.indexOf(edge);\n                    if (!(sourceIndex > -1 && targetIndex > -1)) {\n                        throw \"Source and/or target doesn't know this edge!\";\n                    }\n                    edge.source.edges.splice(sourceIndex, 1);\n                    if (edge.target != edge.source) {\n                        edge.target.edges.splice(targetIndex, 1);\n                    }\n                    var index = edge.source.owner.getEdges().indexOf(edge);\n                    if (index == -1) {\n                        throw \"Not in owner's edge list!\";\n                    }\n                    edge.source.owner.getEdges().splice(index, 1);\n                }\n            };\n            LGraph.prototype.updateLeftTop = function() {\n                var top = Integer.MAX_VALUE;\n                var left = Integer.MAX_VALUE;\n                var nodeTop;\n                var nodeLeft;\n                var margin;\n                var nodes = this.getNodes();\n                var s = nodes.length;\n                for(var i = 0; i < s; i++){\n                    var lNode = nodes[i];\n                    nodeTop = lNode.getTop();\n                    nodeLeft = lNode.getLeft();\n                    if (top > nodeTop) {\n                        top = nodeTop;\n                    }\n                    if (left > nodeLeft) {\n                        left = nodeLeft;\n                    }\n                }\n                // Do we have any nodes in this graph?\n                if (top == Integer.MAX_VALUE) {\n                    return null;\n                }\n                if (nodes[0].getParent().paddingLeft != undefined) {\n                    margin = nodes[0].getParent().paddingLeft;\n                } else {\n                    margin = this.margin;\n                }\n                this.left = left - margin;\n                this.top = top - margin;\n                // Apply the margins and return the result\n                return new Point1(this.left, this.top);\n            };\n            LGraph.prototype.updateBounds = function(recursive) {\n                // calculate bounds\n                var left = Integer.MAX_VALUE;\n                var right = -Integer.MAX_VALUE;\n                var top = Integer.MAX_VALUE;\n                var bottom = -Integer.MAX_VALUE;\n                var nodeLeft;\n                var nodeRight;\n                var nodeTop;\n                var nodeBottom;\n                var margin;\n                var nodes = this.nodes;\n                var s = nodes.length;\n                for(var i = 0; i < s; i++){\n                    var lNode = nodes[i];\n                    if (recursive && lNode.child != null) {\n                        lNode.updateBounds();\n                    }\n                    nodeLeft = lNode.getLeft();\n                    nodeRight = lNode.getRight();\n                    nodeTop = lNode.getTop();\n                    nodeBottom = lNode.getBottom();\n                    if (left > nodeLeft) {\n                        left = nodeLeft;\n                    }\n                    if (right < nodeRight) {\n                        right = nodeRight;\n                    }\n                    if (top > nodeTop) {\n                        top = nodeTop;\n                    }\n                    if (bottom < nodeBottom) {\n                        bottom = nodeBottom;\n                    }\n                }\n                var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n                if (left == Integer.MAX_VALUE) {\n                    this.left = this.parent.getLeft();\n                    this.right = this.parent.getRight();\n                    this.top = this.parent.getTop();\n                    this.bottom = this.parent.getBottom();\n                }\n                if (nodes[0].getParent().paddingLeft != undefined) {\n                    margin = nodes[0].getParent().paddingLeft;\n                } else {\n                    margin = this.margin;\n                }\n                this.left = boundingRect.x - margin;\n                this.right = boundingRect.x + boundingRect.width + margin;\n                this.top = boundingRect.y - margin;\n                this.bottom = boundingRect.y + boundingRect.height + margin;\n            };\n            LGraph.calculateBounds = function(nodes) {\n                var left = Integer.MAX_VALUE;\n                var right = -Integer.MAX_VALUE;\n                var top = Integer.MAX_VALUE;\n                var bottom = -Integer.MAX_VALUE;\n                var nodeLeft;\n                var nodeRight;\n                var nodeTop;\n                var nodeBottom;\n                var s = nodes.length;\n                for(var i = 0; i < s; i++){\n                    var lNode = nodes[i];\n                    nodeLeft = lNode.getLeft();\n                    nodeRight = lNode.getRight();\n                    nodeTop = lNode.getTop();\n                    nodeBottom = lNode.getBottom();\n                    if (left > nodeLeft) {\n                        left = nodeLeft;\n                    }\n                    if (right < nodeRight) {\n                        right = nodeRight;\n                    }\n                    if (top > nodeTop) {\n                        top = nodeTop;\n                    }\n                    if (bottom < nodeBottom) {\n                        bottom = nodeBottom;\n                    }\n                }\n                var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n                return boundingRect;\n            };\n            LGraph.prototype.getInclusionTreeDepth = function() {\n                if (this == this.graphManager.getRoot()) {\n                    return 1;\n                } else {\n                    return this.parent.getInclusionTreeDepth();\n                }\n            };\n            LGraph.prototype.getEstimatedSize = function() {\n                if (this.estimatedSize == Integer.MIN_VALUE) {\n                    throw \"assert failed\";\n                }\n                return this.estimatedSize;\n            };\n            LGraph.prototype.calcEstimatedSize = function() {\n                var size = 0;\n                var nodes = this.nodes;\n                var s = nodes.length;\n                for(var i = 0; i < s; i++){\n                    var lNode = nodes[i];\n                    size += lNode.calcEstimatedSize();\n                }\n                if (size == 0) {\n                    this.estimatedSize = LayoutConstants.EMPTY_COMPOUND_NODE_SIZE;\n                } else {\n                    this.estimatedSize = size / Math.sqrt(this.nodes.length);\n                }\n                return this.estimatedSize;\n            };\n            LGraph.prototype.updateConnected = function() {\n                var self = this;\n                if (this.nodes.length == 0) {\n                    this.isConnected = true;\n                    return;\n                }\n                var queue = new LinkedList();\n                var visited = new Set();\n                var currentNode = this.nodes[0];\n                var neighborEdges;\n                var currentNeighbor;\n                var childrenOfNode = currentNode.withChildren();\n                childrenOfNode.forEach(function(node) {\n                    queue.push(node);\n                    visited.add(node);\n                });\n                while(queue.length !== 0){\n                    currentNode = queue.shift();\n                    // Traverse all neighbors of this node\n                    neighborEdges = currentNode.getEdges();\n                    var size = neighborEdges.length;\n                    for(var i = 0; i < size; i++){\n                        var neighborEdge = neighborEdges[i];\n                        currentNeighbor = neighborEdge.getOtherEndInGraph(currentNode, this);\n                        // Add unvisited neighbors to the list to visit\n                        if (currentNeighbor != null && !visited.has(currentNeighbor)) {\n                            var childrenOfNeighbor = currentNeighbor.withChildren();\n                            childrenOfNeighbor.forEach(function(node) {\n                                queue.push(node);\n                                visited.add(node);\n                            });\n                        }\n                    }\n                }\n                this.isConnected = false;\n                if (visited.size >= this.nodes.length) {\n                    var noOfVisitedInThisGraph = 0;\n                    visited.forEach(function(visitedNode) {\n                        if (visitedNode.owner == self) {\n                            noOfVisitedInThisGraph++;\n                        }\n                    });\n                    if (noOfVisitedInThisGraph == this.nodes.length) {\n                        this.isConnected = true;\n                    }\n                }\n            };\n            module1.exports = LGraph;\n        /***/ },\n        /* 7 */ /***/ function(module1, exports1, __nested_webpack_require_41577__) {\n            \"use strict\";\n            var LGraph;\n            var LEdge = __nested_webpack_require_41577__(1);\n            function LGraphManager(layout) {\n                LGraph = __nested_webpack_require_41577__(6); // It may be better to initilize this out of this function but it gives an error (Right-hand side of 'instanceof' is not callable) now.\n                this.layout = layout;\n                this.graphs = [];\n                this.edges = [];\n            }\n            LGraphManager.prototype.addRoot = function() {\n                var ngraph = this.layout.newGraph();\n                var nnode = this.layout.newNode(null);\n                var root = this.add(ngraph, nnode);\n                this.setRootGraph(root);\n                return this.rootGraph;\n            };\n            LGraphManager.prototype.add = function(newGraph, parentNode, newEdge, sourceNode, targetNode) {\n                //there are just 2 parameters are passed then it adds an LGraph else it adds an LEdge\n                if (newEdge == null && sourceNode == null && targetNode == null) {\n                    if (newGraph == null) {\n                        throw \"Graph is null!\";\n                    }\n                    if (parentNode == null) {\n                        throw \"Parent node is null!\";\n                    }\n                    if (this.graphs.indexOf(newGraph) > -1) {\n                        throw \"Graph already in this graph mgr!\";\n                    }\n                    this.graphs.push(newGraph);\n                    if (newGraph.parent != null) {\n                        throw \"Already has a parent!\";\n                    }\n                    if (parentNode.child != null) {\n                        throw \"Already has a child!\";\n                    }\n                    newGraph.parent = parentNode;\n                    parentNode.child = newGraph;\n                    return newGraph;\n                } else {\n                    //change the order of the parameters\n                    targetNode = newEdge;\n                    sourceNode = parentNode;\n                    newEdge = newGraph;\n                    var sourceGraph = sourceNode.getOwner();\n                    var targetGraph = targetNode.getOwner();\n                    if (!(sourceGraph != null && sourceGraph.getGraphManager() == this)) {\n                        throw \"Source not in this graph mgr!\";\n                    }\n                    if (!(targetGraph != null && targetGraph.getGraphManager() == this)) {\n                        throw \"Target not in this graph mgr!\";\n                    }\n                    if (sourceGraph == targetGraph) {\n                        newEdge.isInterGraph = false;\n                        return sourceGraph.add(newEdge, sourceNode, targetNode);\n                    } else {\n                        newEdge.isInterGraph = true;\n                        // set source and target\n                        newEdge.source = sourceNode;\n                        newEdge.target = targetNode;\n                        // add edge to inter-graph edge list\n                        if (this.edges.indexOf(newEdge) > -1) {\n                            throw \"Edge already in inter-graph edge list!\";\n                        }\n                        this.edges.push(newEdge);\n                        // add edge to source and target incidency lists\n                        if (!(newEdge.source != null && newEdge.target != null)) {\n                            throw \"Edge source and/or target is null!\";\n                        }\n                        if (!(newEdge.source.edges.indexOf(newEdge) == -1 && newEdge.target.edges.indexOf(newEdge) == -1)) {\n                            throw \"Edge already in source and/or target incidency list!\";\n                        }\n                        newEdge.source.edges.push(newEdge);\n                        newEdge.target.edges.push(newEdge);\n                        return newEdge;\n                    }\n                }\n            };\n            LGraphManager.prototype.remove = function(lObj) {\n                if (lObj instanceof LGraph) {\n                    var graph = lObj;\n                    if (graph.getGraphManager() != this) {\n                        throw \"Graph not in this graph mgr\";\n                    }\n                    if (!(graph == this.rootGraph || graph.parent != null && graph.parent.graphManager == this)) {\n                        throw \"Invalid parent node!\";\n                    }\n                    // first the edges (make a copy to do it safely)\n                    var edgesToBeRemoved = [];\n                    edgesToBeRemoved = edgesToBeRemoved.concat(graph.getEdges());\n                    var edge;\n                    var s = edgesToBeRemoved.length;\n                    for(var i = 0; i < s; i++){\n                        edge = edgesToBeRemoved[i];\n                        graph.remove(edge);\n                    }\n                    // then the nodes (make a copy to do it safely)\n                    var nodesToBeRemoved = [];\n                    nodesToBeRemoved = nodesToBeRemoved.concat(graph.getNodes());\n                    var node;\n                    s = nodesToBeRemoved.length;\n                    for(var i = 0; i < s; i++){\n                        node = nodesToBeRemoved[i];\n                        graph.remove(node);\n                    }\n                    // check if graph is the root\n                    if (graph == this.rootGraph) {\n                        this.setRootGraph(null);\n                    }\n                    // now remove the graph itself\n                    var index = this.graphs.indexOf(graph);\n                    this.graphs.splice(index, 1);\n                    // also reset the parent of the graph\n                    graph.parent = null;\n                } else if (lObj instanceof LEdge) {\n                    edge = lObj;\n                    if (edge == null) {\n                        throw \"Edge is null!\";\n                    }\n                    if (!edge.isInterGraph) {\n                        throw \"Not an inter-graph edge!\";\n                    }\n                    if (!(edge.source != null && edge.target != null)) {\n                        throw \"Source and/or target is null!\";\n                    }\n                    // remove edge from source and target nodes' incidency lists\n                    if (!(edge.source.edges.indexOf(edge) != -1 && edge.target.edges.indexOf(edge) != -1)) {\n                        throw \"Source and/or target doesn't know this edge!\";\n                    }\n                    var index = edge.source.edges.indexOf(edge);\n                    edge.source.edges.splice(index, 1);\n                    index = edge.target.edges.indexOf(edge);\n                    edge.target.edges.splice(index, 1);\n                    // remove edge from owner graph manager's inter-graph edge list\n                    if (!(edge.source.owner != null && edge.source.owner.getGraphManager() != null)) {\n                        throw \"Edge owner graph or owner graph manager is null!\";\n                    }\n                    if (edge.source.owner.getGraphManager().edges.indexOf(edge) == -1) {\n                        throw \"Not in owner graph manager's edge list!\";\n                    }\n                    var index = edge.source.owner.getGraphManager().edges.indexOf(edge);\n                    edge.source.owner.getGraphManager().edges.splice(index, 1);\n                }\n            };\n            LGraphManager.prototype.updateBounds = function() {\n                this.rootGraph.updateBounds(true);\n            };\n            LGraphManager.prototype.getGraphs = function() {\n                return this.graphs;\n            };\n            LGraphManager.prototype.getAllNodes = function() {\n                if (this.allNodes == null) {\n                    var nodeList = [];\n                    var graphs = this.getGraphs();\n                    var s = graphs.length;\n                    for(var i = 0; i < s; i++){\n                        nodeList = nodeList.concat(graphs[i].getNodes());\n                    }\n                    this.allNodes = nodeList;\n                }\n                return this.allNodes;\n            };\n            LGraphManager.prototype.resetAllNodes = function() {\n                this.allNodes = null;\n            };\n            LGraphManager.prototype.resetAllEdges = function() {\n                this.allEdges = null;\n            };\n            LGraphManager.prototype.resetAllNodesToApplyGravitation = function() {\n                this.allNodesToApplyGravitation = null;\n            };\n            LGraphManager.prototype.getAllEdges = function() {\n                if (this.allEdges == null) {\n                    var edgeList = [];\n                    var graphs = this.getGraphs();\n                    var s = graphs.length;\n                    for(var i = 0; i < graphs.length; i++){\n                        edgeList = edgeList.concat(graphs[i].getEdges());\n                    }\n                    edgeList = edgeList.concat(this.edges);\n                    this.allEdges = edgeList;\n                }\n                return this.allEdges;\n            };\n            LGraphManager.prototype.getAllNodesToApplyGravitation = function() {\n                return this.allNodesToApplyGravitation;\n            };\n            LGraphManager.prototype.setAllNodesToApplyGravitation = function(nodeList) {\n                if (this.allNodesToApplyGravitation != null) {\n                    throw \"assert failed\";\n                }\n                this.allNodesToApplyGravitation = nodeList;\n            };\n            LGraphManager.prototype.getRoot = function() {\n                return this.rootGraph;\n            };\n            LGraphManager.prototype.setRootGraph = function(graph) {\n                if (graph.getGraphManager() != this) {\n                    throw \"Root not in this graph mgr!\";\n                }\n                this.rootGraph = graph;\n                // root graph must have a root node associated with it for convenience\n                if (graph.parent == null) {\n                    graph.parent = this.layout.newNode(\"Root node\");\n                }\n            };\n            LGraphManager.prototype.getLayout = function() {\n                return this.layout;\n            };\n            LGraphManager.prototype.isOneAncestorOfOther = function(firstNode, secondNode) {\n                if (!(firstNode != null && secondNode != null)) {\n                    throw \"assert failed\";\n                }\n                if (firstNode == secondNode) {\n                    return true;\n                }\n                // Is second node an ancestor of the first one?\n                var ownerGraph = firstNode.getOwner();\n                var parentNode;\n                do {\n                    parentNode = ownerGraph.getParent();\n                    if (parentNode == null) {\n                        break;\n                    }\n                    if (parentNode == secondNode) {\n                        return true;\n                    }\n                    ownerGraph = parentNode.getOwner();\n                    if (ownerGraph == null) {\n                        break;\n                    }\n                }while (true);\n                // Is first node an ancestor of the second one?\n                ownerGraph = secondNode.getOwner();\n                do {\n                    parentNode = ownerGraph.getParent();\n                    if (parentNode == null) {\n                        break;\n                    }\n                    if (parentNode == firstNode) {\n                        return true;\n                    }\n                    ownerGraph = parentNode.getOwner();\n                    if (ownerGraph == null) {\n                        break;\n                    }\n                }while (true);\n                return false;\n            };\n            LGraphManager.prototype.calcLowestCommonAncestors = function() {\n                var edge;\n                var sourceNode;\n                var targetNode;\n                var sourceAncestorGraph;\n                var targetAncestorGraph;\n                var edges = this.getAllEdges();\n                var s = edges.length;\n                for(var i = 0; i < s; i++){\n                    edge = edges[i];\n                    sourceNode = edge.source;\n                    targetNode = edge.target;\n                    edge.lca = null;\n                    edge.sourceInLca = sourceNode;\n                    edge.targetInLca = targetNode;\n                    if (sourceNode == targetNode) {\n                        edge.lca = sourceNode.getOwner();\n                        continue;\n                    }\n                    sourceAncestorGraph = sourceNode.getOwner();\n                    while(edge.lca == null){\n                        edge.targetInLca = targetNode;\n                        targetAncestorGraph = targetNode.getOwner();\n                        while(edge.lca == null){\n                            if (targetAncestorGraph == sourceAncestorGraph) {\n                                edge.lca = targetAncestorGraph;\n                                break;\n                            }\n                            if (targetAncestorGraph == this.rootGraph) {\n                                break;\n                            }\n                            if (edge.lca != null) {\n                                throw \"assert failed\";\n                            }\n                            edge.targetInLca = targetAncestorGraph.getParent();\n                            targetAncestorGraph = edge.targetInLca.getOwner();\n                        }\n                        if (sourceAncestorGraph == this.rootGraph) {\n                            break;\n                        }\n                        if (edge.lca == null) {\n                            edge.sourceInLca = sourceAncestorGraph.getParent();\n                            sourceAncestorGraph = edge.sourceInLca.getOwner();\n                        }\n                    }\n                    if (edge.lca == null) {\n                        throw \"assert failed\";\n                    }\n                }\n            };\n            LGraphManager.prototype.calcLowestCommonAncestor = function(firstNode, secondNode) {\n                if (firstNode == secondNode) {\n                    return firstNode.getOwner();\n                }\n                var firstOwnerGraph = firstNode.getOwner();\n                do {\n                    if (firstOwnerGraph == null) {\n                        break;\n                    }\n                    var secondOwnerGraph = secondNode.getOwner();\n                    do {\n                        if (secondOwnerGraph == null) {\n                            break;\n                        }\n                        if (secondOwnerGraph == firstOwnerGraph) {\n                            return secondOwnerGraph;\n                        }\n                        secondOwnerGraph = secondOwnerGraph.getParent().getOwner();\n                    }while (true);\n                    firstOwnerGraph = firstOwnerGraph.getParent().getOwner();\n                }while (true);\n                return firstOwnerGraph;\n            };\n            LGraphManager.prototype.calcInclusionTreeDepths = function(graph, depth) {\n                if (graph == null && depth == null) {\n                    graph = this.rootGraph;\n                    depth = 1;\n                }\n                var node;\n                var nodes = graph.getNodes();\n                var s = nodes.length;\n                for(var i = 0; i < s; i++){\n                    node = nodes[i];\n                    node.inclusionTreeDepth = depth;\n                    if (node.child != null) {\n                        this.calcInclusionTreeDepths(node.child, depth + 1);\n                    }\n                }\n            };\n            LGraphManager.prototype.includesInvalidEdge = function() {\n                var edge;\n                var edgesToRemove = [];\n                var s = this.edges.length;\n                for(var i = 0; i < s; i++){\n                    edge = this.edges[i];\n                    if (this.isOneAncestorOfOther(edge.source, edge.target)) {\n                        edgesToRemove.push(edge);\n                    }\n                }\n                // Remove invalid edges from graph manager\n                for(var i = 0; i < edgesToRemove.length; i++){\n                    this.remove(edgesToRemove[i]);\n                }\n                // Invalid edges are cleared, so return false\n                return false;\n            };\n            module1.exports = LGraphManager;\n        /***/ },\n        /* 8 */ /***/ function(module1, exports1, __nested_webpack_require_58317__) {\n            \"use strict\";\n            /**\n * This class maintains a list of static geometry related utility methods.\n *\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */ var Point1 = __nested_webpack_require_58317__(12);\n            function IGeometry() {}\n            /**\n * This method calculates *half* the amount in x and y directions of the two\n * input rectangles needed to separate them keeping their respective\n * positioning, and returns the result in the input array. An input\n * separation buffer added to the amount in both directions. We assume that\n * the two rectangles do intersect.\n */ IGeometry.calcSeparationAmount = function(rectA, rectB, overlapAmount, separationBuffer) {\n                if (!rectA.intersects(rectB)) {\n                    throw \"assert failed\";\n                }\n                var directions = new Array(2);\n                this.decideDirectionsForOverlappingNodes(rectA, rectB, directions);\n                overlapAmount[0] = Math.min(rectA.getRight(), rectB.getRight()) - Math.max(rectA.x, rectB.x);\n                overlapAmount[1] = Math.min(rectA.getBottom(), rectB.getBottom()) - Math.max(rectA.y, rectB.y);\n                // update the overlapping amounts for the following cases:\n                if (rectA.getX() <= rectB.getX() && rectA.getRight() >= rectB.getRight()) {\n                    /* Case x.1:\n    *\n    * rectA\n    * \t|                       |\n    * \t|        _________      |\n    * \t|        |       |      |\n    * \t|________|_______|______|\n    * \t\t\t |       |\n    *           |       |\n    *        rectB\n    */ overlapAmount[0] += Math.min(rectB.getX() - rectA.getX(), rectA.getRight() - rectB.getRight());\n                } else if (rectB.getX() <= rectA.getX() && rectB.getRight() >= rectA.getRight()) {\n                    /* Case x.2:\n    *\n    * rectB\n    * \t|                       |\n    * \t|        _________      |\n    * \t|        |       |      |\n    * \t|________|_______|______|\n    * \t\t\t |       |\n    *           |       |\n    *        rectA\n    */ overlapAmount[0] += Math.min(rectA.getX() - rectB.getX(), rectB.getRight() - rectA.getRight());\n                }\n                if (rectA.getY() <= rectB.getY() && rectA.getBottom() >= rectB.getBottom()) {\n                    /* Case y.1:\n     *          ________ rectA\n     *         |\n     *         |\n     *   ______|____  rectB\n     *         |    |\n     *         |    |\n     *   ______|____|\n     *         |\n     *         |\n     *         |________\n     *\n     */ overlapAmount[1] += Math.min(rectB.getY() - rectA.getY(), rectA.getBottom() - rectB.getBottom());\n                } else if (rectB.getY() <= rectA.getY() && rectB.getBottom() >= rectA.getBottom()) {\n                    /* Case y.2:\n    *          ________ rectB\n    *         |\n    *         |\n    *   ______|____  rectA\n    *         |    |\n    *         |    |\n    *   ______|____|\n    *         |\n    *         |\n    *         |________\n    *\n    */ overlapAmount[1] += Math.min(rectA.getY() - rectB.getY(), rectB.getBottom() - rectA.getBottom());\n                }\n                // find slope of the line passes two centers\n                var slope = Math.abs((rectB.getCenterY() - rectA.getCenterY()) / (rectB.getCenterX() - rectA.getCenterX()));\n                // if centers are overlapped\n                if (rectB.getCenterY() === rectA.getCenterY() && rectB.getCenterX() === rectA.getCenterX()) {\n                    // assume the slope is 1 (45 degree)\n                    slope = 1.0;\n                }\n                var moveByY = slope * overlapAmount[0];\n                var moveByX = overlapAmount[1] / slope;\n                if (overlapAmount[0] < moveByX) {\n                    moveByX = overlapAmount[0];\n                } else {\n                    moveByY = overlapAmount[1];\n                }\n                // return half the amount so that if each rectangle is moved by these\n                // amounts in opposite directions, overlap will be resolved\n                overlapAmount[0] = -1 * directions[0] * (moveByX / 2 + separationBuffer);\n                overlapAmount[1] = -1 * directions[1] * (moveByY / 2 + separationBuffer);\n            };\n            /**\n * This method decides the separation direction of overlapping nodes\n *\n * if directions[0] = -1, then rectA goes left\n * if directions[0] = 1,  then rectA goes right\n * if directions[1] = -1, then rectA goes up\n * if directions[1] = 1,  then rectA goes down\n */ IGeometry.decideDirectionsForOverlappingNodes = function(rectA, rectB, directions) {\n                if (rectA.getCenterX() < rectB.getCenterX()) {\n                    directions[0] = -1;\n                } else {\n                    directions[0] = 1;\n                }\n                if (rectA.getCenterY() < rectB.getCenterY()) {\n                    directions[1] = -1;\n                } else {\n                    directions[1] = 1;\n                }\n            };\n            /**\n * This method calculates the intersection (clipping) points of the two\n * input rectangles with line segment defined by the centers of these two\n * rectangles. The clipping points are saved in the input double array and\n * whether or not the two rectangles overlap is returned.\n */ IGeometry.getIntersection2 = function(rectA, rectB, result) {\n                //result[0-1] will contain clipPoint of rectA, result[2-3] will contain clipPoint of rectB\n                var p1x = rectA.getCenterX();\n                var p1y = rectA.getCenterY();\n                var p2x = rectB.getCenterX();\n                var p2y = rectB.getCenterY();\n                //if two rectangles intersect, then clipping points are centers\n                if (rectA.intersects(rectB)) {\n                    result[0] = p1x;\n                    result[1] = p1y;\n                    result[2] = p2x;\n                    result[3] = p2y;\n                    return true;\n                }\n                //variables for rectA\n                var topLeftAx = rectA.getX();\n                var topLeftAy = rectA.getY();\n                var topRightAx = rectA.getRight();\n                var bottomLeftAx = rectA.getX();\n                var bottomLeftAy = rectA.getBottom();\n                var bottomRightAx = rectA.getRight();\n                var halfWidthA = rectA.getWidthHalf();\n                var halfHeightA = rectA.getHeightHalf();\n                //variables for rectB\n                var topLeftBx = rectB.getX();\n                var topLeftBy = rectB.getY();\n                var topRightBx = rectB.getRight();\n                var bottomLeftBx = rectB.getX();\n                var bottomLeftBy = rectB.getBottom();\n                var bottomRightBx = rectB.getRight();\n                var halfWidthB = rectB.getWidthHalf();\n                var halfHeightB = rectB.getHeightHalf();\n                //flag whether clipping points are found\n                var clipPointAFound = false;\n                var clipPointBFound = false;\n                // line is vertical\n                if (p1x === p2x) {\n                    if (p1y > p2y) {\n                        result[0] = p1x;\n                        result[1] = topLeftAy;\n                        result[2] = p2x;\n                        result[3] = bottomLeftBy;\n                        return false;\n                    } else if (p1y < p2y) {\n                        result[0] = p1x;\n                        result[1] = bottomLeftAy;\n                        result[2] = p2x;\n                        result[3] = topLeftBy;\n                        return false;\n                    } else {\n                    //not line, return null;\n                    }\n                } else if (p1y === p2y) {\n                    if (p1x > p2x) {\n                        result[0] = topLeftAx;\n                        result[1] = p1y;\n                        result[2] = topRightBx;\n                        result[3] = p2y;\n                        return false;\n                    } else if (p1x < p2x) {\n                        result[0] = topRightAx;\n                        result[1] = p1y;\n                        result[2] = topLeftBx;\n                        result[3] = p2y;\n                        return false;\n                    } else {\n                    //not valid line, return null;\n                    }\n                } else {\n                    //slopes of rectA's and rectB's diagonals\n                    var slopeA = rectA.height / rectA.width;\n                    var slopeB = rectB.height / rectB.width;\n                    //slope of line between center of rectA and center of rectB\n                    var slopePrime = (p2y - p1y) / (p2x - p1x);\n                    var cardinalDirectionA = void 0;\n                    var cardinalDirectionB = void 0;\n                    var tempPointAx = void 0;\n                    var tempPointAy = void 0;\n                    var tempPointBx = void 0;\n                    var tempPointBy = void 0;\n                    //determine whether clipping point is the corner of nodeA\n                    if (-slopeA === slopePrime) {\n                        if (p1x > p2x) {\n                            result[0] = bottomLeftAx;\n                            result[1] = bottomLeftAy;\n                            clipPointAFound = true;\n                        } else {\n                            result[0] = topRightAx;\n                            result[1] = topLeftAy;\n                            clipPointAFound = true;\n                        }\n                    } else if (slopeA === slopePrime) {\n                        if (p1x > p2x) {\n                            result[0] = topLeftAx;\n                            result[1] = topLeftAy;\n                            clipPointAFound = true;\n                        } else {\n                            result[0] = bottomRightAx;\n                            result[1] = bottomLeftAy;\n                            clipPointAFound = true;\n                        }\n                    }\n                    //determine whether clipping point is the corner of nodeB\n                    if (-slopeB === slopePrime) {\n                        if (p2x > p1x) {\n                            result[2] = bottomLeftBx;\n                            result[3] = bottomLeftBy;\n                            clipPointBFound = true;\n                        } else {\n                            result[2] = topRightBx;\n                            result[3] = topLeftBy;\n                            clipPointBFound = true;\n                        }\n                    } else if (slopeB === slopePrime) {\n                        if (p2x > p1x) {\n                            result[2] = topLeftBx;\n                            result[3] = topLeftBy;\n                            clipPointBFound = true;\n                        } else {\n                            result[2] = bottomRightBx;\n                            result[3] = bottomLeftBy;\n                            clipPointBFound = true;\n                        }\n                    }\n                    //if both clipping points are corners\n                    if (clipPointAFound && clipPointBFound) {\n                        return false;\n                    }\n                    //determine Cardinal Direction of rectangles\n                    if (p1x > p2x) {\n                        if (p1y > p2y) {\n                            cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 4);\n                            cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 2);\n                        } else {\n                            cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 3);\n                            cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 1);\n                        }\n                    } else {\n                        if (p1y > p2y) {\n                            cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 1);\n                            cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 3);\n                        } else {\n                            cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 2);\n                            cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 4);\n                        }\n                    }\n                    //calculate clipping Point if it is not found before\n                    if (!clipPointAFound) {\n                        switch(cardinalDirectionA){\n                            case 1:\n                                tempPointAy = topLeftAy;\n                                tempPointAx = p1x + -halfHeightA / slopePrime;\n                                result[0] = tempPointAx;\n                                result[1] = tempPointAy;\n                                break;\n                            case 2:\n                                tempPointAx = bottomRightAx;\n                                tempPointAy = p1y + halfWidthA * slopePrime;\n                                result[0] = tempPointAx;\n                                result[1] = tempPointAy;\n                                break;\n                            case 3:\n                                tempPointAy = bottomLeftAy;\n                                tempPointAx = p1x + halfHeightA / slopePrime;\n                                result[0] = tempPointAx;\n                                result[1] = tempPointAy;\n                                break;\n                            case 4:\n                                tempPointAx = bottomLeftAx;\n                                tempPointAy = p1y + -halfWidthA * slopePrime;\n                                result[0] = tempPointAx;\n                                result[1] = tempPointAy;\n                                break;\n                        }\n                    }\n                    if (!clipPointBFound) {\n                        switch(cardinalDirectionB){\n                            case 1:\n                                tempPointBy = topLeftBy;\n                                tempPointBx = p2x + -halfHeightB / slopePrime;\n                                result[2] = tempPointBx;\n                                result[3] = tempPointBy;\n                                break;\n                            case 2:\n                                tempPointBx = bottomRightBx;\n                                tempPointBy = p2y + halfWidthB * slopePrime;\n                                result[2] = tempPointBx;\n                                result[3] = tempPointBy;\n                                break;\n                            case 3:\n                                tempPointBy = bottomLeftBy;\n                                tempPointBx = p2x + halfHeightB / slopePrime;\n                                result[2] = tempPointBx;\n                                result[3] = tempPointBy;\n                                break;\n                            case 4:\n                                tempPointBx = bottomLeftBx;\n                                tempPointBy = p2y + -halfWidthB * slopePrime;\n                                result[2] = tempPointBx;\n                                result[3] = tempPointBy;\n                                break;\n                        }\n                    }\n                }\n                return false;\n            };\n            /**\n * This method returns in which cardinal direction does input point stays\n * 1: North\n * 2: East\n * 3: South\n * 4: West\n */ IGeometry.getCardinalDirection = function(slope, slopePrime, line) {\n                if (slope > slopePrime) {\n                    return line;\n                } else {\n                    return 1 + line % 4;\n                }\n            };\n            /**\n * This method calculates the intersection of the two lines defined by\n * point pairs (s1,s2) and (f1,f2).\n */ IGeometry.getIntersection = function(s1, s2, f1, f2) {\n                if (f2 == null) {\n                    return this.getIntersection2(s1, s2, f1);\n                }\n                var x1 = s1.x;\n                var y1 = s1.y;\n                var x2 = s2.x;\n                var y2 = s2.y;\n                var x3 = f1.x;\n                var y3 = f1.y;\n                var x4 = f2.x;\n                var y4 = f2.y;\n                var x = void 0, y = void 0; // intersection point\n                var a1 = void 0, a2 = void 0, b1 = void 0, b2 = void 0, c1 = void 0, c2 = void 0; // coefficients of line eqns.\n                var denom = void 0;\n                a1 = y2 - y1;\n                b1 = x1 - x2;\n                c1 = x2 * y1 - x1 * y2; // { a1*x + b1*y + c1 = 0 is line 1 }\n                a2 = y4 - y3;\n                b2 = x3 - x4;\n                c2 = x4 * y3 - x3 * y4; // { a2*x + b2*y + c2 = 0 is line 2 }\n                denom = a1 * b2 - a2 * b1;\n                if (denom === 0) {\n                    return null;\n                }\n                x = (b1 * c2 - b2 * c1) / denom;\n                y = (a2 * c1 - a1 * c2) / denom;\n                return new Point1(x, y);\n            };\n            /**\n * This method finds and returns the angle of the vector from the + x-axis\n * in clockwise direction (compatible w/ Java coordinate system!).\n */ IGeometry.angleOfVector = function(Cx, Cy, Nx, Ny) {\n                var C_angle = void 0;\n                if (Cx !== Nx) {\n                    C_angle = Math.atan((Ny - Cy) / (Nx - Cx));\n                    if (Nx < Cx) {\n                        C_angle += Math.PI;\n                    } else if (Ny < Cy) {\n                        C_angle += this.TWO_PI;\n                    }\n                } else if (Ny < Cy) {\n                    C_angle = this.ONE_AND_HALF_PI; // 270 degrees\n                } else {\n                    C_angle = this.HALF_PI; // 90 degrees\n                }\n                return C_angle;\n            };\n            /**\n * This method checks whether the given two line segments (one with point\n * p1 and p2, the other with point p3 and p4) intersect at a point other\n * than these points.\n */ IGeometry.doIntersect = function(p1, p2, p3, p4) {\n                var a = p1.x;\n                var b = p1.y;\n                var c = p2.x;\n                var d = p2.y;\n                var p = p3.x;\n                var q = p3.y;\n                var r = p4.x;\n                var s = p4.y;\n                var det = (c - a) * (s - q) - (r - p) * (d - b);\n                if (det === 0) {\n                    return false;\n                } else {\n                    var lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;\n                    var gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;\n                    return 0 < lambda && lambda < 1 && 0 < gamma && gamma < 1;\n                }\n            };\n            /**\n * This method checks and calculates the intersection of \n * a line segment and a circle.\n */ IGeometry.findCircleLineIntersections = function(Ex, Ey, Lx, Ly, Cx, Cy, r) {\n                // E is the starting point of the ray,\n                // L is the end point of the ray,\n                // C is the center of sphere you're testing against\n                // r is the radius of that sphere\n                // Compute:\n                // d = L - E ( Direction vector of ray, from start to end )\n                // f = E - C ( Vector from center sphere to ray start )\n                // Then the intersection is found by..\n                // P = E + t * d\n                // This is a parametric equation:\n                // Px = Ex + tdx\n                // Py = Ey + tdy\n                // get a, b, c values\n                var a = (Lx - Ex) * (Lx - Ex) + (Ly - Ey) * (Ly - Ey);\n                var b = 2 * ((Ex - Cx) * (Lx - Ex) + (Ey - Cy) * (Ly - Ey));\n                var c = (Ex - Cx) * (Ex - Cx) + (Ey - Cy) * (Ey - Cy) - r * r;\n                // get discriminant\n                var disc = b * b - 4 * a * c;\n                if (disc >= 0) {\n                    // insert into quadratic formula\n                    var t1 = (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n                    var t2 = (-b - Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n                    var intersections = null;\n                    if (t1 >= 0 && t1 <= 1) {\n                        // t1 is the intersection, and it's closer than t2\n                        // (since t1 uses -b - discriminant)\n                        // Impale, Poke\n                        return [\n                            t1\n                        ];\n                    }\n                    // here t1 didn't intersect so we are either started\n                    // inside the sphere or completely past it\n                    if (t2 >= 0 && t2 <= 1) {\n                        // ExitWound\n                        return [\n                            t2\n                        ];\n                    }\n                    return intersections;\n                } else return null;\n            };\n            // -----------------------------------------------------------------------------\n            // Section: Class Constants\n            // -----------------------------------------------------------------------------\n            /**\n * Some useful pre-calculated constants\n */ IGeometry.HALF_PI = 0.5 * Math.PI;\n            IGeometry.ONE_AND_HALF_PI = 1.5 * Math.PI;\n            IGeometry.TWO_PI = 2.0 * Math.PI;\n            IGeometry.THREE_PI = 3.0 * Math.PI;\n            module1.exports = IGeometry;\n        /***/ },\n        /* 9 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function IMath() {}\n            /**\n * This method returns the sign of the input value.\n */ IMath.sign = function(value) {\n                if (value > 0) {\n                    return 1;\n                } else if (value < 0) {\n                    return -1;\n                } else {\n                    return 0;\n                }\n            };\n            IMath.floor = function(value) {\n                return value < 0 ? Math.ceil(value) : Math.floor(value);\n            };\n            IMath.ceil = function(value) {\n                return value < 0 ? Math.floor(value) : Math.ceil(value);\n            };\n            module1.exports = IMath;\n        /***/ },\n        /* 10 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function Integer() {}\n            Integer.MAX_VALUE = 2147483647;\n            Integer.MIN_VALUE = -2147483648;\n            module1.exports = Integer;\n        /***/ },\n        /* 11 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            var nodeFrom = function nodeFrom(value) {\n                return {\n                    value: value,\n                    next: null,\n                    prev: null\n                };\n            };\n            var add = function add(prev, node, next, list) {\n                if (prev !== null) {\n                    prev.next = node;\n                } else {\n                    list.head = node;\n                }\n                if (next !== null) {\n                    next.prev = node;\n                } else {\n                    list.tail = node;\n                }\n                node.prev = prev;\n                node.next = next;\n                list.length++;\n                return node;\n            };\n            var _remove = function _remove(node, list) {\n                var prev = node.prev, next = node.next;\n                if (prev !== null) {\n                    prev.next = next;\n                } else {\n                    list.head = next;\n                }\n                if (next !== null) {\n                    next.prev = prev;\n                } else {\n                    list.tail = prev;\n                }\n                node.prev = node.next = null;\n                list.length--;\n                return node;\n            };\n            var LinkedList = function() {\n                function LinkedList(vals) {\n                    var _this = this;\n                    _classCallCheck(this, LinkedList);\n                    this.length = 0;\n                    this.head = null;\n                    this.tail = null;\n                    if (vals != null) {\n                        vals.forEach(function(v) {\n                            return _this.push(v);\n                        });\n                    }\n                }\n                _createClass(LinkedList, [\n                    {\n                        key: \"size\",\n                        value: function size() {\n                            return this.length;\n                        }\n                    },\n                    {\n                        key: \"insertBefore\",\n                        value: function insertBefore(val, otherNode) {\n                            return add(otherNode.prev, nodeFrom(val), otherNode, this);\n                        }\n                    },\n                    {\n                        key: \"insertAfter\",\n                        value: function insertAfter(val, otherNode) {\n                            return add(otherNode, nodeFrom(val), otherNode.next, this);\n                        }\n                    },\n                    {\n                        key: \"insertNodeBefore\",\n                        value: function insertNodeBefore(newNode, otherNode) {\n                            return add(otherNode.prev, newNode, otherNode, this);\n                        }\n                    },\n                    {\n                        key: \"insertNodeAfter\",\n                        value: function insertNodeAfter(newNode, otherNode) {\n                            return add(otherNode, newNode, otherNode.next, this);\n                        }\n                    },\n                    {\n                        key: \"push\",\n                        value: function push(val) {\n                            return add(this.tail, nodeFrom(val), null, this);\n                        }\n                    },\n                    {\n                        key: \"unshift\",\n                        value: function unshift(val) {\n                            return add(null, nodeFrom(val), this.head, this);\n                        }\n                    },\n                    {\n                        key: \"remove\",\n                        value: function remove(node) {\n                            return _remove(node, this);\n                        }\n                    },\n                    {\n                        key: \"pop\",\n                        value: function pop() {\n                            return _remove(this.tail, this).value;\n                        }\n                    },\n                    {\n                        key: \"popNode\",\n                        value: function popNode() {\n                            return _remove(this.tail, this);\n                        }\n                    },\n                    {\n                        key: \"shift\",\n                        value: function shift() {\n                            return _remove(this.head, this).value;\n                        }\n                    },\n                    {\n                        key: \"shiftNode\",\n                        value: function shiftNode() {\n                            return _remove(this.head, this);\n                        }\n                    },\n                    {\n                        key: \"get_object_at\",\n                        value: function get_object_at(index) {\n                            if (index <= this.length()) {\n                                var i = 1;\n                                var current = this.head;\n                                while(i < index){\n                                    current = current.next;\n                                    i++;\n                                }\n                                return current.value;\n                            }\n                        }\n                    },\n                    {\n                        key: \"set_object_at\",\n                        value: function set_object_at(index, value) {\n                            if (index <= this.length()) {\n                                var i = 1;\n                                var current = this.head;\n                                while(i < index){\n                                    current = current.next;\n                                    i++;\n                                }\n                                current.value = value;\n                            }\n                        }\n                    }\n                ]);\n                return LinkedList;\n            }();\n            module1.exports = LinkedList;\n        /***/ },\n        /* 12 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            /*\r\n *This class is the javascript implementation of the Point.java class in jdk\r\n */ function Point1(x, y, p) {\n                this.x = null;\n                this.y = null;\n                if (x == null && y == null && p == null) {\n                    this.x = 0;\n                    this.y = 0;\n                } else if (typeof x == \"number\" && typeof y == \"number\" && p == null) {\n                    this.x = x;\n                    this.y = y;\n                } else if (x.constructor.name == \"Point\" && y == null && p == null) {\n                    p = x;\n                    this.x = p.x;\n                    this.y = p.y;\n                }\n            }\n            Point1.prototype.getX = function() {\n                return this.x;\n            };\n            Point1.prototype.getY = function() {\n                return this.y;\n            };\n            Point1.prototype.getLocation = function() {\n                return new Point1(this.x, this.y);\n            };\n            Point1.prototype.setLocation = function(x, y, p) {\n                if (x.constructor.name == \"Point\" && y == null && p == null) {\n                    p = x;\n                    this.setLocation(p.x, p.y);\n                } else if (typeof x == \"number\" && typeof y == \"number\" && p == null) {\n                    //if both parameters are integer just move (x,y) location\n                    if (parseInt(x) == x && parseInt(y) == y) {\n                        this.move(x, y);\n                    } else {\n                        this.x = Math.floor(x + 0.5);\n                        this.y = Math.floor(y + 0.5);\n                    }\n                }\n            };\n            Point1.prototype.move = function(x, y) {\n                this.x = x;\n                this.y = y;\n            };\n            Point1.prototype.translate = function(dx, dy) {\n                this.x += dx;\n                this.y += dy;\n            };\n            Point1.prototype.equals = function(obj) {\n                if (obj.constructor.name == \"Point\") {\n                    var pt = obj;\n                    return this.x == pt.x && this.y == pt.y;\n                }\n                return this == obj;\n            };\n            Point1.prototype.toString = function() {\n                return new Point1().constructor.name + \"[x=\" + this.x + \",y=\" + this.y + \"]\";\n            };\n            module1.exports = Point1;\n        /***/ },\n        /* 13 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function RectangleD(x, y, width, height) {\n                this.x = 0;\n                this.y = 0;\n                this.width = 0;\n                this.height = 0;\n                if (x != null && y != null && width != null && height != null) {\n                    this.x = x;\n                    this.y = y;\n                    this.width = width;\n                    this.height = height;\n                }\n            }\n            RectangleD.prototype.getX = function() {\n                return this.x;\n            };\n            RectangleD.prototype.setX = function(x) {\n                this.x = x;\n            };\n            RectangleD.prototype.getY = function() {\n                return this.y;\n            };\n            RectangleD.prototype.setY = function(y) {\n                this.y = y;\n            };\n            RectangleD.prototype.getWidth = function() {\n                return this.width;\n            };\n            RectangleD.prototype.setWidth = function(width) {\n                this.width = width;\n            };\n            RectangleD.prototype.getHeight = function() {\n                return this.height;\n            };\n            RectangleD.prototype.setHeight = function(height) {\n                this.height = height;\n            };\n            RectangleD.prototype.getRight = function() {\n                return this.x + this.width;\n            };\n            RectangleD.prototype.getBottom = function() {\n                return this.y + this.height;\n            };\n            RectangleD.prototype.intersects = function(a) {\n                if (this.getRight() < a.x) {\n                    return false;\n                }\n                if (this.getBottom() < a.y) {\n                    return false;\n                }\n                if (a.getRight() < this.x) {\n                    return false;\n                }\n                if (a.getBottom() < this.y) {\n                    return false;\n                }\n                return true;\n            };\n            RectangleD.prototype.getCenterX = function() {\n                return this.x + this.width / 2;\n            };\n            RectangleD.prototype.getMinX = function() {\n                return this.getX();\n            };\n            RectangleD.prototype.getMaxX = function() {\n                return this.getX() + this.width;\n            };\n            RectangleD.prototype.getCenterY = function() {\n                return this.y + this.height / 2;\n            };\n            RectangleD.prototype.getMinY = function() {\n                return this.getY();\n            };\n            RectangleD.prototype.getMaxY = function() {\n                return this.getY() + this.height;\n            };\n            RectangleD.prototype.getWidthHalf = function() {\n                return this.width / 2;\n            };\n            RectangleD.prototype.getHeightHalf = function() {\n                return this.height / 2;\n            };\n            module1.exports = RectangleD;\n        /***/ },\n        /* 14 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n                return typeof obj;\n            } : function(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n            function UniqueIDGeneretor() {}\n            UniqueIDGeneretor.lastID = 0;\n            UniqueIDGeneretor.createID = function(obj) {\n                if (UniqueIDGeneretor.isPrimitive(obj)) {\n                    return obj;\n                }\n                if (obj.uniqueID != null) {\n                    return obj.uniqueID;\n                }\n                obj.uniqueID = UniqueIDGeneretor.getString();\n                UniqueIDGeneretor.lastID++;\n                return obj.uniqueID;\n            };\n            UniqueIDGeneretor.getString = function(id) {\n                if (id == null) id = UniqueIDGeneretor.lastID;\n                return \"Object#\" + id + \"\";\n            };\n            UniqueIDGeneretor.isPrimitive = function(arg) {\n                var type = typeof arg === \"undefined\" ? \"undefined\" : _typeof(arg);\n                return arg == null || type != \"object\" && type != \"function\";\n            };\n            module1.exports = UniqueIDGeneretor;\n        /***/ },\n        /* 15 */ /***/ function(module1, exports1, __nested_webpack_require_95276__) {\n            \"use strict\";\n            function _toConsumableArray(arr) {\n                if (Array.isArray(arr)) {\n                    for(var i = 0, arr2 = Array(arr.length); i < arr.length; i++){\n                        arr2[i] = arr[i];\n                    }\n                    return arr2;\n                } else {\n                    return Array.from(arr);\n                }\n            }\n            var LayoutConstants = __nested_webpack_require_95276__(0);\n            var LGraphManager = __nested_webpack_require_95276__(7);\n            var LNode = __nested_webpack_require_95276__(3);\n            var LEdge = __nested_webpack_require_95276__(1);\n            var LGraph = __nested_webpack_require_95276__(6);\n            var PointD = __nested_webpack_require_95276__(5);\n            var Transform = __nested_webpack_require_95276__(17);\n            var Emitter = __nested_webpack_require_95276__(29);\n            function Layout1(isRemoteUse) {\n                Emitter.call(this);\n                //Layout Quality: 0:draft, 1:default, 2:proof\n                this.layoutQuality = LayoutConstants.QUALITY;\n                //Whether layout should create bendpoints as needed or not\n                this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n                //Whether layout should be incremental or not\n                this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n                //Whether we animate from before to after layout node positions\n                this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n                //Whether we animate the layout process or not\n                this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n                //Number iterations that should be done between two successive animations\n                this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n                /**\r\n   * Whether or not leaf nodes (non-compound nodes) are of uniform sizes. When\r\n   * they are, both spring and repulsion forces between two leaf nodes can be\r\n   * calculated without the expensive clipping point calculations, resulting\r\n   * in major speed-up.\r\n   */ this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n                /**\r\n   * This is used for creation of bendpoints by using dummy nodes and edges.\r\n   * Maps an LEdge to its dummy bendpoint path.\r\n   */ this.edgeToDummyNodes = new Map();\n                this.graphManager = new LGraphManager(this);\n                this.isLayoutFinished = false;\n                this.isSubLayout = false;\n                this.isRemoteUse = false;\n                if (isRemoteUse != null) {\n                    this.isRemoteUse = isRemoteUse;\n                }\n            }\n            Layout1.RANDOM_SEED = 1;\n            Layout1.prototype = Object.create(Emitter.prototype);\n            Layout1.prototype.getGraphManager = function() {\n                return this.graphManager;\n            };\n            Layout1.prototype.getAllNodes = function() {\n                return this.graphManager.getAllNodes();\n            };\n            Layout1.prototype.getAllEdges = function() {\n                return this.graphManager.getAllEdges();\n            };\n            Layout1.prototype.getAllNodesToApplyGravitation = function() {\n                return this.graphManager.getAllNodesToApplyGravitation();\n            };\n            Layout1.prototype.newGraphManager = function() {\n                var gm = new LGraphManager(this);\n                this.graphManager = gm;\n                return gm;\n            };\n            Layout1.prototype.newGraph = function(vGraph) {\n                return new LGraph(null, this.graphManager, vGraph);\n            };\n            Layout1.prototype.newNode = function(vNode) {\n                return new LNode(this.graphManager, vNode);\n            };\n            Layout1.prototype.newEdge = function(vEdge) {\n                return new LEdge(null, null, vEdge);\n            };\n            Layout1.prototype.checkLayoutSuccess = function() {\n                return this.graphManager.getRoot() == null || this.graphManager.getRoot().getNodes().length == 0 || this.graphManager.includesInvalidEdge();\n            };\n            Layout1.prototype.runLayout = function() {\n                this.isLayoutFinished = false;\n                if (this.tilingPreLayout) {\n                    this.tilingPreLayout();\n                }\n                this.initParameters();\n                var isLayoutSuccessfull;\n                if (this.checkLayoutSuccess()) {\n                    isLayoutSuccessfull = false;\n                } else {\n                    isLayoutSuccessfull = this.layout();\n                }\n                if (LayoutConstants.ANIMATE === \"during\") {\n                    // If this is a 'during' layout animation. Layout is not finished yet. \n                    // We need to perform these in index.js when layout is really finished.\n                    return false;\n                }\n                if (isLayoutSuccessfull) {\n                    if (!this.isSubLayout) {\n                        this.doPostLayout();\n                    }\n                }\n                if (this.tilingPostLayout) {\n                    this.tilingPostLayout();\n                }\n                this.isLayoutFinished = true;\n                return isLayoutSuccessfull;\n            };\n            /**\r\n * This method performs the operations required after layout.\r\n */ Layout1.prototype.doPostLayout = function() {\n                //assert !isSubLayout : \"Should not be called on sub-layout!\";\n                // Propagate geometric changes to v-level objects\n                if (!this.incremental) {\n                    this.transform();\n                }\n                this.update();\n            };\n            /**\r\n * This method updates the geometry of the target graph according to\r\n * calculated layout.\r\n */ Layout1.prototype.update2 = function() {\n                // update bend points\n                if (this.createBendsAsNeeded) {\n                    this.createBendpointsFromDummyNodes();\n                    // reset all edges, since the topology has changed\n                    this.graphManager.resetAllEdges();\n                }\n                // perform edge, node and root updates if layout is not called\n                // remotely\n                if (!this.isRemoteUse) {\n                    // update all edges\n                    var edge;\n                    var allEdges = this.graphManager.getAllEdges();\n                    for(var i = 0; i < allEdges.length; i++){\n                        edge = allEdges[i];\n                    //      this.update(edge);\n                    }\n                    // recursively update nodes\n                    var node;\n                    var nodes = this.graphManager.getRoot().getNodes();\n                    for(var i = 0; i < nodes.length; i++){\n                        node = nodes[i];\n                    //      this.update(node);\n                    }\n                    // update root graph\n                    this.update(this.graphManager.getRoot());\n                }\n            };\n            Layout1.prototype.update = function(obj) {\n                if (obj == null) {\n                    this.update2();\n                } else if (obj instanceof LNode) {\n                    var node = obj;\n                    if (node.getChild() != null) {\n                        // since node is compound, recursively update child nodes\n                        var nodes = node.getChild().getNodes();\n                        for(var i = 0; i < nodes.length; i++){\n                            update(nodes[i]);\n                        }\n                    }\n                    // if the l-level node is associated with a v-level graph object,\n                    // then it is assumed that the v-level node implements the\n                    // interface Updatable.\n                    if (node.vGraphObject != null) {\n                        // cast to Updatable without any type check\n                        var vNode = node.vGraphObject;\n                        // call the update method of the interface\n                        vNode.update(node);\n                    }\n                } else if (obj instanceof LEdge) {\n                    var edge = obj;\n                    // if the l-level edge is associated with a v-level graph object,\n                    // then it is assumed that the v-level edge implements the\n                    // interface Updatable.\n                    if (edge.vGraphObject != null) {\n                        // cast to Updatable without any type check\n                        var vEdge = edge.vGraphObject;\n                        // call the update method of the interface\n                        vEdge.update(edge);\n                    }\n                } else if (obj instanceof LGraph) {\n                    var graph = obj;\n                    // if the l-level graph is associated with a v-level graph object,\n                    // then it is assumed that the v-level object implements the\n                    // interface Updatable.\n                    if (graph.vGraphObject != null) {\n                        // cast to Updatable without any type check\n                        var vGraph = graph.vGraphObject;\n                        // call the update method of the interface\n                        vGraph.update(graph);\n                    }\n                }\n            };\n            /**\r\n * This method is used to set all layout parameters to default values\r\n * determined at compile time.\r\n */ Layout1.prototype.initParameters = function() {\n                if (!this.isSubLayout) {\n                    this.layoutQuality = LayoutConstants.QUALITY;\n                    this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n                    this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n                    this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n                    this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n                    this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n                    this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n                }\n                if (this.animationDuringLayout) {\n                    this.animationOnLayout = false;\n                }\n            };\n            Layout1.prototype.transform = function(newLeftTop) {\n                if (newLeftTop == undefined) {\n                    this.transform(new PointD(0, 0));\n                } else {\n                    // create a transformation object (from Eclipse to layout). When an\n                    // inverse transform is applied, we get upper-left coordinate of the\n                    // drawing or the root graph at given input coordinate (some margins\n                    // already included in calculation of left-top).\n                    var trans = new Transform();\n                    var leftTop = this.graphManager.getRoot().updateLeftTop();\n                    if (leftTop != null) {\n                        trans.setWorldOrgX(newLeftTop.x);\n                        trans.setWorldOrgY(newLeftTop.y);\n                        trans.setDeviceOrgX(leftTop.x);\n                        trans.setDeviceOrgY(leftTop.y);\n                        var nodes = this.getAllNodes();\n                        var node;\n                        for(var i = 0; i < nodes.length; i++){\n                            node = nodes[i];\n                            node.transform(trans);\n                        }\n                    }\n                }\n            };\n            Layout1.prototype.positionNodesRandomly = function(graph) {\n                if (graph == undefined) {\n                    //assert !this.incremental;\n                    this.positionNodesRandomly(this.getGraphManager().getRoot());\n                    this.getGraphManager().getRoot().updateBounds(true);\n                } else {\n                    var lNode;\n                    var childGraph;\n                    var nodes = graph.getNodes();\n                    for(var i = 0; i < nodes.length; i++){\n                        lNode = nodes[i];\n                        childGraph = lNode.getChild();\n                        if (childGraph == null) {\n                            lNode.scatter();\n                        } else if (childGraph.getNodes().length == 0) {\n                            lNode.scatter();\n                        } else {\n                            this.positionNodesRandomly(childGraph);\n                            lNode.updateBounds();\n                        }\n                    }\n                }\n            };\n            /**\r\n * This method returns a list of trees where each tree is represented as a\r\n * list of l-nodes. The method returns a list of size 0 when:\r\n * - The graph is not flat or\r\n * - One of the component(s) of the graph is not a tree.\r\n */ Layout1.prototype.getFlatForest = function() {\n                var flatForest = [];\n                var isForest = true;\n                // Quick reference for all nodes in the graph manager associated with\n                // this layout. The list should not be changed.\n                var allNodes = this.graphManager.getRoot().getNodes();\n                // First be sure that the graph is flat\n                var isFlat = true;\n                for(var i = 0; i < allNodes.length; i++){\n                    if (allNodes[i].getChild() != null) {\n                        isFlat = false;\n                    }\n                }\n                // Return empty forest if the graph is not flat.\n                if (!isFlat) {\n                    return flatForest;\n                }\n                // Run BFS for each component of the graph.\n                var visited = new Set();\n                var toBeVisited = [];\n                var parents = new Map();\n                var unProcessedNodes = [];\n                unProcessedNodes = unProcessedNodes.concat(allNodes);\n                // Each iteration of this loop finds a component of the graph and\n                // decides whether it is a tree or not. If it is a tree, adds it to the\n                // forest and continued with the next component.\n                while(unProcessedNodes.length > 0 && isForest){\n                    toBeVisited.push(unProcessedNodes[0]);\n                    // Start the BFS. Each iteration of this loop visits a node in a\n                    // BFS manner.\n                    while(toBeVisited.length > 0 && isForest){\n                        //pool operation\n                        var currentNode = toBeVisited[0];\n                        toBeVisited.splice(0, 1);\n                        visited.add(currentNode);\n                        // Traverse all neighbors of this node\n                        var neighborEdges = currentNode.getEdges();\n                        for(var i = 0; i < neighborEdges.length; i++){\n                            var currentNeighbor = neighborEdges[i].getOtherEnd(currentNode);\n                            // If BFS is not growing from this neighbor.\n                            if (parents.get(currentNode) != currentNeighbor) {\n                                // We haven't previously visited this neighbor.\n                                if (!visited.has(currentNeighbor)) {\n                                    toBeVisited.push(currentNeighbor);\n                                    parents.set(currentNeighbor, currentNode);\n                                } else {\n                                    isForest = false;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    // The graph contains a component that is not a tree. Empty\n                    // previously found trees. The method will end.\n                    if (!isForest) {\n                        flatForest = [];\n                    } else {\n                        var temp = [].concat(_toConsumableArray(visited));\n                        flatForest.push(temp);\n                        //flatForest = flatForest.concat(temp);\n                        //unProcessedNodes.removeAll(visited);\n                        for(var i = 0; i < temp.length; i++){\n                            var value = temp[i];\n                            var index = unProcessedNodes.indexOf(value);\n                            if (index > -1) {\n                                unProcessedNodes.splice(index, 1);\n                            }\n                        }\n                        visited = new Set();\n                        parents = new Map();\n                    }\n                }\n                return flatForest;\n            };\n            /**\r\n * This method creates dummy nodes (an l-level node with minimal dimensions)\r\n * for the given edge (one per bendpoint). The existing l-level structure\r\n * is updated accordingly.\r\n */ Layout1.prototype.createDummyNodesForBendpoints = function(edge) {\n                var dummyNodes = [];\n                var prev = edge.source;\n                var graph = this.graphManager.calcLowestCommonAncestor(edge.source, edge.target);\n                for(var i = 0; i < edge.bendpoints.length; i++){\n                    // create new dummy node\n                    var dummyNode = this.newNode(null);\n                    dummyNode.setRect(new Point(0, 0), new Dimension(1, 1));\n                    graph.add(dummyNode);\n                    // create new dummy edge between prev and dummy node\n                    var dummyEdge = this.newEdge(null);\n                    this.graphManager.add(dummyEdge, prev, dummyNode);\n                    dummyNodes.add(dummyNode);\n                    prev = dummyNode;\n                }\n                var dummyEdge = this.newEdge(null);\n                this.graphManager.add(dummyEdge, prev, edge.target);\n                this.edgeToDummyNodes.set(edge, dummyNodes);\n                // remove real edge from graph manager if it is inter-graph\n                if (edge.isInterGraph()) {\n                    this.graphManager.remove(edge);\n                } else {\n                    graph.remove(edge);\n                }\n                return dummyNodes;\n            };\n            /**\r\n * This method creates bendpoints for edges from the dummy nodes\r\n * at l-level.\r\n */ Layout1.prototype.createBendpointsFromDummyNodes = function() {\n                var edges = [];\n                edges = edges.concat(this.graphManager.getAllEdges());\n                edges = [].concat(_toConsumableArray(this.edgeToDummyNodes.keys())).concat(edges);\n                for(var k = 0; k < edges.length; k++){\n                    var lEdge = edges[k];\n                    if (lEdge.bendpoints.length > 0) {\n                        var path = this.edgeToDummyNodes.get(lEdge);\n                        for(var i = 0; i < path.length; i++){\n                            var dummyNode = path[i];\n                            var p = new PointD(dummyNode.getCenterX(), dummyNode.getCenterY());\n                            // update bendpoint's location according to dummy node\n                            var ebp = lEdge.bendpoints.get(i);\n                            ebp.x = p.x;\n                            ebp.y = p.y;\n                            // remove the dummy node, dummy edges incident with this\n                            // dummy node is also removed (within the remove method)\n                            dummyNode.getOwner().remove(dummyNode);\n                        }\n                        // add the real edge to graph\n                        this.graphManager.add(lEdge, lEdge.source, lEdge.target);\n                    }\n                }\n            };\n            Layout1.transform = function(sliderValue, defaultValue, minDiv, maxMul) {\n                if (minDiv != undefined && maxMul != undefined) {\n                    var value = defaultValue;\n                    if (sliderValue <= 50) {\n                        var minValue = defaultValue / minDiv;\n                        value -= (defaultValue - minValue) / 50 * (50 - sliderValue);\n                    } else {\n                        var maxValue = defaultValue * maxMul;\n                        value += (maxValue - defaultValue) / 50 * (sliderValue - 50);\n                    }\n                    return value;\n                } else {\n                    var a, b;\n                    if (sliderValue <= 50) {\n                        a = 9.0 * defaultValue / 500.0;\n                        b = defaultValue / 10.0;\n                    } else {\n                        a = 9.0 * defaultValue / 50.0;\n                        b = -8 * defaultValue;\n                    }\n                    return a * sliderValue + b;\n                }\n            };\n            /**\r\n * This method finds and returns the center of the given nodes, assuming\r\n * that the given nodes form a tree in themselves.\r\n */ Layout1.findCenterOfTree = function(nodes) {\n                var list = [];\n                list = list.concat(nodes);\n                var removedNodes = [];\n                var remainingDegrees = new Map();\n                var foundCenter = false;\n                var centerNode = null;\n                if (list.length == 1 || list.length == 2) {\n                    foundCenter = true;\n                    centerNode = list[0];\n                }\n                for(var i = 0; i < list.length; i++){\n                    var node = list[i];\n                    var degree = node.getNeighborsList().size;\n                    remainingDegrees.set(node, node.getNeighborsList().size);\n                    if (degree == 1) {\n                        removedNodes.push(node);\n                    }\n                }\n                var tempList = [];\n                tempList = tempList.concat(removedNodes);\n                while(!foundCenter){\n                    var tempList2 = [];\n                    tempList2 = tempList2.concat(tempList);\n                    tempList = [];\n                    for(var i = 0; i < list.length; i++){\n                        var node = list[i];\n                        var index = list.indexOf(node);\n                        if (index >= 0) {\n                            list.splice(index, 1);\n                        }\n                        var neighbours = node.getNeighborsList();\n                        neighbours.forEach(function(neighbour) {\n                            if (removedNodes.indexOf(neighbour) < 0) {\n                                var otherDegree = remainingDegrees.get(neighbour);\n                                var newDegree = otherDegree - 1;\n                                if (newDegree == 1) {\n                                    tempList.push(neighbour);\n                                }\n                                remainingDegrees.set(neighbour, newDegree);\n                            }\n                        });\n                    }\n                    removedNodes = removedNodes.concat(tempList);\n                    if (list.length == 1 || list.length == 2) {\n                        foundCenter = true;\n                        centerNode = list[0];\n                    }\n                }\n                return centerNode;\n            };\n            /**\r\n * During the coarsening process, this layout may be referenced by two graph managers\r\n * this setter function grants access to change the currently being used graph manager\r\n */ Layout1.prototype.setGraphManager = function(gm) {\n                this.graphManager = gm;\n            };\n            module1.exports = Layout1;\n        /***/ },\n        /* 16 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function RandomSeed() {}\n            // adapted from: https://stackoverflow.com/a/19303725\n            RandomSeed.seed = 1;\n            RandomSeed.x = 0;\n            RandomSeed.nextDouble = function() {\n                RandomSeed.x = Math.sin(RandomSeed.seed++) * 10000;\n                return RandomSeed.x - Math.floor(RandomSeed.x);\n            };\n            module1.exports = RandomSeed;\n        /***/ },\n        /* 17 */ /***/ function(module1, exports1, __nested_webpack_require_119580__) {\n            \"use strict\";\n            var PointD = __nested_webpack_require_119580__(5);\n            function Transform(x, y) {\n                this.lworldOrgX = 0.0;\n                this.lworldOrgY = 0.0;\n                this.ldeviceOrgX = 0.0;\n                this.ldeviceOrgY = 0.0;\n                this.lworldExtX = 1.0;\n                this.lworldExtY = 1.0;\n                this.ldeviceExtX = 1.0;\n                this.ldeviceExtY = 1.0;\n            }\n            Transform.prototype.getWorldOrgX = function() {\n                return this.lworldOrgX;\n            };\n            Transform.prototype.setWorldOrgX = function(wox) {\n                this.lworldOrgX = wox;\n            };\n            Transform.prototype.getWorldOrgY = function() {\n                return this.lworldOrgY;\n            };\n            Transform.prototype.setWorldOrgY = function(woy) {\n                this.lworldOrgY = woy;\n            };\n            Transform.prototype.getWorldExtX = function() {\n                return this.lworldExtX;\n            };\n            Transform.prototype.setWorldExtX = function(wex) {\n                this.lworldExtX = wex;\n            };\n            Transform.prototype.getWorldExtY = function() {\n                return this.lworldExtY;\n            };\n            Transform.prototype.setWorldExtY = function(wey) {\n                this.lworldExtY = wey;\n            };\n            /* Device related */ Transform.prototype.getDeviceOrgX = function() {\n                return this.ldeviceOrgX;\n            };\n            Transform.prototype.setDeviceOrgX = function(dox) {\n                this.ldeviceOrgX = dox;\n            };\n            Transform.prototype.getDeviceOrgY = function() {\n                return this.ldeviceOrgY;\n            };\n            Transform.prototype.setDeviceOrgY = function(doy) {\n                this.ldeviceOrgY = doy;\n            };\n            Transform.prototype.getDeviceExtX = function() {\n                return this.ldeviceExtX;\n            };\n            Transform.prototype.setDeviceExtX = function(dex) {\n                this.ldeviceExtX = dex;\n            };\n            Transform.prototype.getDeviceExtY = function() {\n                return this.ldeviceExtY;\n            };\n            Transform.prototype.setDeviceExtY = function(dey) {\n                this.ldeviceExtY = dey;\n            };\n            Transform.prototype.transformX = function(x) {\n                var xDevice = 0.0;\n                var worldExtX = this.lworldExtX;\n                if (worldExtX != 0.0) {\n                    xDevice = this.ldeviceOrgX + (x - this.lworldOrgX) * this.ldeviceExtX / worldExtX;\n                }\n                return xDevice;\n            };\n            Transform.prototype.transformY = function(y) {\n                var yDevice = 0.0;\n                var worldExtY = this.lworldExtY;\n                if (worldExtY != 0.0) {\n                    yDevice = this.ldeviceOrgY + (y - this.lworldOrgY) * this.ldeviceExtY / worldExtY;\n                }\n                return yDevice;\n            };\n            Transform.prototype.inverseTransformX = function(x) {\n                var xWorld = 0.0;\n                var deviceExtX = this.ldeviceExtX;\n                if (deviceExtX != 0.0) {\n                    xWorld = this.lworldOrgX + (x - this.ldeviceOrgX) * this.lworldExtX / deviceExtX;\n                }\n                return xWorld;\n            };\n            Transform.prototype.inverseTransformY = function(y) {\n                var yWorld = 0.0;\n                var deviceExtY = this.ldeviceExtY;\n                if (deviceExtY != 0.0) {\n                    yWorld = this.lworldOrgY + (y - this.ldeviceOrgY) * this.lworldExtY / deviceExtY;\n                }\n                return yWorld;\n            };\n            Transform.prototype.inverseTransformPoint = function(inPoint) {\n                var outPoint = new PointD(this.inverseTransformX(inPoint.x), this.inverseTransformY(inPoint.y));\n                return outPoint;\n            };\n            module1.exports = Transform;\n        /***/ },\n        /* 18 */ /***/ function(module1, exports1, __nested_webpack_require_123704__) {\n            \"use strict\";\n            function _toConsumableArray(arr) {\n                if (Array.isArray(arr)) {\n                    for(var i = 0, arr2 = Array(arr.length); i < arr.length; i++){\n                        arr2[i] = arr[i];\n                    }\n                    return arr2;\n                } else {\n                    return Array.from(arr);\n                }\n            }\n            var Layout1 = __nested_webpack_require_123704__(15);\n            var FDLayoutConstants = __nested_webpack_require_123704__(4);\n            var LayoutConstants = __nested_webpack_require_123704__(0);\n            var IGeometry = __nested_webpack_require_123704__(8);\n            var IMath = __nested_webpack_require_123704__(9);\n            function FDLayout() {\n                Layout1.call(this);\n                this.useSmartIdealEdgeLengthCalculation = FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n                this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n                this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n                this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n                this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n                this.displacementThresholdPerNode = 3.0 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;\n                this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n                this.initialCoolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n                this.totalDisplacement = 0.0;\n                this.oldTotalDisplacement = 0.0;\n                this.maxIterations = FDLayoutConstants.MAX_ITERATIONS;\n            }\n            FDLayout.prototype = Object.create(Layout1.prototype);\n            for(var prop in Layout1){\n                FDLayout[prop] = Layout1[prop];\n            }\n            FDLayout.prototype.initParameters = function() {\n                Layout1.prototype.initParameters.call(this, arguments);\n                this.totalIterations = 0;\n                this.notAnimatedIterations = 0;\n                this.useFRGridVariant = FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION;\n                this.grid = [];\n            };\n            FDLayout.prototype.calcIdealEdgeLengths = function() {\n                var edge;\n                var originalIdealLength;\n                var lcaDepth;\n                var source;\n                var target;\n                var sizeOfSourceInLca;\n                var sizeOfTargetInLca;\n                var allEdges = this.getGraphManager().getAllEdges();\n                for(var i = 0; i < allEdges.length; i++){\n                    edge = allEdges[i];\n                    originalIdealLength = edge.idealLength;\n                    if (edge.isInterGraph) {\n                        source = edge.getSource();\n                        target = edge.getTarget();\n                        sizeOfSourceInLca = edge.getSourceInLca().getEstimatedSize();\n                        sizeOfTargetInLca = edge.getTargetInLca().getEstimatedSize();\n                        if (this.useSmartIdealEdgeLengthCalculation) {\n                            edge.idealLength += sizeOfSourceInLca + sizeOfTargetInLca - 2 * LayoutConstants.SIMPLE_NODE_SIZE;\n                        }\n                        lcaDepth = edge.getLca().getInclusionTreeDepth();\n                        edge.idealLength += originalIdealLength * FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (source.getInclusionTreeDepth() + target.getInclusionTreeDepth() - 2 * lcaDepth);\n                    }\n                }\n            };\n            FDLayout.prototype.initSpringEmbedder = function() {\n                var s = this.getAllNodes().length;\n                if (this.incremental) {\n                    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n                        this.coolingFactor = Math.max(this.coolingFactor * FDLayoutConstants.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n                    }\n                    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL;\n                } else {\n                    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n                        this.coolingFactor = Math.max(FDLayoutConstants.COOLING_ADAPTATION_FACTOR, 1.0 - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n                    } else {\n                        this.coolingFactor = 1.0;\n                    }\n                    this.initialCoolingFactor = this.coolingFactor;\n                    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT;\n                }\n                this.maxIterations = Math.max(this.getAllNodes().length * 5, this.maxIterations);\n                // Reassign this attribute by using new constant value\n                this.displacementThresholdPerNode = 3.0 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;\n                this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length;\n                this.repulsionRange = this.calcRepulsionRange();\n            };\n            FDLayout.prototype.calcSpringForces = function() {\n                var lEdges = this.getAllEdges();\n                var edge;\n                for(var i = 0; i < lEdges.length; i++){\n                    edge = lEdges[i];\n                    this.calcSpringForce(edge, edge.idealLength);\n                }\n            };\n            FDLayout.prototype.calcRepulsionForces = function() {\n                var gridUpdateAllowed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n                var forceToNodeSurroundingUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n                var i, j;\n                var nodeA, nodeB;\n                var lNodes = this.getAllNodes();\n                var processedNodeSet;\n                if (this.useFRGridVariant) {\n                    if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed) {\n                        this.updateGrid();\n                    }\n                    processedNodeSet = new Set();\n                    // calculate repulsion forces between each nodes and its surrounding\n                    for(i = 0; i < lNodes.length; i++){\n                        nodeA = lNodes[i];\n                        this.calculateRepulsionForceOfANode(nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate);\n                        processedNodeSet.add(nodeA);\n                    }\n                } else {\n                    for(i = 0; i < lNodes.length; i++){\n                        nodeA = lNodes[i];\n                        for(j = i + 1; j < lNodes.length; j++){\n                            nodeB = lNodes[j];\n                            // If both nodes are not members of the same graph, skip.\n                            if (nodeA.getOwner() != nodeB.getOwner()) {\n                                continue;\n                            }\n                            this.calcRepulsionForce(nodeA, nodeB);\n                        }\n                    }\n                }\n            };\n            FDLayout.prototype.calcGravitationalForces = function() {\n                var node;\n                var lNodes = this.getAllNodesToApplyGravitation();\n                for(var i = 0; i < lNodes.length; i++){\n                    node = lNodes[i];\n                    this.calcGravitationalForce(node);\n                }\n            };\n            FDLayout.prototype.moveNodes = function() {\n                var lNodes = this.getAllNodes();\n                var node;\n                for(var i = 0; i < lNodes.length; i++){\n                    node = lNodes[i];\n                    node.move();\n                }\n            };\n            FDLayout.prototype.calcSpringForce = function(edge, idealLength) {\n                var sourceNode = edge.getSource();\n                var targetNode = edge.getTarget();\n                var length;\n                var springForce;\n                var springForceX;\n                var springForceY;\n                // Update edge length\n                if (this.uniformLeafNodeSizes && sourceNode.getChild() == null && targetNode.getChild() == null) {\n                    edge.updateLengthSimple();\n                } else {\n                    edge.updateLength();\n                    if (edge.isOverlapingSourceAndTarget) {\n                        return;\n                    }\n                }\n                length = edge.getLength();\n                if (length == 0) return;\n                // Calculate spring forces\n                springForce = edge.edgeElasticity * (length - idealLength);\n                // Project force onto x and y axes\n                springForceX = springForce * (edge.lengthX / length);\n                springForceY = springForce * (edge.lengthY / length);\n                // Apply forces on the end nodes\n                sourceNode.springForceX += springForceX;\n                sourceNode.springForceY += springForceY;\n                targetNode.springForceX -= springForceX;\n                targetNode.springForceY -= springForceY;\n            };\n            FDLayout.prototype.calcRepulsionForce = function(nodeA, nodeB) {\n                var rectA = nodeA.getRect();\n                var rectB = nodeB.getRect();\n                var overlapAmount = new Array(2);\n                var clipPoints = new Array(4);\n                var distanceX;\n                var distanceY;\n                var distanceSquared;\n                var distance;\n                var repulsionForce;\n                var repulsionForceX;\n                var repulsionForceY;\n                if (rectA.intersects(rectB)) {\n                    // calculate separation amount in x and y directions\n                    IGeometry.calcSeparationAmount(rectA, rectB, overlapAmount, FDLayoutConstants.DEFAULT_EDGE_LENGTH / 2.0);\n                    repulsionForceX = 2 * overlapAmount[0];\n                    repulsionForceY = 2 * overlapAmount[1];\n                    var childrenConstant = nodeA.noOfChildren * nodeB.noOfChildren / (nodeA.noOfChildren + nodeB.noOfChildren);\n                    // Apply forces on the two nodes\n                    nodeA.repulsionForceX -= childrenConstant * repulsionForceX;\n                    nodeA.repulsionForceY -= childrenConstant * repulsionForceY;\n                    nodeB.repulsionForceX += childrenConstant * repulsionForceX;\n                    nodeB.repulsionForceY += childrenConstant * repulsionForceY;\n                } else {\n                    // calculate distance\n                    if (this.uniformLeafNodeSizes && nodeA.getChild() == null && nodeB.getChild() == null) {\n                        distanceX = rectB.getCenterX() - rectA.getCenterX();\n                        distanceY = rectB.getCenterY() - rectA.getCenterY();\n                    } else {\n                        IGeometry.getIntersection(rectA, rectB, clipPoints);\n                        distanceX = clipPoints[2] - clipPoints[0];\n                        distanceY = clipPoints[3] - clipPoints[1];\n                    }\n                    // No repulsion range. FR grid variant should take care of this.\n                    if (Math.abs(distanceX) < FDLayoutConstants.MIN_REPULSION_DIST) {\n                        distanceX = IMath.sign(distanceX) * FDLayoutConstants.MIN_REPULSION_DIST;\n                    }\n                    if (Math.abs(distanceY) < FDLayoutConstants.MIN_REPULSION_DIST) {\n                        distanceY = IMath.sign(distanceY) * FDLayoutConstants.MIN_REPULSION_DIST;\n                    }\n                    distanceSquared = distanceX * distanceX + distanceY * distanceY;\n                    distance = Math.sqrt(distanceSquared);\n                    // Here we use half of the nodes' repulsion values for backward compatibility\n                    repulsionForce = (nodeA.nodeRepulsion / 2 + nodeB.nodeRepulsion / 2) * nodeA.noOfChildren * nodeB.noOfChildren / distanceSquared;\n                    // Project force onto x and y axes\n                    repulsionForceX = repulsionForce * distanceX / distance;\n                    repulsionForceY = repulsionForce * distanceY / distance;\n                    // Apply forces on the two nodes    \n                    nodeA.repulsionForceX -= repulsionForceX;\n                    nodeA.repulsionForceY -= repulsionForceY;\n                    nodeB.repulsionForceX += repulsionForceX;\n                    nodeB.repulsionForceY += repulsionForceY;\n                }\n            };\n            FDLayout.prototype.calcGravitationalForce = function(node) {\n                var ownerGraph;\n                var ownerCenterX;\n                var ownerCenterY;\n                var distanceX;\n                var distanceY;\n                var absDistanceX;\n                var absDistanceY;\n                var estimatedSize;\n                ownerGraph = node.getOwner();\n                ownerCenterX = (ownerGraph.getRight() + ownerGraph.getLeft()) / 2;\n                ownerCenterY = (ownerGraph.getTop() + ownerGraph.getBottom()) / 2;\n                distanceX = node.getCenterX() - ownerCenterX;\n                distanceY = node.getCenterY() - ownerCenterY;\n                absDistanceX = Math.abs(distanceX) + node.getWidth() / 2;\n                absDistanceY = Math.abs(distanceY) + node.getHeight() / 2;\n                if (node.getOwner() == this.graphManager.getRoot()) {\n                    estimatedSize = ownerGraph.getEstimatedSize() * this.gravityRangeFactor;\n                    if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n                        node.gravitationForceX = -this.gravityConstant * distanceX;\n                        node.gravitationForceY = -this.gravityConstant * distanceY;\n                    }\n                } else {\n                    estimatedSize = ownerGraph.getEstimatedSize() * this.compoundGravityRangeFactor;\n                    if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n                        node.gravitationForceX = -this.gravityConstant * distanceX * this.compoundGravityConstant;\n                        node.gravitationForceY = -this.gravityConstant * distanceY * this.compoundGravityConstant;\n                    }\n                }\n            };\n            FDLayout.prototype.isConverged = function() {\n                var converged;\n                var oscilating = false;\n                if (this.totalIterations > this.maxIterations / 3) {\n                    oscilating = Math.abs(this.totalDisplacement - this.oldTotalDisplacement) < 2;\n                }\n                converged = this.totalDisplacement < this.totalDisplacementThreshold;\n                this.oldTotalDisplacement = this.totalDisplacement;\n                return converged || oscilating;\n            };\n            FDLayout.prototype.animate = function() {\n                if (this.animationDuringLayout && !this.isSubLayout) {\n                    if (this.notAnimatedIterations == this.animationPeriod) {\n                        this.update();\n                        this.notAnimatedIterations = 0;\n                    } else {\n                        this.notAnimatedIterations++;\n                    }\n                }\n            };\n            //This method calculates the number of children (weight) for all nodes\n            FDLayout.prototype.calcNoOfChildrenForAllNodes = function() {\n                var node;\n                var allNodes = this.graphManager.getAllNodes();\n                for(var i = 0; i < allNodes.length; i++){\n                    node = allNodes[i];\n                    node.noOfChildren = node.getNoOfChildren();\n                }\n            };\n            // -----------------------------------------------------------------------------\n            // Section: FR-Grid Variant Repulsion Force Calculation\n            // -----------------------------------------------------------------------------\n            FDLayout.prototype.calcGrid = function(graph) {\n                var sizeX = 0;\n                var sizeY = 0;\n                sizeX = parseInt(Math.ceil((graph.getRight() - graph.getLeft()) / this.repulsionRange));\n                sizeY = parseInt(Math.ceil((graph.getBottom() - graph.getTop()) / this.repulsionRange));\n                var grid = new Array(sizeX);\n                for(var i = 0; i < sizeX; i++){\n                    grid[i] = new Array(sizeY);\n                }\n                for(var i = 0; i < sizeX; i++){\n                    for(var j = 0; j < sizeY; j++){\n                        grid[i][j] = new Array();\n                    }\n                }\n                return grid;\n            };\n            FDLayout.prototype.addNodeToGrid = function(v, left, top) {\n                var startX = 0;\n                var finishX = 0;\n                var startY = 0;\n                var finishY = 0;\n                startX = parseInt(Math.floor((v.getRect().x - left) / this.repulsionRange));\n                finishX = parseInt(Math.floor((v.getRect().width + v.getRect().x - left) / this.repulsionRange));\n                startY = parseInt(Math.floor((v.getRect().y - top) / this.repulsionRange));\n                finishY = parseInt(Math.floor((v.getRect().height + v.getRect().y - top) / this.repulsionRange));\n                for(var i = startX; i <= finishX; i++){\n                    for(var j = startY; j <= finishY; j++){\n                        this.grid[i][j].push(v);\n                        v.setGridCoordinates(startX, finishX, startY, finishY);\n                    }\n                }\n            };\n            FDLayout.prototype.updateGrid = function() {\n                var i;\n                var nodeA;\n                var lNodes = this.getAllNodes();\n                this.grid = this.calcGrid(this.graphManager.getRoot());\n                // put all nodes to proper grid cells\n                for(i = 0; i < lNodes.length; i++){\n                    nodeA = lNodes[i];\n                    this.addNodeToGrid(nodeA, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());\n                }\n            };\n            FDLayout.prototype.calculateRepulsionForceOfANode = function(nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate) {\n                if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed || forceToNodeSurroundingUpdate) {\n                    var surrounding = new Set();\n                    nodeA.surrounding = new Array();\n                    var nodeB;\n                    var grid = this.grid;\n                    for(var i = nodeA.startX - 1; i < nodeA.finishX + 2; i++){\n                        for(var j = nodeA.startY - 1; j < nodeA.finishY + 2; j++){\n                            if (!(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length)) {\n                                for(var k = 0; k < grid[i][j].length; k++){\n                                    nodeB = grid[i][j][k];\n                                    // If both nodes are not members of the same graph, \n                                    // or both nodes are the same, skip.\n                                    if (nodeA.getOwner() != nodeB.getOwner() || nodeA == nodeB) {\n                                        continue;\n                                    }\n                                    // check if the repulsion force between\n                                    // nodeA and nodeB has already been calculated\n                                    if (!processedNodeSet.has(nodeB) && !surrounding.has(nodeB)) {\n                                        var distanceX = Math.abs(nodeA.getCenterX() - nodeB.getCenterX()) - (nodeA.getWidth() / 2 + nodeB.getWidth() / 2);\n                                        var distanceY = Math.abs(nodeA.getCenterY() - nodeB.getCenterY()) - (nodeA.getHeight() / 2 + nodeB.getHeight() / 2);\n                                        // if the distance between nodeA and nodeB \n                                        // is less then calculation range\n                                        if (distanceX <= this.repulsionRange && distanceY <= this.repulsionRange) {\n                                            //then add nodeB to surrounding of nodeA\n                                            surrounding.add(nodeB);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    nodeA.surrounding = [].concat(_toConsumableArray(surrounding));\n                }\n                for(i = 0; i < nodeA.surrounding.length; i++){\n                    this.calcRepulsionForce(nodeA, nodeA.surrounding[i]);\n                }\n            };\n            FDLayout.prototype.calcRepulsionRange = function() {\n                return 0.0;\n            };\n            module1.exports = FDLayout;\n        /***/ },\n        /* 19 */ /***/ function(module1, exports1, __nested_webpack_require_145254__) {\n            \"use strict\";\n            var LEdge = __nested_webpack_require_145254__(1);\n            var FDLayoutConstants = __nested_webpack_require_145254__(4);\n            function FDLayoutEdge(source, target, vEdge) {\n                LEdge.call(this, source, target, vEdge);\n                // Ideal length and elasticity value for this edge\n                this.idealLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n                this.edgeElasticity = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n            }\n            FDLayoutEdge.prototype = Object.create(LEdge.prototype);\n            for(var prop in LEdge){\n                FDLayoutEdge[prop] = LEdge[prop];\n            }\n            module1.exports = FDLayoutEdge;\n        /***/ },\n        /* 20 */ /***/ function(module1, exports1, __nested_webpack_require_146044__) {\n            \"use strict\";\n            var LNode = __nested_webpack_require_146044__(3);\n            var FDLayoutConstants = __nested_webpack_require_146044__(4);\n            function FDLayoutNode(gm, loc, size, vNode) {\n                // alternative constructor is handled inside LNode\n                LNode.call(this, gm, loc, size, vNode);\n                // Repulsion value of this node\n                this.nodeRepulsion = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n                //Spring, repulsion and gravitational forces acting on this node\n                this.springForceX = 0;\n                this.springForceY = 0;\n                this.repulsionForceX = 0;\n                this.repulsionForceY = 0;\n                this.gravitationForceX = 0;\n                this.gravitationForceY = 0;\n                //Amount by which this node is to be moved in this iteration\n                this.displacementX = 0;\n                this.displacementY = 0;\n                //Start and finish grid coordinates that this node is fallen into\n                this.startX = 0;\n                this.finishX = 0;\n                this.startY = 0;\n                this.finishY = 0;\n                //Geometric neighbors of this node\n                this.surrounding = [];\n            }\n            FDLayoutNode.prototype = Object.create(LNode.prototype);\n            for(var prop in LNode){\n                FDLayoutNode[prop] = LNode[prop];\n            }\n            FDLayoutNode.prototype.setGridCoordinates = function(_startX, _finishX, _startY, _finishY) {\n                this.startX = _startX;\n                this.finishX = _finishX;\n                this.startY = _startY;\n                this.finishY = _finishY;\n            };\n            module1.exports = FDLayoutNode;\n        /***/ },\n        /* 21 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function DimensionD1(width, height) {\n                this.width = 0;\n                this.height = 0;\n                if (width !== null && height !== null) {\n                    this.height = height;\n                    this.width = width;\n                }\n            }\n            DimensionD1.prototype.getWidth = function() {\n                return this.width;\n            };\n            DimensionD1.prototype.setWidth = function(width) {\n                this.width = width;\n            };\n            DimensionD1.prototype.getHeight = function() {\n                return this.height;\n            };\n            DimensionD1.prototype.setHeight = function(height) {\n                this.height = height;\n            };\n            module1.exports = DimensionD1;\n        /***/ },\n        /* 22 */ /***/ function(module1, exports1, __nested_webpack_require_148778__) {\n            \"use strict\";\n            var UniqueIDGeneretor = __nested_webpack_require_148778__(14);\n            function HashMap() {\n                this.map = {};\n                this.keys = [];\n            }\n            HashMap.prototype.put = function(key, value) {\n                var theId = UniqueIDGeneretor.createID(key);\n                if (!this.contains(theId)) {\n                    this.map[theId] = value;\n                    this.keys.push(key);\n                }\n            };\n            HashMap.prototype.contains = function(key) {\n                var theId = UniqueIDGeneretor.createID(key);\n                return this.map[key] != null;\n            };\n            HashMap.prototype.get = function(key) {\n                var theId = UniqueIDGeneretor.createID(key);\n                return this.map[theId];\n            };\n            HashMap.prototype.keySet = function() {\n                return this.keys;\n            };\n            module1.exports = HashMap;\n        /***/ },\n        /* 23 */ /***/ function(module1, exports1, __nested_webpack_require_149837__) {\n            \"use strict\";\n            var UniqueIDGeneretor = __nested_webpack_require_149837__(14);\n            function HashSet() {\n                this.set = {};\n            }\n            ;\n            HashSet.prototype.add = function(obj) {\n                var theId = UniqueIDGeneretor.createID(obj);\n                if (!this.contains(theId)) this.set[theId] = obj;\n            };\n            HashSet.prototype.remove = function(obj) {\n                delete this.set[UniqueIDGeneretor.createID(obj)];\n            };\n            HashSet.prototype.clear = function() {\n                this.set = {};\n            };\n            HashSet.prototype.contains = function(obj) {\n                return this.set[UniqueIDGeneretor.createID(obj)] == obj;\n            };\n            HashSet.prototype.isEmpty = function() {\n                return this.size() === 0;\n            };\n            HashSet.prototype.size = function() {\n                return Object.keys(this.set).length;\n            };\n            //concats this.set to the given list\n            HashSet.prototype.addAllTo = function(list) {\n                var keys = Object.keys(this.set);\n                var length = keys.length;\n                for(var i = 0; i < length; i++){\n                    list.push(this.set[keys[i]]);\n                }\n            };\n            HashSet.prototype.size = function() {\n                return Object.keys(this.set).length;\n            };\n            HashSet.prototype.addAll = function(list) {\n                var s = list.length;\n                for(var i = 0; i < s; i++){\n                    var v = list[i];\n                    this.add(v);\n                }\n            };\n            module1.exports = HashSet;\n        /***/ },\n        /* 24 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            // Some matrix (1d and 2d array) operations\n            function Matrix() {}\n            /**\n * matrix multiplication\n * array1, array2 and result are 2d arrays\n */ Matrix.multMat = function(array1, array2) {\n                var result = [];\n                for(var i = 0; i < array1.length; i++){\n                    result[i] = [];\n                    for(var j = 0; j < array2[0].length; j++){\n                        result[i][j] = 0;\n                        for(var k = 0; k < array1[0].length; k++){\n                            result[i][j] += array1[i][k] * array2[k][j];\n                        }\n                    }\n                }\n                return result;\n            };\n            /**\n * matrix transpose\n * array and result are 2d arrays\n */ Matrix.transpose = function(array) {\n                var result = [];\n                for(var i = 0; i < array[0].length; i++){\n                    result[i] = [];\n                    for(var j = 0; j < array.length; j++){\n                        result[i][j] = array[j][i];\n                    }\n                }\n                return result;\n            };\n            /**\n * multiply array with constant\n * array and result are 1d arrays\n */ Matrix.multCons = function(array, constant) {\n                var result = [];\n                for(var i = 0; i < array.length; i++){\n                    result[i] = array[i] * constant;\n                }\n                return result;\n            };\n            /**\n * substract two arrays\n * array1, array2 and result are 1d arrays\n */ Matrix.minusOp = function(array1, array2) {\n                var result = [];\n                for(var i = 0; i < array1.length; i++){\n                    result[i] = array1[i] - array2[i];\n                }\n                return result;\n            };\n            /**\n * dot product of two arrays with same size\n * array1 and array2 are 1d arrays\n */ Matrix.dotProduct = function(array1, array2) {\n                var product = 0;\n                for(var i = 0; i < array1.length; i++){\n                    product += array1[i] * array2[i];\n                }\n                return product;\n            };\n            /**\n * magnitude of an array\n * array is 1d array\n */ Matrix.mag = function(array) {\n                return Math.sqrt(this.dotProduct(array, array));\n            };\n            /**\n * normalization of an array\n * array and result are 1d array\n */ Matrix.normalize = function(array) {\n                var result = [];\n                var magnitude = this.mag(array);\n                for(var i = 0; i < array.length; i++){\n                    result[i] = array[i] / magnitude;\n                }\n                return result;\n            };\n            /**\n * multiply an array with centering matrix\n * array and result are 1d array\n */ Matrix.multGamma = function(array) {\n                var result = [];\n                var sum = 0;\n                for(var i = 0; i < array.length; i++){\n                    sum += array[i];\n                }\n                sum *= -1 / array.length;\n                for(var _i = 0; _i < array.length; _i++){\n                    result[_i] = sum + array[_i];\n                }\n                return result;\n            };\n            /**\n * a special matrix multiplication\n * result = 0.5 * C * INV * C^T * array\n * array and result are 1d, C and INV are 2d arrays\n */ Matrix.multL = function(array, C, INV) {\n                var result = [];\n                var temp1 = [];\n                var temp2 = [];\n                // multiply by C^T\n                for(var i = 0; i < C[0].length; i++){\n                    var sum = 0;\n                    for(var j = 0; j < C.length; j++){\n                        sum += -0.5 * C[j][i] * array[j];\n                    }\n                    temp1[i] = sum;\n                }\n                // multiply the result by INV\n                for(var _i2 = 0; _i2 < INV.length; _i2++){\n                    var _sum = 0;\n                    for(var _j = 0; _j < INV.length; _j++){\n                        _sum += INV[_i2][_j] * temp1[_j];\n                    }\n                    temp2[_i2] = _sum;\n                }\n                // multiply the result by C\n                for(var _i3 = 0; _i3 < C.length; _i3++){\n                    var _sum2 = 0;\n                    for(var _j2 = 0; _j2 < C[0].length; _j2++){\n                        _sum2 += C[_i3][_j2] * temp2[_j2];\n                    }\n                    result[_i3] = _sum2;\n                }\n                return result;\n            };\n            module1.exports = Matrix;\n        /***/ },\n        /* 25 */ /***/ function(module1, exports1, __nested_webpack_require_156346__) {\n            \"use strict\";\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            /**\n * A classic Quicksort algorithm with Hoare's partition\n * - Works also on LinkedList objects\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */ var LinkedList = __nested_webpack_require_156346__(11);\n            var Quicksort = function() {\n                function Quicksort(A, compareFunction) {\n                    _classCallCheck(this, Quicksort);\n                    if (compareFunction !== null || compareFunction !== undefined) this.compareFunction = this._defaultCompareFunction;\n                    var length = void 0;\n                    if (A instanceof LinkedList) length = A.size();\n                    else length = A.length;\n                    this._quicksort(A, 0, length - 1);\n                }\n                _createClass(Quicksort, [\n                    {\n                        key: \"_quicksort\",\n                        value: function _quicksort(A, p, r) {\n                            if (p < r) {\n                                var q = this._partition(A, p, r);\n                                this._quicksort(A, p, q);\n                                this._quicksort(A, q + 1, r);\n                            }\n                        }\n                    },\n                    {\n                        key: \"_partition\",\n                        value: function _partition(A, p, r) {\n                            var x = this._get(A, p);\n                            var i = p;\n                            var j = r;\n                            while(true){\n                                while(this.compareFunction(x, this._get(A, j))){\n                                    j--;\n                                }\n                                while(this.compareFunction(this._get(A, i), x)){\n                                    i++;\n                                }\n                                if (i < j) {\n                                    this._swap(A, i, j);\n                                    i++;\n                                    j--;\n                                } else return j;\n                            }\n                        }\n                    },\n                    {\n                        key: \"_get\",\n                        value: function _get(object, index) {\n                            if (object instanceof LinkedList) return object.get_object_at(index);\n                            else return object[index];\n                        }\n                    },\n                    {\n                        key: \"_set\",\n                        value: function _set(object, index, value) {\n                            if (object instanceof LinkedList) object.set_object_at(index, value);\n                            else object[index] = value;\n                        }\n                    },\n                    {\n                        key: \"_swap\",\n                        value: function _swap(A, i, j) {\n                            var temp = this._get(A, i);\n                            this._set(A, i, this._get(A, j));\n                            this._set(A, j, temp);\n                        }\n                    },\n                    {\n                        key: \"_defaultCompareFunction\",\n                        value: function _defaultCompareFunction(a, b) {\n                            return b > a;\n                        }\n                    }\n                ]);\n                return Quicksort;\n            }();\n            module1.exports = Quicksort;\n        /***/ },\n        /* 26 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            // Singular Value Decomposition implementation\n            function SVD() {}\n            ;\n            /* Below singular value decomposition (svd) code including hypot function is adopted from https://github.com/dragonfly-ai/JamaJS\n   Some changes are applied to make the code compatible with the fcose code and to make it independent from Jama.\n   Input matrix is changed to a 2D array instead of Jama matrix. Matrix dimensions are taken according to 2D array instead of using Jama functions.\n   An object that includes singular value components is created for return. \n   The types of input parameters of the hypot function are removed. \n   let is used instead of var for the variable initialization.\n*/ /*\n                               Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright {yyyy} {name of copyright owner}\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/ SVD.svd = function(A) {\n                this.U = null;\n                this.V = null;\n                this.s = null;\n                this.m = 0;\n                this.n = 0;\n                this.m = A.length;\n                this.n = A[0].length;\n                var nu = Math.min(this.m, this.n);\n                this.s = function(s) {\n                    var a = [];\n                    while(s-- > 0){\n                        a.push(0);\n                    }\n                    return a;\n                }(Math.min(this.m + 1, this.n));\n                this.U = function(dims) {\n                    var allocate = function allocate(dims) {\n                        if (dims.length == 0) {\n                            return 0;\n                        } else {\n                            var array = [];\n                            for(var i = 0; i < dims[0]; i++){\n                                array.push(allocate(dims.slice(1)));\n                            }\n                            return array;\n                        }\n                    };\n                    return allocate(dims);\n                }([\n                    this.m,\n                    nu\n                ]);\n                this.V = function(dims) {\n                    var allocate = function allocate(dims) {\n                        if (dims.length == 0) {\n                            return 0;\n                        } else {\n                            var array = [];\n                            for(var i = 0; i < dims[0]; i++){\n                                array.push(allocate(dims.slice(1)));\n                            }\n                            return array;\n                        }\n                    };\n                    return allocate(dims);\n                }([\n                    this.n,\n                    this.n\n                ]);\n                var e = function(s) {\n                    var a = [];\n                    while(s-- > 0){\n                        a.push(0);\n                    }\n                    return a;\n                }(this.n);\n                var work = function(s) {\n                    var a = [];\n                    while(s-- > 0){\n                        a.push(0);\n                    }\n                    return a;\n                }(this.m);\n                var wantu = true;\n                var wantv = true;\n                var nct = Math.min(this.m - 1, this.n);\n                var nrt = Math.max(0, Math.min(this.n - 2, this.m));\n                for(var k = 0; k < Math.max(nct, nrt); k++){\n                    if (k < nct) {\n                        this.s[k] = 0;\n                        for(var i = k; i < this.m; i++){\n                            this.s[k] = SVD.hypot(this.s[k], A[i][k]);\n                        }\n                        ;\n                        if (this.s[k] !== 0.0) {\n                            if (A[k][k] < 0.0) {\n                                this.s[k] = -this.s[k];\n                            }\n                            for(var _i = k; _i < this.m; _i++){\n                                A[_i][k] /= this.s[k];\n                            }\n                            ;\n                            A[k][k] += 1.0;\n                        }\n                        this.s[k] = -this.s[k];\n                    }\n                    for(var j = k + 1; j < this.n; j++){\n                        if (function(lhs, rhs) {\n                            return lhs && rhs;\n                        }(k < nct, this.s[k] !== 0.0)) {\n                            var t = 0;\n                            for(var _i2 = k; _i2 < this.m; _i2++){\n                                t += A[_i2][k] * A[_i2][j];\n                            }\n                            ;\n                            t = -t / A[k][k];\n                            for(var _i3 = k; _i3 < this.m; _i3++){\n                                A[_i3][j] += t * A[_i3][k];\n                            }\n                            ;\n                        }\n                        e[j] = A[k][j];\n                    }\n                    ;\n                    if (function(lhs, rhs) {\n                        return lhs && rhs;\n                    }(wantu, k < nct)) {\n                        for(var _i4 = k; _i4 < this.m; _i4++){\n                            this.U[_i4][k] = A[_i4][k];\n                        }\n                        ;\n                    }\n                    if (k < nrt) {\n                        e[k] = 0;\n                        for(var _i5 = k + 1; _i5 < this.n; _i5++){\n                            e[k] = SVD.hypot(e[k], e[_i5]);\n                        }\n                        ;\n                        if (e[k] !== 0.0) {\n                            if (e[k + 1] < 0.0) {\n                                e[k] = -e[k];\n                            }\n                            for(var _i6 = k + 1; _i6 < this.n; _i6++){\n                                e[_i6] /= e[k];\n                            }\n                            ;\n                            e[k + 1] += 1.0;\n                        }\n                        e[k] = -e[k];\n                        if (function(lhs, rhs) {\n                            return lhs && rhs;\n                        }(k + 1 < this.m, e[k] !== 0.0)) {\n                            for(var _i7 = k + 1; _i7 < this.m; _i7++){\n                                work[_i7] = 0.0;\n                            }\n                            ;\n                            for(var _j = k + 1; _j < this.n; _j++){\n                                for(var _i8 = k + 1; _i8 < this.m; _i8++){\n                                    work[_i8] += e[_j] * A[_i8][_j];\n                                }\n                                ;\n                            }\n                            ;\n                            for(var _j2 = k + 1; _j2 < this.n; _j2++){\n                                var _t = -e[_j2] / e[k + 1];\n                                for(var _i9 = k + 1; _i9 < this.m; _i9++){\n                                    A[_i9][_j2] += _t * work[_i9];\n                                }\n                                ;\n                            }\n                            ;\n                        }\n                        if (wantv) {\n                            for(var _i10 = k + 1; _i10 < this.n; _i10++){\n                                this.V[_i10][k] = e[_i10];\n                            }\n                            ;\n                        }\n                    }\n                }\n                ;\n                var p = Math.min(this.n, this.m + 1);\n                if (nct < this.n) {\n                    this.s[nct] = A[nct][nct];\n                }\n                if (this.m < p) {\n                    this.s[p - 1] = 0.0;\n                }\n                if (nrt + 1 < p) {\n                    e[nrt] = A[nrt][p - 1];\n                }\n                e[p - 1] = 0.0;\n                if (wantu) {\n                    for(var _j3 = nct; _j3 < nu; _j3++){\n                        for(var _i11 = 0; _i11 < this.m; _i11++){\n                            this.U[_i11][_j3] = 0.0;\n                        }\n                        ;\n                        this.U[_j3][_j3] = 1.0;\n                    }\n                    ;\n                    for(var _k = nct - 1; _k >= 0; _k--){\n                        if (this.s[_k] !== 0.0) {\n                            for(var _j4 = _k + 1; _j4 < nu; _j4++){\n                                var _t2 = 0;\n                                for(var _i12 = _k; _i12 < this.m; _i12++){\n                                    _t2 += this.U[_i12][_k] * this.U[_i12][_j4];\n                                }\n                                ;\n                                _t2 = -_t2 / this.U[_k][_k];\n                                for(var _i13 = _k; _i13 < this.m; _i13++){\n                                    this.U[_i13][_j4] += _t2 * this.U[_i13][_k];\n                                }\n                                ;\n                            }\n                            ;\n                            for(var _i14 = _k; _i14 < this.m; _i14++){\n                                this.U[_i14][_k] = -this.U[_i14][_k];\n                            }\n                            ;\n                            this.U[_k][_k] = 1.0 + this.U[_k][_k];\n                            for(var _i15 = 0; _i15 < _k - 1; _i15++){\n                                this.U[_i15][_k] = 0.0;\n                            }\n                            ;\n                        } else {\n                            for(var _i16 = 0; _i16 < this.m; _i16++){\n                                this.U[_i16][_k] = 0.0;\n                            }\n                            ;\n                            this.U[_k][_k] = 1.0;\n                        }\n                    }\n                    ;\n                }\n                if (wantv) {\n                    for(var _k2 = this.n - 1; _k2 >= 0; _k2--){\n                        if (function(lhs, rhs) {\n                            return lhs && rhs;\n                        }(_k2 < nrt, e[_k2] !== 0.0)) {\n                            for(var _j5 = _k2 + 1; _j5 < nu; _j5++){\n                                var _t3 = 0;\n                                for(var _i17 = _k2 + 1; _i17 < this.n; _i17++){\n                                    _t3 += this.V[_i17][_k2] * this.V[_i17][_j5];\n                                }\n                                ;\n                                _t3 = -_t3 / this.V[_k2 + 1][_k2];\n                                for(var _i18 = _k2 + 1; _i18 < this.n; _i18++){\n                                    this.V[_i18][_j5] += _t3 * this.V[_i18][_k2];\n                                }\n                                ;\n                            }\n                            ;\n                        }\n                        for(var _i19 = 0; _i19 < this.n; _i19++){\n                            this.V[_i19][_k2] = 0.0;\n                        }\n                        ;\n                        this.V[_k2][_k2] = 1.0;\n                    }\n                    ;\n                }\n                var pp = p - 1;\n                var iter = 0;\n                var eps = Math.pow(2.0, -52.0);\n                var tiny = Math.pow(2.0, -966.0);\n                while(p > 0){\n                    var _k3 = void 0;\n                    var kase = void 0;\n                    for(_k3 = p - 2; _k3 >= -1; _k3--){\n                        if (_k3 === -1) {\n                            break;\n                        }\n                        if (Math.abs(e[_k3]) <= tiny + eps * (Math.abs(this.s[_k3]) + Math.abs(this.s[_k3 + 1]))) {\n                            e[_k3] = 0.0;\n                            break;\n                        }\n                    }\n                    ;\n                    if (_k3 === p - 2) {\n                        kase = 4;\n                    } else {\n                        var ks = void 0;\n                        for(ks = p - 1; ks >= _k3; ks--){\n                            if (ks === _k3) {\n                                break;\n                            }\n                            var _t4 = (ks !== p ? Math.abs(e[ks]) : 0.0) + (ks !== _k3 + 1 ? Math.abs(e[ks - 1]) : 0.0);\n                            if (Math.abs(this.s[ks]) <= tiny + eps * _t4) {\n                                this.s[ks] = 0.0;\n                                break;\n                            }\n                        }\n                        ;\n                        if (ks === _k3) {\n                            kase = 3;\n                        } else if (ks === p - 1) {\n                            kase = 1;\n                        } else {\n                            kase = 2;\n                            _k3 = ks;\n                        }\n                    }\n                    _k3++;\n                    switch(kase){\n                        case 1:\n                            {\n                                var f = e[p - 2];\n                                e[p - 2] = 0.0;\n                                for(var _j6 = p - 2; _j6 >= _k3; _j6--){\n                                    var _t5 = SVD.hypot(this.s[_j6], f);\n                                    var cs = this.s[_j6] / _t5;\n                                    var sn = f / _t5;\n                                    this.s[_j6] = _t5;\n                                    if (_j6 !== _k3) {\n                                        f = -sn * e[_j6 - 1];\n                                        e[_j6 - 1] = cs * e[_j6 - 1];\n                                    }\n                                    if (wantv) {\n                                        for(var _i20 = 0; _i20 < this.n; _i20++){\n                                            _t5 = cs * this.V[_i20][_j6] + sn * this.V[_i20][p - 1];\n                                            this.V[_i20][p - 1] = -sn * this.V[_i20][_j6] + cs * this.V[_i20][p - 1];\n                                            this.V[_i20][_j6] = _t5;\n                                        }\n                                        ;\n                                    }\n                                }\n                                ;\n                            }\n                            ;\n                            break;\n                        case 2:\n                            {\n                                var _f = e[_k3 - 1];\n                                e[_k3 - 1] = 0.0;\n                                for(var _j7 = _k3; _j7 < p; _j7++){\n                                    var _t6 = SVD.hypot(this.s[_j7], _f);\n                                    var _cs = this.s[_j7] / _t6;\n                                    var _sn = _f / _t6;\n                                    this.s[_j7] = _t6;\n                                    _f = -_sn * e[_j7];\n                                    e[_j7] = _cs * e[_j7];\n                                    if (wantu) {\n                                        for(var _i21 = 0; _i21 < this.m; _i21++){\n                                            _t6 = _cs * this.U[_i21][_j7] + _sn * this.U[_i21][_k3 - 1];\n                                            this.U[_i21][_k3 - 1] = -_sn * this.U[_i21][_j7] + _cs * this.U[_i21][_k3 - 1];\n                                            this.U[_i21][_j7] = _t6;\n                                        }\n                                        ;\n                                    }\n                                }\n                                ;\n                            }\n                            ;\n                            break;\n                        case 3:\n                            {\n                                var scale = Math.max(Math.max(Math.max(Math.max(Math.abs(this.s[p - 1]), Math.abs(this.s[p - 2])), Math.abs(e[p - 2])), Math.abs(this.s[_k3])), Math.abs(e[_k3]));\n                                var sp = this.s[p - 1] / scale;\n                                var spm1 = this.s[p - 2] / scale;\n                                var epm1 = e[p - 2] / scale;\n                                var sk = this.s[_k3] / scale;\n                                var ek = e[_k3] / scale;\n                                var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n                                var c = sp * epm1 * (sp * epm1);\n                                var shift = 0.0;\n                                if (function(lhs, rhs) {\n                                    return lhs || rhs;\n                                }(b !== 0.0, c !== 0.0)) {\n                                    shift = Math.sqrt(b * b + c);\n                                    if (b < 0.0) {\n                                        shift = -shift;\n                                    }\n                                    shift = c / (b + shift);\n                                }\n                                var _f2 = (sk + sp) * (sk - sp) + shift;\n                                var g = sk * ek;\n                                for(var _j8 = _k3; _j8 < p - 1; _j8++){\n                                    var _t7 = SVD.hypot(_f2, g);\n                                    var _cs2 = _f2 / _t7;\n                                    var _sn2 = g / _t7;\n                                    if (_j8 !== _k3) {\n                                        e[_j8 - 1] = _t7;\n                                    }\n                                    _f2 = _cs2 * this.s[_j8] + _sn2 * e[_j8];\n                                    e[_j8] = _cs2 * e[_j8] - _sn2 * this.s[_j8];\n                                    g = _sn2 * this.s[_j8 + 1];\n                                    this.s[_j8 + 1] = _cs2 * this.s[_j8 + 1];\n                                    if (wantv) {\n                                        for(var _i22 = 0; _i22 < this.n; _i22++){\n                                            _t7 = _cs2 * this.V[_i22][_j8] + _sn2 * this.V[_i22][_j8 + 1];\n                                            this.V[_i22][_j8 + 1] = -_sn2 * this.V[_i22][_j8] + _cs2 * this.V[_i22][_j8 + 1];\n                                            this.V[_i22][_j8] = _t7;\n                                        }\n                                        ;\n                                    }\n                                    _t7 = SVD.hypot(_f2, g);\n                                    _cs2 = _f2 / _t7;\n                                    _sn2 = g / _t7;\n                                    this.s[_j8] = _t7;\n                                    _f2 = _cs2 * e[_j8] + _sn2 * this.s[_j8 + 1];\n                                    this.s[_j8 + 1] = -_sn2 * e[_j8] + _cs2 * this.s[_j8 + 1];\n                                    g = _sn2 * e[_j8 + 1];\n                                    e[_j8 + 1] = _cs2 * e[_j8 + 1];\n                                    if (wantu && _j8 < this.m - 1) {\n                                        for(var _i23 = 0; _i23 < this.m; _i23++){\n                                            _t7 = _cs2 * this.U[_i23][_j8] + _sn2 * this.U[_i23][_j8 + 1];\n                                            this.U[_i23][_j8 + 1] = -_sn2 * this.U[_i23][_j8] + _cs2 * this.U[_i23][_j8 + 1];\n                                            this.U[_i23][_j8] = _t7;\n                                        }\n                                        ;\n                                    }\n                                }\n                                ;\n                                e[p - 2] = _f2;\n                                iter = iter + 1;\n                            }\n                            ;\n                            break;\n                        case 4:\n                            {\n                                if (this.s[_k3] <= 0.0) {\n                                    this.s[_k3] = this.s[_k3] < 0.0 ? -this.s[_k3] : 0.0;\n                                    if (wantv) {\n                                        for(var _i24 = 0; _i24 <= pp; _i24++){\n                                            this.V[_i24][_k3] = -this.V[_i24][_k3];\n                                        }\n                                        ;\n                                    }\n                                }\n                                while(_k3 < pp){\n                                    if (this.s[_k3] >= this.s[_k3 + 1]) {\n                                        break;\n                                    }\n                                    var _t8 = this.s[_k3];\n                                    this.s[_k3] = this.s[_k3 + 1];\n                                    this.s[_k3 + 1] = _t8;\n                                    if (wantv && _k3 < this.n - 1) {\n                                        for(var _i25 = 0; _i25 < this.n; _i25++){\n                                            _t8 = this.V[_i25][_k3 + 1];\n                                            this.V[_i25][_k3 + 1] = this.V[_i25][_k3];\n                                            this.V[_i25][_k3] = _t8;\n                                        }\n                                        ;\n                                    }\n                                    if (wantu && _k3 < this.m - 1) {\n                                        for(var _i26 = 0; _i26 < this.m; _i26++){\n                                            _t8 = this.U[_i26][_k3 + 1];\n                                            this.U[_i26][_k3 + 1] = this.U[_i26][_k3];\n                                            this.U[_i26][_k3] = _t8;\n                                        }\n                                        ;\n                                    }\n                                    _k3++;\n                                }\n                                ;\n                                iter = 0;\n                                p--;\n                            }\n                            ;\n                            break;\n                    }\n                }\n                ;\n                var result = {\n                    U: this.U,\n                    V: this.V,\n                    S: this.s\n                };\n                return result;\n            };\n            // sqrt(a^2 + b^2) without under/overflow.\n            SVD.hypot = function(a, b) {\n                var r = void 0;\n                if (Math.abs(a) > Math.abs(b)) {\n                    r = b / a;\n                    r = Math.abs(a) * Math.sqrt(1 + r * r);\n                } else if (b != 0) {\n                    r = a / b;\n                    r = Math.abs(b) * Math.sqrt(1 + r * r);\n                } else {\n                    r = 0.0;\n                }\n                return r;\n            };\n            module1.exports = SVD;\n        /***/ },\n        /* 27 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            var _createClass = function() {\n                function defineProperties(target, props) {\n                    for(var i = 0; i < props.length; i++){\n                        var descriptor = props[i];\n                        descriptor.enumerable = descriptor.enumerable || false;\n                        descriptor.configurable = true;\n                        if (\"value\" in descriptor) descriptor.writable = true;\n                        Object.defineProperty(target, descriptor.key, descriptor);\n                    }\n                }\n                return function(Constructor, protoProps, staticProps) {\n                    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n                    if (staticProps) defineProperties(Constructor, staticProps);\n                    return Constructor;\n                };\n            }();\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            /**\n *   Needleman-Wunsch algorithm is an procedure to compute the optimal global alignment of two string\n *   sequences by S.B.Needleman and C.D.Wunsch (1970).\n *\n *   Aside from the inputs, you can assign the scores for,\n *   - Match: The two characters at the current index are same.\n *   - Mismatch: The two characters at the current index are different.\n *   - Insertion/Deletion(gaps): The best alignment involves one letter aligning to a gap in the other string.\n */ var NeedlemanWunsch = function() {\n                function NeedlemanWunsch(sequence1, sequence2) {\n                    var match_score = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n                    var mismatch_penalty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n                    var gap_penalty = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;\n                    _classCallCheck(this, NeedlemanWunsch);\n                    this.sequence1 = sequence1;\n                    this.sequence2 = sequence2;\n                    this.match_score = match_score;\n                    this.mismatch_penalty = mismatch_penalty;\n                    this.gap_penalty = gap_penalty;\n                    // Just the remove redundancy\n                    this.iMax = sequence1.length + 1;\n                    this.jMax = sequence2.length + 1;\n                    // Grid matrix of scores\n                    this.grid = new Array(this.iMax);\n                    for(var i = 0; i < this.iMax; i++){\n                        this.grid[i] = new Array(this.jMax);\n                        for(var j = 0; j < this.jMax; j++){\n                            this.grid[i][j] = 0;\n                        }\n                    }\n                    // Traceback matrix (2D array, each cell is an array of boolean values for [`Diag`, `Up`, `Left`] positions)\n                    this.tracebackGrid = new Array(this.iMax);\n                    for(var _i = 0; _i < this.iMax; _i++){\n                        this.tracebackGrid[_i] = new Array(this.jMax);\n                        for(var _j = 0; _j < this.jMax; _j++){\n                            this.tracebackGrid[_i][_j] = [\n                                null,\n                                null,\n                                null\n                            ];\n                        }\n                    }\n                    // The aligned sequences (return multiple possibilities)\n                    this.alignments = [];\n                    // Final alignment score\n                    this.score = -1;\n                    // Calculate scores and tracebacks\n                    this.computeGrids();\n                }\n                _createClass(NeedlemanWunsch, [\n                    {\n                        key: \"getScore\",\n                        value: function getScore() {\n                            return this.score;\n                        }\n                    },\n                    {\n                        key: \"getAlignments\",\n                        value: function getAlignments() {\n                            return this.alignments;\n                        }\n                    },\n                    {\n                        key: \"computeGrids\",\n                        value: function computeGrids() {\n                            // Fill in the first row\n                            for(var j = 1; j < this.jMax; j++){\n                                this.grid[0][j] = this.grid[0][j - 1] + this.gap_penalty;\n                                this.tracebackGrid[0][j] = [\n                                    false,\n                                    false,\n                                    true\n                                ];\n                            }\n                            // Fill in the first column\n                            for(var i = 1; i < this.iMax; i++){\n                                this.grid[i][0] = this.grid[i - 1][0] + this.gap_penalty;\n                                this.tracebackGrid[i][0] = [\n                                    false,\n                                    true,\n                                    false\n                                ];\n                            }\n                            // Fill the rest of the grid\n                            for(var _i2 = 1; _i2 < this.iMax; _i2++){\n                                for(var _j2 = 1; _j2 < this.jMax; _j2++){\n                                    // Find the max score(s) among [`Diag`, `Up`, `Left`]\n                                    var diag = void 0;\n                                    if (this.sequence1[_i2 - 1] === this.sequence2[_j2 - 1]) diag = this.grid[_i2 - 1][_j2 - 1] + this.match_score;\n                                    else diag = this.grid[_i2 - 1][_j2 - 1] + this.mismatch_penalty;\n                                    var up = this.grid[_i2 - 1][_j2] + this.gap_penalty;\n                                    var left = this.grid[_i2][_j2 - 1] + this.gap_penalty;\n                                    // If there exists multiple max values, capture them for multiple paths\n                                    var maxOf = [\n                                        diag,\n                                        up,\n                                        left\n                                    ];\n                                    var indices = this.arrayAllMaxIndexes(maxOf);\n                                    // Update Grids\n                                    this.grid[_i2][_j2] = maxOf[indices[0]];\n                                    this.tracebackGrid[_i2][_j2] = [\n                                        indices.includes(0),\n                                        indices.includes(1),\n                                        indices.includes(2)\n                                    ];\n                                }\n                            }\n                            // Update alignment score\n                            this.score = this.grid[this.iMax - 1][this.jMax - 1];\n                        }\n                    },\n                    {\n                        key: \"alignmentTraceback\",\n                        value: function alignmentTraceback() {\n                            var inProcessAlignments = [];\n                            inProcessAlignments.push({\n                                pos: [\n                                    this.sequence1.length,\n                                    this.sequence2.length\n                                ],\n                                seq1: \"\",\n                                seq2: \"\"\n                            });\n                            while(inProcessAlignments[0]){\n                                var current = inProcessAlignments[0];\n                                var directions = this.tracebackGrid[current.pos[0]][current.pos[1]];\n                                if (directions[0]) {\n                                    inProcessAlignments.push({\n                                        pos: [\n                                            current.pos[0] - 1,\n                                            current.pos[1] - 1\n                                        ],\n                                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                                    });\n                                }\n                                if (directions[1]) {\n                                    inProcessAlignments.push({\n                                        pos: [\n                                            current.pos[0] - 1,\n                                            current.pos[1]\n                                        ],\n                                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                                        seq2: \"-\" + current.seq2\n                                    });\n                                }\n                                if (directions[2]) {\n                                    inProcessAlignments.push({\n                                        pos: [\n                                            current.pos[0],\n                                            current.pos[1] - 1\n                                        ],\n                                        seq1: \"-\" + current.seq1,\n                                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                                    });\n                                }\n                                if (current.pos[0] === 0 && current.pos[1] === 0) this.alignments.push({\n                                    sequence1: current.seq1,\n                                    sequence2: current.seq2\n                                });\n                                inProcessAlignments.shift();\n                            }\n                            return this.alignments;\n                        }\n                    },\n                    {\n                        key: \"getAllIndexes\",\n                        value: function getAllIndexes(arr, val) {\n                            var indexes = [], i = -1;\n                            while((i = arr.indexOf(val, i + 1)) !== -1){\n                                indexes.push(i);\n                            }\n                            return indexes;\n                        }\n                    },\n                    {\n                        key: \"arrayAllMaxIndexes\",\n                        value: function arrayAllMaxIndexes(array) {\n                            return this.getAllIndexes(array, Math.max.apply(null, array));\n                        }\n                    }\n                ]);\n                return NeedlemanWunsch;\n            }();\n            module1.exports = NeedlemanWunsch;\n        /***/ },\n        /* 28 */ /***/ function(module1, exports1, __nested_webpack_require_206004__) {\n            \"use strict\";\n            var layoutBase = function layoutBase() {\n                return;\n            };\n            layoutBase.FDLayout = __nested_webpack_require_206004__(18);\n            layoutBase.FDLayoutConstants = __nested_webpack_require_206004__(4);\n            layoutBase.FDLayoutEdge = __nested_webpack_require_206004__(19);\n            layoutBase.FDLayoutNode = __nested_webpack_require_206004__(20);\n            layoutBase.DimensionD = __nested_webpack_require_206004__(21);\n            layoutBase.HashMap = __nested_webpack_require_206004__(22);\n            layoutBase.HashSet = __nested_webpack_require_206004__(23);\n            layoutBase.IGeometry = __nested_webpack_require_206004__(8);\n            layoutBase.IMath = __nested_webpack_require_206004__(9);\n            layoutBase.Integer = __nested_webpack_require_206004__(10);\n            layoutBase.Point = __nested_webpack_require_206004__(12);\n            layoutBase.PointD = __nested_webpack_require_206004__(5);\n            layoutBase.RandomSeed = __nested_webpack_require_206004__(16);\n            layoutBase.RectangleD = __nested_webpack_require_206004__(13);\n            layoutBase.Transform = __nested_webpack_require_206004__(17);\n            layoutBase.UniqueIDGeneretor = __nested_webpack_require_206004__(14);\n            layoutBase.Quicksort = __nested_webpack_require_206004__(25);\n            layoutBase.LinkedList = __nested_webpack_require_206004__(11);\n            layoutBase.LGraphObject = __nested_webpack_require_206004__(2);\n            layoutBase.LGraph = __nested_webpack_require_206004__(6);\n            layoutBase.LEdge = __nested_webpack_require_206004__(1);\n            layoutBase.LGraphManager = __nested_webpack_require_206004__(7);\n            layoutBase.LNode = __nested_webpack_require_206004__(3);\n            layoutBase.Layout = __nested_webpack_require_206004__(15);\n            layoutBase.LayoutConstants = __nested_webpack_require_206004__(0);\n            layoutBase.NeedlemanWunsch = __nested_webpack_require_206004__(27);\n            layoutBase.Matrix = __nested_webpack_require_206004__(24);\n            layoutBase.SVD = __nested_webpack_require_206004__(26);\n            module1.exports = layoutBase;\n        /***/ },\n        /* 29 */ /***/ function(module1, exports1, __webpack_require__) {\n            \"use strict\";\n            function Emitter() {\n                this.listeners = [];\n            }\n            var p = Emitter.prototype;\n            p.addListener = function(event, callback) {\n                this.listeners.push({\n                    event: event,\n                    callback: callback\n                });\n            };\n            p.removeListener = function(event, callback) {\n                for(var i = this.listeners.length; i >= 0; i--){\n                    var l = this.listeners[i];\n                    if (l.event === event && l.callback === callback) {\n                        this.listeners.splice(i, 1);\n                    }\n                }\n            };\n            p.emit = function(event, data) {\n                for(var i = 0; i < this.listeners.length; i++){\n                    var l = this.listeners[i];\n                    if (event === l.event) {\n                        l.callback(data);\n                    }\n                }\n            };\n            module1.exports = Emitter;\n        /***/ }\n    ]);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlLWZjb3NlL25vZGVfbW9kdWxlcy9sYXlvdXQtYmFzZS9sYXlvdXQtYmFzZS5qcyIsIm1hcHBpbmdzIjoiO0FBQUMsVUFBU0EsaUNBQWlDQyxJQUFJLEVBQUVDLE9BQU87SUFDdkQsSUFBRyxJQUFpRCxFQUNuREUsT0FBT0QsT0FBTyxHQUFHRDtTQUNiLEVBSzJCQTtBQUNqQyxHQUFHLFFBQU07SUFDVCxPQUFnQixNQUFILEdBQUksU0FBU0ssT0FBTztRQUNqQyxNQUFNLEdBQUksbUJBQW1CO1FBQzdCLE1BQU0sR0FBSSxJQUFJQyxtQkFBbUIsQ0FBQztRQUNsQyxNQUFNLEdBQ04sTUFBTSxHQUFJLHVCQUF1QjtRQUNqQyxNQUFNLEdBQUksU0FBU0MsOEJBQW1CQSxDQUFDQyxRQUFRO1lBQy9DLE1BQU0sR0FDTixNQUFNLEdBQUssOEJBQThCO1lBQ3pDLE1BQU0sR0FBSyxJQUFHRixnQkFBZ0IsQ0FBQ0UsU0FBUyxFQUFFO2dCQUMxQyxNQUFNLEdBQU0sT0FBT0YsZ0JBQWdCLENBQUNFLFNBQVMsQ0FBQ1AsT0FBTztZQUNyRCxNQUFNLEdBQUs7WUFDWCxNQUFNLEdBQUssa0RBQWtEO1lBQzdELE1BQU0sR0FBSyxJQUFJQyxVQUFTSSxnQkFBZ0IsQ0FBQ0UsU0FBUyxHQUFHO2dCQUNyRCxNQUFNLEdBQU1DLEdBQUdEO2dCQUNmLE1BQU0sR0FBTUUsR0FBRztnQkFDZixNQUFNLEdBQU1ULFNBQVMsQ0FBQztZQUNYO1lBQ1gsTUFBTSxHQUNOLE1BQU0sR0FBSyw4QkFBOEI7WUFDekMsTUFBTSxHQUFLSSxPQUFPLENBQUNHLFNBQVMsQ0FBQ0csSUFBSSxDQUFDVCxRQUFPRCxPQUFPLEVBQUVDLFNBQVFBLFFBQU9ELE9BQU8sRUFBRU0sOEJBQW1CQTtZQUM3RixNQUFNLEdBQ04sTUFBTSxHQUFLLDRCQUE0QjtZQUN2QyxNQUFNLEdBQUtMLFFBQU9RLENBQUMsR0FBRztZQUN0QixNQUFNLEdBQ04sTUFBTSxHQUFLLG1D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QUksQ0FBQ0gsU0FBUyxDQUFDbGxCLE1BQU0sQ0FBQzNPLEdBQUc7b0JBQzNCO2dCQUNGO1lBQ0Y7WUFFQXVCLEVBQUUyeUIsSUFBSSxHQUFHLFNBQVVILEtBQUssRUFBRUksSUFBSTtnQkFDNUIsSUFBSyxJQUFJbjBCLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUM2ekIsU0FBUyxDQUFDbHdCLE1BQU0sRUFBRTNELElBQUs7b0JBQzlDLElBQUlDLElBQUksSUFBSSxDQUFDNHpCLFNBQVMsQ0FBQzd6QixFQUFFO29CQUV6QixJQUFJK3pCLFVBQVU5ekIsRUFBRTh6QixLQUFLLEVBQUU7d0JBQ3JCOXpCLEVBQUUrekIsUUFBUSxDQUFDRztvQkFDYjtnQkFDRjtZQUNGO1lBRUExMEIsUUFBT0QsT0FBTyxHQUFHNmQ7UUFFakIsR0FBRyxHQUFHO0tBQ0k7QUFDViIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLXBtLWFnZW50LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2N5dG9zY2FwZS1mY29zZS9ub2RlX21vZHVsZXMvbGF5b3V0LWJhc2UvbGF5b3V0LWJhc2UuanM/YTM5MiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJsYXlvdXRCYXNlXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImxheW91dEJhc2VcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAyOCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIExheW91dENvbnN0YW50cygpIHt9XG5cbi8qKlxyXG4gKiBMYXlvdXQgUXVhbGl0eTogMDpkcmFmdCwgMTpkZWZhdWx0LCAyOnByb29mXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLlFVQUxJVFkgPSAxO1xuXG4vKipcclxuICogRGVmYXVsdCBwYXJhbWV0ZXJzXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ1JFQVRFX0JFTkRTX0FTX05FRURFRCA9IGZhbHNlO1xuTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfSU5DUkVNRU5UQUwgPSBmYWxzZTtcbkxheW91dENvbnN0YW50cy5ERUZBVUxUX0FOSU1BVElPTl9PTl9MQVlPVVQgPSB0cnVlO1xuTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX0RVUklOR19MQVlPVVQgPSBmYWxzZTtcbkxheW91dENvbnN0YW50cy5ERUZBVUxUX0FOSU1BVElPTl9QRVJJT0QgPSA1MDtcbkxheW91dENvbnN0YW50cy5ERUZBVUxUX1VOSUZPUk1fTEVBRl9OT0RFX1NJWkVTID0gZmFsc2U7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBTZWN0aW9uOiBHZW5lcmFsIG90aGVyIGNvbnN0YW50c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qXHJcbiAqIE1hcmdpbnMgb2YgYSBncmFwaCB0byBiZSBhcHBsaWVkIG9uIGJvdWRpbmcgcmVjdGFuZ2xlIG9mIGl0cyBjb250ZW50cy4gV2VcclxuICogYXNzdW1lIG1hcmdpbnMgb24gYWxsIGZvdXIgc2lkZXMgdG8gYmUgdW5pZm9ybS5cclxuICovXG5MYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFQSF9NQVJHSU4gPSAxNTtcblxuLypcclxuICogV2hldGhlciB0byBjb25zaWRlciBsYWJlbHMgaW4gbm9kZSBkaW1lbnNpb25zIG9yIG5vdFxyXG4gKi9cbkxheW91dENvbnN0YW50cy5OT0RFX0RJTUVOU0lPTlNfSU5DTFVERV9MQUJFTFMgPSBmYWxzZTtcblxuLypcclxuICogRGVmYXVsdCBkaW1lbnNpb24gb2YgYSBub24tY29tcG91bmQgbm9kZS5cclxuICovXG5MYXlvdXRDb25zdGFudHMuU0lNUExFX05PREVfU0laRSA9IDQwO1xuXG4vKlxyXG4gKiBEZWZhdWx0IGRpbWVuc2lvbiBvZiBhIG5vbi1jb21wb3VuZCBub2RlLlxyXG4gKi9cbkxheW91dENvbnN0YW50cy5TSU1QTEVfTk9ERV9IQUxGX1NJWkUgPSBMYXlvdXRDb25zdGFudHMuU0lNUExFX05PREVfU0laRSAvIDI7XG5cbi8qXHJcbiAqIEVtcHR5IGNvbXBvdW5kIG5vZGUgc2l6ZS4gV2hlbiBhIGNvbXBvdW5kIG5vZGUgaXMgZW1wdHksIGl0cyBib3RoXHJcbiAqIGRpbWVuc2lvbnMgc2hvdWxkIGJlIG9mIHRoaXMgdmFsdWUuXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLkVNUFRZX0NPTVBPVU5EX05PREVfU0laRSA9IDQwO1xuXG4vKlxyXG4gKiBNaW5pbXVtIGxlbmd0aCB0aGF0IGFuIGVkZ2Ugc2hvdWxkIHRha2UgZHVyaW5nIGxheW91dFxyXG4gKi9cbkxheW91dENvbnN0YW50cy5NSU5fRURHRV9MRU5HVEggPSAxO1xuXG4vKlxyXG4gKiBXb3JsZCBib3VuZGFyaWVzIHRoYXQgbGF5b3V0IG9wZXJhdGVzIG9uXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZID0gMTAwMDAwMDtcblxuLypcclxuICogV29ybGQgYm91bmRhcmllcyB0aGF0IHJhbmRvbSBwb3NpdGlvbmluZyBjYW4gYmUgcGVyZm9ybWVkIHdpdGhcclxuICovXG5MYXlvdXRDb25zdGFudHMuSU5JVElBTF9XT1JMRF9CT1VOREFSWSA9IExheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWSAvIDEwMDA7XG5cbi8qXHJcbiAqIENvb3JkaW5hdGVzIG9mIHRoZSB3b3JsZCBjZW50ZXJcclxuICovXG5MYXlvdXRDb25zdGFudHMuV09STERfQ0VOVEVSX1ggPSAxMjAwO1xuTGF5b3V0Q29uc3RhbnRzLldPUkxEX0NFTlRFUl9ZID0gOTAwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExheW91dENvbnN0YW50cztcblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBMR3JhcGhPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIElHZW9tZXRyeSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG52YXIgSU1hdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG5mdW5jdGlvbiBMRWRnZShzb3VyY2UsIHRhcmdldCwgdkVkZ2UpIHtcbiAgTEdyYXBoT2JqZWN0LmNhbGwodGhpcywgdkVkZ2UpO1xuXG4gIHRoaXMuaXNPdmVybGFwaW5nU291cmNlQW5kVGFyZ2V0ID0gZmFsc2U7XG4gIHRoaXMudkdyYXBoT2JqZWN0ID0gdkVkZ2U7XG4gIHRoaXMuYmVuZHBvaW50cyA9IFtdO1xuICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG59XG5cbkxFZGdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTEdyYXBoT2JqZWN0LnByb3RvdHlwZSk7XG5cbmZvciAodmFyIHByb3AgaW4gTEdyYXBoT2JqZWN0KSB7XG4gIExFZGdlW3Byb3BdID0gTEdyYXBoT2JqZWN0W3Byb3BdO1xufVxuXG5MRWRnZS5wcm90b3R5cGUuZ2V0U291cmNlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zb3VyY2U7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy50YXJnZXQ7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuaXNJbnRlckdyYXBoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5pc0ludGVyR3JhcGg7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sZW5ndGg7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuaXNPdmVybGFwaW5nU291cmNlQW5kVGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5pc092ZXJsYXBpbmdTb3VyY2VBbmRUYXJnZXQ7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuZ2V0QmVuZHBvaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuYmVuZHBvaW50cztcbn07XG5cbkxFZGdlLnByb3RvdHlwZS5nZXRMY2EgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxjYTtcbn07XG5cbkxFZGdlLnByb3RvdHlwZS5nZXRTb3VyY2VJbkxjYSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc291cmNlSW5MY2E7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuZ2V0VGFyZ2V0SW5MY2EgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnRhcmdldEluTGNhO1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmdldE90aGVyRW5kID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKHRoaXMuc291cmNlID09PSBub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMudGFyZ2V0O1xuICB9IGVsc2UgaWYgKHRoaXMudGFyZ2V0ID09PSBub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IFwiTm9kZSBpcyBub3QgaW5jaWRlbnQgd2l0aCB0aGlzIGVkZ2VcIjtcbiAgfVxufTtcblxuTEVkZ2UucHJvdG90eXBlLmdldE90aGVyRW5kSW5HcmFwaCA9IGZ1bmN0aW9uIChub2RlLCBncmFwaCkge1xuICB2YXIgb3RoZXJFbmQgPSB0aGlzLmdldE90aGVyRW5kKG5vZGUpO1xuICB2YXIgcm9vdCA9IGdyYXBoLmdldEdyYXBoTWFuYWdlcigpLmdldFJvb3QoKTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChvdGhlckVuZC5nZXRPd25lcigpID09IGdyYXBoKSB7XG4gICAgICByZXR1cm4gb3RoZXJFbmQ7XG4gICAgfVxuXG4gICAgaWYgKG90aGVyRW5kLmdldE93bmVyKCkgPT0gcm9vdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgb3RoZXJFbmQgPSBvdGhlckVuZC5nZXRPd25lcigpLmdldFBhcmVudCgpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUudXBkYXRlTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2xpcFBvaW50Q29vcmRpbmF0ZXMgPSBuZXcgQXJyYXkoNCk7XG5cbiAgdGhpcy5pc092ZXJsYXBpbmdTb3VyY2VBbmRUYXJnZXQgPSBJR2VvbWV0cnkuZ2V0SW50ZXJzZWN0aW9uKHRoaXMudGFyZ2V0LmdldFJlY3QoKSwgdGhpcy5zb3VyY2UuZ2V0UmVjdCgpLCBjbGlwUG9pbnRDb29yZGluYXRlcyk7XG5cbiAgaWYgKCF0aGlzLmlzT3ZlcmxhcGluZ1NvdXJjZUFuZFRhcmdldCkge1xuICAgIHRoaXMubGVuZ3RoWCA9IGNsaXBQb2ludENvb3JkaW5hdGVzWzBdIC0gY2xpcFBvaW50Q29vcmRpbmF0ZXNbMl07XG4gICAgdGhpcy5sZW5ndGhZID0gY2xpcFBvaW50Q29vcmRpbmF0ZXNbMV0gLSBjbGlwUG9pbnRDb29yZGluYXRlc1szXTtcblxuICAgIGlmIChNYXRoLmFicyh0aGlzLmxlbmd0aFgpIDwgMS4wKSB7XG4gICAgICB0aGlzLmxlbmd0aFggPSBJTWF0aC5zaWduKHRoaXMubGVuZ3RoWCk7XG4gICAgfVxuXG4gICAgaWYgKE1hdGguYWJzKHRoaXMubGVuZ3RoWSkgPCAxLjApIHtcbiAgICAgIHRoaXMubGVuZ3RoWSA9IElNYXRoLnNpZ24odGhpcy5sZW5ndGhZKTtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGguc3FydCh0aGlzLmxlbmd0aFggKiB0aGlzLmxlbmd0aFggKyB0aGlzLmxlbmd0aFkgKiB0aGlzLmxlbmd0aFkpO1xuICB9XG59O1xuXG5MRWRnZS5wcm90b3R5cGUudXBkYXRlTGVuZ3RoU2ltcGxlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxlbmd0aFggPSB0aGlzLnRhcmdldC5nZXRDZW50ZXJYKCkgLSB0aGlzLnNvdXJjZS5nZXRDZW50ZXJYKCk7XG4gIHRoaXMubGVuZ3RoWSA9IHRoaXMudGFyZ2V0LmdldENlbnRlclkoKSAtIHRoaXMuc291cmNlLmdldENlbnRlclkoKTtcblxuICBpZiAoTWF0aC5hYnModGhpcy5sZW5ndGhYKSA8IDEuMCkge1xuICAgIHRoaXMubGVuZ3RoWCA9IElNYXRoLnNpZ24odGhpcy5sZW5ndGhYKTtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyh0aGlzLmxlbmd0aFkpIDwgMS4wKSB7XG4gICAgdGhpcy5sZW5ndGhZID0gSU1hdGguc2lnbih0aGlzLmxlbmd0aFkpO1xuICB9XG5cbiAgdGhpcy5sZW5ndGggPSBNYXRoLnNxcnQodGhpcy5sZW5ndGhYICogdGhpcy5sZW5ndGhYICsgdGhpcy5sZW5ndGhZICogdGhpcy5sZW5ndGhZKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTEVkZ2U7XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBMR3JhcGhPYmplY3QodkdyYXBoT2JqZWN0KSB7XG4gIHRoaXMudkdyYXBoT2JqZWN0ID0gdkdyYXBoT2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExHcmFwaE9iamVjdDtcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBMR3JhcGhPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIEludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbnZhciBSZWN0YW5nbGVEID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG52YXIgTGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBSYW5kb21TZWVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG52YXIgUG9pbnREID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxuZnVuY3Rpb24gTE5vZGUoZ20sIGxvYywgc2l6ZSwgdk5vZGUpIHtcbiAgLy9BbHRlcm5hdGl2ZSBjb25zdHJ1Y3RvciAxIDogTE5vZGUoTEdyYXBoTWFuYWdlciBnbSwgUG9pbnQgbG9jLCBEaW1lbnNpb24gc2l6ZSwgT2JqZWN0IHZOb2RlKVxuICBpZiAoc2l6ZSA9PSBudWxsICYmIHZOb2RlID09IG51bGwpIHtcbiAgICB2Tm9kZSA9IGxvYztcbiAgfVxuXG4gIExHcmFwaE9iamVjdC5jYWxsKHRoaXMsIHZOb2RlKTtcblxuICAvL0FsdGVybmF0aXZlIGNvbnN0cnVjdG9yIDIgOiBMTm9kZShMYXlvdXQgbGF5b3V0LCBPYmplY3Qgdk5vZGUpXG4gIGlmIChnbS5ncmFwaE1hbmFnZXIgIT0gbnVsbCkgZ20gPSBnbS5ncmFwaE1hbmFnZXI7XG5cbiAgdGhpcy5lc3RpbWF0ZWRTaXplID0gSW50ZWdlci5NSU5fVkFMVUU7XG4gIHRoaXMuaW5jbHVzaW9uVHJlZURlcHRoID0gSW50ZWdlci5NQVhfVkFMVUU7XG4gIHRoaXMudkdyYXBoT2JqZWN0ID0gdk5vZGU7XG4gIHRoaXMuZWRnZXMgPSBbXTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIgPSBnbTtcblxuICBpZiAoc2l6ZSAhPSBudWxsICYmIGxvYyAhPSBudWxsKSB0aGlzLnJlY3QgPSBuZXcgUmVjdGFuZ2xlRChsb2MueCwgbG9jLnksIHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtlbHNlIHRoaXMucmVjdCA9IG5ldyBSZWN0YW5nbGVEKCk7XG59XG5cbkxOb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTEdyYXBoT2JqZWN0LnByb3RvdHlwZSk7XG5mb3IgKHZhciBwcm9wIGluIExHcmFwaE9iamVjdCkge1xuICBMTm9kZVtwcm9wXSA9IExHcmFwaE9iamVjdFtwcm9wXTtcbn1cblxuTE5vZGUucHJvdG90eXBlLmdldEVkZ2VzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5lZGdlcztcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRDaGlsZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2hpbGQ7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0T3duZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8vICBpZiAodGhpcy5vd25lciAhPSBudWxsKSB7XG4gIC8vICAgIGlmICghKHRoaXMub3duZXIgPT0gbnVsbCB8fCB0aGlzLm93bmVyLmdldE5vZGVzKCkuaW5kZXhPZih0aGlzKSA+IC0xKSkge1xuICAvLyAgICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICAvLyAgICB9XG4gIC8vICB9XG5cbiAgcmV0dXJuIHRoaXMub3duZXI7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlY3Qud2lkdGg7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuc2V0V2lkdGggPSBmdW5jdGlvbiAod2lkdGgpIHtcbiAgdGhpcy5yZWN0LndpZHRoID0gd2lkdGg7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWN0LmhlaWdodDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5zZXRIZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0KSB7XG4gIHRoaXMucmVjdC5oZWlnaHQgPSBoZWlnaHQ7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0Q2VudGVyWCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC54ICsgdGhpcy5yZWN0LndpZHRoIC8gMjtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRDZW50ZXJZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWN0LnkgKyB0aGlzLnJlY3QuaGVpZ2h0IC8gMjtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRDZW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgUG9pbnREKHRoaXMucmVjdC54ICsgdGhpcy5yZWN0LndpZHRoIC8gMiwgdGhpcy5yZWN0LnkgKyB0aGlzLnJlY3QuaGVpZ2h0IC8gMik7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0TG9jYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgUG9pbnREKHRoaXMucmVjdC54LCB0aGlzLnJlY3QueSk7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0UmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXREaWFnb25hbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE1hdGguc3FydCh0aGlzLnJlY3Qud2lkdGggKiB0aGlzLnJlY3Qud2lkdGggKyB0aGlzLnJlY3QuaGVpZ2h0ICogdGhpcy5yZWN0LmhlaWdodCk7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgaGFsZiB0aGUgZGlhZ29uYWwgbGVuZ3RoIG9mIHRoaXMgbm9kZS5cbiAqL1xuTE5vZGUucHJvdG90eXBlLmdldEhhbGZUaGVEaWFnb25hbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE1hdGguc3FydCh0aGlzLnJlY3QuaGVpZ2h0ICogdGhpcy5yZWN0LmhlaWdodCArIHRoaXMucmVjdC53aWR0aCAqIHRoaXMucmVjdC53aWR0aCkgLyAyO1xufTtcblxuTE5vZGUucHJvdG90eXBlLnNldFJlY3QgPSBmdW5jdGlvbiAodXBwZXJMZWZ0LCBkaW1lbnNpb24pIHtcbiAgdGhpcy5yZWN0LnggPSB1cHBlckxlZnQueDtcbiAgdGhpcy5yZWN0LnkgPSB1cHBlckxlZnQueTtcbiAgdGhpcy5yZWN0LndpZHRoID0gZGltZW5zaW9uLndpZHRoO1xuICB0aGlzLnJlY3QuaGVpZ2h0ID0gZGltZW5zaW9uLmhlaWdodDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5zZXRDZW50ZXIgPSBmdW5jdGlvbiAoY3gsIGN5KSB7XG4gIHRoaXMucmVjdC54ID0gY3ggLSB0aGlzLnJlY3Qud2lkdGggLyAyO1xuICB0aGlzLnJlY3QueSA9IGN5IC0gdGhpcy5yZWN0LmhlaWdodCAvIDI7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuc2V0TG9jYXRpb24gPSBmdW5jdGlvbiAoeCwgeSkge1xuICB0aGlzLnJlY3QueCA9IHg7XG4gIHRoaXMucmVjdC55ID0geTtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5tb3ZlQnkgPSBmdW5jdGlvbiAoZHgsIGR5KSB7XG4gIHRoaXMucmVjdC54ICs9IGR4O1xuICB0aGlzLnJlY3QueSArPSBkeTtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRFZGdlTGlzdFRvTm9kZSA9IGZ1bmN0aW9uICh0bykge1xuICB2YXIgZWRnZUxpc3QgPSBbXTtcbiAgdmFyIGVkZ2U7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBzZWxmLmVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcblxuICAgIGlmIChlZGdlLnRhcmdldCA9PSB0bykge1xuICAgICAgaWYgKGVkZ2Uuc291cmNlICE9IHNlbGYpIHRocm93IFwiSW5jb3JyZWN0IGVkZ2Ugc291cmNlIVwiO1xuXG4gICAgICBlZGdlTGlzdC5wdXNoKGVkZ2UpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGVkZ2VMaXN0O1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldEVkZ2VzQmV0d2VlbiA9IGZ1bmN0aW9uIChvdGhlcikge1xuICB2YXIgZWRnZUxpc3QgPSBbXTtcbiAgdmFyIGVkZ2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLmVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcblxuICAgIGlmICghKGVkZ2Uuc291cmNlID09IHNlbGYgfHwgZWRnZS50YXJnZXQgPT0gc2VsZikpIHRocm93IFwiSW5jb3JyZWN0IGVkZ2Ugc291cmNlIGFuZC9vciB0YXJnZXRcIjtcblxuICAgIGlmIChlZGdlLnRhcmdldCA9PSBvdGhlciB8fCBlZGdlLnNvdXJjZSA9PSBvdGhlcikge1xuICAgICAgZWRnZUxpc3QucHVzaChlZGdlKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBlZGdlTGlzdDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXROZWlnaGJvcnNMaXN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbmVpZ2hib3JzID0gbmV3IFNldCgpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5lZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG5cbiAgICBpZiAoZWRnZS5zb3VyY2UgPT0gc2VsZikge1xuICAgICAgbmVpZ2hib3JzLmFkZChlZGdlLnRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChlZGdlLnRhcmdldCAhPSBzZWxmKSB7XG4gICAgICAgIHRocm93IFwiSW5jb3JyZWN0IGluY2lkZW5jeSFcIjtcbiAgICAgIH1cblxuICAgICAgbmVpZ2hib3JzLmFkZChlZGdlLnNvdXJjZSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gbmVpZ2hib3JzO1xufTtcblxuTE5vZGUucHJvdG90eXBlLndpdGhDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHdpdGhOZWlnaGJvcnNMaXN0ID0gbmV3IFNldCgpO1xuICB2YXIgY2hpbGROb2RlO1xuICB2YXIgY2hpbGRyZW47XG5cbiAgd2l0aE5laWdoYm9yc0xpc3QuYWRkKHRoaXMpO1xuXG4gIGlmICh0aGlzLmNoaWxkICE9IG51bGwpIHtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLmNoaWxkLmdldE5vZGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGROb2RlID0gbm9kZXNbaV07XG4gICAgICBjaGlsZHJlbiA9IGNoaWxkTm9kZS53aXRoQ2hpbGRyZW4oKTtcbiAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgd2l0aE5laWdoYm9yc0xpc3QuYWRkKG5vZGUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdpdGhOZWlnaGJvcnNMaXN0O1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldE5vT2ZDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vT2ZDaGlsZHJlbiA9IDA7XG4gIHZhciBjaGlsZE5vZGU7XG5cbiAgaWYgKHRoaXMuY2hpbGQgPT0gbnVsbCkge1xuICAgIG5vT2ZDaGlsZHJlbiA9IDE7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5jaGlsZC5nZXROb2RlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkTm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgICBub09mQ2hpbGRyZW4gKz0gY2hpbGROb2RlLmdldE5vT2ZDaGlsZHJlbigpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChub09mQ2hpbGRyZW4gPT0gMCkge1xuICAgIG5vT2ZDaGlsZHJlbiA9IDE7XG4gIH1cbiAgcmV0dXJuIG5vT2ZDaGlsZHJlbjtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRFc3RpbWF0ZWRTaXplID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5lc3RpbWF0ZWRTaXplID09IEludGVnZXIuTUlOX1ZBTFVFKSB7XG4gICAgdGhyb3cgXCJhc3NlcnQgZmFpbGVkXCI7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZXN0aW1hdGVkU2l6ZTtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5jYWxjRXN0aW1hdGVkU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY2hpbGQgPT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLmVzdGltYXRlZFNpemUgPSAodGhpcy5yZWN0LndpZHRoICsgdGhpcy5yZWN0LmhlaWdodCkgLyAyO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZXN0aW1hdGVkU2l6ZSA9IHRoaXMuY2hpbGQuY2FsY0VzdGltYXRlZFNpemUoKTtcbiAgICB0aGlzLnJlY3Qud2lkdGggPSB0aGlzLmVzdGltYXRlZFNpemU7XG4gICAgdGhpcy5yZWN0LmhlaWdodCA9IHRoaXMuZXN0aW1hdGVkU2l6ZTtcblxuICAgIHJldHVybiB0aGlzLmVzdGltYXRlZFNpemU7XG4gIH1cbn07XG5cbkxOb2RlLnByb3RvdHlwZS5zY2F0dGVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcmFuZG9tQ2VudGVyWDtcbiAgdmFyIHJhbmRvbUNlbnRlclk7XG5cbiAgdmFyIG1pblggPSAtTGF5b3V0Q29uc3RhbnRzLklOSVRJQUxfV09STERfQk9VTkRBUlk7XG4gIHZhciBtYXhYID0gTGF5b3V0Q29uc3RhbnRzLklOSVRJQUxfV09STERfQk9VTkRBUlk7XG4gIHJhbmRvbUNlbnRlclggPSBMYXlvdXRDb25zdGFudHMuV09STERfQ0VOVEVSX1ggKyBSYW5kb21TZWVkLm5leHREb3VibGUoKSAqIChtYXhYIC0gbWluWCkgKyBtaW5YO1xuXG4gIHZhciBtaW5ZID0gLUxheW91dENvbnN0YW50cy5JTklUSUFMX1dPUkxEX0JPVU5EQVJZO1xuICB2YXIgbWF4WSA9IExheW91dENvbnN0YW50cy5JTklUSUFMX1dPUkxEX0JPVU5EQVJZO1xuICByYW5kb21DZW50ZXJZID0gTGF5b3V0Q29uc3RhbnRzLldPUkxEX0NFTlRFUl9ZICsgUmFuZG9tU2VlZC5uZXh0RG91YmxlKCkgKiAobWF4WSAtIG1pblkpICsgbWluWTtcblxuICB0aGlzLnJlY3QueCA9IHJhbmRvbUNlbnRlclg7XG4gIHRoaXMucmVjdC55ID0gcmFuZG9tQ2VudGVyWTtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS51cGRhdGVCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmdldENoaWxkKCkgPT0gbnVsbCkge1xuICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICB9XG4gIGlmICh0aGlzLmdldENoaWxkKCkuZ2V0Tm9kZXMoKS5sZW5ndGggIT0gMCkge1xuICAgIC8vIHdyYXAgdGhlIGNoaWxkcmVuIG5vZGVzIGJ5IHJlLWFycmFuZ2luZyB0aGUgYm91bmRhcmllc1xuICAgIHZhciBjaGlsZEdyYXBoID0gdGhpcy5nZXRDaGlsZCgpO1xuICAgIGNoaWxkR3JhcGgudXBkYXRlQm91bmRzKHRydWUpO1xuXG4gICAgdGhpcy5yZWN0LnggPSBjaGlsZEdyYXBoLmdldExlZnQoKTtcbiAgICB0aGlzLnJlY3QueSA9IGNoaWxkR3JhcGguZ2V0VG9wKCk7XG5cbiAgICB0aGlzLnNldFdpZHRoKGNoaWxkR3JhcGguZ2V0UmlnaHQoKSAtIGNoaWxkR3JhcGguZ2V0TGVmdCgpKTtcbiAgICB0aGlzLnNldEhlaWdodChjaGlsZEdyYXBoLmdldEJvdHRvbSgpIC0gY2hpbGRHcmFwaC5nZXRUb3AoKSk7XG5cbiAgICAvLyBVcGRhdGUgY29tcG91bmQgYm91bmRzIGNvbnNpZGVyaW5nIGl0cyBsYWJlbCBwcm9wZXJ0aWVzICAgIFxuICAgIGlmIChMYXlvdXRDb25zdGFudHMuTk9ERV9ESU1FTlNJT05TX0lOQ0xVREVfTEFCRUxTKSB7XG5cbiAgICAgIHZhciB3aWR0aCA9IGNoaWxkR3JhcGguZ2V0UmlnaHQoKSAtIGNoaWxkR3JhcGguZ2V0TGVmdCgpO1xuICAgICAgdmFyIGhlaWdodCA9IGNoaWxkR3JhcGguZ2V0Qm90dG9tKCkgLSBjaGlsZEdyYXBoLmdldFRvcCgpO1xuXG4gICAgICBpZiAodGhpcy5sYWJlbFdpZHRoKSB7XG4gICAgICAgIGlmICh0aGlzLmxhYmVsUG9zSG9yaXpvbnRhbCA9PSBcImxlZnRcIikge1xuICAgICAgICAgIHRoaXMucmVjdC54IC09IHRoaXMubGFiZWxXaWR0aDtcbiAgICAgICAgICB0aGlzLnNldFdpZHRoKHdpZHRoICsgdGhpcy5sYWJlbFdpZHRoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxhYmVsUG9zSG9yaXpvbnRhbCA9PSBcImNlbnRlclwiICYmIHRoaXMubGFiZWxXaWR0aCA+IHdpZHRoKSB7XG4gICAgICAgICAgdGhpcy5yZWN0LnggLT0gKHRoaXMubGFiZWxXaWR0aCAtIHdpZHRoKSAvIDI7XG4gICAgICAgICAgdGhpcy5zZXRXaWR0aCh0aGlzLmxhYmVsV2lkdGgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGFiZWxQb3NIb3Jpem9udGFsID09IFwicmlnaHRcIikge1xuICAgICAgICAgIHRoaXMuc2V0V2lkdGgod2lkdGggKyB0aGlzLmxhYmVsV2lkdGgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmxhYmVsSGVpZ2h0KSB7XG4gICAgICAgIGlmICh0aGlzLmxhYmVsUG9zVmVydGljYWwgPT0gXCJ0b3BcIikge1xuICAgICAgICAgIHRoaXMucmVjdC55IC09IHRoaXMubGFiZWxIZWlnaHQ7XG4gICAgICAgICAgdGhpcy5zZXRIZWlnaHQoaGVpZ2h0ICsgdGhpcy5sYWJlbEhlaWdodCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5sYWJlbFBvc1ZlcnRpY2FsID09IFwiY2VudGVyXCIgJiYgdGhpcy5sYWJlbEhlaWdodCA+IGhlaWdodCkge1xuICAgICAgICAgIHRoaXMucmVjdC55IC09ICh0aGlzLmxhYmVsSGVpZ2h0IC0gaGVpZ2h0KSAvIDI7XG4gICAgICAgICAgdGhpcy5zZXRIZWlnaHQodGhpcy5sYWJlbEhlaWdodCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5sYWJlbFBvc1ZlcnRpY2FsID09IFwiYm90dG9tXCIpIHtcbiAgICAgICAgICB0aGlzLnNldEhlaWdodChoZWlnaHQgKyB0aGlzLmxhYmVsSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuTE5vZGUucHJvdG90eXBlLmdldEluY2x1c2lvblRyZWVEZXB0aCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuaW5jbHVzaW9uVHJlZURlcHRoID09IEludGVnZXIuTUFYX1ZBTFVFKSB7XG4gICAgdGhyb3cgXCJhc3NlcnQgZmFpbGVkXCI7XG4gIH1cbiAgcmV0dXJuIHRoaXMuaW5jbHVzaW9uVHJlZURlcHRoO1xufTtcblxuTE5vZGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0cmFucykge1xuICB2YXIgbGVmdCA9IHRoaXMucmVjdC54O1xuXG4gIGlmIChsZWZ0ID4gTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZKSB7XG4gICAgbGVmdCA9IExheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWTtcbiAgfSBlbHNlIGlmIChsZWZ0IDwgLUxheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWSkge1xuICAgIGxlZnQgPSAtTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZO1xuICB9XG5cbiAgdmFyIHRvcCA9IHRoaXMucmVjdC55O1xuXG4gIGlmICh0b3AgPiBMYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlkpIHtcbiAgICB0b3AgPSBMYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlk7XG4gIH0gZWxzZSBpZiAodG9wIDwgLUxheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWSkge1xuICAgIHRvcCA9IC1MYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlk7XG4gIH1cblxuICB2YXIgbGVmdFRvcCA9IG5ldyBQb2ludEQobGVmdCwgdG9wKTtcbiAgdmFyIHZMZWZ0VG9wID0gdHJhbnMuaW52ZXJzZVRyYW5zZm9ybVBvaW50KGxlZnRUb3ApO1xuXG4gIHRoaXMuc2V0TG9jYXRpb24odkxlZnRUb3AueCwgdkxlZnRUb3AueSk7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0TGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC54O1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWN0LnggKyB0aGlzLnJlY3Qud2lkdGg7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0VG9wID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWN0Lnk7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0Qm90dG9tID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWN0LnkgKyB0aGlzLnJlY3QuaGVpZ2h0O1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldFBhcmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMub3duZXIgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMub3duZXIuZ2V0UGFyZW50KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExOb2RlO1xuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbmZ1bmN0aW9uIEZETGF5b3V0Q29uc3RhbnRzKCkge31cblxuLy9GRExheW91dENvbnN0YW50cyBpbmhlcml0cyBzdGF0aWMgcHJvcHMgaW4gTGF5b3V0Q29uc3RhbnRzXG5mb3IgKHZhciBwcm9wIGluIExheW91dENvbnN0YW50cykge1xuICBGRExheW91dENvbnN0YW50c1twcm9wXSA9IExheW91dENvbnN0YW50c1twcm9wXTtcbn1cblxuRkRMYXlvdXRDb25zdGFudHMuTUFYX0lURVJBVElPTlMgPSAyNTAwO1xuXG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIID0gNTA7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX1NQUklOR19TVFJFTkdUSCA9IDAuNDU7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX1JFUFVMU0lPTl9TVFJFTkdUSCA9IDQ1MDAuMDtcbkZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9TVFJFTkdUSCA9IDAuNDtcbkZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9TVFJFTkdUSCA9IDEuMDtcbkZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9SQU5HRV9GQUNUT1IgPSAzLjg7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfUkFOR0VfRkFDVE9SID0gMS41O1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9VU0VfU01BUlRfSURFQUxfRURHRV9MRU5HVEhfQ0FMQ1VMQVRJT04gPSB0cnVlO1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9VU0VfU01BUlRfUkVQVUxTSU9OX1JBTkdFX0NBTENVTEFUSU9OID0gdHJ1ZTtcbkZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUwgPSAwLjM7XG5GRExheW91dENvbnN0YW50cy5DT09MSU5HX0FEQVBUQVRJT05fRkFDVE9SID0gMC4zMztcbkZETGF5b3V0Q29uc3RhbnRzLkFEQVBUQVRJT05fTE9XRVJfTk9ERV9MSU1JVCA9IDEwMDA7XG5GRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX1VQUEVSX05PREVfTElNSVQgPSA1MDAwO1xuRkRMYXlvdXRDb25zdGFudHMuTUFYX05PREVfRElTUExBQ0VNRU5UX0lOQ1JFTUVOVEFMID0gMTAwLjA7XG5GRExheW91dENvbnN0YW50cy5NQVhfTk9ERV9ESVNQTEFDRU1FTlQgPSBGRExheW91dENvbnN0YW50cy5NQVhfTk9ERV9ESVNQTEFDRU1FTlRfSU5DUkVNRU5UQUwgKiAzO1xuRkRMYXlvdXRDb25zdGFudHMuTUlOX1JFUFVMU0lPTl9ESVNUID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCAvIDEwLjA7XG5GRExheW91dENvbnN0YW50cy5DT05WRVJHRU5DRV9DSEVDS19QRVJJT0QgPSAxMDA7XG5GRExheW91dENvbnN0YW50cy5QRVJfTEVWRUxfSURFQUxfRURHRV9MRU5HVEhfRkFDVE9SID0gMC4xO1xuRkRMYXlvdXRDb25zdGFudHMuTUlOX0VER0VfTEVOR1RIID0gMTtcbkZETGF5b3V0Q29uc3RhbnRzLkdSSURfQ0FMQ1VMQVRJT05fQ0hFQ0tfUEVSSU9EID0gMTA7XG5cbm1vZHVsZS5leHBvcnRzID0gRkRMYXlvdXRDb25zdGFudHM7XG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBQb2ludEQoeCwgeSkge1xuICBpZiAoeCA9PSBudWxsICYmIHkgPT0gbnVsbCkge1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cbn1cblxuUG9pbnRELnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy54O1xufTtcblxuUG9pbnRELnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy55O1xufTtcblxuUG9pbnRELnByb3RvdHlwZS5zZXRYID0gZnVuY3Rpb24gKHgpIHtcbiAgdGhpcy54ID0geDtcbn07XG5cblBvaW50RC5wcm90b3R5cGUuc2V0WSA9IGZ1bmN0aW9uICh5KSB7XG4gIHRoaXMueSA9IHk7XG59O1xuXG5Qb2ludEQucHJvdG90eXBlLmdldERpZmZlcmVuY2UgPSBmdW5jdGlvbiAocHQpIHtcbiAgcmV0dXJuIG5ldyBEaW1lbnNpb25EKHRoaXMueCAtIHB0LngsIHRoaXMueSAtIHB0LnkpO1xufTtcblxuUG9pbnRELnByb3RvdHlwZS5nZXRDb3B5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IFBvaW50RCh0aGlzLngsIHRoaXMueSk7XG59O1xuXG5Qb2ludEQucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChkaW0pIHtcbiAgdGhpcy54ICs9IGRpbS53aWR0aDtcbiAgdGhpcy55ICs9IGRpbS5oZWlnaHQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2ludEQ7XG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgTEdyYXBoT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbnZhciBJbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG52YXIgTGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBMR3JhcGhNYW5hZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbnZhciBMTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgTEVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIFJlY3RhbmdsZUQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbnZhciBQb2ludCA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xudmFyIExpbmtlZExpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxuZnVuY3Rpb24gTEdyYXBoKHBhcmVudCwgb2JqMiwgdkdyYXBoKSB7XG4gIExHcmFwaE9iamVjdC5jYWxsKHRoaXMsIHZHcmFwaCk7XG4gIHRoaXMuZXN0aW1hdGVkU2l6ZSA9IEludGVnZXIuTUlOX1ZBTFVFO1xuICB0aGlzLm1hcmdpbiA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVBIX01BUkdJTjtcbiAgdGhpcy5lZGdlcyA9IFtdO1xuICB0aGlzLm5vZGVzID0gW107XG4gIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgaWYgKG9iajIgIT0gbnVsbCAmJiBvYmoyIGluc3RhbmNlb2YgTEdyYXBoTWFuYWdlcikge1xuICAgIHRoaXMuZ3JhcGhNYW5hZ2VyID0gb2JqMjtcbiAgfSBlbHNlIGlmIChvYmoyICE9IG51bGwgJiYgb2JqMiBpbnN0YW5jZW9mIExheW91dCkge1xuICAgIHRoaXMuZ3JhcGhNYW5hZ2VyID0gb2JqMi5ncmFwaE1hbmFnZXI7XG4gIH1cbn1cblxuTEdyYXBoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTEdyYXBoT2JqZWN0LnByb3RvdHlwZSk7XG5mb3IgKHZhciBwcm9wIGluIExHcmFwaE9iamVjdCkge1xuICBMR3JhcGhbcHJvcF0gPSBMR3JhcGhPYmplY3RbcHJvcF07XG59XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0Tm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVzO1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5nZXRFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZWRnZXM7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmdldEdyYXBoTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ3JhcGhNYW5hZ2VyO1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5nZXRQYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnBhcmVudDtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0TGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGVmdDtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0UmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJpZ2h0O1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5nZXRUb3AgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnRvcDtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0Qm90dG9tID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ib3R0b207XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmlzQ29ubmVjdGVkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5pc0Nvbm5lY3RlZDtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG9iajEsIHNvdXJjZU5vZGUsIHRhcmdldE5vZGUpIHtcbiAgaWYgKHNvdXJjZU5vZGUgPT0gbnVsbCAmJiB0YXJnZXROb2RlID09IG51bGwpIHtcbiAgICB2YXIgbmV3Tm9kZSA9IG9iajE7XG4gICAgaWYgKHRoaXMuZ3JhcGhNYW5hZ2VyID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiR3JhcGggaGFzIG5vIGdyYXBoIG1nciFcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0Tm9kZXMoKS5pbmRleE9mKG5ld05vZGUpID4gLTEpIHtcbiAgICAgIHRocm93IFwiTm9kZSBhbHJlYWR5IGluIGdyYXBoIVwiO1xuICAgIH1cbiAgICBuZXdOb2RlLm93bmVyID0gdGhpcztcbiAgICB0aGlzLmdldE5vZGVzKCkucHVzaChuZXdOb2RlKTtcblxuICAgIHJldHVybiBuZXdOb2RlO1xuICB9IGVsc2Uge1xuICAgIHZhciBuZXdFZGdlID0gb2JqMTtcbiAgICBpZiAoISh0aGlzLmdldE5vZGVzKCkuaW5kZXhPZihzb3VyY2VOb2RlKSA+IC0xICYmIHRoaXMuZ2V0Tm9kZXMoKS5pbmRleE9mKHRhcmdldE5vZGUpID4gLTEpKSB7XG4gICAgICB0aHJvdyBcIlNvdXJjZSBvciB0YXJnZXQgbm90IGluIGdyYXBoIVwiO1xuICAgIH1cblxuICAgIGlmICghKHNvdXJjZU5vZGUub3duZXIgPT0gdGFyZ2V0Tm9kZS5vd25lciAmJiBzb3VyY2VOb2RlLm93bmVyID09IHRoaXMpKSB7XG4gICAgICB0aHJvdyBcIkJvdGggb3duZXJzIG11c3QgYmUgdGhpcyBncmFwaCFcIjtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlTm9kZS5vd25lciAhPSB0YXJnZXROb2RlLm93bmVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBzZXQgc291cmNlIGFuZCB0YXJnZXRcbiAgICBuZXdFZGdlLnNvdXJjZSA9IHNvdXJjZU5vZGU7XG4gICAgbmV3RWRnZS50YXJnZXQgPSB0YXJnZXROb2RlO1xuXG4gICAgLy8gc2V0IGFzIGludHJhLWdyYXBoIGVkZ2VcbiAgICBuZXdFZGdlLmlzSW50ZXJHcmFwaCA9IGZhbHNlO1xuXG4gICAgLy8gYWRkIHRvIGdyYXBoIGVkZ2UgbGlzdFxuICAgIHRoaXMuZ2V0RWRnZXMoKS5wdXNoKG5ld0VkZ2UpO1xuXG4gICAgLy8gYWRkIHRvIGluY2lkZW5jeSBsaXN0c1xuICAgIHNvdXJjZU5vZGUuZWRnZXMucHVzaChuZXdFZGdlKTtcblxuICAgIGlmICh0YXJnZXROb2RlICE9IHNvdXJjZU5vZGUpIHtcbiAgICAgIHRhcmdldE5vZGUuZWRnZXMucHVzaChuZXdFZGdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RWRnZTtcbiAgfVxufTtcblxuTEdyYXBoLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBub2RlID0gb2JqO1xuICBpZiAob2JqIGluc3RhbmNlb2YgTE5vZGUpIHtcbiAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBcIk5vZGUgaXMgbnVsbCFcIjtcbiAgICB9XG4gICAgaWYgKCEobm9kZS5vd25lciAhPSBudWxsICYmIG5vZGUub3duZXIgPT0gdGhpcykpIHtcbiAgICAgIHRocm93IFwiT3duZXIgZ3JhcGggaXMgaW52YWxpZCFcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ3JhcGhNYW5hZ2VyID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiT3duZXIgZ3JhcGggbWFuYWdlciBpcyBpbnZhbGlkIVwiO1xuICAgIH1cbiAgICAvLyByZW1vdmUgaW5jaWRlbnQgZWRnZXMgZmlyc3QgKG1ha2UgYSBjb3B5IHRvIGRvIGl0IHNhZmVseSlcbiAgICB2YXIgZWRnZXNUb0JlUmVtb3ZlZCA9IG5vZGUuZWRnZXMuc2xpY2UoKTtcbiAgICB2YXIgZWRnZTtcbiAgICB2YXIgcyA9IGVkZ2VzVG9CZVJlbW92ZWQubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICBlZGdlID0gZWRnZXNUb0JlUmVtb3ZlZFtpXTtcblxuICAgICAgaWYgKGVkZ2UuaXNJbnRlckdyYXBoKSB7XG4gICAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlbW92ZShlZGdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkZ2Uuc291cmNlLm93bmVyLnJlbW92ZShlZGdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBub3cgdGhlIG5vZGUgaXRzZWxmXG4gICAgdmFyIGluZGV4ID0gdGhpcy5ub2Rlcy5pbmRleE9mKG5vZGUpO1xuICAgIGlmIChpbmRleCA9PSAtMSkge1xuICAgICAgdGhyb3cgXCJOb2RlIG5vdCBpbiBvd25lciBub2RlIGxpc3QhXCI7XG4gICAgfVxuXG4gICAgdGhpcy5ub2Rlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIExFZGdlKSB7XG4gICAgdmFyIGVkZ2UgPSBvYmo7XG4gICAgaWYgKGVkZ2UgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJFZGdlIGlzIG51bGwhXCI7XG4gICAgfVxuICAgIGlmICghKGVkZ2Uuc291cmNlICE9IG51bGwgJiYgZWRnZS50YXJnZXQgIT0gbnVsbCkpIHtcbiAgICAgIHRocm93IFwiU291cmNlIGFuZC9vciB0YXJnZXQgaXMgbnVsbCFcIjtcbiAgICB9XG4gICAgaWYgKCEoZWRnZS5zb3VyY2Uub3duZXIgIT0gbnVsbCAmJiBlZGdlLnRhcmdldC5vd25lciAhPSBudWxsICYmIGVkZ2Uuc291cmNlLm93bmVyID09IHRoaXMgJiYgZWRnZS50YXJnZXQub3duZXIgPT0gdGhpcykpIHtcbiAgICAgIHRocm93IFwiU291cmNlIGFuZC9vciB0YXJnZXQgb3duZXIgaXMgaW52YWxpZCFcIjtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlSW5kZXggPSBlZGdlLnNvdXJjZS5lZGdlcy5pbmRleE9mKGVkZ2UpO1xuICAgIHZhciB0YXJnZXRJbmRleCA9IGVkZ2UudGFyZ2V0LmVkZ2VzLmluZGV4T2YoZWRnZSk7XG4gICAgaWYgKCEoc291cmNlSW5kZXggPiAtMSAmJiB0YXJnZXRJbmRleCA+IC0xKSkge1xuICAgICAgdGhyb3cgXCJTb3VyY2UgYW5kL29yIHRhcmdldCBkb2Vzbid0IGtub3cgdGhpcyBlZGdlIVwiO1xuICAgIH1cblxuICAgIGVkZ2Uuc291cmNlLmVkZ2VzLnNwbGljZShzb3VyY2VJbmRleCwgMSk7XG5cbiAgICBpZiAoZWRnZS50YXJnZXQgIT0gZWRnZS5zb3VyY2UpIHtcbiAgICAgIGVkZ2UudGFyZ2V0LmVkZ2VzLnNwbGljZSh0YXJnZXRJbmRleCwgMSk7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gZWRnZS5zb3VyY2Uub3duZXIuZ2V0RWRnZXMoKS5pbmRleE9mKGVkZ2UpO1xuICAgIGlmIChpbmRleCA9PSAtMSkge1xuICAgICAgdGhyb3cgXCJOb3QgaW4gb3duZXIncyBlZGdlIGxpc3QhXCI7XG4gICAgfVxuXG4gICAgZWRnZS5zb3VyY2Uub3duZXIuZ2V0RWRnZXMoKS5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLnVwZGF0ZUxlZnRUb3AgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0b3AgPSBJbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIGxlZnQgPSBJbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIG5vZGVUb3A7XG4gIHZhciBub2RlTGVmdDtcbiAgdmFyIG1hcmdpbjtcblxuICB2YXIgbm9kZXMgPSB0aGlzLmdldE5vZGVzKCk7XG4gIHZhciBzID0gbm9kZXMubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgdmFyIGxOb2RlID0gbm9kZXNbaV07XG4gICAgbm9kZVRvcCA9IGxOb2RlLmdldFRvcCgpO1xuICAgIG5vZGVMZWZ0ID0gbE5vZGUuZ2V0TGVmdCgpO1xuXG4gICAgaWYgKHRvcCA+IG5vZGVUb3ApIHtcbiAgICAgIHRvcCA9IG5vZGVUb3A7XG4gICAgfVxuXG4gICAgaWYgKGxlZnQgPiBub2RlTGVmdCkge1xuICAgICAgbGVmdCA9IG5vZGVMZWZ0O1xuICAgIH1cbiAgfVxuXG4gIC8vIERvIHdlIGhhdmUgYW55IG5vZGVzIGluIHRoaXMgZ3JhcGg/XG4gIGlmICh0b3AgPT0gSW50ZWdlci5NQVhfVkFMVUUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChub2Rlc1swXS5nZXRQYXJlbnQoKS5wYWRkaW5nTGVmdCAhPSB1bmRlZmluZWQpIHtcbiAgICBtYXJnaW4gPSBub2Rlc1swXS5nZXRQYXJlbnQoKS5wYWRkaW5nTGVmdDtcbiAgfSBlbHNlIHtcbiAgICBtYXJnaW4gPSB0aGlzLm1hcmdpbjtcbiAgfVxuXG4gIHRoaXMubGVmdCA9IGxlZnQgLSBtYXJnaW47XG4gIHRoaXMudG9wID0gdG9wIC0gbWFyZ2luO1xuXG4gIC8vIEFwcGx5IHRoZSBtYXJnaW5zIGFuZCByZXR1cm4gdGhlIHJlc3VsdFxuICByZXR1cm4gbmV3IFBvaW50KHRoaXMubGVmdCwgdGhpcy50b3ApO1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS51cGRhdGVCb3VuZHMgPSBmdW5jdGlvbiAocmVjdXJzaXZlKSB7XG4gIC8vIGNhbGN1bGF0ZSBib3VuZHNcbiAgdmFyIGxlZnQgPSBJbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIHJpZ2h0ID0gLUludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgdG9wID0gSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciBib3R0b20gPSAtSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciBub2RlTGVmdDtcbiAgdmFyIG5vZGVSaWdodDtcbiAgdmFyIG5vZGVUb3A7XG4gIHZhciBub2RlQm90dG9tO1xuICB2YXIgbWFyZ2luO1xuXG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXM7XG4gIHZhciBzID0gbm9kZXMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIHZhciBsTm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgaWYgKHJlY3Vyc2l2ZSAmJiBsTm9kZS5jaGlsZCAhPSBudWxsKSB7XG4gICAgICBsTm9kZS51cGRhdGVCb3VuZHMoKTtcbiAgICB9XG4gICAgbm9kZUxlZnQgPSBsTm9kZS5nZXRMZWZ0KCk7XG4gICAgbm9kZVJpZ2h0ID0gbE5vZGUuZ2V0UmlnaHQoKTtcbiAgICBub2RlVG9wID0gbE5vZGUuZ2V0VG9wKCk7XG4gICAgbm9kZUJvdHRvbSA9IGxOb2RlLmdldEJvdHRvbSgpO1xuXG4gICAgaWYgKGxlZnQgPiBub2RlTGVmdCkge1xuICAgICAgbGVmdCA9IG5vZGVMZWZ0O1xuICAgIH1cblxuICAgIGlmIChyaWdodCA8IG5vZGVSaWdodCkge1xuICAgICAgcmlnaHQgPSBub2RlUmlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKHRvcCA+IG5vZGVUb3ApIHtcbiAgICAgIHRvcCA9IG5vZGVUb3A7XG4gICAgfVxuXG4gICAgaWYgKGJvdHRvbSA8IG5vZGVCb3R0b20pIHtcbiAgICAgIGJvdHRvbSA9IG5vZGVCb3R0b207XG4gICAgfVxuICB9XG5cbiAgdmFyIGJvdW5kaW5nUmVjdCA9IG5ldyBSZWN0YW5nbGVEKGxlZnQsIHRvcCwgcmlnaHQgLSBsZWZ0LCBib3R0b20gLSB0b3ApO1xuICBpZiAobGVmdCA9PSBJbnRlZ2VyLk1BWF9WQUxVRSkge1xuICAgIHRoaXMubGVmdCA9IHRoaXMucGFyZW50LmdldExlZnQoKTtcbiAgICB0aGlzLnJpZ2h0ID0gdGhpcy5wYXJlbnQuZ2V0UmlnaHQoKTtcbiAgICB0aGlzLnRvcCA9IHRoaXMucGFyZW50LmdldFRvcCgpO1xuICAgIHRoaXMuYm90dG9tID0gdGhpcy5wYXJlbnQuZ2V0Qm90dG9tKCk7XG4gIH1cblxuICBpZiAobm9kZXNbMF0uZ2V0UGFyZW50KCkucGFkZGluZ0xlZnQgIT0gdW5kZWZpbmVkKSB7XG4gICAgbWFyZ2luID0gbm9kZXNbMF0uZ2V0UGFyZW50KCkucGFkZGluZ0xlZnQ7XG4gIH0gZWxzZSB7XG4gICAgbWFyZ2luID0gdGhpcy5tYXJnaW47XG4gIH1cblxuICB0aGlzLmxlZnQgPSBib3VuZGluZ1JlY3QueCAtIG1hcmdpbjtcbiAgdGhpcy5yaWdodCA9IGJvdW5kaW5nUmVjdC54ICsgYm91bmRpbmdSZWN0LndpZHRoICsgbWFyZ2luO1xuICB0aGlzLnRvcCA9IGJvdW5kaW5nUmVjdC55IC0gbWFyZ2luO1xuICB0aGlzLmJvdHRvbSA9IGJvdW5kaW5nUmVjdC55ICsgYm91bmRpbmdSZWN0LmhlaWdodCArIG1hcmdpbjtcbn07XG5cbkxHcmFwaC5jYWxjdWxhdGVCb3VuZHMgPSBmdW5jdGlvbiAobm9kZXMpIHtcbiAgdmFyIGxlZnQgPSBJbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIHJpZ2h0ID0gLUludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgdG9wID0gSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciBib3R0b20gPSAtSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciBub2RlTGVmdDtcbiAgdmFyIG5vZGVSaWdodDtcbiAgdmFyIG5vZGVUb3A7XG4gIHZhciBub2RlQm90dG9tO1xuXG4gIHZhciBzID0gbm9kZXMubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgdmFyIGxOb2RlID0gbm9kZXNbaV07XG4gICAgbm9kZUxlZnQgPSBsTm9kZS5nZXRMZWZ0KCk7XG4gICAgbm9kZVJpZ2h0ID0gbE5vZGUuZ2V0UmlnaHQoKTtcbiAgICBub2RlVG9wID0gbE5vZGUuZ2V0VG9wKCk7XG4gICAgbm9kZUJvdHRvbSA9IGxOb2RlLmdldEJvdHRvbSgpO1xuXG4gICAgaWYgKGxlZnQgPiBub2RlTGVmdCkge1xuICAgICAgbGVmdCA9IG5vZGVMZWZ0O1xuICAgIH1cblxuICAgIGlmIChyaWdodCA8IG5vZGVSaWdodCkge1xuICAgICAgcmlnaHQgPSBub2RlUmlnaHQ7XG4gICAgfVxuXG4gICAgaWYgKHRvcCA+IG5vZGVUb3ApIHtcbiAgICAgIHRvcCA9IG5vZGVUb3A7XG4gICAgfVxuXG4gICAgaWYgKGJvdHRvbSA8IG5vZGVCb3R0b20pIHtcbiAgICAgIGJvdHRvbSA9IG5vZGVCb3R0b207XG4gICAgfVxuICB9XG5cbiAgdmFyIGJvdW5kaW5nUmVjdCA9IG5ldyBSZWN0YW5nbGVEKGxlZnQsIHRvcCwgcmlnaHQgLSBsZWZ0LCBib3R0b20gLSB0b3ApO1xuXG4gIHJldHVybiBib3VuZGluZ1JlY3Q7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmdldEluY2x1c2lvblRyZWVEZXB0aCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMgPT0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50LmdldEluY2x1c2lvblRyZWVEZXB0aCgpO1xuICB9XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmdldEVzdGltYXRlZFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmVzdGltYXRlZFNpemUgPT0gSW50ZWdlci5NSU5fVkFMVUUpIHtcbiAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgfVxuICByZXR1cm4gdGhpcy5lc3RpbWF0ZWRTaXplO1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5jYWxjRXN0aW1hdGVkU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNpemUgPSAwO1xuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICB2YXIgcyA9IG5vZGVzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIHZhciBsTm9kZSA9IG5vZGVzW2ldO1xuICAgIHNpemUgKz0gbE5vZGUuY2FsY0VzdGltYXRlZFNpemUoKTtcbiAgfVxuXG4gIGlmIChzaXplID09IDApIHtcbiAgICB0aGlzLmVzdGltYXRlZFNpemUgPSBMYXlvdXRDb25zdGFudHMuRU1QVFlfQ09NUE9VTkRfTk9ERV9TSVpFO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZXN0aW1hdGVkU2l6ZSA9IHNpemUgLyBNYXRoLnNxcnQodGhpcy5ub2Rlcy5sZW5ndGgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZXN0aW1hdGVkU2l6ZTtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUudXBkYXRlQ29ubmVjdGVkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh0aGlzLm5vZGVzLmxlbmd0aCA9PSAwKSB7XG4gICAgdGhpcy5pc0Nvbm5lY3RlZCA9IHRydWU7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHF1ZXVlID0gbmV3IExpbmtlZExpc3QoKTtcbiAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gIHZhciBjdXJyZW50Tm9kZSA9IHRoaXMubm9kZXNbMF07XG4gIHZhciBuZWlnaGJvckVkZ2VzO1xuICB2YXIgY3VycmVudE5laWdoYm9yO1xuICB2YXIgY2hpbGRyZW5PZk5vZGUgPSBjdXJyZW50Tm9kZS53aXRoQ2hpbGRyZW4oKTtcbiAgY2hpbGRyZW5PZk5vZGUuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgIHF1ZXVlLnB1c2gobm9kZSk7XG4gICAgdmlzaXRlZC5hZGQobm9kZSk7XG4gIH0pO1xuXG4gIHdoaWxlIChxdWV1ZS5sZW5ndGggIT09IDApIHtcbiAgICBjdXJyZW50Tm9kZSA9IHF1ZXVlLnNoaWZ0KCk7XG5cbiAgICAvLyBUcmF2ZXJzZSBhbGwgbmVpZ2hib3JzIG9mIHRoaXMgbm9kZVxuICAgIG5laWdoYm9yRWRnZXMgPSBjdXJyZW50Tm9kZS5nZXRFZGdlcygpO1xuICAgIHZhciBzaXplID0gbmVpZ2hib3JFZGdlcy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgIHZhciBuZWlnaGJvckVkZ2UgPSBuZWlnaGJvckVkZ2VzW2ldO1xuICAgICAgY3VycmVudE5laWdoYm9yID0gbmVpZ2hib3JFZGdlLmdldE90aGVyRW5kSW5HcmFwaChjdXJyZW50Tm9kZSwgdGhpcyk7XG5cbiAgICAgIC8vIEFkZCB1bnZpc2l0ZWQgbmVpZ2hib3JzIHRvIHRoZSBsaXN0IHRvIHZpc2l0XG4gICAgICBpZiAoY3VycmVudE5laWdoYm9yICE9IG51bGwgJiYgIXZpc2l0ZWQuaGFzKGN1cnJlbnROZWlnaGJvcikpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuT2ZOZWlnaGJvciA9IGN1cnJlbnROZWlnaGJvci53aXRoQ2hpbGRyZW4oKTtcblxuICAgICAgICBjaGlsZHJlbk9mTmVpZ2hib3IuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHF1ZXVlLnB1c2gobm9kZSk7XG4gICAgICAgICAgdmlzaXRlZC5hZGQobm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcblxuICBpZiAodmlzaXRlZC5zaXplID49IHRoaXMubm9kZXMubGVuZ3RoKSB7XG4gICAgdmFyIG5vT2ZWaXNpdGVkSW5UaGlzR3JhcGggPSAwO1xuXG4gICAgdmlzaXRlZC5mb3JFYWNoKGZ1bmN0aW9uICh2aXNpdGVkTm9kZSkge1xuICAgICAgaWYgKHZpc2l0ZWROb2RlLm93bmVyID09IHNlbGYpIHtcbiAgICAgICAgbm9PZlZpc2l0ZWRJblRoaXNHcmFwaCsrO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKG5vT2ZWaXNpdGVkSW5UaGlzR3JhcGggPT0gdGhpcy5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMR3JhcGg7XG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgTEdyYXBoO1xudmFyIExFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuZnVuY3Rpb24gTEdyYXBoTWFuYWdlcihsYXlvdXQpIHtcbiAgTEdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTsgLy8gSXQgbWF5IGJlIGJldHRlciB0byBpbml0aWxpemUgdGhpcyBvdXQgb2YgdGhpcyBmdW5jdGlvbiBidXQgaXQgZ2l2ZXMgYW4gZXJyb3IgKFJpZ2h0LWhhbmQgc2lkZSBvZiAnaW5zdGFuY2VvZicgaXMgbm90IGNhbGxhYmxlKSBub3cuXG4gIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuXG4gIHRoaXMuZ3JhcGhzID0gW107XG4gIHRoaXMuZWRnZXMgPSBbXTtcbn1cblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuYWRkUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5ncmFwaCA9IHRoaXMubGF5b3V0Lm5ld0dyYXBoKCk7XG4gIHZhciBubm9kZSA9IHRoaXMubGF5b3V0Lm5ld05vZGUobnVsbCk7XG4gIHZhciByb290ID0gdGhpcy5hZGQobmdyYXBoLCBubm9kZSk7XG4gIHRoaXMuc2V0Um9vdEdyYXBoKHJvb3QpO1xuICByZXR1cm4gdGhpcy5yb290R3JhcGg7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobmV3R3JhcGgsIHBhcmVudE5vZGUsIG5ld0VkZ2UsIHNvdXJjZU5vZGUsIHRhcmdldE5vZGUpIHtcbiAgLy90aGVyZSBhcmUganVzdCAyIHBhcmFtZXRlcnMgYXJlIHBhc3NlZCB0aGVuIGl0IGFkZHMgYW4gTEdyYXBoIGVsc2UgaXQgYWRkcyBhbiBMRWRnZVxuICBpZiAobmV3RWRnZSA9PSBudWxsICYmIHNvdXJjZU5vZGUgPT0gbnVsbCAmJiB0YXJnZXROb2RlID09IG51bGwpIHtcbiAgICBpZiAobmV3R3JhcGggPT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJHcmFwaCBpcyBudWxsIVwiO1xuICAgIH1cbiAgICBpZiAocGFyZW50Tm9kZSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBcIlBhcmVudCBub2RlIGlzIG51bGwhXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmdyYXBocy5pbmRleE9mKG5ld0dyYXBoKSA+IC0xKSB7XG4gICAgICB0aHJvdyBcIkdyYXBoIGFscmVhZHkgaW4gdGhpcyBncmFwaCBtZ3IhXCI7XG4gICAgfVxuXG4gICAgdGhpcy5ncmFwaHMucHVzaChuZXdHcmFwaCk7XG5cbiAgICBpZiAobmV3R3JhcGgucGFyZW50ICE9IG51bGwpIHtcbiAgICAgIHRocm93IFwiQWxyZWFkeSBoYXMgYSBwYXJlbnQhXCI7XG4gICAgfVxuICAgIGlmIChwYXJlbnROb2RlLmNoaWxkICE9IG51bGwpIHtcbiAgICAgIHRocm93IFwiQWxyZWFkeSBoYXMgYSBjaGlsZCFcIjtcbiAgICB9XG5cbiAgICBuZXdHcmFwaC5wYXJlbnQgPSBwYXJlbnROb2RlO1xuICAgIHBhcmVudE5vZGUuY2hpbGQgPSBuZXdHcmFwaDtcblxuICAgIHJldHVybiBuZXdHcmFwaDtcbiAgfSBlbHNlIHtcbiAgICAvL2NoYW5nZSB0aGUgb3JkZXIgb2YgdGhlIHBhcmFtZXRlcnNcbiAgICB0YXJnZXROb2RlID0gbmV3RWRnZTtcbiAgICBzb3VyY2VOb2RlID0gcGFyZW50Tm9kZTtcbiAgICBuZXdFZGdlID0gbmV3R3JhcGg7XG4gICAgdmFyIHNvdXJjZUdyYXBoID0gc291cmNlTm9kZS5nZXRPd25lcigpO1xuICAgIHZhciB0YXJnZXRHcmFwaCA9IHRhcmdldE5vZGUuZ2V0T3duZXIoKTtcblxuICAgIGlmICghKHNvdXJjZUdyYXBoICE9IG51bGwgJiYgc291cmNlR3JhcGguZ2V0R3JhcGhNYW5hZ2VyKCkgPT0gdGhpcykpIHtcbiAgICAgIHRocm93IFwiU291cmNlIG5vdCBpbiB0aGlzIGdyYXBoIG1nciFcIjtcbiAgICB9XG4gICAgaWYgKCEodGFyZ2V0R3JhcGggIT0gbnVsbCAmJiB0YXJnZXRHcmFwaC5nZXRHcmFwaE1hbmFnZXIoKSA9PSB0aGlzKSkge1xuICAgICAgdGhyb3cgXCJUYXJnZXQgbm90IGluIHRoaXMgZ3JhcGggbWdyIVwiO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2VHcmFwaCA9PSB0YXJnZXRHcmFwaCkge1xuICAgICAgbmV3RWRnZS5pc0ludGVyR3JhcGggPSBmYWxzZTtcbiAgICAgIHJldHVybiBzb3VyY2VHcmFwaC5hZGQobmV3RWRnZSwgc291cmNlTm9kZSwgdGFyZ2V0Tm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0VkZ2UuaXNJbnRlckdyYXBoID0gdHJ1ZTtcblxuICAgICAgLy8gc2V0IHNvdXJjZSBhbmQgdGFyZ2V0XG4gICAgICBuZXdFZGdlLnNvdXJjZSA9IHNvdXJjZU5vZGU7XG4gICAgICBuZXdFZGdlLnRhcmdldCA9IHRhcmdldE5vZGU7XG5cbiAgICAgIC8vIGFkZCBlZGdlIHRvIGludGVyLWdyYXBoIGVkZ2UgbGlzdFxuICAgICAgaWYgKHRoaXMuZWRnZXMuaW5kZXhPZihuZXdFZGdlKSA+IC0xKSB7XG4gICAgICAgIHRocm93IFwiRWRnZSBhbHJlYWR5IGluIGludGVyLWdyYXBoIGVkZ2UgbGlzdCFcIjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lZGdlcy5wdXNoKG5ld0VkZ2UpO1xuXG4gICAgICAvLyBhZGQgZWRnZSB0byBzb3VyY2UgYW5kIHRhcmdldCBpbmNpZGVuY3kgbGlzdHNcbiAgICAgIGlmICghKG5ld0VkZ2Uuc291cmNlICE9IG51bGwgJiYgbmV3RWRnZS50YXJnZXQgIT0gbnVsbCkpIHtcbiAgICAgICAgdGhyb3cgXCJFZGdlIHNvdXJjZSBhbmQvb3IgdGFyZ2V0IGlzIG51bGwhXCI7XG4gICAgICB9XG5cbiAgICAgIGlmICghKG5ld0VkZ2Uuc291cmNlLmVkZ2VzLmluZGV4T2YobmV3RWRnZSkgPT0gLTEgJiYgbmV3RWRnZS50YXJnZXQuZWRnZXMuaW5kZXhPZihuZXdFZGdlKSA9PSAtMSkpIHtcbiAgICAgICAgdGhyb3cgXCJFZGdlIGFscmVhZHkgaW4gc291cmNlIGFuZC9vciB0YXJnZXQgaW5jaWRlbmN5IGxpc3QhXCI7XG4gICAgICB9XG5cbiAgICAgIG5ld0VkZ2Uuc291cmNlLmVkZ2VzLnB1c2gobmV3RWRnZSk7XG4gICAgICBuZXdFZGdlLnRhcmdldC5lZGdlcy5wdXNoKG5ld0VkZ2UpO1xuXG4gICAgICByZXR1cm4gbmV3RWRnZTtcbiAgICB9XG4gIH1cbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChsT2JqKSB7XG4gIGlmIChsT2JqIGluc3RhbmNlb2YgTEdyYXBoKSB7XG4gICAgdmFyIGdyYXBoID0gbE9iajtcbiAgICBpZiAoZ3JhcGguZ2V0R3JhcGhNYW5hZ2VyKCkgIT0gdGhpcykge1xuICAgICAgdGhyb3cgXCJHcmFwaCBub3QgaW4gdGhpcyBncmFwaCBtZ3JcIjtcbiAgICB9XG4gICAgaWYgKCEoZ3JhcGggPT0gdGhpcy5yb290R3JhcGggfHwgZ3JhcGgucGFyZW50ICE9IG51bGwgJiYgZ3JhcGgucGFyZW50LmdyYXBoTWFuYWdlciA9PSB0aGlzKSkge1xuICAgICAgdGhyb3cgXCJJbnZhbGlkIHBhcmVudCBub2RlIVwiO1xuICAgIH1cblxuICAgIC8vIGZpcnN0IHRoZSBlZGdlcyAobWFrZSBhIGNvcHkgdG8gZG8gaXQgc2FmZWx5KVxuICAgIHZhciBlZGdlc1RvQmVSZW1vdmVkID0gW107XG5cbiAgICBlZGdlc1RvQmVSZW1vdmVkID0gZWRnZXNUb0JlUmVtb3ZlZC5jb25jYXQoZ3JhcGguZ2V0RWRnZXMoKSk7XG5cbiAgICB2YXIgZWRnZTtcbiAgICB2YXIgcyA9IGVkZ2VzVG9CZVJlbW92ZWQubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICBlZGdlID0gZWRnZXNUb0JlUmVtb3ZlZFtpXTtcbiAgICAgIGdyYXBoLnJlbW92ZShlZGdlKTtcbiAgICB9XG5cbiAgICAvLyB0aGVuIHRoZSBub2RlcyAobWFrZSBhIGNvcHkgdG8gZG8gaXQgc2FmZWx5KVxuICAgIHZhciBub2Rlc1RvQmVSZW1vdmVkID0gW107XG5cbiAgICBub2Rlc1RvQmVSZW1vdmVkID0gbm9kZXNUb0JlUmVtb3ZlZC5jb25jYXQoZ3JhcGguZ2V0Tm9kZXMoKSk7XG5cbiAgICB2YXIgbm9kZTtcbiAgICBzID0gbm9kZXNUb0JlUmVtb3ZlZC5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgIG5vZGUgPSBub2Rlc1RvQmVSZW1vdmVkW2ldO1xuICAgICAgZ3JhcGgucmVtb3ZlKG5vZGUpO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIGdyYXBoIGlzIHRoZSByb290XG4gICAgaWYgKGdyYXBoID09IHRoaXMucm9vdEdyYXBoKSB7XG4gICAgICB0aGlzLnNldFJvb3RHcmFwaChudWxsKTtcbiAgICB9XG5cbiAgICAvLyBub3cgcmVtb3ZlIHRoZSBncmFwaCBpdHNlbGZcbiAgICB2YXIgaW5kZXggPSB0aGlzLmdyYXBocy5pbmRleE9mKGdyYXBoKTtcbiAgICB0aGlzLmdyYXBocy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgLy8gYWxzbyByZXNldCB0aGUgcGFyZW50IG9mIHRoZSBncmFwaFxuICAgIGdyYXBoLnBhcmVudCA9IG51bGw7XG4gIH0gZWxzZSBpZiAobE9iaiBpbnN0YW5jZW9mIExFZGdlKSB7XG4gICAgZWRnZSA9IGxPYmo7XG4gICAgaWYgKGVkZ2UgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJFZGdlIGlzIG51bGwhXCI7XG4gICAgfVxuICAgIGlmICghZWRnZS5pc0ludGVyR3JhcGgpIHtcbiAgICAgIHRocm93IFwiTm90IGFuIGludGVyLWdyYXBoIGVkZ2UhXCI7XG4gICAgfVxuICAgIGlmICghKGVkZ2Uuc291cmNlICE9IG51bGwgJiYgZWRnZS50YXJnZXQgIT0gbnVsbCkpIHtcbiAgICAgIHRocm93IFwiU291cmNlIGFuZC9vciB0YXJnZXQgaXMgbnVsbCFcIjtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgZWRnZSBmcm9tIHNvdXJjZSBhbmQgdGFyZ2V0IG5vZGVzJyBpbmNpZGVuY3kgbGlzdHNcblxuICAgIGlmICghKGVkZ2Uuc291cmNlLmVkZ2VzLmluZGV4T2YoZWRnZSkgIT0gLTEgJiYgZWRnZS50YXJnZXQuZWRnZXMuaW5kZXhPZihlZGdlKSAhPSAtMSkpIHtcbiAgICAgIHRocm93IFwiU291cmNlIGFuZC9vciB0YXJnZXQgZG9lc24ndCBrbm93IHRoaXMgZWRnZSFcIjtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSBlZGdlLnNvdXJjZS5lZGdlcy5pbmRleE9mKGVkZ2UpO1xuICAgIGVkZ2Uuc291cmNlLmVkZ2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgaW5kZXggPSBlZGdlLnRhcmdldC5lZGdlcy5pbmRleE9mKGVkZ2UpO1xuICAgIGVkZ2UudGFyZ2V0LmVkZ2VzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAvLyByZW1vdmUgZWRnZSBmcm9tIG93bmVyIGdyYXBoIG1hbmFnZXIncyBpbnRlci1ncmFwaCBlZGdlIGxpc3RcblxuICAgIGlmICghKGVkZ2Uuc291cmNlLm93bmVyICE9IG51bGwgJiYgZWRnZS5zb3VyY2Uub3duZXIuZ2V0R3JhcGhNYW5hZ2VyKCkgIT0gbnVsbCkpIHtcbiAgICAgIHRocm93IFwiRWRnZSBvd25lciBncmFwaCBvciBvd25lciBncmFwaCBtYW5hZ2VyIGlzIG51bGwhXCI7XG4gICAgfVxuICAgIGlmIChlZGdlLnNvdXJjZS5vd25lci5nZXRHcmFwaE1hbmFnZXIoKS5lZGdlcy5pbmRleE9mKGVkZ2UpID09IC0xKSB7XG4gICAgICB0aHJvdyBcIk5vdCBpbiBvd25lciBncmFwaCBtYW5hZ2VyJ3MgZWRnZSBsaXN0IVwiO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IGVkZ2Uuc291cmNlLm93bmVyLmdldEdyYXBoTWFuYWdlcigpLmVkZ2VzLmluZGV4T2YoZWRnZSk7XG4gICAgZWRnZS5zb3VyY2Uub3duZXIuZ2V0R3JhcGhNYW5hZ2VyKCkuZWRnZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUudXBkYXRlQm91bmRzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJvb3RHcmFwaC51cGRhdGVCb3VuZHModHJ1ZSk7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5nZXRHcmFwaHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdyYXBocztcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmdldEFsbE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5hbGxOb2RlcyA9PSBudWxsKSB7XG4gICAgdmFyIG5vZGVMaXN0ID0gW107XG4gICAgdmFyIGdyYXBocyA9IHRoaXMuZ2V0R3JhcGhzKCk7XG4gICAgdmFyIHMgPSBncmFwaHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICBub2RlTGlzdCA9IG5vZGVMaXN0LmNvbmNhdChncmFwaHNbaV0uZ2V0Tm9kZXMoKSk7XG4gICAgfVxuICAgIHRoaXMuYWxsTm9kZXMgPSBub2RlTGlzdDtcbiAgfVxuICByZXR1cm4gdGhpcy5hbGxOb2Rlcztcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLnJlc2V0QWxsTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYWxsTm9kZXMgPSBudWxsO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUucmVzZXRBbGxFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5hbGxFZGdlcyA9IG51bGw7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5yZXNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uID0gbnVsbDtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmdldEFsbEVkZ2VzID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5hbGxFZGdlcyA9PSBudWxsKSB7XG4gICAgdmFyIGVkZ2VMaXN0ID0gW107XG4gICAgdmFyIGdyYXBocyA9IHRoaXMuZ2V0R3JhcGhzKCk7XG4gICAgdmFyIHMgPSBncmFwaHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhcGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBlZGdlTGlzdCA9IGVkZ2VMaXN0LmNvbmNhdChncmFwaHNbaV0uZ2V0RWRnZXMoKSk7XG4gICAgfVxuXG4gICAgZWRnZUxpc3QgPSBlZGdlTGlzdC5jb25jYXQodGhpcy5lZGdlcyk7XG5cbiAgICB0aGlzLmFsbEVkZ2VzID0gZWRnZUxpc3Q7XG4gIH1cbiAgcmV0dXJuIHRoaXMuYWxsRWRnZXM7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5nZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuYWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb247XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5zZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiA9IGZ1bmN0aW9uIChub2RlTGlzdCkge1xuICBpZiAodGhpcy5hbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiAhPSBudWxsKSB7XG4gICAgdGhyb3cgXCJhc3NlcnQgZmFpbGVkXCI7XG4gIH1cblxuICB0aGlzLmFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uID0gbm9kZUxpc3Q7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5nZXRSb290ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yb290R3JhcGg7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5zZXRSb290R3JhcGggPSBmdW5jdGlvbiAoZ3JhcGgpIHtcbiAgaWYgKGdyYXBoLmdldEdyYXBoTWFuYWdlcigpICE9IHRoaXMpIHtcbiAgICB0aHJvdyBcIlJvb3Qgbm90IGluIHRoaXMgZ3JhcGggbWdyIVwiO1xuICB9XG5cbiAgdGhpcy5yb290R3JhcGggPSBncmFwaDtcbiAgLy8gcm9vdCBncmFwaCBtdXN0IGhhdmUgYSByb290IG5vZGUgYXNzb2NpYXRlZCB3aXRoIGl0IGZvciBjb252ZW5pZW5jZVxuICBpZiAoZ3JhcGgucGFyZW50ID09IG51bGwpIHtcbiAgICBncmFwaC5wYXJlbnQgPSB0aGlzLmxheW91dC5uZXdOb2RlKFwiUm9vdCBub2RlXCIpO1xuICB9XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5nZXRMYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxheW91dDtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmlzT25lQW5jZXN0b3JPZk90aGVyID0gZnVuY3Rpb24gKGZpcnN0Tm9kZSwgc2Vjb25kTm9kZSkge1xuICBpZiAoIShmaXJzdE5vZGUgIT0gbnVsbCAmJiBzZWNvbmROb2RlICE9IG51bGwpKSB7XG4gICAgdGhyb3cgXCJhc3NlcnQgZmFpbGVkXCI7XG4gIH1cblxuICBpZiAoZmlyc3ROb2RlID09IHNlY29uZE5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBJcyBzZWNvbmQgbm9kZSBhbiBhbmNlc3RvciBvZiB0aGUgZmlyc3Qgb25lP1xuICB2YXIgb3duZXJHcmFwaCA9IGZpcnN0Tm9kZS5nZXRPd25lcigpO1xuICB2YXIgcGFyZW50Tm9kZTtcblxuICBkbyB7XG4gICAgcGFyZW50Tm9kZSA9IG93bmVyR3JhcGguZ2V0UGFyZW50KCk7XG5cbiAgICBpZiAocGFyZW50Tm9kZSA9PSBudWxsKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAocGFyZW50Tm9kZSA9PSBzZWNvbmROb2RlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBvd25lckdyYXBoID0gcGFyZW50Tm9kZS5nZXRPd25lcigpO1xuICAgIGlmIChvd25lckdyYXBoID09IG51bGwpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSB3aGlsZSAodHJ1ZSk7XG4gIC8vIElzIGZpcnN0IG5vZGUgYW4gYW5jZXN0b3Igb2YgdGhlIHNlY29uZCBvbmU/XG4gIG93bmVyR3JhcGggPSBzZWNvbmROb2RlLmdldE93bmVyKCk7XG5cbiAgZG8ge1xuICAgIHBhcmVudE5vZGUgPSBvd25lckdyYXBoLmdldFBhcmVudCgpO1xuXG4gICAgaWYgKHBhcmVudE5vZGUgPT0gbnVsbCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHBhcmVudE5vZGUgPT0gZmlyc3ROb2RlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBvd25lckdyYXBoID0gcGFyZW50Tm9kZS5nZXRPd25lcigpO1xuICAgIGlmIChvd25lckdyYXBoID09IG51bGwpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuY2FsY0xvd2VzdENvbW1vbkFuY2VzdG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVkZ2U7XG4gIHZhciBzb3VyY2VOb2RlO1xuICB2YXIgdGFyZ2V0Tm9kZTtcbiAgdmFyIHNvdXJjZUFuY2VzdG9yR3JhcGg7XG4gIHZhciB0YXJnZXRBbmNlc3RvckdyYXBoO1xuXG4gIHZhciBlZGdlcyA9IHRoaXMuZ2V0QWxsRWRnZXMoKTtcbiAgdmFyIHMgPSBlZGdlcy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgZWRnZSA9IGVkZ2VzW2ldO1xuXG4gICAgc291cmNlTm9kZSA9IGVkZ2Uuc291cmNlO1xuICAgIHRhcmdldE5vZGUgPSBlZGdlLnRhcmdldDtcbiAgICBlZGdlLmxjYSA9IG51bGw7XG4gICAgZWRnZS5zb3VyY2VJbkxjYSA9IHNvdXJjZU5vZGU7XG4gICAgZWRnZS50YXJnZXRJbkxjYSA9IHRhcmdldE5vZGU7XG5cbiAgICBpZiAoc291cmNlTm9kZSA9PSB0YXJnZXROb2RlKSB7XG4gICAgICBlZGdlLmxjYSA9IHNvdXJjZU5vZGUuZ2V0T3duZXIoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHNvdXJjZUFuY2VzdG9yR3JhcGggPSBzb3VyY2VOb2RlLmdldE93bmVyKCk7XG5cbiAgICB3aGlsZSAoZWRnZS5sY2EgPT0gbnVsbCkge1xuICAgICAgZWRnZS50YXJnZXRJbkxjYSA9IHRhcmdldE5vZGU7XG4gICAgICB0YXJnZXRBbmNlc3RvckdyYXBoID0gdGFyZ2V0Tm9kZS5nZXRPd25lcigpO1xuXG4gICAgICB3aGlsZSAoZWRnZS5sY2EgPT0gbnVsbCkge1xuICAgICAgICBpZiAodGFyZ2V0QW5jZXN0b3JHcmFwaCA9PSBzb3VyY2VBbmNlc3RvckdyYXBoKSB7XG4gICAgICAgICAgZWRnZS5sY2EgPSB0YXJnZXRBbmNlc3RvckdyYXBoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhcmdldEFuY2VzdG9yR3JhcGggPT0gdGhpcy5yb290R3JhcGgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlZGdlLmxjYSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgXCJhc3NlcnQgZmFpbGVkXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWRnZS50YXJnZXRJbkxjYSA9IHRhcmdldEFuY2VzdG9yR3JhcGguZ2V0UGFyZW50KCk7XG4gICAgICAgIHRhcmdldEFuY2VzdG9yR3JhcGggPSBlZGdlLnRhcmdldEluTGNhLmdldE93bmVyKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzb3VyY2VBbmNlc3RvckdyYXBoID09IHRoaXMucm9vdEdyYXBoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWRnZS5sY2EgPT0gbnVsbCkge1xuICAgICAgICBlZGdlLnNvdXJjZUluTGNhID0gc291cmNlQW5jZXN0b3JHcmFwaC5nZXRQYXJlbnQoKTtcbiAgICAgICAgc291cmNlQW5jZXN0b3JHcmFwaCA9IGVkZ2Uuc291cmNlSW5MY2EuZ2V0T3duZXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZWRnZS5sY2EgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJhc3NlcnQgZmFpbGVkXCI7XG4gICAgfVxuICB9XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5jYWxjTG93ZXN0Q29tbW9uQW5jZXN0b3IgPSBmdW5jdGlvbiAoZmlyc3ROb2RlLCBzZWNvbmROb2RlKSB7XG4gIGlmIChmaXJzdE5vZGUgPT0gc2Vjb25kTm9kZSkge1xuICAgIHJldHVybiBmaXJzdE5vZGUuZ2V0T3duZXIoKTtcbiAgfVxuICB2YXIgZmlyc3RPd25lckdyYXBoID0gZmlyc3ROb2RlLmdldE93bmVyKCk7XG5cbiAgZG8ge1xuICAgIGlmIChmaXJzdE93bmVyR3JhcGggPT0gbnVsbCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBzZWNvbmRPd25lckdyYXBoID0gc2Vjb25kTm9kZS5nZXRPd25lcigpO1xuXG4gICAgZG8ge1xuICAgICAgaWYgKHNlY29uZE93bmVyR3JhcGggPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHNlY29uZE93bmVyR3JhcGggPT0gZmlyc3RPd25lckdyYXBoKSB7XG4gICAgICAgIHJldHVybiBzZWNvbmRPd25lckdyYXBoO1xuICAgICAgfVxuICAgICAgc2Vjb25kT3duZXJHcmFwaCA9IHNlY29uZE93bmVyR3JhcGguZ2V0UGFyZW50KCkuZ2V0T3duZXIoKTtcbiAgICB9IHdoaWxlICh0cnVlKTtcblxuICAgIGZpcnN0T3duZXJHcmFwaCA9IGZpcnN0T3duZXJHcmFwaC5nZXRQYXJlbnQoKS5nZXRPd25lcigpO1xuICB9IHdoaWxlICh0cnVlKTtcblxuICByZXR1cm4gZmlyc3RPd25lckdyYXBoO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuY2FsY0luY2x1c2lvblRyZWVEZXB0aHMgPSBmdW5jdGlvbiAoZ3JhcGgsIGRlcHRoKSB7XG4gIGlmIChncmFwaCA9PSBudWxsICYmIGRlcHRoID09IG51bGwpIHtcbiAgICBncmFwaCA9IHRoaXMucm9vdEdyYXBoO1xuICAgIGRlcHRoID0gMTtcbiAgfVxuICB2YXIgbm9kZTtcblxuICB2YXIgbm9kZXMgPSBncmFwaC5nZXROb2RlcygpO1xuICB2YXIgcyA9IG5vZGVzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICBub2RlID0gbm9kZXNbaV07XG4gICAgbm9kZS5pbmNsdXNpb25UcmVlRGVwdGggPSBkZXB0aDtcblxuICAgIGlmIChub2RlLmNoaWxkICE9IG51bGwpIHtcbiAgICAgIHRoaXMuY2FsY0luY2x1c2lvblRyZWVEZXB0aHMobm9kZS5jaGlsZCwgZGVwdGggKyAxKTtcbiAgICB9XG4gIH1cbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmluY2x1ZGVzSW52YWxpZEVkZ2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlZGdlO1xuICB2YXIgZWRnZXNUb1JlbW92ZSA9IFtdO1xuXG4gIHZhciBzID0gdGhpcy5lZGdlcy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgZWRnZSA9IHRoaXMuZWRnZXNbaV07XG5cbiAgICBpZiAodGhpcy5pc09uZUFuY2VzdG9yT2ZPdGhlcihlZGdlLnNvdXJjZSwgZWRnZS50YXJnZXQpKSB7XG4gICAgICBlZGdlc1RvUmVtb3ZlLnB1c2goZWRnZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVtb3ZlIGludmFsaWQgZWRnZXMgZnJvbSBncmFwaCBtYW5hZ2VyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXNUb1JlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucmVtb3ZlKGVkZ2VzVG9SZW1vdmVbaV0pO1xuICB9XG5cbiAgLy8gSW52YWxpZCBlZGdlcyBhcmUgY2xlYXJlZCwgc28gcmV0dXJuIGZhbHNlXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTEdyYXBoTWFuYWdlcjtcblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKlxuICogVGhpcyBjbGFzcyBtYWludGFpbnMgYSBsaXN0IG9mIHN0YXRpYyBnZW9tZXRyeSByZWxhdGVkIHV0aWxpdHkgbWV0aG9kcy5cbiAqXG4gKlxuICogQ29weXJpZ2h0OiBpLVZpcyBSZXNlYXJjaCBHcm91cCwgQmlsa2VudCBVbml2ZXJzaXR5LCAyMDA3IC0gcHJlc2VudFxuICovXG5cbnZhciBQb2ludCA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xuXG5mdW5jdGlvbiBJR2VvbWV0cnkoKSB7fVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGNhbGN1bGF0ZXMgKmhhbGYqIHRoZSBhbW91bnQgaW4geCBhbmQgeSBkaXJlY3Rpb25zIG9mIHRoZSB0d29cbiAqIGlucHV0IHJlY3RhbmdsZXMgbmVlZGVkIHRvIHNlcGFyYXRlIHRoZW0ga2VlcGluZyB0aGVpciByZXNwZWN0aXZlXG4gKiBwb3NpdGlvbmluZywgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBpbiB0aGUgaW5wdXQgYXJyYXkuIEFuIGlucHV0XG4gKiBzZXBhcmF0aW9uIGJ1ZmZlciBhZGRlZCB0byB0aGUgYW1vdW50IGluIGJvdGggZGlyZWN0aW9ucy4gV2UgYXNzdW1lIHRoYXRcbiAqIHRoZSB0d28gcmVjdGFuZ2xlcyBkbyBpbnRlcnNlY3QuXG4gKi9cbklHZW9tZXRyeS5jYWxjU2VwYXJhdGlvbkFtb3VudCA9IGZ1bmN0aW9uIChyZWN0QSwgcmVjdEIsIG92ZXJsYXBBbW91bnQsIHNlcGFyYXRpb25CdWZmZXIpIHtcbiAgaWYgKCFyZWN0QS5pbnRlcnNlY3RzKHJlY3RCKSkge1xuICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICB9XG5cbiAgdmFyIGRpcmVjdGlvbnMgPSBuZXcgQXJyYXkoMik7XG5cbiAgdGhpcy5kZWNpZGVEaXJlY3Rpb25zRm9yT3ZlcmxhcHBpbmdOb2RlcyhyZWN0QSwgcmVjdEIsIGRpcmVjdGlvbnMpO1xuXG4gIG92ZXJsYXBBbW91bnRbMF0gPSBNYXRoLm1pbihyZWN0QS5nZXRSaWdodCgpLCByZWN0Qi5nZXRSaWdodCgpKSAtIE1hdGgubWF4KHJlY3RBLngsIHJlY3RCLngpO1xuICBvdmVybGFwQW1vdW50WzFdID0gTWF0aC5taW4ocmVjdEEuZ2V0Qm90dG9tKCksIHJlY3RCLmdldEJvdHRvbSgpKSAtIE1hdGgubWF4KHJlY3RBLnksIHJlY3RCLnkpO1xuXG4gIC8vIHVwZGF0ZSB0aGUgb3ZlcmxhcHBpbmcgYW1vdW50cyBmb3IgdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgaWYgKHJlY3RBLmdldFgoKSA8PSByZWN0Qi5nZXRYKCkgJiYgcmVjdEEuZ2V0UmlnaHQoKSA+PSByZWN0Qi5nZXRSaWdodCgpKSB7XG4gICAgLyogQ2FzZSB4LjE6XG4gICAgKlxuICAgICogcmVjdEFcbiAgICAqIFx0fCAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICogXHR8ICAgICAgICBfX19fX19fX18gICAgICB8XG4gICAgKiBcdHwgICAgICAgIHwgICAgICAgfCAgICAgIHxcbiAgICAqIFx0fF9fX19fX19ffF9fX19fX198X19fX19ffFxuICAgICogXHRcdFx0IHwgICAgICAgfFxuICAgICogICAgICAgICAgIHwgICAgICAgfFxuICAgICogICAgICAgIHJlY3RCXG4gICAgKi9cbiAgICBvdmVybGFwQW1vdW50WzBdICs9IE1hdGgubWluKHJlY3RCLmdldFgoKSAtIHJlY3RBLmdldFgoKSwgcmVjdEEuZ2V0UmlnaHQoKSAtIHJlY3RCLmdldFJpZ2h0KCkpO1xuICB9IGVsc2UgaWYgKHJlY3RCLmdldFgoKSA8PSByZWN0QS5nZXRYKCkgJiYgcmVjdEIuZ2V0UmlnaHQoKSA+PSByZWN0QS5nZXRSaWdodCgpKSB7XG4gICAgLyogQ2FzZSB4LjI6XG4gICAgKlxuICAgICogcmVjdEJcbiAgICAqIFx0fCAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICogXHR8ICAgICAgICBfX19fX19fX18gICAgICB8XG4gICAgKiBcdHwgICAgICAgIHwgICAgICAgfCAgICAgIHxcbiAgICAqIFx0fF9fX19fX19ffF9fX19fX198X19fX19ffFxuICAgICogXHRcdFx0IHwgICAgICAgfFxuICAgICogICAgICAgICAgIHwgICAgICAgfFxuICAgICogICAgICAgIHJlY3RBXG4gICAgKi9cbiAgICBvdmVybGFwQW1vdW50WzBdICs9IE1hdGgubWluKHJlY3RBLmdldFgoKSAtIHJlY3RCLmdldFgoKSwgcmVjdEIuZ2V0UmlnaHQoKSAtIHJlY3RBLmdldFJpZ2h0KCkpO1xuICB9XG4gIGlmIChyZWN0QS5nZXRZKCkgPD0gcmVjdEIuZ2V0WSgpICYmIHJlY3RBLmdldEJvdHRvbSgpID49IHJlY3RCLmdldEJvdHRvbSgpKSB7XG4gICAgLyogQ2FzZSB5LjE6XG4gICAgICogICAgICAgICAgX19fX19fX18gcmVjdEFcbiAgICAgKiAgICAgICAgIHxcbiAgICAgKiAgICAgICAgIHxcbiAgICAgKiAgIF9fX19fX3xfX19fICByZWN0QlxuICAgICAqICAgICAgICAgfCAgICB8XG4gICAgICogICAgICAgICB8ICAgIHxcbiAgICAgKiAgIF9fX19fX3xfX19ffFxuICAgICAqICAgICAgICAgfFxuICAgICAqICAgICAgICAgfFxuICAgICAqICAgICAgICAgfF9fX19fX19fXG4gICAgICpcbiAgICAgKi9cbiAgICBvdmVybGFwQW1vdW50WzFdICs9IE1hdGgubWluKHJlY3RCLmdldFkoKSAtIHJlY3RBLmdldFkoKSwgcmVjdEEuZ2V0Qm90dG9tKCkgLSByZWN0Qi5nZXRCb3R0b20oKSk7XG4gIH0gZWxzZSBpZiAocmVjdEIuZ2V0WSgpIDw9IHJlY3RBLmdldFkoKSAmJiByZWN0Qi5nZXRCb3R0b20oKSA+PSByZWN0QS5nZXRCb3R0b20oKSkge1xuICAgIC8qIENhc2UgeS4yOlxuICAgICogICAgICAgICAgX19fX19fX18gcmVjdEJcbiAgICAqICAgICAgICAgfFxuICAgICogICAgICAgICB8XG4gICAgKiAgIF9fX19fX3xfX19fICByZWN0QVxuICAgICogICAgICAgICB8ICAgIHxcbiAgICAqICAgICAgICAgfCAgICB8XG4gICAgKiAgIF9fX19fX3xfX19ffFxuICAgICogICAgICAgICB8XG4gICAgKiAgICAgICAgIHxcbiAgICAqICAgICAgICAgfF9fX19fX19fXG4gICAgKlxuICAgICovXG4gICAgb3ZlcmxhcEFtb3VudFsxXSArPSBNYXRoLm1pbihyZWN0QS5nZXRZKCkgLSByZWN0Qi5nZXRZKCksIHJlY3RCLmdldEJvdHRvbSgpIC0gcmVjdEEuZ2V0Qm90dG9tKCkpO1xuICB9XG5cbiAgLy8gZmluZCBzbG9wZSBvZiB0aGUgbGluZSBwYXNzZXMgdHdvIGNlbnRlcnNcbiAgdmFyIHNsb3BlID0gTWF0aC5hYnMoKHJlY3RCLmdldENlbnRlclkoKSAtIHJlY3RBLmdldENlbnRlclkoKSkgLyAocmVjdEIuZ2V0Q2VudGVyWCgpIC0gcmVjdEEuZ2V0Q2VudGVyWCgpKSk7XG4gIC8vIGlmIGNlbnRlcnMgYXJlIG92ZXJsYXBwZWRcbiAgaWYgKHJlY3RCLmdldENlbnRlclkoKSA9PT0gcmVjdEEuZ2V0Q2VudGVyWSgpICYmIHJlY3RCLmdldENlbnRlclgoKSA9PT0gcmVjdEEuZ2V0Q2VudGVyWCgpKSB7XG4gICAgLy8gYXNzdW1lIHRoZSBzbG9wZSBpcyAxICg0NSBkZWdyZWUpXG4gICAgc2xvcGUgPSAxLjA7XG4gIH1cblxuICB2YXIgbW92ZUJ5WSA9IHNsb3BlICogb3ZlcmxhcEFtb3VudFswXTtcbiAgdmFyIG1vdmVCeVggPSBvdmVybGFwQW1vdW50WzFdIC8gc2xvcGU7XG4gIGlmIChvdmVybGFwQW1vdW50WzBdIDwgbW92ZUJ5WCkge1xuICAgIG1vdmVCeVggPSBvdmVybGFwQW1vdW50WzBdO1xuICB9IGVsc2Uge1xuICAgIG1vdmVCeVkgPSBvdmVybGFwQW1vdW50WzFdO1xuICB9XG4gIC8vIHJldHVybiBoYWxmIHRoZSBhbW91bnQgc28gdGhhdCBpZiBlYWNoIHJlY3RhbmdsZSBpcyBtb3ZlZCBieSB0aGVzZVxuICAvLyBhbW91bnRzIGluIG9wcG9zaXRlIGRpcmVjdGlvbnMsIG92ZXJsYXAgd2lsbCBiZSByZXNvbHZlZFxuICBvdmVybGFwQW1vdW50WzBdID0gLTEgKiBkaXJlY3Rpb25zWzBdICogKG1vdmVCeVggLyAyICsgc2VwYXJhdGlvbkJ1ZmZlcik7XG4gIG92ZXJsYXBBbW91bnRbMV0gPSAtMSAqIGRpcmVjdGlvbnNbMV0gKiAobW92ZUJ5WSAvIDIgKyBzZXBhcmF0aW9uQnVmZmVyKTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgZGVjaWRlcyB0aGUgc2VwYXJhdGlvbiBkaXJlY3Rpb24gb2Ygb3ZlcmxhcHBpbmcgbm9kZXNcbiAqXG4gKiBpZiBkaXJlY3Rpb25zWzBdID0gLTEsIHRoZW4gcmVjdEEgZ29lcyBsZWZ0XG4gKiBpZiBkaXJlY3Rpb25zWzBdID0gMSwgIHRoZW4gcmVjdEEgZ29lcyByaWdodFxuICogaWYgZGlyZWN0aW9uc1sxXSA9IC0xLCB0aGVuIHJlY3RBIGdvZXMgdXBcbiAqIGlmIGRpcmVjdGlvbnNbMV0gPSAxLCAgdGhlbiByZWN0QSBnb2VzIGRvd25cbiAqL1xuSUdlb21ldHJ5LmRlY2lkZURpcmVjdGlvbnNGb3JPdmVybGFwcGluZ05vZGVzID0gZnVuY3Rpb24gKHJlY3RBLCByZWN0QiwgZGlyZWN0aW9ucykge1xuICBpZiAocmVjdEEuZ2V0Q2VudGVyWCgpIDwgcmVjdEIuZ2V0Q2VudGVyWCgpKSB7XG4gICAgZGlyZWN0aW9uc1swXSA9IC0xO1xuICB9IGVsc2Uge1xuICAgIGRpcmVjdGlvbnNbMF0gPSAxO1xuICB9XG5cbiAgaWYgKHJlY3RBLmdldENlbnRlclkoKSA8IHJlY3RCLmdldENlbnRlclkoKSkge1xuICAgIGRpcmVjdGlvbnNbMV0gPSAtMTtcbiAgfSBlbHNlIHtcbiAgICBkaXJlY3Rpb25zWzFdID0gMTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBjYWxjdWxhdGVzIHRoZSBpbnRlcnNlY3Rpb24gKGNsaXBwaW5nKSBwb2ludHMgb2YgdGhlIHR3b1xuICogaW5wdXQgcmVjdGFuZ2xlcyB3aXRoIGxpbmUgc2VnbWVudCBkZWZpbmVkIGJ5IHRoZSBjZW50ZXJzIG9mIHRoZXNlIHR3b1xuICogcmVjdGFuZ2xlcy4gVGhlIGNsaXBwaW5nIHBvaW50cyBhcmUgc2F2ZWQgaW4gdGhlIGlucHV0IGRvdWJsZSBhcnJheSBhbmRcbiAqIHdoZXRoZXIgb3Igbm90IHRoZSB0d28gcmVjdGFuZ2xlcyBvdmVybGFwIGlzIHJldHVybmVkLlxuICovXG5JR2VvbWV0cnkuZ2V0SW50ZXJzZWN0aW9uMiA9IGZ1bmN0aW9uIChyZWN0QSwgcmVjdEIsIHJlc3VsdCkge1xuICAvL3Jlc3VsdFswLTFdIHdpbGwgY29udGFpbiBjbGlwUG9pbnQgb2YgcmVjdEEsIHJlc3VsdFsyLTNdIHdpbGwgY29udGFpbiBjbGlwUG9pbnQgb2YgcmVjdEJcbiAgdmFyIHAxeCA9IHJlY3RBLmdldENlbnRlclgoKTtcbiAgdmFyIHAxeSA9IHJlY3RBLmdldENlbnRlclkoKTtcbiAgdmFyIHAyeCA9IHJlY3RCLmdldENlbnRlclgoKTtcbiAgdmFyIHAyeSA9IHJlY3RCLmdldENlbnRlclkoKTtcblxuICAvL2lmIHR3byByZWN0YW5nbGVzIGludGVyc2VjdCwgdGhlbiBjbGlwcGluZyBwb2ludHMgYXJlIGNlbnRlcnNcbiAgaWYgKHJlY3RBLmludGVyc2VjdHMocmVjdEIpKSB7XG4gICAgcmVzdWx0WzBdID0gcDF4O1xuICAgIHJlc3VsdFsxXSA9IHAxeTtcbiAgICByZXN1bHRbMl0gPSBwMng7XG4gICAgcmVzdWx0WzNdID0gcDJ5O1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vdmFyaWFibGVzIGZvciByZWN0QVxuICB2YXIgdG9wTGVmdEF4ID0gcmVjdEEuZ2V0WCgpO1xuICB2YXIgdG9wTGVmdEF5ID0gcmVjdEEuZ2V0WSgpO1xuICB2YXIgdG9wUmlnaHRBeCA9IHJlY3RBLmdldFJpZ2h0KCk7XG4gIHZhciBib3R0b21MZWZ0QXggPSByZWN0QS5nZXRYKCk7XG4gIHZhciBib3R0b21MZWZ0QXkgPSByZWN0QS5nZXRCb3R0b20oKTtcbiAgdmFyIGJvdHRvbVJpZ2h0QXggPSByZWN0QS5nZXRSaWdodCgpO1xuICB2YXIgaGFsZldpZHRoQSA9IHJlY3RBLmdldFdpZHRoSGFsZigpO1xuICB2YXIgaGFsZkhlaWdodEEgPSByZWN0QS5nZXRIZWlnaHRIYWxmKCk7XG4gIC8vdmFyaWFibGVzIGZvciByZWN0QlxuICB2YXIgdG9wTGVmdEJ4ID0gcmVjdEIuZ2V0WCgpO1xuICB2YXIgdG9wTGVmdEJ5ID0gcmVjdEIuZ2V0WSgpO1xuICB2YXIgdG9wUmlnaHRCeCA9IHJlY3RCLmdldFJpZ2h0KCk7XG4gIHZhciBib3R0b21MZWZ0QnggPSByZWN0Qi5nZXRYKCk7XG4gIHZhciBib3R0b21MZWZ0QnkgPSByZWN0Qi5nZXRCb3R0b20oKTtcbiAgdmFyIGJvdHRvbVJpZ2h0QnggPSByZWN0Qi5nZXRSaWdodCgpO1xuICB2YXIgaGFsZldpZHRoQiA9IHJlY3RCLmdldFdpZHRoSGFsZigpO1xuICB2YXIgaGFsZkhlaWdodEIgPSByZWN0Qi5nZXRIZWlnaHRIYWxmKCk7XG5cbiAgLy9mbGFnIHdoZXRoZXIgY2xpcHBpbmcgcG9pbnRzIGFyZSBmb3VuZFxuICB2YXIgY2xpcFBvaW50QUZvdW5kID0gZmFsc2U7XG4gIHZhciBjbGlwUG9pbnRCRm91bmQgPSBmYWxzZTtcblxuICAvLyBsaW5lIGlzIHZlcnRpY2FsXG4gIGlmIChwMXggPT09IHAyeCkge1xuICAgIGlmIChwMXkgPiBwMnkpIHtcbiAgICAgIHJlc3VsdFswXSA9IHAxeDtcbiAgICAgIHJlc3VsdFsxXSA9IHRvcExlZnRBeTtcbiAgICAgIHJlc3VsdFsyXSA9IHAyeDtcbiAgICAgIHJlc3VsdFszXSA9IGJvdHRvbUxlZnRCeTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHAxeSA8IHAyeSkge1xuICAgICAgcmVzdWx0WzBdID0gcDF4O1xuICAgICAgcmVzdWx0WzFdID0gYm90dG9tTGVmdEF5O1xuICAgICAgcmVzdWx0WzJdID0gcDJ4O1xuICAgICAgcmVzdWx0WzNdID0gdG9wTGVmdEJ5O1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL25vdCBsaW5lLCByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgLy8gbGluZSBpcyBob3Jpem9udGFsXG4gIGVsc2UgaWYgKHAxeSA9PT0gcDJ5KSB7XG4gICAgICBpZiAocDF4ID4gcDJ4KSB7XG4gICAgICAgIHJlc3VsdFswXSA9IHRvcExlZnRBeDtcbiAgICAgICAgcmVzdWx0WzFdID0gcDF5O1xuICAgICAgICByZXN1bHRbMl0gPSB0b3BSaWdodEJ4O1xuICAgICAgICByZXN1bHRbM10gPSBwMnk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAocDF4IDwgcDJ4KSB7XG4gICAgICAgIHJlc3VsdFswXSA9IHRvcFJpZ2h0QXg7XG4gICAgICAgIHJlc3VsdFsxXSA9IHAxeTtcbiAgICAgICAgcmVzdWx0WzJdID0gdG9wTGVmdEJ4O1xuICAgICAgICByZXN1bHRbM10gPSBwMnk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vbm90IHZhbGlkIGxpbmUsIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvL3Nsb3BlcyBvZiByZWN0QSdzIGFuZCByZWN0QidzIGRpYWdvbmFsc1xuICAgICAgdmFyIHNsb3BlQSA9IHJlY3RBLmhlaWdodCAvIHJlY3RBLndpZHRoO1xuICAgICAgdmFyIHNsb3BlQiA9IHJlY3RCLmhlaWdodCAvIHJlY3RCLndpZHRoO1xuXG4gICAgICAvL3Nsb3BlIG9mIGxpbmUgYmV0d2VlbiBjZW50ZXIgb2YgcmVjdEEgYW5kIGNlbnRlciBvZiByZWN0QlxuICAgICAgdmFyIHNsb3BlUHJpbWUgPSAocDJ5IC0gcDF5KSAvIChwMnggLSBwMXgpO1xuICAgICAgdmFyIGNhcmRpbmFsRGlyZWN0aW9uQSA9IHZvaWQgMDtcbiAgICAgIHZhciBjYXJkaW5hbERpcmVjdGlvbkIgPSB2b2lkIDA7XG4gICAgICB2YXIgdGVtcFBvaW50QXggPSB2b2lkIDA7XG4gICAgICB2YXIgdGVtcFBvaW50QXkgPSB2b2lkIDA7XG4gICAgICB2YXIgdGVtcFBvaW50QnggPSB2b2lkIDA7XG4gICAgICB2YXIgdGVtcFBvaW50QnkgPSB2b2lkIDA7XG5cbiAgICAgIC8vZGV0ZXJtaW5lIHdoZXRoZXIgY2xpcHBpbmcgcG9pbnQgaXMgdGhlIGNvcm5lciBvZiBub2RlQVxuICAgICAgaWYgKC1zbG9wZUEgPT09IHNsb3BlUHJpbWUpIHtcbiAgICAgICAgaWYgKHAxeCA+IHAyeCkge1xuICAgICAgICAgIHJlc3VsdFswXSA9IGJvdHRvbUxlZnRBeDtcbiAgICAgICAgICByZXN1bHRbMV0gPSBib3R0b21MZWZ0QXk7XG4gICAgICAgICAgY2xpcFBvaW50QUZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbMF0gPSB0b3BSaWdodEF4O1xuICAgICAgICAgIHJlc3VsdFsxXSA9IHRvcExlZnRBeTtcbiAgICAgICAgICBjbGlwUG9pbnRBRm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNsb3BlQSA9PT0gc2xvcGVQcmltZSkge1xuICAgICAgICBpZiAocDF4ID4gcDJ4KSB7XG4gICAgICAgICAgcmVzdWx0WzBdID0gdG9wTGVmdEF4O1xuICAgICAgICAgIHJlc3VsdFsxXSA9IHRvcExlZnRBeTtcbiAgICAgICAgICBjbGlwUG9pbnRBRm91bmQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFswXSA9IGJvdHRvbVJpZ2h0QXg7XG4gICAgICAgICAgcmVzdWx0WzFdID0gYm90dG9tTGVmdEF5O1xuICAgICAgICAgIGNsaXBQb2ludEFGb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy9kZXRlcm1pbmUgd2hldGhlciBjbGlwcGluZyBwb2ludCBpcyB0aGUgY29ybmVyIG9mIG5vZGVCXG4gICAgICBpZiAoLXNsb3BlQiA9PT0gc2xvcGVQcmltZSkge1xuICAgICAgICBpZiAocDJ4ID4gcDF4KSB7XG4gICAgICAgICAgcmVzdWx0WzJdID0gYm90dG9tTGVmdEJ4O1xuICAgICAgICAgIHJlc3VsdFszXSA9IGJvdHRvbUxlZnRCeTtcbiAgICAgICAgICBjbGlwUG9pbnRCRm91bmQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFsyXSA9IHRvcFJpZ2h0Qng7XG4gICAgICAgICAgcmVzdWx0WzNdID0gdG9wTGVmdEJ5O1xuICAgICAgICAgIGNsaXBQb2ludEJGb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2xvcGVCID09PSBzbG9wZVByaW1lKSB7XG4gICAgICAgIGlmIChwMnggPiBwMXgpIHtcbiAgICAgICAgICByZXN1bHRbMl0gPSB0b3BMZWZ0Qng7XG4gICAgICAgICAgcmVzdWx0WzNdID0gdG9wTGVmdEJ5O1xuICAgICAgICAgIGNsaXBQb2ludEJGb3VuZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0WzJdID0gYm90dG9tUmlnaHRCeDtcbiAgICAgICAgICByZXN1bHRbM10gPSBib3R0b21MZWZ0Qnk7XG4gICAgICAgICAgY2xpcFBvaW50QkZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvL2lmIGJvdGggY2xpcHBpbmcgcG9pbnRzIGFyZSBjb3JuZXJzXG4gICAgICBpZiAoY2xpcFBvaW50QUZvdW5kICYmIGNsaXBQb2ludEJGb3VuZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vZGV0ZXJtaW5lIENhcmRpbmFsIERpcmVjdGlvbiBvZiByZWN0YW5nbGVzXG4gICAgICBpZiAocDF4ID4gcDJ4KSB7XG4gICAgICAgIGlmIChwMXkgPiBwMnkpIHtcbiAgICAgICAgICBjYXJkaW5hbERpcmVjdGlvbkEgPSB0aGlzLmdldENhcmRpbmFsRGlyZWN0aW9uKHNsb3BlQSwgc2xvcGVQcmltZSwgNCk7XG4gICAgICAgICAgY2FyZGluYWxEaXJlY3Rpb25CID0gdGhpcy5nZXRDYXJkaW5hbERpcmVjdGlvbihzbG9wZUIsIHNsb3BlUHJpbWUsIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhcmRpbmFsRGlyZWN0aW9uQSA9IHRoaXMuZ2V0Q2FyZGluYWxEaXJlY3Rpb24oLXNsb3BlQSwgc2xvcGVQcmltZSwgMyk7XG4gICAgICAgICAgY2FyZGluYWxEaXJlY3Rpb25CID0gdGhpcy5nZXRDYXJkaW5hbERpcmVjdGlvbigtc2xvcGVCLCBzbG9wZVByaW1lLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHAxeSA+IHAyeSkge1xuICAgICAgICAgIGNhcmRpbmFsRGlyZWN0aW9uQSA9IHRoaXMuZ2V0Q2FyZGluYWxEaXJlY3Rpb24oLXNsb3BlQSwgc2xvcGVQcmltZSwgMSk7XG4gICAgICAgICAgY2FyZGluYWxEaXJlY3Rpb25CID0gdGhpcy5nZXRDYXJkaW5hbERpcmVjdGlvbigtc2xvcGVCLCBzbG9wZVByaW1lLCAzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXJkaW5hbERpcmVjdGlvbkEgPSB0aGlzLmdldENhcmRpbmFsRGlyZWN0aW9uKHNsb3BlQSwgc2xvcGVQcmltZSwgMik7XG4gICAgICAgICAgY2FyZGluYWxEaXJlY3Rpb25CID0gdGhpcy5nZXRDYXJkaW5hbERpcmVjdGlvbihzbG9wZUIsIHNsb3BlUHJpbWUsIDQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL2NhbGN1bGF0ZSBjbGlwcGluZyBQb2ludCBpZiBpdCBpcyBub3QgZm91bmQgYmVmb3JlXG4gICAgICBpZiAoIWNsaXBQb2ludEFGb3VuZCkge1xuICAgICAgICBzd2l0Y2ggKGNhcmRpbmFsRGlyZWN0aW9uQSkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHRlbXBQb2ludEF5ID0gdG9wTGVmdEF5O1xuICAgICAgICAgICAgdGVtcFBvaW50QXggPSBwMXggKyAtaGFsZkhlaWdodEEgLyBzbG9wZVByaW1lO1xuICAgICAgICAgICAgcmVzdWx0WzBdID0gdGVtcFBvaW50QXg7XG4gICAgICAgICAgICByZXN1bHRbMV0gPSB0ZW1wUG9pbnRBeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRlbXBQb2ludEF4ID0gYm90dG9tUmlnaHRBeDtcbiAgICAgICAgICAgIHRlbXBQb2ludEF5ID0gcDF5ICsgaGFsZldpZHRoQSAqIHNsb3BlUHJpbWU7XG4gICAgICAgICAgICByZXN1bHRbMF0gPSB0ZW1wUG9pbnRBeDtcbiAgICAgICAgICAgIHJlc3VsdFsxXSA9IHRlbXBQb2ludEF5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgdGVtcFBvaW50QXkgPSBib3R0b21MZWZ0QXk7XG4gICAgICAgICAgICB0ZW1wUG9pbnRBeCA9IHAxeCArIGhhbGZIZWlnaHRBIC8gc2xvcGVQcmltZTtcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IHRlbXBQb2ludEF4O1xuICAgICAgICAgICAgcmVzdWx0WzFdID0gdGVtcFBvaW50QXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB0ZW1wUG9pbnRBeCA9IGJvdHRvbUxlZnRBeDtcbiAgICAgICAgICAgIHRlbXBQb2ludEF5ID0gcDF5ICsgLWhhbGZXaWR0aEEgKiBzbG9wZVByaW1lO1xuICAgICAgICAgICAgcmVzdWx0WzBdID0gdGVtcFBvaW50QXg7XG4gICAgICAgICAgICByZXN1bHRbMV0gPSB0ZW1wUG9pbnRBeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWNsaXBQb2ludEJGb3VuZCkge1xuICAgICAgICBzd2l0Y2ggKGNhcmRpbmFsRGlyZWN0aW9uQikge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHRlbXBQb2ludEJ5ID0gdG9wTGVmdEJ5O1xuICAgICAgICAgICAgdGVtcFBvaW50QnggPSBwMnggKyAtaGFsZkhlaWdodEIgLyBzbG9wZVByaW1lO1xuICAgICAgICAgICAgcmVzdWx0WzJdID0gdGVtcFBvaW50Qng7XG4gICAgICAgICAgICByZXN1bHRbM10gPSB0ZW1wUG9pbnRCeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRlbXBQb2ludEJ4ID0gYm90dG9tUmlnaHRCeDtcbiAgICAgICAgICAgIHRlbXBQb2ludEJ5ID0gcDJ5ICsgaGFsZldpZHRoQiAqIHNsb3BlUHJpbWU7XG4gICAgICAgICAgICByZXN1bHRbMl0gPSB0ZW1wUG9pbnRCeDtcbiAgICAgICAgICAgIHJlc3VsdFszXSA9IHRlbXBQb2ludEJ5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgdGVtcFBvaW50QnkgPSBib3R0b21MZWZ0Qnk7XG4gICAgICAgICAgICB0ZW1wUG9pbnRCeCA9IHAyeCArIGhhbGZIZWlnaHRCIC8gc2xvcGVQcmltZTtcbiAgICAgICAgICAgIHJlc3VsdFsyXSA9IHRlbXBQb2ludEJ4O1xuICAgICAgICAgICAgcmVzdWx0WzNdID0gdGVtcFBvaW50Qnk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB0ZW1wUG9pbnRCeCA9IGJvdHRvbUxlZnRCeDtcbiAgICAgICAgICAgIHRlbXBQb2ludEJ5ID0gcDJ5ICsgLWhhbGZXaWR0aEIgKiBzbG9wZVByaW1lO1xuICAgICAgICAgICAgcmVzdWx0WzJdID0gdGVtcFBvaW50Qng7XG4gICAgICAgICAgICByZXN1bHRbM10gPSB0ZW1wUG9pbnRCeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgaW4gd2hpY2ggY2FyZGluYWwgZGlyZWN0aW9uIGRvZXMgaW5wdXQgcG9pbnQgc3RheXNcbiAqIDE6IE5vcnRoXG4gKiAyOiBFYXN0XG4gKiAzOiBTb3V0aFxuICogNDogV2VzdFxuICovXG5JR2VvbWV0cnkuZ2V0Q2FyZGluYWxEaXJlY3Rpb24gPSBmdW5jdGlvbiAoc2xvcGUsIHNsb3BlUHJpbWUsIGxpbmUpIHtcbiAgaWYgKHNsb3BlID4gc2xvcGVQcmltZSkge1xuICAgIHJldHVybiBsaW5lO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAxICsgbGluZSAlIDQ7XG4gIH1cbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgY2FsY3VsYXRlcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSB0d28gbGluZXMgZGVmaW5lZCBieVxuICogcG9pbnQgcGFpcnMgKHMxLHMyKSBhbmQgKGYxLGYyKS5cbiAqL1xuSUdlb21ldHJ5LmdldEludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIChzMSwgczIsIGYxLCBmMikge1xuICBpZiAoZjIgPT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLmdldEludGVyc2VjdGlvbjIoczEsIHMyLCBmMSk7XG4gIH1cblxuICB2YXIgeDEgPSBzMS54O1xuICB2YXIgeTEgPSBzMS55O1xuICB2YXIgeDIgPSBzMi54O1xuICB2YXIgeTIgPSBzMi55O1xuICB2YXIgeDMgPSBmMS54O1xuICB2YXIgeTMgPSBmMS55O1xuICB2YXIgeDQgPSBmMi54O1xuICB2YXIgeTQgPSBmMi55O1xuICB2YXIgeCA9IHZvaWQgMCxcbiAgICAgIHkgPSB2b2lkIDA7IC8vIGludGVyc2VjdGlvbiBwb2ludFxuICB2YXIgYTEgPSB2b2lkIDAsXG4gICAgICBhMiA9IHZvaWQgMCxcbiAgICAgIGIxID0gdm9pZCAwLFxuICAgICAgYjIgPSB2b2lkIDAsXG4gICAgICBjMSA9IHZvaWQgMCxcbiAgICAgIGMyID0gdm9pZCAwOyAvLyBjb2VmZmljaWVudHMgb2YgbGluZSBlcW5zLlxuICB2YXIgZGVub20gPSB2b2lkIDA7XG5cbiAgYTEgPSB5MiAtIHkxO1xuICBiMSA9IHgxIC0geDI7XG4gIGMxID0geDIgKiB5MSAtIHgxICogeTI7IC8vIHsgYTEqeCArIGIxKnkgKyBjMSA9IDAgaXMgbGluZSAxIH1cblxuICBhMiA9IHk0IC0geTM7XG4gIGIyID0geDMgLSB4NDtcbiAgYzIgPSB4NCAqIHkzIC0geDMgKiB5NDsgLy8geyBhMip4ICsgYjIqeSArIGMyID0gMCBpcyBsaW5lIDIgfVxuXG4gIGRlbm9tID0gYTEgKiBiMiAtIGEyICogYjE7XG5cbiAgaWYgKGRlbm9tID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB4ID0gKGIxICogYzIgLSBiMiAqIGMxKSAvIGRlbm9tO1xuICB5ID0gKGEyICogYzEgLSBhMSAqIGMyKSAvIGRlbm9tO1xuXG4gIHJldHVybiBuZXcgUG9pbnQoeCwgeSk7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGZpbmRzIGFuZCByZXR1cm5zIHRoZSBhbmdsZSBvZiB0aGUgdmVjdG9yIGZyb20gdGhlICsgeC1heGlzXG4gKiBpbiBjbG9ja3dpc2UgZGlyZWN0aW9uIChjb21wYXRpYmxlIHcvIEphdmEgY29vcmRpbmF0ZSBzeXN0ZW0hKS5cbiAqL1xuSUdlb21ldHJ5LmFuZ2xlT2ZWZWN0b3IgPSBmdW5jdGlvbiAoQ3gsIEN5LCBOeCwgTnkpIHtcbiAgdmFyIENfYW5nbGUgPSB2b2lkIDA7XG5cbiAgaWYgKEN4ICE9PSBOeCkge1xuICAgIENfYW5nbGUgPSBNYXRoLmF0YW4oKE55IC0gQ3kpIC8gKE54IC0gQ3gpKTtcblxuICAgIGlmIChOeCA8IEN4KSB7XG4gICAgICBDX2FuZ2xlICs9IE1hdGguUEk7XG4gICAgfSBlbHNlIGlmIChOeSA8IEN5KSB7XG4gICAgICBDX2FuZ2xlICs9IHRoaXMuVFdPX1BJO1xuICAgIH1cbiAgfSBlbHNlIGlmIChOeSA8IEN5KSB7XG4gICAgQ19hbmdsZSA9IHRoaXMuT05FX0FORF9IQUxGX1BJOyAvLyAyNzAgZGVncmVlc1xuICB9IGVsc2Uge1xuICAgIENfYW5nbGUgPSB0aGlzLkhBTEZfUEk7IC8vIDkwIGRlZ3JlZXNcbiAgfVxuXG4gIHJldHVybiBDX2FuZ2xlO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBjaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdHdvIGxpbmUgc2VnbWVudHMgKG9uZSB3aXRoIHBvaW50XG4gKiBwMSBhbmQgcDIsIHRoZSBvdGhlciB3aXRoIHBvaW50IHAzIGFuZCBwNCkgaW50ZXJzZWN0IGF0IGEgcG9pbnQgb3RoZXJcbiAqIHRoYW4gdGhlc2UgcG9pbnRzLlxuICovXG5JR2VvbWV0cnkuZG9JbnRlcnNlY3QgPSBmdW5jdGlvbiAocDEsIHAyLCBwMywgcDQpIHtcbiAgdmFyIGEgPSBwMS54O1xuICB2YXIgYiA9IHAxLnk7XG4gIHZhciBjID0gcDIueDtcbiAgdmFyIGQgPSBwMi55O1xuICB2YXIgcCA9IHAzLng7XG4gIHZhciBxID0gcDMueTtcbiAgdmFyIHIgPSBwNC54O1xuICB2YXIgcyA9IHA0Lnk7XG4gIHZhciBkZXQgPSAoYyAtIGEpICogKHMgLSBxKSAtIChyIC0gcCkgKiAoZCAtIGIpO1xuXG4gIGlmIChkZXQgPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxhbWJkYSA9ICgocyAtIHEpICogKHIgLSBhKSArIChwIC0gcikgKiAocyAtIGIpKSAvIGRldDtcbiAgICB2YXIgZ2FtbWEgPSAoKGIgLSBkKSAqIChyIC0gYSkgKyAoYyAtIGEpICogKHMgLSBiKSkgLyBkZXQ7XG4gICAgcmV0dXJuIDAgPCBsYW1iZGEgJiYgbGFtYmRhIDwgMSAmJiAwIDwgZ2FtbWEgJiYgZ2FtbWEgPCAxO1xuICB9XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGNoZWNrcyBhbmQgY2FsY3VsYXRlcyB0aGUgaW50ZXJzZWN0aW9uIG9mIFxuICogYSBsaW5lIHNlZ21lbnQgYW5kIGEgY2lyY2xlLlxuICovXG5JR2VvbWV0cnkuZmluZENpcmNsZUxpbmVJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gKEV4LCBFeSwgTHgsIEx5LCBDeCwgQ3ksIHIpIHtcblxuICAvLyBFIGlzIHRoZSBzdGFydGluZyBwb2ludCBvZiB0aGUgcmF5LFxuICAvLyBMIGlzIHRoZSBlbmQgcG9pbnQgb2YgdGhlIHJheSxcbiAgLy8gQyBpcyB0aGUgY2VudGVyIG9mIHNwaGVyZSB5b3UncmUgdGVzdGluZyBhZ2FpbnN0XG4gIC8vIHIgaXMgdGhlIHJhZGl1cyBvZiB0aGF0IHNwaGVyZVxuXG4gIC8vIENvbXB1dGU6XG4gIC8vIGQgPSBMIC0gRSAoIERpcmVjdGlvbiB2ZWN0b3Igb2YgcmF5LCBmcm9tIHN0YXJ0IHRvIGVuZCApXG4gIC8vIGYgPSBFIC0gQyAoIFZlY3RvciBmcm9tIGNlbnRlciBzcGhlcmUgdG8gcmF5IHN0YXJ0IClcblxuICAvLyBUaGVuIHRoZSBpbnRlcnNlY3Rpb24gaXMgZm91bmQgYnkuLlxuICAvLyBQID0gRSArIHQgKiBkXG4gIC8vIFRoaXMgaXMgYSBwYXJhbWV0cmljIGVxdWF0aW9uOlxuICAvLyBQeCA9IEV4ICsgdGR4XG4gIC8vIFB5ID0gRXkgKyB0ZHlcblxuICAvLyBnZXQgYSwgYiwgYyB2YWx1ZXNcbiAgdmFyIGEgPSAoTHggLSBFeCkgKiAoTHggLSBFeCkgKyAoTHkgLSBFeSkgKiAoTHkgLSBFeSk7XG4gIHZhciBiID0gMiAqICgoRXggLSBDeCkgKiAoTHggLSBFeCkgKyAoRXkgLSBDeSkgKiAoTHkgLSBFeSkpO1xuICB2YXIgYyA9IChFeCAtIEN4KSAqIChFeCAtIEN4KSArIChFeSAtIEN5KSAqIChFeSAtIEN5KSAtIHIgKiByO1xuXG4gIC8vIGdldCBkaXNjcmltaW5hbnRcbiAgdmFyIGRpc2MgPSBiICogYiAtIDQgKiBhICogYztcbiAgaWYgKGRpc2MgPj0gMCkge1xuICAgIC8vIGluc2VydCBpbnRvIHF1YWRyYXRpYyBmb3JtdWxhXG4gICAgdmFyIHQxID0gKC1iICsgTWF0aC5zcXJ0KGIgKiBiIC0gNCAqIGEgKiBjKSkgLyAoMiAqIGEpO1xuICAgIHZhciB0MiA9ICgtYiAtIE1hdGguc3FydChiICogYiAtIDQgKiBhICogYykpIC8gKDIgKiBhKTtcbiAgICB2YXIgaW50ZXJzZWN0aW9ucyA9IG51bGw7XG4gICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgLy8gdDEgaXMgdGhlIGludGVyc2VjdGlvbiwgYW5kIGl0J3MgY2xvc2VyIHRoYW4gdDJcbiAgICAgIC8vIChzaW5jZSB0MSB1c2VzIC1iIC0gZGlzY3JpbWluYW50KVxuICAgICAgLy8gSW1wYWxlLCBQb2tlXG4gICAgICByZXR1cm4gW3QxXTtcbiAgICB9XG5cbiAgICAvLyBoZXJlIHQxIGRpZG4ndCBpbnRlcnNlY3Qgc28gd2UgYXJlIGVpdGhlciBzdGFydGVkXG4gICAgLy8gaW5zaWRlIHRoZSBzcGhlcmUgb3IgY29tcGxldGVseSBwYXN0IGl0XG4gICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgLy8gRXhpdFdvdW5kXG4gICAgICByZXR1cm4gW3QyXTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbiAgfSBlbHNlIHJldHVybiBudWxsO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFNlY3Rpb246IENsYXNzIENvbnN0YW50c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogU29tZSB1c2VmdWwgcHJlLWNhbGN1bGF0ZWQgY29uc3RhbnRzXG4gKi9cbklHZW9tZXRyeS5IQUxGX1BJID0gMC41ICogTWF0aC5QSTtcbklHZW9tZXRyeS5PTkVfQU5EX0hBTEZfUEkgPSAxLjUgKiBNYXRoLlBJO1xuSUdlb21ldHJ5LlRXT19QSSA9IDIuMCAqIE1hdGguUEk7XG5JR2VvbWV0cnkuVEhSRUVfUEkgPSAzLjAgKiBNYXRoLlBJO1xuXG5tb2R1bGUuZXhwb3J0cyA9IElHZW9tZXRyeTtcblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIElNYXRoKCkge31cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBzaWduIG9mIHRoZSBpbnB1dCB2YWx1ZS5cbiAqL1xuSU1hdGguc2lnbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAodmFsdWUgPiAwKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAodmFsdWUgPCAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG5JTWF0aC5mbG9vciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPCAwID8gTWF0aC5jZWlsKHZhbHVlKSA6IE1hdGguZmxvb3IodmFsdWUpO1xufTtcblxuSU1hdGguY2VpbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPCAwID8gTWF0aC5mbG9vcih2YWx1ZSkgOiBNYXRoLmNlaWwodmFsdWUpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJTWF0aDtcblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBJbnRlZ2VyKCkge31cblxuSW50ZWdlci5NQVhfVkFMVUUgPSAyMTQ3NDgzNjQ3O1xuSW50ZWdlci5NSU5fVkFMVUUgPSAtMjE0NzQ4MzY0ODtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlZ2VyO1xuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBub2RlRnJvbSA9IGZ1bmN0aW9uIG5vZGVGcm9tKHZhbHVlKSB7XG4gIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgbmV4dDogbnVsbCwgcHJldjogbnVsbCB9O1xufTtcblxudmFyIGFkZCA9IGZ1bmN0aW9uIGFkZChwcmV2LCBub2RlLCBuZXh0LCBsaXN0KSB7XG4gIGlmIChwcmV2ICE9PSBudWxsKSB7XG4gICAgcHJldi5uZXh0ID0gbm9kZTtcbiAgfSBlbHNlIHtcbiAgICBsaXN0LmhlYWQgPSBub2RlO1xuICB9XG5cbiAgaWYgKG5leHQgIT09IG51bGwpIHtcbiAgICBuZXh0LnByZXYgPSBub2RlO1xuICB9IGVsc2Uge1xuICAgIGxpc3QudGFpbCA9IG5vZGU7XG4gIH1cblxuICBub2RlLnByZXYgPSBwcmV2O1xuICBub2RlLm5leHQgPSBuZXh0O1xuXG4gIGxpc3QubGVuZ3RoKys7XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG52YXIgX3JlbW92ZSA9IGZ1bmN0aW9uIF9yZW1vdmUobm9kZSwgbGlzdCkge1xuICB2YXIgcHJldiA9IG5vZGUucHJldixcbiAgICAgIG5leHQgPSBub2RlLm5leHQ7XG5cblxuICBpZiAocHJldiAhPT0gbnVsbCkge1xuICAgIHByZXYubmV4dCA9IG5leHQ7XG4gIH0gZWxzZSB7XG4gICAgbGlzdC5oZWFkID0gbmV4dDtcbiAgfVxuXG4gIGlmIChuZXh0ICE9PSBudWxsKSB7XG4gICAgbmV4dC5wcmV2ID0gcHJldjtcbiAgfSBlbHNlIHtcbiAgICBsaXN0LnRhaWwgPSBwcmV2O1xuICB9XG5cbiAgbm9kZS5wcmV2ID0gbm9kZS5uZXh0ID0gbnVsbDtcblxuICBsaXN0Lmxlbmd0aC0tO1xuXG4gIHJldHVybiBub2RlO1xufTtcblxudmFyIExpbmtlZExpc3QgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExpbmtlZExpc3QodmFscykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGlua2VkTGlzdCk7XG5cbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuXG4gICAgaWYgKHZhbHMgIT0gbnVsbCkge1xuICAgICAgdmFscy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5wdXNoKHYpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExpbmtlZExpc3QsIFt7XG4gICAga2V5OiBcInNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2l6ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0QmVmb3JlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEJlZm9yZSh2YWwsIG90aGVyTm9kZSkge1xuICAgICAgcmV0dXJuIGFkZChvdGhlck5vZGUucHJldiwgbm9kZUZyb20odmFsKSwgb3RoZXJOb2RlLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0QWZ0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0QWZ0ZXIodmFsLCBvdGhlck5vZGUpIHtcbiAgICAgIHJldHVybiBhZGQob3RoZXJOb2RlLCBub2RlRnJvbSh2YWwpLCBvdGhlck5vZGUubmV4dCwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluc2VydE5vZGVCZWZvcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0Tm9kZUJlZm9yZShuZXdOb2RlLCBvdGhlck5vZGUpIHtcbiAgICAgIHJldHVybiBhZGQob3RoZXJOb2RlLnByZXYsIG5ld05vZGUsIG90aGVyTm9kZSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluc2VydE5vZGVBZnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnROb2RlQWZ0ZXIobmV3Tm9kZSwgb3RoZXJOb2RlKSB7XG4gICAgICByZXR1cm4gYWRkKG90aGVyTm9kZSwgbmV3Tm9kZSwgb3RoZXJOb2RlLm5leHQsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwdXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2godmFsKSB7XG4gICAgICByZXR1cm4gYWRkKHRoaXMudGFpbCwgbm9kZUZyb20odmFsKSwgbnVsbCwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVuc2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5zaGlmdCh2YWwpIHtcbiAgICAgIHJldHVybiBhZGQobnVsbCwgbm9kZUZyb20odmFsKSwgdGhpcy5oZWFkLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShub2RlKSB7XG4gICAgICByZXR1cm4gX3JlbW92ZShub2RlLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvcCgpIHtcbiAgICAgIHJldHVybiBfcmVtb3ZlKHRoaXMudGFpbCwgdGhpcykudmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvcE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9wTm9kZSgpIHtcbiAgICAgIHJldHVybiBfcmVtb3ZlKHRoaXMudGFpbCwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgICAgcmV0dXJuIF9yZW1vdmUodGhpcy5oZWFkLCB0aGlzKS52YWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2hpZnROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNoaWZ0Tm9kZSgpIHtcbiAgICAgIHJldHVybiBfcmVtb3ZlKHRoaXMuaGVhZCwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldF9vYmplY3RfYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0X29iamVjdF9hdChpbmRleCkge1xuICAgICAgaWYgKGluZGV4IDw9IHRoaXMubGVuZ3RoKCkpIHtcbiAgICAgICAgdmFyIGkgPSAxO1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuaGVhZDtcbiAgICAgICAgd2hpbGUgKGkgPCBpbmRleCkge1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50LnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRfb2JqZWN0X2F0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldF9vYmplY3RfYXQoaW5kZXgsIHZhbHVlKSB7XG4gICAgICBpZiAoaW5kZXggPD0gdGhpcy5sZW5ndGgoKSkge1xuICAgICAgICB2YXIgaSA9IDE7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5oZWFkO1xuICAgICAgICB3aGlsZSAoaSA8IGluZGV4KSB7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudC52YWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMaW5rZWRMaXN0O1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmtlZExpc3Q7XG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLypcclxuICpUaGlzIGNsYXNzIGlzIHRoZSBqYXZhc2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBQb2ludC5qYXZhIGNsYXNzIGluIGpka1xyXG4gKi9cbmZ1bmN0aW9uIFBvaW50KHgsIHksIHApIHtcbiAgdGhpcy54ID0gbnVsbDtcbiAgdGhpcy55ID0gbnVsbDtcbiAgaWYgKHggPT0gbnVsbCAmJiB5ID09IG51bGwgJiYgcCA9PSBudWxsKSB7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB4ID09ICdudW1iZXInICYmIHR5cGVvZiB5ID09ICdudW1iZXInICYmIHAgPT0gbnVsbCkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfSBlbHNlIGlmICh4LmNvbnN0cnVjdG9yLm5hbWUgPT0gJ1BvaW50JyAmJiB5ID09IG51bGwgJiYgcCA9PSBudWxsKSB7XG4gICAgcCA9IHg7XG4gICAgdGhpcy54ID0gcC54O1xuICAgIHRoaXMueSA9IHAueTtcbiAgfVxufVxuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueDtcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy55O1xufTtcblxuUG9pbnQucHJvdG90eXBlLmdldExvY2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5zZXRMb2NhdGlvbiA9IGZ1bmN0aW9uICh4LCB5LCBwKSB7XG4gIGlmICh4LmNvbnN0cnVjdG9yLm5hbWUgPT0gJ1BvaW50JyAmJiB5ID09IG51bGwgJiYgcCA9PSBudWxsKSB7XG4gICAgcCA9IHg7XG4gICAgdGhpcy5zZXRMb2NhdGlvbihwLngsIHAueSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHggPT0gJ251bWJlcicgJiYgdHlwZW9mIHkgPT0gJ251bWJlcicgJiYgcCA9PSBudWxsKSB7XG4gICAgLy9pZiBib3RoIHBhcmFtZXRlcnMgYXJlIGludGVnZXIganVzdCBtb3ZlICh4LHkpIGxvY2F0aW9uXG4gICAgaWYgKHBhcnNlSW50KHgpID09IHggJiYgcGFyc2VJbnQoeSkgPT0geSkge1xuICAgICAgdGhpcy5tb3ZlKHgsIHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnggPSBNYXRoLmZsb29yKHggKyAwLjUpO1xuICAgICAgdGhpcy55ID0gTWF0aC5mbG9vcih5ICsgMC41KTtcbiAgICB9XG4gIH1cbn07XG5cblBvaW50LnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgdGhpcy54ID0geDtcbiAgdGhpcy55ID0geTtcbn07XG5cblBvaW50LnByb3RvdHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbiAoZHgsIGR5KSB7XG4gIHRoaXMueCArPSBkeDtcbiAgdGhpcy55ICs9IGR5O1xufTtcblxuUG9pbnQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgaWYgKG9iai5jb25zdHJ1Y3Rvci5uYW1lID09IFwiUG9pbnRcIikge1xuICAgIHZhciBwdCA9IG9iajtcbiAgICByZXR1cm4gdGhpcy54ID09IHB0LnggJiYgdGhpcy55ID09IHB0Lnk7XG4gIH1cbiAgcmV0dXJuIHRoaXMgPT0gb2JqO1xufTtcblxuUG9pbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IFBvaW50KCkuY29uc3RydWN0b3IubmFtZSArIFwiW3g9XCIgKyB0aGlzLnggKyBcIix5PVwiICsgdGhpcy55ICsgXCJdXCI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50O1xuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIFJlY3RhbmdsZUQoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICB0aGlzLnggPSAwO1xuICB0aGlzLnkgPSAwO1xuICB0aGlzLndpZHRoID0gMDtcbiAgdGhpcy5oZWlnaHQgPSAwO1xuXG4gIGlmICh4ICE9IG51bGwgJiYgeSAhPSBudWxsICYmIHdpZHRoICE9IG51bGwgJiYgaGVpZ2h0ICE9IG51bGwpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG59XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLng7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5zZXRYID0gZnVuY3Rpb24gKHgpIHtcbiAgdGhpcy54ID0geDtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnk7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5zZXRZID0gZnVuY3Rpb24gKHkpIHtcbiAgdGhpcy55ID0geTtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy53aWR0aDtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLnNldFdpZHRoID0gZnVuY3Rpb24gKHdpZHRoKSB7XG4gIHRoaXMud2lkdGggPSB3aWR0aDtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCkge1xuICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy54ICsgdGhpcy53aWR0aDtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldEJvdHRvbSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueSArIHRoaXMuaGVpZ2h0O1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uIChhKSB7XG4gIGlmICh0aGlzLmdldFJpZ2h0KCkgPCBhLngpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5nZXRCb3R0b20oKSA8IGEueSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChhLmdldFJpZ2h0KCkgPCB0aGlzLngpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYS5nZXRCb3R0b20oKSA8IHRoaXMueSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0Q2VudGVyWCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGggLyAyO1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0TWluWCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0WCgpO1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0TWF4WCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0WCgpICsgdGhpcy53aWR0aDtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldENlbnRlclkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodCAvIDI7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRNaW5ZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5nZXRZKCk7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRNYXhZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5nZXRZKCkgKyB0aGlzLmhlaWdodDtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldFdpZHRoSGFsZiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMud2lkdGggLyAyO1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0SGVpZ2h0SGFsZiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaGVpZ2h0IC8gMjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVjdGFuZ2xlRDtcblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIFVuaXF1ZUlER2VuZXJldG9yKCkge31cblxuVW5pcXVlSURHZW5lcmV0b3IubGFzdElEID0gMDtcblxuVW5pcXVlSURHZW5lcmV0b3IuY3JlYXRlSUQgPSBmdW5jdGlvbiAob2JqKSB7XG4gIGlmIChVbmlxdWVJREdlbmVyZXRvci5pc1ByaW1pdGl2ZShvYmopKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBpZiAob2JqLnVuaXF1ZUlEICE9IG51bGwpIHtcbiAgICByZXR1cm4gb2JqLnVuaXF1ZUlEO1xuICB9XG4gIG9iai51bmlxdWVJRCA9IFVuaXF1ZUlER2VuZXJldG9yLmdldFN0cmluZygpO1xuICBVbmlxdWVJREdlbmVyZXRvci5sYXN0SUQrKztcbiAgcmV0dXJuIG9iai51bmlxdWVJRDtcbn07XG5cblVuaXF1ZUlER2VuZXJldG9yLmdldFN0cmluZyA9IGZ1bmN0aW9uIChpZCkge1xuICBpZiAoaWQgPT0gbnVsbCkgaWQgPSBVbmlxdWVJREdlbmVyZXRvci5sYXN0SUQ7XG4gIHJldHVybiBcIk9iamVjdCNcIiArIGlkICsgXCJcIjtcbn07XG5cblVuaXF1ZUlER2VuZXJldG9yLmlzUHJpbWl0aXZlID0gZnVuY3Rpb24gKGFyZykge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBhcmcgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihhcmcpO1xuICByZXR1cm4gYXJnID09IG51bGwgfHwgdHlwZSAhPSBcIm9iamVjdFwiICYmIHR5cGUgIT0gXCJmdW5jdGlvblwiO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBVbmlxdWVJREdlbmVyZXRvcjtcblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxudmFyIExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgTEdyYXBoTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG52YXIgTE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIExFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBMR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIFBvaW50RCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG52YXIgVHJhbnNmb3JtID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG52YXIgRW1pdHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xuXG5mdW5jdGlvbiBMYXlvdXQoaXNSZW1vdGVVc2UpIHtcbiAgRW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIC8vTGF5b3V0IFF1YWxpdHk6IDA6ZHJhZnQsIDE6ZGVmYXVsdCwgMjpwcm9vZlxuICB0aGlzLmxheW91dFF1YWxpdHkgPSBMYXlvdXRDb25zdGFudHMuUVVBTElUWTtcbiAgLy9XaGV0aGVyIGxheW91dCBzaG91bGQgY3JlYXRlIGJlbmRwb2ludHMgYXMgbmVlZGVkIG9yIG5vdFxuICB0aGlzLmNyZWF0ZUJlbmRzQXNOZWVkZWQgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DUkVBVEVfQkVORFNfQVNfTkVFREVEO1xuICAvL1doZXRoZXIgbGF5b3V0IHNob3VsZCBiZSBpbmNyZW1lbnRhbCBvciBub3RcbiAgdGhpcy5pbmNyZW1lbnRhbCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMO1xuICAvL1doZXRoZXIgd2UgYW5pbWF0ZSBmcm9tIGJlZm9yZSB0byBhZnRlciBsYXlvdXQgbm9kZSBwb3NpdGlvbnNcbiAgdGhpcy5hbmltYXRpb25PbkxheW91dCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0FOSU1BVElPTl9PTl9MQVlPVVQ7XG4gIC8vV2hldGhlciB3ZSBhbmltYXRlIHRoZSBsYXlvdXQgcHJvY2VzcyBvciBub3RcbiAgdGhpcy5hbmltYXRpb25EdXJpbmdMYXlvdXQgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fRFVSSU5HX0xBWU9VVDtcbiAgLy9OdW1iZXIgaXRlcmF0aW9ucyB0aGF0IHNob3VsZCBiZSBkb25lIGJldHdlZW4gdHdvIHN1Y2Nlc3NpdmUgYW5pbWF0aW9uc1xuICB0aGlzLmFuaW1hdGlvblBlcmlvZCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0FOSU1BVElPTl9QRVJJT0Q7XG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgb3Igbm90IGxlYWYgbm9kZXMgKG5vbi1jb21wb3VuZCBub2RlcykgYXJlIG9mIHVuaWZvcm0gc2l6ZXMuIFdoZW5cclxuICAgKiB0aGV5IGFyZSwgYm90aCBzcHJpbmcgYW5kIHJlcHVsc2lvbiBmb3JjZXMgYmV0d2VlbiB0d28gbGVhZiBub2RlcyBjYW4gYmVcclxuICAgKiBjYWxjdWxhdGVkIHdpdGhvdXQgdGhlIGV4cGVuc2l2ZSBjbGlwcGluZyBwb2ludCBjYWxjdWxhdGlvbnMsIHJlc3VsdGluZ1xyXG4gICAqIGluIG1ham9yIHNwZWVkLXVwLlxyXG4gICAqL1xuICB0aGlzLnVuaWZvcm1MZWFmTm9kZVNpemVzID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfVU5JRk9STV9MRUFGX05PREVfU0laRVM7XG4gIC8qKlxyXG4gICAqIFRoaXMgaXMgdXNlZCBmb3IgY3JlYXRpb24gb2YgYmVuZHBvaW50cyBieSB1c2luZyBkdW1teSBub2RlcyBhbmQgZWRnZXMuXHJcbiAgICogTWFwcyBhbiBMRWRnZSB0byBpdHMgZHVtbXkgYmVuZHBvaW50IHBhdGguXHJcbiAgICovXG4gIHRoaXMuZWRnZVRvRHVtbXlOb2RlcyA9IG5ldyBNYXAoKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIgPSBuZXcgTEdyYXBoTWFuYWdlcih0aGlzKTtcbiAgdGhpcy5pc0xheW91dEZpbmlzaGVkID0gZmFsc2U7XG4gIHRoaXMuaXNTdWJMYXlvdXQgPSBmYWxzZTtcbiAgdGhpcy5pc1JlbW90ZVVzZSA9IGZhbHNlO1xuXG4gIGlmIChpc1JlbW90ZVVzZSAhPSBudWxsKSB7XG4gICAgdGhpcy5pc1JlbW90ZVVzZSA9IGlzUmVtb3RlVXNlO1xuICB9XG59XG5cbkxheW91dC5SQU5ET01fU0VFRCA9IDE7XG5cbkxheW91dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVtaXR0ZXIucHJvdG90eXBlKTtcblxuTGF5b3V0LnByb3RvdHlwZS5nZXRHcmFwaE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdyYXBoTWFuYWdlcjtcbn07XG5cbkxheW91dC5wcm90b3R5cGUuZ2V0QWxsTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxOb2RlcygpO1xufTtcblxuTGF5b3V0LnByb3RvdHlwZS5nZXRBbGxFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbEVkZ2VzKCk7XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLmdldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oKTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUubmV3R3JhcGhNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZ20gPSBuZXcgTEdyYXBoTWFuYWdlcih0aGlzKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIgPSBnbTtcbiAgcmV0dXJuIGdtO1xufTtcblxuTGF5b3V0LnByb3RvdHlwZS5uZXdHcmFwaCA9IGZ1bmN0aW9uICh2R3JhcGgpIHtcbiAgcmV0dXJuIG5ldyBMR3JhcGgobnVsbCwgdGhpcy5ncmFwaE1hbmFnZXIsIHZHcmFwaCk7XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLm5ld05vZGUgPSBmdW5jdGlvbiAodk5vZGUpIHtcbiAgcmV0dXJuIG5ldyBMTm9kZSh0aGlzLmdyYXBoTWFuYWdlciwgdk5vZGUpO1xufTtcblxuTGF5b3V0LnByb3RvdHlwZS5uZXdFZGdlID0gZnVuY3Rpb24gKHZFZGdlKSB7XG4gIHJldHVybiBuZXcgTEVkZ2UobnVsbCwgbnVsbCwgdkVkZ2UpO1xufTtcblxuTGF5b3V0LnByb3RvdHlwZS5jaGVja0xheW91dFN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkgPT0gbnVsbCB8fCB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuZ2V0Tm9kZXMoKS5sZW5ndGggPT0gMCB8fCB0aGlzLmdyYXBoTWFuYWdlci5pbmNsdWRlc0ludmFsaWRFZGdlKCk7XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLnJ1bkxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5pc0xheW91dEZpbmlzaGVkID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMudGlsaW5nUHJlTGF5b3V0KSB7XG4gICAgdGhpcy50aWxpbmdQcmVMYXlvdXQoKTtcbiAgfVxuXG4gIHRoaXMuaW5pdFBhcmFtZXRlcnMoKTtcbiAgdmFyIGlzTGF5b3V0U3VjY2Vzc2Z1bGw7XG5cbiAgaWYgKHRoaXMuY2hlY2tMYXlvdXRTdWNjZXNzKCkpIHtcbiAgICBpc0xheW91dFN1Y2Nlc3NmdWxsID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgaXNMYXlvdXRTdWNjZXNzZnVsbCA9IHRoaXMubGF5b3V0KCk7XG4gIH1cblxuICBpZiAoTGF5b3V0Q29uc3RhbnRzLkFOSU1BVEUgPT09ICdkdXJpbmcnKSB7XG4gICAgLy8gSWYgdGhpcyBpcyBhICdkdXJpbmcnIGxheW91dCBhbmltYXRpb24uIExheW91dCBpcyBub3QgZmluaXNoZWQgeWV0LiBcbiAgICAvLyBXZSBuZWVkIHRvIHBlcmZvcm0gdGhlc2UgaW4gaW5kZXguanMgd2hlbiBsYXlvdXQgaXMgcmVhbGx5IGZpbmlzaGVkLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChpc0xheW91dFN1Y2Nlc3NmdWxsKSB7XG4gICAgaWYgKCF0aGlzLmlzU3ViTGF5b3V0KSB7XG4gICAgICB0aGlzLmRvUG9zdExheW91dCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnRpbGluZ1Bvc3RMYXlvdXQpIHtcbiAgICB0aGlzLnRpbGluZ1Bvc3RMYXlvdXQoKTtcbiAgfVxuXG4gIHRoaXMuaXNMYXlvdXRGaW5pc2hlZCA9IHRydWU7XG5cbiAgcmV0dXJuIGlzTGF5b3V0U3VjY2Vzc2Z1bGw7XG59O1xuXG4vKipcclxuICogVGhpcyBtZXRob2QgcGVyZm9ybXMgdGhlIG9wZXJhdGlvbnMgcmVxdWlyZWQgYWZ0ZXIgbGF5b3V0LlxyXG4gKi9cbkxheW91dC5wcm90b3R5cGUuZG9Qb3N0TGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICAvL2Fzc2VydCAhaXNTdWJMYXlvdXQgOiBcIlNob3VsZCBub3QgYmUgY2FsbGVkIG9uIHN1Yi1sYXlvdXQhXCI7XG4gIC8vIFByb3BhZ2F0ZSBnZW9tZXRyaWMgY2hhbmdlcyB0byB2LWxldmVsIG9iamVjdHNcbiAgaWYgKCF0aGlzLmluY3JlbWVudGFsKSB7XG4gICAgdGhpcy50cmFuc2Zvcm0oKTtcbiAgfVxuICB0aGlzLnVwZGF0ZSgpO1xufTtcblxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIHVwZGF0ZXMgdGhlIGdlb21ldHJ5IG9mIHRoZSB0YXJnZXQgZ3JhcGggYWNjb3JkaW5nIHRvXHJcbiAqIGNhbGN1bGF0ZWQgbGF5b3V0LlxyXG4gKi9cbkxheW91dC5wcm90b3R5cGUudXBkYXRlMiA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gdXBkYXRlIGJlbmQgcG9pbnRzXG4gIGlmICh0aGlzLmNyZWF0ZUJlbmRzQXNOZWVkZWQpIHtcbiAgICB0aGlzLmNyZWF0ZUJlbmRwb2ludHNGcm9tRHVtbXlOb2RlcygpO1xuXG4gICAgLy8gcmVzZXQgYWxsIGVkZ2VzLCBzaW5jZSB0aGUgdG9wb2xvZ3kgaGFzIGNoYW5nZWRcbiAgICB0aGlzLmdyYXBoTWFuYWdlci5yZXNldEFsbEVkZ2VzKCk7XG4gIH1cblxuICAvLyBwZXJmb3JtIGVkZ2UsIG5vZGUgYW5kIHJvb3QgdXBkYXRlcyBpZiBsYXlvdXQgaXMgbm90IGNhbGxlZFxuICAvLyByZW1vdGVseVxuICBpZiAoIXRoaXMuaXNSZW1vdGVVc2UpIHtcbiAgICAvLyB1cGRhdGUgYWxsIGVkZ2VzXG4gICAgdmFyIGVkZ2U7XG4gICAgdmFyIGFsbEVkZ2VzID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsRWRnZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbEVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBlZGdlID0gYWxsRWRnZXNbaV07XG4gICAgICAvLyAgICAgIHRoaXMudXBkYXRlKGVkZ2UpO1xuICAgIH1cblxuICAgIC8vIHJlY3Vyc2l2ZWx5IHVwZGF0ZSBub2Rlc1xuICAgIHZhciBub2RlO1xuICAgIHZhciBub2RlcyA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKS5nZXROb2RlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIC8vICAgICAgdGhpcy51cGRhdGUobm9kZSk7XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIHJvb3QgZ3JhcGhcbiAgICB0aGlzLnVwZGF0ZSh0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkpO1xuICB9XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgdGhpcy51cGRhdGUyKCk7XG4gIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTE5vZGUpIHtcbiAgICB2YXIgbm9kZSA9IG9iajtcbiAgICBpZiAobm9kZS5nZXRDaGlsZCgpICE9IG51bGwpIHtcbiAgICAgIC8vIHNpbmNlIG5vZGUgaXMgY29tcG91bmQsIHJlY3Vyc2l2ZWx5IHVwZGF0ZSBjaGlsZCBub2Rlc1xuICAgICAgdmFyIG5vZGVzID0gbm9kZS5nZXRDaGlsZCgpLmdldE5vZGVzKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHVwZGF0ZShub2Rlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIGwtbGV2ZWwgbm9kZSBpcyBhc3NvY2lhdGVkIHdpdGggYSB2LWxldmVsIGdyYXBoIG9iamVjdCxcbiAgICAvLyB0aGVuIGl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgdi1sZXZlbCBub2RlIGltcGxlbWVudHMgdGhlXG4gICAgLy8gaW50ZXJmYWNlIFVwZGF0YWJsZS5cbiAgICBpZiAobm9kZS52R3JhcGhPYmplY3QgIT0gbnVsbCkge1xuICAgICAgLy8gY2FzdCB0byBVcGRhdGFibGUgd2l0aG91dCBhbnkgdHlwZSBjaGVja1xuICAgICAgdmFyIHZOb2RlID0gbm9kZS52R3JhcGhPYmplY3Q7XG5cbiAgICAgIC8vIGNhbGwgdGhlIHVwZGF0ZSBtZXRob2Qgb2YgdGhlIGludGVyZmFjZVxuICAgICAgdk5vZGUudXBkYXRlKG5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMRWRnZSkge1xuICAgIHZhciBlZGdlID0gb2JqO1xuICAgIC8vIGlmIHRoZSBsLWxldmVsIGVkZ2UgaXMgYXNzb2NpYXRlZCB3aXRoIGEgdi1sZXZlbCBncmFwaCBvYmplY3QsXG4gICAgLy8gdGhlbiBpdCBpcyBhc3N1bWVkIHRoYXQgdGhlIHYtbGV2ZWwgZWRnZSBpbXBsZW1lbnRzIHRoZVxuICAgIC8vIGludGVyZmFjZSBVcGRhdGFibGUuXG5cbiAgICBpZiAoZWRnZS52R3JhcGhPYmplY3QgIT0gbnVsbCkge1xuICAgICAgLy8gY2FzdCB0byBVcGRhdGFibGUgd2l0aG91dCBhbnkgdHlwZSBjaGVja1xuICAgICAgdmFyIHZFZGdlID0gZWRnZS52R3JhcGhPYmplY3Q7XG5cbiAgICAgIC8vIGNhbGwgdGhlIHVwZGF0ZSBtZXRob2Qgb2YgdGhlIGludGVyZmFjZVxuICAgICAgdkVkZ2UudXBkYXRlKGVkZ2UpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMR3JhcGgpIHtcbiAgICB2YXIgZ3JhcGggPSBvYmo7XG4gICAgLy8gaWYgdGhlIGwtbGV2ZWwgZ3JhcGggaXMgYXNzb2NpYXRlZCB3aXRoIGEgdi1sZXZlbCBncmFwaCBvYmplY3QsXG4gICAgLy8gdGhlbiBpdCBpcyBhc3N1bWVkIHRoYXQgdGhlIHYtbGV2ZWwgb2JqZWN0IGltcGxlbWVudHMgdGhlXG4gICAgLy8gaW50ZXJmYWNlIFVwZGF0YWJsZS5cblxuICAgIGlmIChncmFwaC52R3JhcGhPYmplY3QgIT0gbnVsbCkge1xuICAgICAgLy8gY2FzdCB0byBVcGRhdGFibGUgd2l0aG91dCBhbnkgdHlwZSBjaGVja1xuICAgICAgdmFyIHZHcmFwaCA9IGdyYXBoLnZHcmFwaE9iamVjdDtcblxuICAgICAgLy8gY2FsbCB0aGUgdXBkYXRlIG1ldGhvZCBvZiB0aGUgaW50ZXJmYWNlXG4gICAgICB2R3JhcGgudXBkYXRlKGdyYXBoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIHNldCBhbGwgbGF5b3V0IHBhcmFtZXRlcnMgdG8gZGVmYXVsdCB2YWx1ZXNcclxuICogZGV0ZXJtaW5lZCBhdCBjb21waWxlIHRpbWUuXHJcbiAqL1xuTGF5b3V0LnByb3RvdHlwZS5pbml0UGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLmlzU3ViTGF5b3V0KSB7XG4gICAgdGhpcy5sYXlvdXRRdWFsaXR5ID0gTGF5b3V0Q29uc3RhbnRzLlFVQUxJVFk7XG4gICAgdGhpcy5hbmltYXRpb25EdXJpbmdMYXlvdXQgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fRFVSSU5HX0xBWU9VVDtcbiAgICB0aGlzLmFuaW1hdGlvblBlcmlvZCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0FOSU1BVElPTl9QRVJJT0Q7XG4gICAgdGhpcy5hbmltYXRpb25PbkxheW91dCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0FOSU1BVElPTl9PTl9MQVlPVVQ7XG4gICAgdGhpcy5pbmNyZW1lbnRhbCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMO1xuICAgIHRoaXMuY3JlYXRlQmVuZHNBc05lZWRlZCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0NSRUFURV9CRU5EU19BU19ORUVERUQ7XG4gICAgdGhpcy51bmlmb3JtTGVhZk5vZGVTaXplcyA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX1VOSUZPUk1fTEVBRl9OT0RFX1NJWkVTO1xuICB9XG5cbiAgaWYgKHRoaXMuYW5pbWF0aW9uRHVyaW5nTGF5b3V0KSB7XG4gICAgdGhpcy5hbmltYXRpb25PbkxheW91dCA9IGZhbHNlO1xuICB9XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChuZXdMZWZ0VG9wKSB7XG4gIGlmIChuZXdMZWZ0VG9wID09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMudHJhbnNmb3JtKG5ldyBQb2ludEQoMCwgMCkpO1xuICB9IGVsc2Uge1xuICAgIC8vIGNyZWF0ZSBhIHRyYW5zZm9ybWF0aW9uIG9iamVjdCAoZnJvbSBFY2xpcHNlIHRvIGxheW91dCkuIFdoZW4gYW5cbiAgICAvLyBpbnZlcnNlIHRyYW5zZm9ybSBpcyBhcHBsaWVkLCB3ZSBnZXQgdXBwZXItbGVmdCBjb29yZGluYXRlIG9mIHRoZVxuICAgIC8vIGRyYXdpbmcgb3IgdGhlIHJvb3QgZ3JhcGggYXQgZ2l2ZW4gaW5wdXQgY29vcmRpbmF0ZSAoc29tZSBtYXJnaW5zXG4gICAgLy8gYWxyZWFkeSBpbmNsdWRlZCBpbiBjYWxjdWxhdGlvbiBvZiBsZWZ0LXRvcCkuXG5cbiAgICB2YXIgdHJhbnMgPSBuZXcgVHJhbnNmb3JtKCk7XG4gICAgdmFyIGxlZnRUb3AgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkudXBkYXRlTGVmdFRvcCgpO1xuXG4gICAgaWYgKGxlZnRUb3AgIT0gbnVsbCkge1xuICAgICAgdHJhbnMuc2V0V29ybGRPcmdYKG5ld0xlZnRUb3AueCk7XG4gICAgICB0cmFucy5zZXRXb3JsZE9yZ1kobmV3TGVmdFRvcC55KTtcblxuICAgICAgdHJhbnMuc2V0RGV2aWNlT3JnWChsZWZ0VG9wLngpO1xuICAgICAgdHJhbnMuc2V0RGV2aWNlT3JnWShsZWZ0VG9wLnkpO1xuXG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmdldEFsbE5vZGVzKCk7XG4gICAgICB2YXIgbm9kZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIG5vZGUudHJhbnNmb3JtKHRyYW5zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbkxheW91dC5wcm90b3R5cGUucG9zaXRpb25Ob2Rlc1JhbmRvbWx5ID0gZnVuY3Rpb24gKGdyYXBoKSB7XG5cbiAgaWYgKGdyYXBoID09IHVuZGVmaW5lZCkge1xuICAgIC8vYXNzZXJ0ICF0aGlzLmluY3JlbWVudGFsO1xuICAgIHRoaXMucG9zaXRpb25Ob2Rlc1JhbmRvbWx5KHRoaXMuZ2V0R3JhcGhNYW5hZ2VyKCkuZ2V0Um9vdCgpKTtcbiAgICB0aGlzLmdldEdyYXBoTWFuYWdlcigpLmdldFJvb3QoKS51cGRhdGVCb3VuZHModHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxOb2RlO1xuICAgIHZhciBjaGlsZEdyYXBoO1xuXG4gICAgdmFyIG5vZGVzID0gZ3JhcGguZ2V0Tm9kZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsTm9kZSA9IG5vZGVzW2ldO1xuICAgICAgY2hpbGRHcmFwaCA9IGxOb2RlLmdldENoaWxkKCk7XG5cbiAgICAgIGlmIChjaGlsZEdyYXBoID09IG51bGwpIHtcbiAgICAgICAgbE5vZGUuc2NhdHRlcigpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZEdyYXBoLmdldE5vZGVzKCkubGVuZ3RoID09IDApIHtcbiAgICAgICAgbE5vZGUuc2NhdHRlcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbk5vZGVzUmFuZG9tbHkoY2hpbGRHcmFwaCk7XG4gICAgICAgIGxOb2RlLnVwZGF0ZUJvdW5kcygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBsaXN0IG9mIHRyZWVzIHdoZXJlIGVhY2ggdHJlZSBpcyByZXByZXNlbnRlZCBhcyBhXHJcbiAqIGxpc3Qgb2YgbC1ub2Rlcy4gVGhlIG1ldGhvZCByZXR1cm5zIGEgbGlzdCBvZiBzaXplIDAgd2hlbjpcclxuICogLSBUaGUgZ3JhcGggaXMgbm90IGZsYXQgb3JcclxuICogLSBPbmUgb2YgdGhlIGNvbXBvbmVudChzKSBvZiB0aGUgZ3JhcGggaXMgbm90IGEgdHJlZS5cclxuICovXG5MYXlvdXQucHJvdG90eXBlLmdldEZsYXRGb3Jlc3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBmbGF0Rm9yZXN0ID0gW107XG4gIHZhciBpc0ZvcmVzdCA9IHRydWU7XG5cbiAgLy8gUXVpY2sgcmVmZXJlbmNlIGZvciBhbGwgbm9kZXMgaW4gdGhlIGdyYXBoIG1hbmFnZXIgYXNzb2NpYXRlZCB3aXRoXG4gIC8vIHRoaXMgbGF5b3V0LiBUaGUgbGlzdCBzaG91bGQgbm90IGJlIGNoYW5nZWQuXG4gIHZhciBhbGxOb2RlcyA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKS5nZXROb2RlcygpO1xuXG4gIC8vIEZpcnN0IGJlIHN1cmUgdGhhdCB0aGUgZ3JhcGggaXMgZmxhdFxuICB2YXIgaXNGbGF0ID0gdHJ1ZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFsbE5vZGVzW2ldLmdldENoaWxkKCkgIT0gbnVsbCkge1xuICAgICAgaXNGbGF0ID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJuIGVtcHR5IGZvcmVzdCBpZiB0aGUgZ3JhcGggaXMgbm90IGZsYXQuXG4gIGlmICghaXNGbGF0KSB7XG4gICAgcmV0dXJuIGZsYXRGb3Jlc3Q7XG4gIH1cblxuICAvLyBSdW4gQkZTIGZvciBlYWNoIGNvbXBvbmVudCBvZiB0aGUgZ3JhcGguXG5cbiAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gIHZhciB0b0JlVmlzaXRlZCA9IFtdO1xuICB2YXIgcGFyZW50cyA9IG5ldyBNYXAoKTtcbiAgdmFyIHVuUHJvY2Vzc2VkTm9kZXMgPSBbXTtcblxuICB1blByb2Nlc3NlZE5vZGVzID0gdW5Qcm9jZXNzZWROb2Rlcy5jb25jYXQoYWxsTm9kZXMpO1xuXG4gIC8vIEVhY2ggaXRlcmF0aW9uIG9mIHRoaXMgbG9vcCBmaW5kcyBhIGNvbXBvbmVudCBvZiB0aGUgZ3JhcGggYW5kXG4gIC8vIGRlY2lkZXMgd2hldGhlciBpdCBpcyBhIHRyZWUgb3Igbm90LiBJZiBpdCBpcyBhIHRyZWUsIGFkZHMgaXQgdG8gdGhlXG4gIC8vIGZvcmVzdCBhbmQgY29udGludWVkIHdpdGggdGhlIG5leHQgY29tcG9uZW50LlxuXG4gIHdoaWxlICh1blByb2Nlc3NlZE5vZGVzLmxlbmd0aCA+IDAgJiYgaXNGb3Jlc3QpIHtcbiAgICB0b0JlVmlzaXRlZC5wdXNoKHVuUHJvY2Vzc2VkTm9kZXNbMF0pO1xuXG4gICAgLy8gU3RhcnQgdGhlIEJGUy4gRWFjaCBpdGVyYXRpb24gb2YgdGhpcyBsb29wIHZpc2l0cyBhIG5vZGUgaW4gYVxuICAgIC8vIEJGUyBtYW5uZXIuXG4gICAgd2hpbGUgKHRvQmVWaXNpdGVkLmxlbmd0aCA+IDAgJiYgaXNGb3Jlc3QpIHtcbiAgICAgIC8vcG9vbCBvcGVyYXRpb25cbiAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHRvQmVWaXNpdGVkWzBdO1xuICAgICAgdG9CZVZpc2l0ZWQuc3BsaWNlKDAsIDEpO1xuICAgICAgdmlzaXRlZC5hZGQoY3VycmVudE5vZGUpO1xuXG4gICAgICAvLyBUcmF2ZXJzZSBhbGwgbmVpZ2hib3JzIG9mIHRoaXMgbm9kZVxuICAgICAgdmFyIG5laWdoYm9yRWRnZXMgPSBjdXJyZW50Tm9kZS5nZXRFZGdlcygpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5laWdoYm9yRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGN1cnJlbnROZWlnaGJvciA9IG5laWdoYm9yRWRnZXNbaV0uZ2V0T3RoZXJFbmQoY3VycmVudE5vZGUpO1xuXG4gICAgICAgIC8vIElmIEJGUyBpcyBub3QgZ3Jvd2luZyBmcm9tIHRoaXMgbmVpZ2hib3IuXG4gICAgICAgIGlmIChwYXJlbnRzLmdldChjdXJyZW50Tm9kZSkgIT0gY3VycmVudE5laWdoYm9yKSB7XG4gICAgICAgICAgLy8gV2UgaGF2ZW4ndCBwcmV2aW91c2x5IHZpc2l0ZWQgdGhpcyBuZWlnaGJvci5cbiAgICAgICAgICBpZiAoIXZpc2l0ZWQuaGFzKGN1cnJlbnROZWlnaGJvcikpIHtcbiAgICAgICAgICAgIHRvQmVWaXNpdGVkLnB1c2goY3VycmVudE5laWdoYm9yKTtcbiAgICAgICAgICAgIHBhcmVudHMuc2V0KGN1cnJlbnROZWlnaGJvciwgY3VycmVudE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBTaW5jZSB3ZSBoYXZlIHByZXZpb3VzbHkgdmlzaXRlZCB0aGlzIG5laWdoYm9yIGFuZFxuICAgICAgICAgIC8vIHRoaXMgbmVpZ2hib3IgaXMgbm90IHBhcmVudCBvZiBjdXJyZW50Tm9kZSwgZ2l2ZW5cbiAgICAgICAgICAvLyBncmFwaCBjb250YWlucyBhIGNvbXBvbmVudCB0aGF0IGlzIG5vdCB0cmVlLCBoZW5jZVxuICAgICAgICAgIC8vIGl0IGlzIG5vdCBhIGZvcmVzdC5cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgaXNGb3Jlc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGUgZ3JhcGggY29udGFpbnMgYSBjb21wb25lbnQgdGhhdCBpcyBub3QgYSB0cmVlLiBFbXB0eVxuICAgIC8vIHByZXZpb3VzbHkgZm91bmQgdHJlZXMuIFRoZSBtZXRob2Qgd2lsbCBlbmQuXG4gICAgaWYgKCFpc0ZvcmVzdCkge1xuICAgICAgZmxhdEZvcmVzdCA9IFtdO1xuICAgIH1cbiAgICAvLyBTYXZlIGN1cnJlbnRseSB2aXNpdGVkIG5vZGVzIGFzIGEgdHJlZSBpbiBvdXIgZm9yZXN0LiBSZXNldFxuICAgIC8vIHZpc2l0ZWQgYW5kIHBhcmVudHMgbGlzdHMuIENvbnRpbnVlIHdpdGggdGhlIG5leHQgY29tcG9uZW50IG9mXG4gICAgLy8gdGhlIGdyYXBoLCBpZiBhbnkuXG4gICAgZWxzZSB7XG4gICAgICAgIHZhciB0ZW1wID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh2aXNpdGVkKSk7XG4gICAgICAgIGZsYXRGb3Jlc3QucHVzaCh0ZW1wKTtcbiAgICAgICAgLy9mbGF0Rm9yZXN0ID0gZmxhdEZvcmVzdC5jb25jYXQodGVtcCk7XG4gICAgICAgIC8vdW5Qcm9jZXNzZWROb2Rlcy5yZW1vdmVBbGwodmlzaXRlZCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVtcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHRlbXBbaV07XG4gICAgICAgICAgdmFyIGluZGV4ID0gdW5Qcm9jZXNzZWROb2Rlcy5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdW5Qcm9jZXNzZWROb2Rlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgICAgICBwYXJlbnRzID0gbmV3IE1hcCgpO1xuICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIGZsYXRGb3Jlc3Q7XG59O1xuXG4vKipcclxuICogVGhpcyBtZXRob2QgY3JlYXRlcyBkdW1teSBub2RlcyAoYW4gbC1sZXZlbCBub2RlIHdpdGggbWluaW1hbCBkaW1lbnNpb25zKVxyXG4gKiBmb3IgdGhlIGdpdmVuIGVkZ2UgKG9uZSBwZXIgYmVuZHBvaW50KS4gVGhlIGV4aXN0aW5nIGwtbGV2ZWwgc3RydWN0dXJlXHJcbiAqIGlzIHVwZGF0ZWQgYWNjb3JkaW5nbHkuXHJcbiAqL1xuTGF5b3V0LnByb3RvdHlwZS5jcmVhdGVEdW1teU5vZGVzRm9yQmVuZHBvaW50cyA9IGZ1bmN0aW9uIChlZGdlKSB7XG4gIHZhciBkdW1teU5vZGVzID0gW107XG4gIHZhciBwcmV2ID0gZWRnZS5zb3VyY2U7XG5cbiAgdmFyIGdyYXBoID0gdGhpcy5ncmFwaE1hbmFnZXIuY2FsY0xvd2VzdENvbW1vbkFuY2VzdG9yKGVkZ2Uuc291cmNlLCBlZGdlLnRhcmdldCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlLmJlbmRwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBjcmVhdGUgbmV3IGR1bW15IG5vZGVcbiAgICB2YXIgZHVtbXlOb2RlID0gdGhpcy5uZXdOb2RlKG51bGwpO1xuICAgIGR1bW15Tm9kZS5zZXRSZWN0KG5ldyBQb2ludCgwLCAwKSwgbmV3IERpbWVuc2lvbigxLCAxKSk7XG5cbiAgICBncmFwaC5hZGQoZHVtbXlOb2RlKTtcblxuICAgIC8vIGNyZWF0ZSBuZXcgZHVtbXkgZWRnZSBiZXR3ZWVuIHByZXYgYW5kIGR1bW15IG5vZGVcbiAgICB2YXIgZHVtbXlFZGdlID0gdGhpcy5uZXdFZGdlKG51bGwpO1xuICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLmFkZChkdW1teUVkZ2UsIHByZXYsIGR1bW15Tm9kZSk7XG5cbiAgICBkdW1teU5vZGVzLmFkZChkdW1teU5vZGUpO1xuICAgIHByZXYgPSBkdW1teU5vZGU7XG4gIH1cblxuICB2YXIgZHVtbXlFZGdlID0gdGhpcy5uZXdFZGdlKG51bGwpO1xuICB0aGlzLmdyYXBoTWFuYWdlci5hZGQoZHVtbXlFZGdlLCBwcmV2LCBlZGdlLnRhcmdldCk7XG5cbiAgdGhpcy5lZGdlVG9EdW1teU5vZGVzLnNldChlZGdlLCBkdW1teU5vZGVzKTtcblxuICAvLyByZW1vdmUgcmVhbCBlZGdlIGZyb20gZ3JhcGggbWFuYWdlciBpZiBpdCBpcyBpbnRlci1ncmFwaFxuICBpZiAoZWRnZS5pc0ludGVyR3JhcGgoKSkge1xuICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlbW92ZShlZGdlKTtcbiAgfVxuICAvLyBlbHNlLCByZW1vdmUgdGhlIGVkZ2UgZnJvbSB0aGUgY3VycmVudCBncmFwaFxuICBlbHNlIHtcbiAgICAgIGdyYXBoLnJlbW92ZShlZGdlKTtcbiAgICB9XG5cbiAgcmV0dXJuIGR1bW15Tm9kZXM7XG59O1xuXG4vKipcclxuICogVGhpcyBtZXRob2QgY3JlYXRlcyBiZW5kcG9pbnRzIGZvciBlZGdlcyBmcm9tIHRoZSBkdW1teSBub2Rlc1xyXG4gKiBhdCBsLWxldmVsLlxyXG4gKi9cbkxheW91dC5wcm90b3R5cGUuY3JlYXRlQmVuZHBvaW50c0Zyb21EdW1teU5vZGVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWRnZXMgPSBbXTtcbiAgZWRnZXMgPSBlZGdlcy5jb25jYXQodGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsRWRnZXMoKSk7XG4gIGVkZ2VzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh0aGlzLmVkZ2VUb0R1bW15Tm9kZXMua2V5cygpKSkuY29uY2F0KGVkZ2VzKTtcblxuICBmb3IgKHZhciBrID0gMDsgayA8IGVkZ2VzLmxlbmd0aDsgaysrKSB7XG4gICAgdmFyIGxFZGdlID0gZWRnZXNba107XG5cbiAgICBpZiAobEVkZ2UuYmVuZHBvaW50cy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMuZWRnZVRvRHVtbXlOb2Rlcy5nZXQobEVkZ2UpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGR1bW15Tm9kZSA9IHBhdGhbaV07XG4gICAgICAgIHZhciBwID0gbmV3IFBvaW50RChkdW1teU5vZGUuZ2V0Q2VudGVyWCgpLCBkdW1teU5vZGUuZ2V0Q2VudGVyWSgpKTtcblxuICAgICAgICAvLyB1cGRhdGUgYmVuZHBvaW50J3MgbG9jYXRpb24gYWNjb3JkaW5nIHRvIGR1bW15IG5vZGVcbiAgICAgICAgdmFyIGVicCA9IGxFZGdlLmJlbmRwb2ludHMuZ2V0KGkpO1xuICAgICAgICBlYnAueCA9IHAueDtcbiAgICAgICAgZWJwLnkgPSBwLnk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBkdW1teSBub2RlLCBkdW1teSBlZGdlcyBpbmNpZGVudCB3aXRoIHRoaXNcbiAgICAgICAgLy8gZHVtbXkgbm9kZSBpcyBhbHNvIHJlbW92ZWQgKHdpdGhpbiB0aGUgcmVtb3ZlIG1ldGhvZClcbiAgICAgICAgZHVtbXlOb2RlLmdldE93bmVyKCkucmVtb3ZlKGR1bW15Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZCB0aGUgcmVhbCBlZGdlIHRvIGdyYXBoXG4gICAgICB0aGlzLmdyYXBoTWFuYWdlci5hZGQobEVkZ2UsIGxFZGdlLnNvdXJjZSwgbEVkZ2UudGFyZ2V0KTtcbiAgICB9XG4gIH1cbn07XG5cbkxheW91dC50cmFuc2Zvcm0gPSBmdW5jdGlvbiAoc2xpZGVyVmFsdWUsIGRlZmF1bHRWYWx1ZSwgbWluRGl2LCBtYXhNdWwpIHtcbiAgaWYgKG1pbkRpdiAhPSB1bmRlZmluZWQgJiYgbWF4TXVsICE9IHVuZGVmaW5lZCkge1xuICAgIHZhciB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcblxuICAgIGlmIChzbGlkZXJWYWx1ZSA8PSA1MCkge1xuICAgICAgdmFyIG1pblZhbHVlID0gZGVmYXVsdFZhbHVlIC8gbWluRGl2O1xuICAgICAgdmFsdWUgLT0gKGRlZmF1bHRWYWx1ZSAtIG1pblZhbHVlKSAvIDUwICogKDUwIC0gc2xpZGVyVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbWF4VmFsdWUgPSBkZWZhdWx0VmFsdWUgKiBtYXhNdWw7XG4gICAgICB2YWx1ZSArPSAobWF4VmFsdWUgLSBkZWZhdWx0VmFsdWUpIC8gNTAgKiAoc2xpZGVyVmFsdWUgLSA1MCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBhLCBiO1xuXG4gICAgaWYgKHNsaWRlclZhbHVlIDw9IDUwKSB7XG4gICAgICBhID0gOS4wICogZGVmYXVsdFZhbHVlIC8gNTAwLjA7XG4gICAgICBiID0gZGVmYXVsdFZhbHVlIC8gMTAuMDtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IDkuMCAqIGRlZmF1bHRWYWx1ZSAvIDUwLjA7XG4gICAgICBiID0gLTggKiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGEgKiBzbGlkZXJWYWx1ZSArIGI7XG4gIH1cbn07XG5cbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCBmaW5kcyBhbmQgcmV0dXJucyB0aGUgY2VudGVyIG9mIHRoZSBnaXZlbiBub2RlcywgYXNzdW1pbmdcclxuICogdGhhdCB0aGUgZ2l2ZW4gbm9kZXMgZm9ybSBhIHRyZWUgaW4gdGhlbXNlbHZlcy5cclxuICovXG5MYXlvdXQuZmluZENlbnRlck9mVHJlZSA9IGZ1bmN0aW9uIChub2Rlcykge1xuICB2YXIgbGlzdCA9IFtdO1xuICBsaXN0ID0gbGlzdC5jb25jYXQobm9kZXMpO1xuXG4gIHZhciByZW1vdmVkTm9kZXMgPSBbXTtcbiAgdmFyIHJlbWFpbmluZ0RlZ3JlZXMgPSBuZXcgTWFwKCk7XG4gIHZhciBmb3VuZENlbnRlciA9IGZhbHNlO1xuICB2YXIgY2VudGVyTm9kZSA9IG51bGw7XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09IDEgfHwgbGlzdC5sZW5ndGggPT0gMikge1xuICAgIGZvdW5kQ2VudGVyID0gdHJ1ZTtcbiAgICBjZW50ZXJOb2RlID0gbGlzdFswXTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gbGlzdFtpXTtcbiAgICB2YXIgZGVncmVlID0gbm9kZS5nZXROZWlnaGJvcnNMaXN0KCkuc2l6ZTtcbiAgICByZW1haW5pbmdEZWdyZWVzLnNldChub2RlLCBub2RlLmdldE5laWdoYm9yc0xpc3QoKS5zaXplKTtcblxuICAgIGlmIChkZWdyZWUgPT0gMSkge1xuICAgICAgcmVtb3ZlZE5vZGVzLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRlbXBMaXN0ID0gW107XG4gIHRlbXBMaXN0ID0gdGVtcExpc3QuY29uY2F0KHJlbW92ZWROb2Rlcyk7XG5cbiAgd2hpbGUgKCFmb3VuZENlbnRlcikge1xuICAgIHZhciB0ZW1wTGlzdDIgPSBbXTtcbiAgICB0ZW1wTGlzdDIgPSB0ZW1wTGlzdDIuY29uY2F0KHRlbXBMaXN0KTtcbiAgICB0ZW1wTGlzdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbm9kZSA9IGxpc3RbaV07XG5cbiAgICAgIHZhciBpbmRleCA9IGxpc3QuaW5kZXhPZihub2RlKTtcbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5laWdoYm91cnMgPSBub2RlLmdldE5laWdoYm9yc0xpc3QoKTtcblxuICAgICAgbmVpZ2hib3Vycy5mb3JFYWNoKGZ1bmN0aW9uIChuZWlnaGJvdXIpIHtcbiAgICAgICAgaWYgKHJlbW92ZWROb2Rlcy5pbmRleE9mKG5laWdoYm91cikgPCAwKSB7XG4gICAgICAgICAgdmFyIG90aGVyRGVncmVlID0gcmVtYWluaW5nRGVncmVlcy5nZXQobmVpZ2hib3VyKTtcbiAgICAgICAgICB2YXIgbmV3RGVncmVlID0gb3RoZXJEZWdyZWUgLSAxO1xuXG4gICAgICAgICAgaWYgKG5ld0RlZ3JlZSA9PSAxKSB7XG4gICAgICAgICAgICB0ZW1wTGlzdC5wdXNoKG5laWdoYm91cik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVtYWluaW5nRGVncmVlcy5zZXQobmVpZ2hib3VyLCBuZXdEZWdyZWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZW1vdmVkTm9kZXMgPSByZW1vdmVkTm9kZXMuY29uY2F0KHRlbXBMaXN0KTtcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PSAxIHx8IGxpc3QubGVuZ3RoID09IDIpIHtcbiAgICAgIGZvdW5kQ2VudGVyID0gdHJ1ZTtcbiAgICAgIGNlbnRlck5vZGUgPSBsaXN0WzBdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjZW50ZXJOb2RlO1xufTtcblxuLyoqXHJcbiAqIER1cmluZyB0aGUgY29hcnNlbmluZyBwcm9jZXNzLCB0aGlzIGxheW91dCBtYXkgYmUgcmVmZXJlbmNlZCBieSB0d28gZ3JhcGggbWFuYWdlcnNcclxuICogdGhpcyBzZXR0ZXIgZnVuY3Rpb24gZ3JhbnRzIGFjY2VzcyB0byBjaGFuZ2UgdGhlIGN1cnJlbnRseSBiZWluZyB1c2VkIGdyYXBoIG1hbmFnZXJcclxuICovXG5MYXlvdXQucHJvdG90eXBlLnNldEdyYXBoTWFuYWdlciA9IGZ1bmN0aW9uIChnbSkge1xuICB0aGlzLmdyYXBoTWFuYWdlciA9IGdtO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMYXlvdXQ7XG5cbi8qKiovIH0pLFxuLyogMTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gUmFuZG9tU2VlZCgpIHt9XG4vLyBhZGFwdGVkIGZyb206IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xOTMwMzcyNVxuUmFuZG9tU2VlZC5zZWVkID0gMTtcblJhbmRvbVNlZWQueCA9IDA7XG5cblJhbmRvbVNlZWQubmV4dERvdWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgUmFuZG9tU2VlZC54ID0gTWF0aC5zaW4oUmFuZG9tU2VlZC5zZWVkKyspICogMTAwMDA7XG4gIHJldHVybiBSYW5kb21TZWVkLnggLSBNYXRoLmZsb29yKFJhbmRvbVNlZWQueCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhbmRvbVNlZWQ7XG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIFBvaW50RCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybSh4LCB5KSB7XG4gIHRoaXMubHdvcmxkT3JnWCA9IDAuMDtcbiAgdGhpcy5sd29ybGRPcmdZID0gMC4wO1xuICB0aGlzLmxkZXZpY2VPcmdYID0gMC4wO1xuICB0aGlzLmxkZXZpY2VPcmdZID0gMC4wO1xuICB0aGlzLmx3b3JsZEV4dFggPSAxLjA7XG4gIHRoaXMubHdvcmxkRXh0WSA9IDEuMDtcbiAgdGhpcy5sZGV2aWNlRXh0WCA9IDEuMDtcbiAgdGhpcy5sZGV2aWNlRXh0WSA9IDEuMDtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5nZXRXb3JsZE9yZ1ggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmx3b3JsZE9yZ1g7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldFdvcmxkT3JnWCA9IGZ1bmN0aW9uICh3b3gpIHtcbiAgdGhpcy5sd29ybGRPcmdYID0gd294O1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5nZXRXb3JsZE9yZ1kgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmx3b3JsZE9yZ1k7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldFdvcmxkT3JnWSA9IGZ1bmN0aW9uICh3b3kpIHtcbiAgdGhpcy5sd29ybGRPcmdZID0gd295O1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5nZXRXb3JsZEV4dFggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmx3b3JsZEV4dFg7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldFdvcmxkRXh0WCA9IGZ1bmN0aW9uICh3ZXgpIHtcbiAgdGhpcy5sd29ybGRFeHRYID0gd2V4O1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5nZXRXb3JsZEV4dFkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmx3b3JsZEV4dFk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldFdvcmxkRXh0WSA9IGZ1bmN0aW9uICh3ZXkpIHtcbiAgdGhpcy5sd29ybGRFeHRZID0gd2V5O1xufTtcblxuLyogRGV2aWNlIHJlbGF0ZWQgKi9cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5nZXREZXZpY2VPcmdYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sZGV2aWNlT3JnWDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0RGV2aWNlT3JnWCA9IGZ1bmN0aW9uIChkb3gpIHtcbiAgdGhpcy5sZGV2aWNlT3JnWCA9IGRveDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0RGV2aWNlT3JnWSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGRldmljZU9yZ1k7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldERldmljZU9yZ1kgPSBmdW5jdGlvbiAoZG95KSB7XG4gIHRoaXMubGRldmljZU9yZ1kgPSBkb3k7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldERldmljZUV4dFggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxkZXZpY2VFeHRYO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXREZXZpY2VFeHRYID0gZnVuY3Rpb24gKGRleCkge1xuICB0aGlzLmxkZXZpY2VFeHRYID0gZGV4O1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5nZXREZXZpY2VFeHRZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sZGV2aWNlRXh0WTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0RGV2aWNlRXh0WSA9IGZ1bmN0aW9uIChkZXkpIHtcbiAgdGhpcy5sZGV2aWNlRXh0WSA9IGRleTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUudHJhbnNmb3JtWCA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciB4RGV2aWNlID0gMC4wO1xuICB2YXIgd29ybGRFeHRYID0gdGhpcy5sd29ybGRFeHRYO1xuICBpZiAod29ybGRFeHRYICE9IDAuMCkge1xuICAgIHhEZXZpY2UgPSB0aGlzLmxkZXZpY2VPcmdYICsgKHggLSB0aGlzLmx3b3JsZE9yZ1gpICogdGhpcy5sZGV2aWNlRXh0WCAvIHdvcmxkRXh0WDtcbiAgfVxuXG4gIHJldHVybiB4RGV2aWNlO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS50cmFuc2Zvcm1ZID0gZnVuY3Rpb24gKHkpIHtcbiAgdmFyIHlEZXZpY2UgPSAwLjA7XG4gIHZhciB3b3JsZEV4dFkgPSB0aGlzLmx3b3JsZEV4dFk7XG4gIGlmICh3b3JsZEV4dFkgIT0gMC4wKSB7XG4gICAgeURldmljZSA9IHRoaXMubGRldmljZU9yZ1kgKyAoeSAtIHRoaXMubHdvcmxkT3JnWSkgKiB0aGlzLmxkZXZpY2VFeHRZIC8gd29ybGRFeHRZO1xuICB9XG5cbiAgcmV0dXJuIHlEZXZpY2U7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmludmVyc2VUcmFuc2Zvcm1YID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIHhXb3JsZCA9IDAuMDtcbiAgdmFyIGRldmljZUV4dFggPSB0aGlzLmxkZXZpY2VFeHRYO1xuICBpZiAoZGV2aWNlRXh0WCAhPSAwLjApIHtcbiAgICB4V29ybGQgPSB0aGlzLmx3b3JsZE9yZ1ggKyAoeCAtIHRoaXMubGRldmljZU9yZ1gpICogdGhpcy5sd29ybGRFeHRYIC8gZGV2aWNlRXh0WDtcbiAgfVxuXG4gIHJldHVybiB4V29ybGQ7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmludmVyc2VUcmFuc2Zvcm1ZID0gZnVuY3Rpb24gKHkpIHtcbiAgdmFyIHlXb3JsZCA9IDAuMDtcbiAgdmFyIGRldmljZUV4dFkgPSB0aGlzLmxkZXZpY2VFeHRZO1xuICBpZiAoZGV2aWNlRXh0WSAhPSAwLjApIHtcbiAgICB5V29ybGQgPSB0aGlzLmx3b3JsZE9yZ1kgKyAoeSAtIHRoaXMubGRldmljZU9yZ1kpICogdGhpcy5sd29ybGRFeHRZIC8gZGV2aWNlRXh0WTtcbiAgfVxuICByZXR1cm4geVdvcmxkO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5pbnZlcnNlVHJhbnNmb3JtUG9pbnQgPSBmdW5jdGlvbiAoaW5Qb2ludCkge1xuICB2YXIgb3V0UG9pbnQgPSBuZXcgUG9pbnREKHRoaXMuaW52ZXJzZVRyYW5zZm9ybVgoaW5Qb2ludC54KSwgdGhpcy5pbnZlcnNlVHJhbnNmb3JtWShpblBvaW50LnkpKTtcbiAgcmV0dXJuIG91dFBvaW50O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbi8qKiovIH0pLFxuLyogMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbnZhciBMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcbnZhciBGRExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG52YXIgTGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBJR2VvbWV0cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xudmFyIElNYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxuZnVuY3Rpb24gRkRMYXlvdXQoKSB7XG4gIExheW91dC5jYWxsKHRoaXMpO1xuXG4gIHRoaXMudXNlU21hcnRJZGVhbEVkZ2VMZW5ndGhDYWxjdWxhdGlvbiA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfVVNFX1NNQVJUX0lERUFMX0VER0VfTEVOR1RIX0NBTENVTEFUSU9OO1xuICB0aGlzLmdyYXZpdHlDb25zdGFudCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9TVFJFTkdUSDtcbiAgdGhpcy5jb21wb3VuZEdyYXZpdHlDb25zdGFudCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9TVFJFTkdUSDtcbiAgdGhpcy5ncmF2aXR5UmFuZ2VGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfUkFOR0VfRkFDVE9SO1xuICB0aGlzLmNvbXBvdW5kR3Jhdml0eVJhbmdlRmFjdG9yID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUjtcbiAgdGhpcy5kaXNwbGFjZW1lbnRUaHJlc2hvbGRQZXJOb2RlID0gMy4wICogRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCAvIDEwMDtcbiAgdGhpcy5jb29saW5nRmFjdG9yID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT09MSU5HX0ZBQ1RPUl9JTkNSRU1FTlRBTDtcbiAgdGhpcy5pbml0aWFsQ29vbGluZ0ZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUw7XG4gIHRoaXMudG90YWxEaXNwbGFjZW1lbnQgPSAwLjA7XG4gIHRoaXMub2xkVG90YWxEaXNwbGFjZW1lbnQgPSAwLjA7XG4gIHRoaXMubWF4SXRlcmF0aW9ucyA9IEZETGF5b3V0Q29uc3RhbnRzLk1BWF9JVEVSQVRJT05TO1xufVxuXG5GRExheW91dC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExheW91dC5wcm90b3R5cGUpO1xuXG5mb3IgKHZhciBwcm9wIGluIExheW91dCkge1xuICBGRExheW91dFtwcm9wXSA9IExheW91dFtwcm9wXTtcbn1cblxuRkRMYXlvdXQucHJvdG90eXBlLmluaXRQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkge1xuICBMYXlvdXQucHJvdG90eXBlLmluaXRQYXJhbWV0ZXJzLmNhbGwodGhpcywgYXJndW1lbnRzKTtcblxuICB0aGlzLnRvdGFsSXRlcmF0aW9ucyA9IDA7XG4gIHRoaXMubm90QW5pbWF0ZWRJdGVyYXRpb25zID0gMDtcblxuICB0aGlzLnVzZUZSR3JpZFZhcmlhbnQgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX1VTRV9TTUFSVF9SRVBVTFNJT05fUkFOR0VfQ0FMQ1VMQVRJT047XG5cbiAgdGhpcy5ncmlkID0gW107XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY0lkZWFsRWRnZUxlbmd0aHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlZGdlO1xuICB2YXIgb3JpZ2luYWxJZGVhbExlbmd0aDtcbiAgdmFyIGxjYURlcHRoO1xuICB2YXIgc291cmNlO1xuICB2YXIgdGFyZ2V0O1xuICB2YXIgc2l6ZU9mU291cmNlSW5MY2E7XG4gIHZhciBzaXplT2ZUYXJnZXRJbkxjYTtcblxuICB2YXIgYWxsRWRnZXMgPSB0aGlzLmdldEdyYXBoTWFuYWdlcigpLmdldEFsbEVkZ2VzKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICBlZGdlID0gYWxsRWRnZXNbaV07XG5cbiAgICBvcmlnaW5hbElkZWFsTGVuZ3RoID0gZWRnZS5pZGVhbExlbmd0aDtcblxuICAgIGlmIChlZGdlLmlzSW50ZXJHcmFwaCkge1xuICAgICAgc291cmNlID0gZWRnZS5nZXRTb3VyY2UoKTtcbiAgICAgIHRhcmdldCA9IGVkZ2UuZ2V0VGFyZ2V0KCk7XG5cbiAgICAgIHNpemVPZlNvdXJjZUluTGNhID0gZWRnZS5nZXRTb3VyY2VJbkxjYSgpLmdldEVzdGltYXRlZFNpemUoKTtcbiAgICAgIHNpemVPZlRhcmdldEluTGNhID0gZWRnZS5nZXRUYXJnZXRJbkxjYSgpLmdldEVzdGltYXRlZFNpemUoKTtcblxuICAgICAgaWYgKHRoaXMudXNlU21hcnRJZGVhbEVkZ2VMZW5ndGhDYWxjdWxhdGlvbikge1xuICAgICAgICBlZGdlLmlkZWFsTGVuZ3RoICs9IHNpemVPZlNvdXJjZUluTGNhICsgc2l6ZU9mVGFyZ2V0SW5MY2EgLSAyICogTGF5b3V0Q29uc3RhbnRzLlNJTVBMRV9OT0RFX1NJWkU7XG4gICAgICB9XG5cbiAgICAgIGxjYURlcHRoID0gZWRnZS5nZXRMY2EoKS5nZXRJbmNsdXNpb25UcmVlRGVwdGgoKTtcblxuICAgICAgZWRnZS5pZGVhbExlbmd0aCArPSBvcmlnaW5hbElkZWFsTGVuZ3RoICogRkRMYXlvdXRDb25zdGFudHMuUEVSX0xFVkVMX0lERUFMX0VER0VfTEVOR1RIX0ZBQ1RPUiAqIChzb3VyY2UuZ2V0SW5jbHVzaW9uVHJlZURlcHRoKCkgKyB0YXJnZXQuZ2V0SW5jbHVzaW9uVHJlZURlcHRoKCkgLSAyICogbGNhRGVwdGgpO1xuICAgIH1cbiAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmluaXRTcHJpbmdFbWJlZGRlciA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgcyA9IHRoaXMuZ2V0QWxsTm9kZXMoKS5sZW5ndGg7XG4gIGlmICh0aGlzLmluY3JlbWVudGFsKSB7XG4gICAgaWYgKHMgPiBGRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX0xPV0VSX05PREVfTElNSVQpIHtcbiAgICAgIHRoaXMuY29vbGluZ0ZhY3RvciA9IE1hdGgubWF4KHRoaXMuY29vbGluZ0ZhY3RvciAqIEZETGF5b3V0Q29uc3RhbnRzLkNPT0xJTkdfQURBUFRBVElPTl9GQUNUT1IsIHRoaXMuY29vbGluZ0ZhY3RvciAtIChzIC0gRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9MT1dFUl9OT0RFX0xJTUlUKSAvIChGRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX1VQUEVSX05PREVfTElNSVQgLSBGRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX0xPV0VSX05PREVfTElNSVQpICogdGhpcy5jb29saW5nRmFjdG9yICogKDEgLSBGRExheW91dENvbnN0YW50cy5DT09MSU5HX0FEQVBUQVRJT05fRkFDVE9SKSk7XG4gICAgfVxuICAgIHRoaXMubWF4Tm9kZURpc3BsYWNlbWVudCA9IEZETGF5b3V0Q29uc3RhbnRzLk1BWF9OT0RFX0RJU1BMQUNFTUVOVF9JTkNSRU1FTlRBTDtcbiAgfSBlbHNlIHtcbiAgICBpZiAocyA+IEZETGF5b3V0Q29uc3RhbnRzLkFEQVBUQVRJT05fTE9XRVJfTk9ERV9MSU1JVCkge1xuICAgICAgdGhpcy5jb29saW5nRmFjdG9yID0gTWF0aC5tYXgoRkRMYXlvdXRDb25zdGFudHMuQ09PTElOR19BREFQVEFUSU9OX0ZBQ1RPUiwgMS4wIC0gKHMgLSBGRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX0xPV0VSX05PREVfTElNSVQpIC8gKEZETGF5b3V0Q29uc3RhbnRzLkFEQVBUQVRJT05fVVBQRVJfTk9ERV9MSU1JVCAtIEZETGF5b3V0Q29uc3RhbnRzLkFEQVBUQVRJT05fTE9XRVJfTk9ERV9MSU1JVCkgKiAoMSAtIEZETGF5b3V0Q29uc3RhbnRzLkNPT0xJTkdfQURBUFRBVElPTl9GQUNUT1IpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb29saW5nRmFjdG9yID0gMS4wO1xuICAgIH1cbiAgICB0aGlzLmluaXRpYWxDb29saW5nRmFjdG9yID0gdGhpcy5jb29saW5nRmFjdG9yO1xuICAgIHRoaXMubWF4Tm9kZURpc3BsYWNlbWVudCA9IEZETGF5b3V0Q29uc3RhbnRzLk1BWF9OT0RFX0RJU1BMQUNFTUVOVDtcbiAgfVxuXG4gIHRoaXMubWF4SXRlcmF0aW9ucyA9IE1hdGgubWF4KHRoaXMuZ2V0QWxsTm9kZXMoKS5sZW5ndGggKiA1LCB0aGlzLm1heEl0ZXJhdGlvbnMpO1xuXG4gIC8vIFJlYXNzaWduIHRoaXMgYXR0cmlidXRlIGJ5IHVzaW5nIG5ldyBjb25zdGFudCB2YWx1ZVxuICB0aGlzLmRpc3BsYWNlbWVudFRocmVzaG9sZFBlck5vZGUgPSAzLjAgKiBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIIC8gMTAwO1xuICB0aGlzLnRvdGFsRGlzcGxhY2VtZW50VGhyZXNob2xkID0gdGhpcy5kaXNwbGFjZW1lbnRUaHJlc2hvbGRQZXJOb2RlICogdGhpcy5nZXRBbGxOb2RlcygpLmxlbmd0aDtcblxuICB0aGlzLnJlcHVsc2lvblJhbmdlID0gdGhpcy5jYWxjUmVwdWxzaW9uUmFuZ2UoKTtcbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjU3ByaW5nRm9yY2VzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbEVkZ2VzID0gdGhpcy5nZXRBbGxFZGdlcygpO1xuICB2YXIgZWRnZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgIGVkZ2UgPSBsRWRnZXNbaV07XG5cbiAgICB0aGlzLmNhbGNTcHJpbmdGb3JjZShlZGdlLCBlZGdlLmlkZWFsTGVuZ3RoKTtcbiAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNSZXB1bHNpb25Gb3JjZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBncmlkVXBkYXRlQWxsb3dlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgdmFyIGZvcmNlVG9Ob2RlU3Vycm91bmRpbmdVcGRhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gIHZhciBpLCBqO1xuICB2YXIgbm9kZUEsIG5vZGVCO1xuICB2YXIgbE5vZGVzID0gdGhpcy5nZXRBbGxOb2RlcygpO1xuICB2YXIgcHJvY2Vzc2VkTm9kZVNldDtcblxuICBpZiAodGhpcy51c2VGUkdyaWRWYXJpYW50KSB7XG4gICAgaWYgKHRoaXMudG90YWxJdGVyYXRpb25zICUgRkRMYXlvdXRDb25zdGFudHMuR1JJRF9DQUxDVUxBVElPTl9DSEVDS19QRVJJT0QgPT0gMSAmJiBncmlkVXBkYXRlQWxsb3dlZCkge1xuICAgICAgdGhpcy51cGRhdGVHcmlkKCk7XG4gICAgfVxuXG4gICAgcHJvY2Vzc2VkTm9kZVNldCA9IG5ldyBTZXQoKTtcblxuICAgIC8vIGNhbGN1bGF0ZSByZXB1bHNpb24gZm9yY2VzIGJldHdlZW4gZWFjaCBub2RlcyBhbmQgaXRzIHN1cnJvdW5kaW5nXG4gICAgZm9yIChpID0gMDsgaSA8IGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbm9kZUEgPSBsTm9kZXNbaV07XG4gICAgICB0aGlzLmNhbGN1bGF0ZVJlcHVsc2lvbkZvcmNlT2ZBTm9kZShub2RlQSwgcHJvY2Vzc2VkTm9kZVNldCwgZ3JpZFVwZGF0ZUFsbG93ZWQsIGZvcmNlVG9Ob2RlU3Vycm91bmRpbmdVcGRhdGUpO1xuICAgICAgcHJvY2Vzc2VkTm9kZVNldC5hZGQobm9kZUEpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBub2RlQSA9IGxOb2Rlc1tpXTtcblxuICAgICAgZm9yIChqID0gaSArIDE7IGogPCBsTm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbm9kZUIgPSBsTm9kZXNbal07XG5cbiAgICAgICAgLy8gSWYgYm90aCBub2RlcyBhcmUgbm90IG1lbWJlcnMgb2YgdGhlIHNhbWUgZ3JhcGgsIHNraXAuXG4gICAgICAgIGlmIChub2RlQS5nZXRPd25lcigpICE9IG5vZGVCLmdldE93bmVyKCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsY1JlcHVsc2lvbkZvcmNlKG5vZGVBLCBub2RlQik7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY0dyYXZpdGF0aW9uYWxGb3JjZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlO1xuICB2YXIgbE5vZGVzID0gdGhpcy5nZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbigpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbm9kZSA9IGxOb2Rlc1tpXTtcbiAgICB0aGlzLmNhbGNHcmF2aXRhdGlvbmFsRm9yY2Uobm9kZSk7XG4gIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5tb3ZlTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsTm9kZXMgPSB0aGlzLmdldEFsbE5vZGVzKCk7XG4gIHZhciBub2RlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbm9kZSA9IGxOb2Rlc1tpXTtcbiAgICBub2RlLm1vdmUoKTtcbiAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNTcHJpbmdGb3JjZSA9IGZ1bmN0aW9uIChlZGdlLCBpZGVhbExlbmd0aCkge1xuICB2YXIgc291cmNlTm9kZSA9IGVkZ2UuZ2V0U291cmNlKCk7XG4gIHZhciB0YXJnZXROb2RlID0gZWRnZS5nZXRUYXJnZXQoKTtcblxuICB2YXIgbGVuZ3RoO1xuICB2YXIgc3ByaW5nRm9yY2U7XG4gIHZhciBzcHJpbmdGb3JjZVg7XG4gIHZhciBzcHJpbmdGb3JjZVk7XG5cbiAgLy8gVXBkYXRlIGVkZ2UgbGVuZ3RoXG4gIGlmICh0aGlzLnVuaWZvcm1MZWFmTm9kZVNpemVzICYmIHNvdXJjZU5vZGUuZ2V0Q2hpbGQoKSA9PSBudWxsICYmIHRhcmdldE5vZGUuZ2V0Q2hpbGQoKSA9PSBudWxsKSB7XG4gICAgZWRnZS51cGRhdGVMZW5ndGhTaW1wbGUoKTtcbiAgfSBlbHNlIHtcbiAgICBlZGdlLnVwZGF0ZUxlbmd0aCgpO1xuXG4gICAgaWYgKGVkZ2UuaXNPdmVybGFwaW5nU291cmNlQW5kVGFyZ2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgbGVuZ3RoID0gZWRnZS5nZXRMZW5ndGgoKTtcblxuICBpZiAobGVuZ3RoID09IDApIHJldHVybjtcblxuICAvLyBDYWxjdWxhdGUgc3ByaW5nIGZvcmNlc1xuICBzcHJpbmdGb3JjZSA9IGVkZ2UuZWRnZUVsYXN0aWNpdHkgKiAobGVuZ3RoIC0gaWRlYWxMZW5ndGgpO1xuXG4gIC8vIFByb2plY3QgZm9yY2Ugb250byB4IGFuZCB5IGF4ZXNcbiAgc3ByaW5nRm9yY2VYID0gc3ByaW5nRm9yY2UgKiAoZWRnZS5sZW5ndGhYIC8gbGVuZ3RoKTtcbiAgc3ByaW5nRm9yY2VZID0gc3ByaW5nRm9yY2UgKiAoZWRnZS5sZW5ndGhZIC8gbGVuZ3RoKTtcblxuICAvLyBBcHBseSBmb3JjZXMgb24gdGhlIGVuZCBub2Rlc1xuICBzb3VyY2VOb2RlLnNwcmluZ0ZvcmNlWCArPSBzcHJpbmdGb3JjZVg7XG4gIHNvdXJjZU5vZGUuc3ByaW5nRm9yY2VZICs9IHNwcmluZ0ZvcmNlWTtcbiAgdGFyZ2V0Tm9kZS5zcHJpbmdGb3JjZVggLT0gc3ByaW5nRm9yY2VYO1xuICB0YXJnZXROb2RlLnNwcmluZ0ZvcmNlWSAtPSBzcHJpbmdGb3JjZVk7XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY1JlcHVsc2lvbkZvcmNlID0gZnVuY3Rpb24gKG5vZGVBLCBub2RlQikge1xuICB2YXIgcmVjdEEgPSBub2RlQS5nZXRSZWN0KCk7XG4gIHZhciByZWN0QiA9IG5vZGVCLmdldFJlY3QoKTtcbiAgdmFyIG92ZXJsYXBBbW91bnQgPSBuZXcgQXJyYXkoMik7XG4gIHZhciBjbGlwUG9pbnRzID0gbmV3IEFycmF5KDQpO1xuICB2YXIgZGlzdGFuY2VYO1xuICB2YXIgZGlzdGFuY2VZO1xuICB2YXIgZGlzdGFuY2VTcXVhcmVkO1xuICB2YXIgZGlzdGFuY2U7XG4gIHZhciByZXB1bHNpb25Gb3JjZTtcbiAgdmFyIHJlcHVsc2lvbkZvcmNlWDtcbiAgdmFyIHJlcHVsc2lvbkZvcmNlWTtcblxuICBpZiAocmVjdEEuaW50ZXJzZWN0cyhyZWN0QikpIC8vIHR3byBub2RlcyBvdmVybGFwXG4gICAge1xuICAgICAgLy8gY2FsY3VsYXRlIHNlcGFyYXRpb24gYW1vdW50IGluIHggYW5kIHkgZGlyZWN0aW9uc1xuICAgICAgSUdlb21ldHJ5LmNhbGNTZXBhcmF0aW9uQW1vdW50KHJlY3RBLCByZWN0Qiwgb3ZlcmxhcEFtb3VudCwgRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCAvIDIuMCk7XG5cbiAgICAgIHJlcHVsc2lvbkZvcmNlWCA9IDIgKiBvdmVybGFwQW1vdW50WzBdO1xuICAgICAgcmVwdWxzaW9uRm9yY2VZID0gMiAqIG92ZXJsYXBBbW91bnRbMV07XG5cbiAgICAgIHZhciBjaGlsZHJlbkNvbnN0YW50ID0gbm9kZUEubm9PZkNoaWxkcmVuICogbm9kZUIubm9PZkNoaWxkcmVuIC8gKG5vZGVBLm5vT2ZDaGlsZHJlbiArIG5vZGVCLm5vT2ZDaGlsZHJlbik7XG5cbiAgICAgIC8vIEFwcGx5IGZvcmNlcyBvbiB0aGUgdHdvIG5vZGVzXG4gICAgICBub2RlQS5yZXB1bHNpb25Gb3JjZVggLT0gY2hpbGRyZW5Db25zdGFudCAqIHJlcHVsc2lvbkZvcmNlWDtcbiAgICAgIG5vZGVBLnJlcHVsc2lvbkZvcmNlWSAtPSBjaGlsZHJlbkNvbnN0YW50ICogcmVwdWxzaW9uRm9yY2VZO1xuICAgICAgbm9kZUIucmVwdWxzaW9uRm9yY2VYICs9IGNoaWxkcmVuQ29uc3RhbnQgKiByZXB1bHNpb25Gb3JjZVg7XG4gICAgICBub2RlQi5yZXB1bHNpb25Gb3JjZVkgKz0gY2hpbGRyZW5Db25zdGFudCAqIHJlcHVsc2lvbkZvcmNlWTtcbiAgICB9IGVsc2UgLy8gbm8gb3ZlcmxhcFxuICAgIHtcbiAgICAgIC8vIGNhbGN1bGF0ZSBkaXN0YW5jZVxuXG4gICAgICBpZiAodGhpcy51bmlmb3JtTGVhZk5vZGVTaXplcyAmJiBub2RlQS5nZXRDaGlsZCgpID09IG51bGwgJiYgbm9kZUIuZ2V0Q2hpbGQoKSA9PSBudWxsKSAvLyBzaW1wbHkgYmFzZSByZXB1bHNpb24gb24gZGlzdGFuY2Ugb2Ygbm9kZSBjZW50ZXJzXG4gICAgICAgIHtcbiAgICAgICAgICBkaXN0YW5jZVggPSByZWN0Qi5nZXRDZW50ZXJYKCkgLSByZWN0QS5nZXRDZW50ZXJYKCk7XG4gICAgICAgICAgZGlzdGFuY2VZID0gcmVjdEIuZ2V0Q2VudGVyWSgpIC0gcmVjdEEuZ2V0Q2VudGVyWSgpO1xuICAgICAgICB9IGVsc2UgLy8gdXNlIGNsaXBwaW5nIHBvaW50c1xuICAgICAgICB7XG4gICAgICAgICAgSUdlb21ldHJ5LmdldEludGVyc2VjdGlvbihyZWN0QSwgcmVjdEIsIGNsaXBQb2ludHMpO1xuXG4gICAgICAgICAgZGlzdGFuY2VYID0gY2xpcFBvaW50c1syXSAtIGNsaXBQb2ludHNbMF07XG4gICAgICAgICAgZGlzdGFuY2VZID0gY2xpcFBvaW50c1szXSAtIGNsaXBQb2ludHNbMV07XG4gICAgICAgIH1cblxuICAgICAgLy8gTm8gcmVwdWxzaW9uIHJhbmdlLiBGUiBncmlkIHZhcmlhbnQgc2hvdWxkIHRha2UgY2FyZSBvZiB0aGlzLlxuICAgICAgaWYgKE1hdGguYWJzKGRpc3RhbmNlWCkgPCBGRExheW91dENvbnN0YW50cy5NSU5fUkVQVUxTSU9OX0RJU1QpIHtcbiAgICAgICAgZGlzdGFuY2VYID0gSU1hdGguc2lnbihkaXN0YW5jZVgpICogRkRMYXlvdXRDb25zdGFudHMuTUlOX1JFUFVMU0lPTl9ESVNUO1xuICAgICAgfVxuXG4gICAgICBpZiAoTWF0aC5hYnMoZGlzdGFuY2VZKSA8IEZETGF5b3V0Q29uc3RhbnRzLk1JTl9SRVBVTFNJT05fRElTVCkge1xuICAgICAgICBkaXN0YW5jZVkgPSBJTWF0aC5zaWduKGRpc3RhbmNlWSkgKiBGRExheW91dENvbnN0YW50cy5NSU5fUkVQVUxTSU9OX0RJU1Q7XG4gICAgICB9XG5cbiAgICAgIGRpc3RhbmNlU3F1YXJlZCA9IGRpc3RhbmNlWCAqIGRpc3RhbmNlWCArIGRpc3RhbmNlWSAqIGRpc3RhbmNlWTtcbiAgICAgIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGRpc3RhbmNlU3F1YXJlZCk7XG5cbiAgICAgIC8vIEhlcmUgd2UgdXNlIGhhbGYgb2YgdGhlIG5vZGVzJyByZXB1bHNpb24gdmFsdWVzIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICByZXB1bHNpb25Gb3JjZSA9IChub2RlQS5ub2RlUmVwdWxzaW9uIC8gMiArIG5vZGVCLm5vZGVSZXB1bHNpb24gLyAyKSAqIG5vZGVBLm5vT2ZDaGlsZHJlbiAqIG5vZGVCLm5vT2ZDaGlsZHJlbiAvIGRpc3RhbmNlU3F1YXJlZDtcblxuICAgICAgLy8gUHJvamVjdCBmb3JjZSBvbnRvIHggYW5kIHkgYXhlc1xuICAgICAgcmVwdWxzaW9uRm9yY2VYID0gcmVwdWxzaW9uRm9yY2UgKiBkaXN0YW5jZVggLyBkaXN0YW5jZTtcbiAgICAgIHJlcHVsc2lvbkZvcmNlWSA9IHJlcHVsc2lvbkZvcmNlICogZGlzdGFuY2VZIC8gZGlzdGFuY2U7XG5cbiAgICAgIC8vIEFwcGx5IGZvcmNlcyBvbiB0aGUgdHdvIG5vZGVzICAgIFxuICAgICAgbm9kZUEucmVwdWxzaW9uRm9yY2VYIC09IHJlcHVsc2lvbkZvcmNlWDtcbiAgICAgIG5vZGVBLnJlcHVsc2lvbkZvcmNlWSAtPSByZXB1bHNpb25Gb3JjZVk7XG4gICAgICBub2RlQi5yZXB1bHNpb25Gb3JjZVggKz0gcmVwdWxzaW9uRm9yY2VYO1xuICAgICAgbm9kZUIucmVwdWxzaW9uRm9yY2VZICs9IHJlcHVsc2lvbkZvcmNlWTtcbiAgICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY0dyYXZpdGF0aW9uYWxGb3JjZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBvd25lckdyYXBoO1xuICB2YXIgb3duZXJDZW50ZXJYO1xuICB2YXIgb3duZXJDZW50ZXJZO1xuICB2YXIgZGlzdGFuY2VYO1xuICB2YXIgZGlzdGFuY2VZO1xuICB2YXIgYWJzRGlzdGFuY2VYO1xuICB2YXIgYWJzRGlzdGFuY2VZO1xuICB2YXIgZXN0aW1hdGVkU2l6ZTtcbiAgb3duZXJHcmFwaCA9IG5vZGUuZ2V0T3duZXIoKTtcblxuICBvd25lckNlbnRlclggPSAob3duZXJHcmFwaC5nZXRSaWdodCgpICsgb3duZXJHcmFwaC5nZXRMZWZ0KCkpIC8gMjtcbiAgb3duZXJDZW50ZXJZID0gKG93bmVyR3JhcGguZ2V0VG9wKCkgKyBvd25lckdyYXBoLmdldEJvdHRvbSgpKSAvIDI7XG4gIGRpc3RhbmNlWCA9IG5vZGUuZ2V0Q2VudGVyWCgpIC0gb3duZXJDZW50ZXJYO1xuICBkaXN0YW5jZVkgPSBub2RlLmdldENlbnRlclkoKSAtIG93bmVyQ2VudGVyWTtcbiAgYWJzRGlzdGFuY2VYID0gTWF0aC5hYnMoZGlzdGFuY2VYKSArIG5vZGUuZ2V0V2lkdGgoKSAvIDI7XG4gIGFic0Rpc3RhbmNlWSA9IE1hdGguYWJzKGRpc3RhbmNlWSkgKyBub2RlLmdldEhlaWdodCgpIC8gMjtcblxuICBpZiAobm9kZS5nZXRPd25lcigpID09IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKSkgLy8gaW4gdGhlIHJvb3QgZ3JhcGhcbiAgICB7XG4gICAgICBlc3RpbWF0ZWRTaXplID0gb3duZXJHcmFwaC5nZXRFc3RpbWF0ZWRTaXplKCkgKiB0aGlzLmdyYXZpdHlSYW5nZUZhY3RvcjtcblxuICAgICAgaWYgKGFic0Rpc3RhbmNlWCA+IGVzdGltYXRlZFNpemUgfHwgYWJzRGlzdGFuY2VZID4gZXN0aW1hdGVkU2l6ZSkge1xuICAgICAgICBub2RlLmdyYXZpdGF0aW9uRm9yY2VYID0gLXRoaXMuZ3Jhdml0eUNvbnN0YW50ICogZGlzdGFuY2VYO1xuICAgICAgICBub2RlLmdyYXZpdGF0aW9uRm9yY2VZID0gLXRoaXMuZ3Jhdml0eUNvbnN0YW50ICogZGlzdGFuY2VZO1xuICAgICAgfVxuICAgIH0gZWxzZSAvLyBpbnNpZGUgYSBjb21wb3VuZFxuICAgIHtcbiAgICAgIGVzdGltYXRlZFNpemUgPSBvd25lckdyYXBoLmdldEVzdGltYXRlZFNpemUoKSAqIHRoaXMuY29tcG91bmRHcmF2aXR5UmFuZ2VGYWN0b3I7XG5cbiAgICAgIGlmIChhYnNEaXN0YW5jZVggPiBlc3RpbWF0ZWRTaXplIHx8IGFic0Rpc3RhbmNlWSA+IGVzdGltYXRlZFNpemUpIHtcbiAgICAgICAgbm9kZS5ncmF2aXRhdGlvbkZvcmNlWCA9IC10aGlzLmdyYXZpdHlDb25zdGFudCAqIGRpc3RhbmNlWCAqIHRoaXMuY29tcG91bmRHcmF2aXR5Q29uc3RhbnQ7XG4gICAgICAgIG5vZGUuZ3Jhdml0YXRpb25Gb3JjZVkgPSAtdGhpcy5ncmF2aXR5Q29uc3RhbnQgKiBkaXN0YW5jZVkgKiB0aGlzLmNvbXBvdW5kR3Jhdml0eUNvbnN0YW50O1xuICAgICAgfVxuICAgIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5pc0NvbnZlcmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNvbnZlcmdlZDtcbiAgdmFyIG9zY2lsYXRpbmcgPSBmYWxzZTtcblxuICBpZiAodGhpcy50b3RhbEl0ZXJhdGlvbnMgPiB0aGlzLm1heEl0ZXJhdGlvbnMgLyAzKSB7XG4gICAgb3NjaWxhdGluZyA9IE1hdGguYWJzKHRoaXMudG90YWxEaXNwbGFjZW1lbnQgLSB0aGlzLm9sZFRvdGFsRGlzcGxhY2VtZW50KSA8IDI7XG4gIH1cblxuICBjb252ZXJnZWQgPSB0aGlzLnRvdGFsRGlzcGxhY2VtZW50IDwgdGhpcy50b3RhbERpc3BsYWNlbWVudFRocmVzaG9sZDtcblxuICB0aGlzLm9sZFRvdGFsRGlzcGxhY2VtZW50ID0gdGhpcy50b3RhbERpc3BsYWNlbWVudDtcblxuICByZXR1cm4gY29udmVyZ2VkIHx8IG9zY2lsYXRpbmc7XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuYW5pbWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYW5pbWF0aW9uRHVyaW5nTGF5b3V0ICYmICF0aGlzLmlzU3ViTGF5b3V0KSB7XG4gICAgaWYgKHRoaXMubm90QW5pbWF0ZWRJdGVyYXRpb25zID09IHRoaXMuYW5pbWF0aW9uUGVyaW9kKSB7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgdGhpcy5ub3RBbmltYXRlZEl0ZXJhdGlvbnMgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5vdEFuaW1hdGVkSXRlcmF0aW9ucysrO1xuICAgIH1cbiAgfVxufTtcblxuLy9UaGlzIG1ldGhvZCBjYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gKHdlaWdodCkgZm9yIGFsbCBub2Rlc1xuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNOb09mQ2hpbGRyZW5Gb3JBbGxOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGU7XG4gIHZhciBhbGxOb2RlcyA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbE5vZGVzKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIG5vZGUgPSBhbGxOb2Rlc1tpXTtcbiAgICBub2RlLm5vT2ZDaGlsZHJlbiA9IG5vZGUuZ2V0Tm9PZkNoaWxkcmVuKCk7XG4gIH1cbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBTZWN0aW9uOiBGUi1HcmlkIFZhcmlhbnQgUmVwdWxzaW9uIEZvcmNlIENhbGN1bGF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY0dyaWQgPSBmdW5jdGlvbiAoZ3JhcGgpIHtcblxuICB2YXIgc2l6ZVggPSAwO1xuICB2YXIgc2l6ZVkgPSAwO1xuXG4gIHNpemVYID0gcGFyc2VJbnQoTWF0aC5jZWlsKChncmFwaC5nZXRSaWdodCgpIC0gZ3JhcGguZ2V0TGVmdCgpKSAvIHRoaXMucmVwdWxzaW9uUmFuZ2UpKTtcbiAgc2l6ZVkgPSBwYXJzZUludChNYXRoLmNlaWwoKGdyYXBoLmdldEJvdHRvbSgpIC0gZ3JhcGguZ2V0VG9wKCkpIC8gdGhpcy5yZXB1bHNpb25SYW5nZSkpO1xuXG4gIHZhciBncmlkID0gbmV3IEFycmF5KHNpemVYKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemVYOyBpKyspIHtcbiAgICBncmlkW2ldID0gbmV3IEFycmF5KHNpemVZKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZVg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2l6ZVk7IGorKykge1xuICAgICAgZ3JpZFtpXVtqXSA9IG5ldyBBcnJheSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBncmlkO1xufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmFkZE5vZGVUb0dyaWQgPSBmdW5jdGlvbiAodiwgbGVmdCwgdG9wKSB7XG5cbiAgdmFyIHN0YXJ0WCA9IDA7XG4gIHZhciBmaW5pc2hYID0gMDtcbiAgdmFyIHN0YXJ0WSA9IDA7XG4gIHZhciBmaW5pc2hZID0gMDtcblxuICBzdGFydFggPSBwYXJzZUludChNYXRoLmZsb29yKCh2LmdldFJlY3QoKS54IC0gbGVmdCkgLyB0aGlzLnJlcHVsc2lvblJhbmdlKSk7XG4gIGZpbmlzaFggPSBwYXJzZUludChNYXRoLmZsb29yKCh2LmdldFJlY3QoKS53aWR0aCArIHYuZ2V0UmVjdCgpLnggLSBsZWZ0KSAvIHRoaXMucmVwdWxzaW9uUmFuZ2UpKTtcbiAgc3RhcnRZID0gcGFyc2VJbnQoTWF0aC5mbG9vcigodi5nZXRSZWN0KCkueSAtIHRvcCkgLyB0aGlzLnJlcHVsc2lvblJhbmdlKSk7XG4gIGZpbmlzaFkgPSBwYXJzZUludChNYXRoLmZsb29yKCh2LmdldFJlY3QoKS5oZWlnaHQgKyB2LmdldFJlY3QoKS55IC0gdG9wKSAvIHRoaXMucmVwdWxzaW9uUmFuZ2UpKTtcblxuICBmb3IgKHZhciBpID0gc3RhcnRYOyBpIDw9IGZpbmlzaFg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSBzdGFydFk7IGogPD0gZmluaXNoWTsgaisrKSB7XG4gICAgICB0aGlzLmdyaWRbaV1bal0ucHVzaCh2KTtcbiAgICAgIHYuc2V0R3JpZENvb3JkaW5hdGVzKHN0YXJ0WCwgZmluaXNoWCwgc3RhcnRZLCBmaW5pc2hZKTtcbiAgICB9XG4gIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS51cGRhdGVHcmlkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaTtcbiAgdmFyIG5vZGVBO1xuICB2YXIgbE5vZGVzID0gdGhpcy5nZXRBbGxOb2RlcygpO1xuXG4gIHRoaXMuZ3JpZCA9IHRoaXMuY2FsY0dyaWQodGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpKTtcblxuICAvLyBwdXQgYWxsIG5vZGVzIHRvIHByb3BlciBncmlkIGNlbGxzXG4gIGZvciAoaSA9IDA7IGkgPCBsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlQSA9IGxOb2Rlc1tpXTtcbiAgICB0aGlzLmFkZE5vZGVUb0dyaWQobm9kZUEsIHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKS5nZXRMZWZ0KCksIHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKS5nZXRUb3AoKSk7XG4gIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjdWxhdGVSZXB1bHNpb25Gb3JjZU9mQU5vZGUgPSBmdW5jdGlvbiAobm9kZUEsIHByb2Nlc3NlZE5vZGVTZXQsIGdyaWRVcGRhdGVBbGxvd2VkLCBmb3JjZVRvTm9kZVN1cnJvdW5kaW5nVXBkYXRlKSB7XG5cbiAgaWYgKHRoaXMudG90YWxJdGVyYXRpb25zICUgRkRMYXlvdXRDb25zdGFudHMuR1JJRF9DQUxDVUxBVElPTl9DSEVDS19QRVJJT0QgPT0gMSAmJiBncmlkVXBkYXRlQWxsb3dlZCB8fCBmb3JjZVRvTm9kZVN1cnJvdW5kaW5nVXBkYXRlKSB7XG4gICAgdmFyIHN1cnJvdW5kaW5nID0gbmV3IFNldCgpO1xuICAgIG5vZGVBLnN1cnJvdW5kaW5nID0gbmV3IEFycmF5KCk7XG4gICAgdmFyIG5vZGVCO1xuICAgIHZhciBncmlkID0gdGhpcy5ncmlkO1xuXG4gICAgZm9yICh2YXIgaSA9IG5vZGVBLnN0YXJ0WCAtIDE7IGkgPCBub2RlQS5maW5pc2hYICsgMjsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gbm9kZUEuc3RhcnRZIC0gMTsgaiA8IG5vZGVBLmZpbmlzaFkgKyAyOyBqKyspIHtcbiAgICAgICAgaWYgKCEoaSA8IDAgfHwgaiA8IDAgfHwgaSA+PSBncmlkLmxlbmd0aCB8fCBqID49IGdyaWRbMF0ubGVuZ3RoKSkge1xuICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZ3JpZFtpXVtqXS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgbm9kZUIgPSBncmlkW2ldW2pdW2tdO1xuXG4gICAgICAgICAgICAvLyBJZiBib3RoIG5vZGVzIGFyZSBub3QgbWVtYmVycyBvZiB0aGUgc2FtZSBncmFwaCwgXG4gICAgICAgICAgICAvLyBvciBib3RoIG5vZGVzIGFyZSB0aGUgc2FtZSwgc2tpcC5cbiAgICAgICAgICAgIGlmIChub2RlQS5nZXRPd25lcigpICE9IG5vZGVCLmdldE93bmVyKCkgfHwgbm9kZUEgPT0gbm9kZUIpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSByZXB1bHNpb24gZm9yY2UgYmV0d2VlblxuICAgICAgICAgICAgLy8gbm9kZUEgYW5kIG5vZGVCIGhhcyBhbHJlYWR5IGJlZW4gY2FsY3VsYXRlZFxuICAgICAgICAgICAgaWYgKCFwcm9jZXNzZWROb2RlU2V0Lmhhcyhub2RlQikgJiYgIXN1cnJvdW5kaW5nLmhhcyhub2RlQikpIHtcbiAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlWCA9IE1hdGguYWJzKG5vZGVBLmdldENlbnRlclgoKSAtIG5vZGVCLmdldENlbnRlclgoKSkgLSAobm9kZUEuZ2V0V2lkdGgoKSAvIDIgKyBub2RlQi5nZXRXaWR0aCgpIC8gMik7XG4gICAgICAgICAgICAgIHZhciBkaXN0YW5jZVkgPSBNYXRoLmFicyhub2RlQS5nZXRDZW50ZXJZKCkgLSBub2RlQi5nZXRDZW50ZXJZKCkpIC0gKG5vZGVBLmdldEhlaWdodCgpIC8gMiArIG5vZGVCLmdldEhlaWdodCgpIC8gMik7XG5cbiAgICAgICAgICAgICAgLy8gaWYgdGhlIGRpc3RhbmNlIGJldHdlZW4gbm9kZUEgYW5kIG5vZGVCIFxuICAgICAgICAgICAgICAvLyBpcyBsZXNzIHRoZW4gY2FsY3VsYXRpb24gcmFuZ2VcbiAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlWCA8PSB0aGlzLnJlcHVsc2lvblJhbmdlICYmIGRpc3RhbmNlWSA8PSB0aGlzLnJlcHVsc2lvblJhbmdlKSB7XG4gICAgICAgICAgICAgICAgLy90aGVuIGFkZCBub2RlQiB0byBzdXJyb3VuZGluZyBvZiBub2RlQVxuICAgICAgICAgICAgICAgIHN1cnJvdW5kaW5nLmFkZChub2RlQik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlQS5zdXJyb3VuZGluZyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoc3Vycm91bmRpbmcpKTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgbm9kZUEuc3Vycm91bmRpbmcubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLmNhbGNSZXB1bHNpb25Gb3JjZShub2RlQSwgbm9kZUEuc3Vycm91bmRpbmdbaV0pO1xuICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY1JlcHVsc2lvblJhbmdlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gMC4wO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGRExheW91dDtcblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgTEVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIEZETGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuZnVuY3Rpb24gRkRMYXlvdXRFZGdlKHNvdXJjZSwgdGFyZ2V0LCB2RWRnZSkge1xuICBMRWRnZS5jYWxsKHRoaXMsIHNvdXJjZSwgdGFyZ2V0LCB2RWRnZSk7XG5cbiAgLy8gSWRlYWwgbGVuZ3RoIGFuZCBlbGFzdGljaXR5IHZhbHVlIGZvciB0aGlzIGVkZ2VcbiAgdGhpcy5pZGVhbExlbmd0aCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEg7XG4gIHRoaXMuZWRnZUVsYXN0aWNpdHkgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX1NQUklOR19TVFJFTkdUSDtcbn1cblxuRkRMYXlvdXRFZGdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTEVkZ2UucHJvdG90eXBlKTtcblxuZm9yICh2YXIgcHJvcCBpbiBMRWRnZSkge1xuICBGRExheW91dEVkZ2VbcHJvcF0gPSBMRWRnZVtwcm9wXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBGRExheW91dEVkZ2U7XG5cbi8qKiovIH0pLFxuLyogMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIExOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBGRExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbmZ1bmN0aW9uIEZETGF5b3V0Tm9kZShnbSwgbG9jLCBzaXplLCB2Tm9kZSkge1xuICAvLyBhbHRlcm5hdGl2ZSBjb25zdHJ1Y3RvciBpcyBoYW5kbGVkIGluc2lkZSBMTm9kZVxuICBMTm9kZS5jYWxsKHRoaXMsIGdtLCBsb2MsIHNpemUsIHZOb2RlKTtcblxuICAvLyBSZXB1bHNpb24gdmFsdWUgb2YgdGhpcyBub2RlXG4gIHRoaXMubm9kZVJlcHVsc2lvbiA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfUkVQVUxTSU9OX1NUUkVOR1RIO1xuXG4gIC8vU3ByaW5nLCByZXB1bHNpb24gYW5kIGdyYXZpdGF0aW9uYWwgZm9yY2VzIGFjdGluZyBvbiB0aGlzIG5vZGVcbiAgdGhpcy5zcHJpbmdGb3JjZVggPSAwO1xuICB0aGlzLnNwcmluZ0ZvcmNlWSA9IDA7XG4gIHRoaXMucmVwdWxzaW9uRm9yY2VYID0gMDtcbiAgdGhpcy5yZXB1bHNpb25Gb3JjZVkgPSAwO1xuICB0aGlzLmdyYXZpdGF0aW9uRm9yY2VYID0gMDtcbiAgdGhpcy5ncmF2aXRhdGlvbkZvcmNlWSA9IDA7XG4gIC8vQW1vdW50IGJ5IHdoaWNoIHRoaXMgbm9kZSBpcyB0byBiZSBtb3ZlZCBpbiB0aGlzIGl0ZXJhdGlvblxuICB0aGlzLmRpc3BsYWNlbWVudFggPSAwO1xuICB0aGlzLmRpc3BsYWNlbWVudFkgPSAwO1xuXG4gIC8vU3RhcnQgYW5kIGZpbmlzaCBncmlkIGNvb3JkaW5hdGVzIHRoYXQgdGhpcyBub2RlIGlzIGZhbGxlbiBpbnRvXG4gIHRoaXMuc3RhcnRYID0gMDtcbiAgdGhpcy5maW5pc2hYID0gMDtcbiAgdGhpcy5zdGFydFkgPSAwO1xuICB0aGlzLmZpbmlzaFkgPSAwO1xuXG4gIC8vR2VvbWV0cmljIG5laWdoYm9ycyBvZiB0aGlzIG5vZGVcbiAgdGhpcy5zdXJyb3VuZGluZyA9IFtdO1xufVxuXG5GRExheW91dE5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMTm9kZS5wcm90b3R5cGUpO1xuXG5mb3IgKHZhciBwcm9wIGluIExOb2RlKSB7XG4gIEZETGF5b3V0Tm9kZVtwcm9wXSA9IExOb2RlW3Byb3BdO1xufVxuXG5GRExheW91dE5vZGUucHJvdG90eXBlLnNldEdyaWRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIChfc3RhcnRYLCBfZmluaXNoWCwgX3N0YXJ0WSwgX2ZpbmlzaFkpIHtcbiAgdGhpcy5zdGFydFggPSBfc3RhcnRYO1xuICB0aGlzLmZpbmlzaFggPSBfZmluaXNoWDtcbiAgdGhpcy5zdGFydFkgPSBfc3RhcnRZO1xuICB0aGlzLmZpbmlzaFkgPSBfZmluaXNoWTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRkRMYXlvdXROb2RlO1xuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIERpbWVuc2lvbkQod2lkdGgsIGhlaWdodCkge1xuICB0aGlzLndpZHRoID0gMDtcbiAgdGhpcy5oZWlnaHQgPSAwO1xuICBpZiAod2lkdGggIT09IG51bGwgJiYgaGVpZ2h0ICE9PSBudWxsKSB7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICB9XG59XG5cbkRpbWVuc2lvbkQucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy53aWR0aDtcbn07XG5cbkRpbWVuc2lvbkQucHJvdG90eXBlLnNldFdpZHRoID0gZnVuY3Rpb24gKHdpZHRoKSB7XG4gIHRoaXMud2lkdGggPSB3aWR0aDtcbn07XG5cbkRpbWVuc2lvbkQucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xufTtcblxuRGltZW5zaW9uRC5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCkge1xuICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGltZW5zaW9uRDtcblxuLyoqKi8gfSksXG4vKiAyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgVW5pcXVlSURHZW5lcmV0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblxuZnVuY3Rpb24gSGFzaE1hcCgpIHtcbiAgdGhpcy5tYXAgPSB7fTtcbiAgdGhpcy5rZXlzID0gW107XG59XG5cbkhhc2hNYXAucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHZhciB0aGVJZCA9IFVuaXF1ZUlER2VuZXJldG9yLmNyZWF0ZUlEKGtleSk7XG4gIGlmICghdGhpcy5jb250YWlucyh0aGVJZCkpIHtcbiAgICB0aGlzLm1hcFt0aGVJZF0gPSB2YWx1ZTtcbiAgICB0aGlzLmtleXMucHVzaChrZXkpO1xuICB9XG59O1xuXG5IYXNoTWFwLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgdmFyIHRoZUlkID0gVW5pcXVlSURHZW5lcmV0b3IuY3JlYXRlSUQoa2V5KTtcbiAgcmV0dXJuIHRoaXMubWFwW2tleV0gIT0gbnVsbDtcbn07XG5cbkhhc2hNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgdmFyIHRoZUlkID0gVW5pcXVlSURHZW5lcmV0b3IuY3JlYXRlSUQoa2V5KTtcbiAgcmV0dXJuIHRoaXMubWFwW3RoZUlkXTtcbn07XG5cbkhhc2hNYXAucHJvdG90eXBlLmtleVNldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMua2V5cztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaE1hcDtcblxuLyoqKi8gfSksXG4vKiAyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgVW5pcXVlSURHZW5lcmV0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblxuZnVuY3Rpb24gSGFzaFNldCgpIHtcbiAgdGhpcy5zZXQgPSB7fTtcbn1cbjtcblxuSGFzaFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgdGhlSWQgPSBVbmlxdWVJREdlbmVyZXRvci5jcmVhdGVJRChvYmopO1xuICBpZiAoIXRoaXMuY29udGFpbnModGhlSWQpKSB0aGlzLnNldFt0aGVJZF0gPSBvYmo7XG59O1xuXG5IYXNoU2V0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIGRlbGV0ZSB0aGlzLnNldFtVbmlxdWVJREdlbmVyZXRvci5jcmVhdGVJRChvYmopXTtcbn07XG5cbkhhc2hTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnNldCA9IHt9O1xufTtcblxuSGFzaFNldC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0aGlzLnNldFtVbmlxdWVJREdlbmVyZXRvci5jcmVhdGVJRChvYmopXSA9PSBvYmo7XG59O1xuXG5IYXNoU2V0LnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zaXplKCkgPT09IDA7XG59O1xuXG5IYXNoU2V0LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zZXQpLmxlbmd0aDtcbn07XG5cbi8vY29uY2F0cyB0aGlzLnNldCB0byB0aGUgZ2l2ZW4gbGlzdFxuSGFzaFNldC5wcm90b3R5cGUuYWRkQWxsVG8gPSBmdW5jdGlvbiAobGlzdCkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMuc2V0KTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgbGlzdC5wdXNoKHRoaXMuc2V0W2tleXNbaV1dKTtcbiAgfVxufTtcblxuSGFzaFNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc2V0KS5sZW5ndGg7XG59O1xuXG5IYXNoU2V0LnByb3RvdHlwZS5hZGRBbGwgPSBmdW5jdGlvbiAobGlzdCkge1xuICB2YXIgcyA9IGxpc3QubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIHZhciB2ID0gbGlzdFtpXTtcbiAgICB0aGlzLmFkZCh2KTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoU2V0O1xuXG4vKioqLyB9KSxcbi8qIDI0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8vIFNvbWUgbWF0cml4ICgxZCBhbmQgMmQgYXJyYXkpIG9wZXJhdGlvbnNcbmZ1bmN0aW9uIE1hdHJpeCgpIHt9XG5cbi8qKlxuICogbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gKiBhcnJheTEsIGFycmF5MiBhbmQgcmVzdWx0IGFyZSAyZCBhcnJheXNcbiAqL1xuTWF0cml4Lm11bHRNYXQgPSBmdW5jdGlvbiAoYXJyYXkxLCBhcnJheTIpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkxLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0W2ldID0gW107XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBhcnJheTJbMF0ubGVuZ3RoOyBqKyspIHtcbiAgICAgIHJlc3VsdFtpXVtqXSA9IDA7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IGFycmF5MVswXS5sZW5ndGg7IGsrKykge1xuICAgICAgICByZXN1bHRbaV1bal0gKz0gYXJyYXkxW2ldW2tdICogYXJyYXkyW2tdW2pdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBtYXRyaXggdHJhbnNwb3NlXG4gKiBhcnJheSBhbmQgcmVzdWx0IGFyZSAyZCBhcnJheXNcbiAqL1xuTWF0cml4LnRyYW5zcG9zZSA9IGZ1bmN0aW9uIChhcnJheSkge1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheVswXS5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdFtpXSA9IFtdO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgIHJlc3VsdFtpXVtqXSA9IGFycmF5W2pdW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIG11bHRpcGx5IGFycmF5IHdpdGggY29uc3RhbnRcbiAqIGFycmF5IGFuZCByZXN1bHQgYXJlIDFkIGFycmF5c1xuICovXG5NYXRyaXgubXVsdENvbnMgPSBmdW5jdGlvbiAoYXJyYXksIGNvbnN0YW50KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0W2ldID0gYXJyYXlbaV0gKiBjb25zdGFudDtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIHN1YnN0cmFjdCB0d28gYXJyYXlzXG4gKiBhcnJheTEsIGFycmF5MiBhbmQgcmVzdWx0IGFyZSAxZCBhcnJheXNcbiAqL1xuTWF0cml4Lm1pbnVzT3AgPSBmdW5jdGlvbiAoYXJyYXkxLCBhcnJheTIpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkxLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0W2ldID0gYXJyYXkxW2ldIC0gYXJyYXkyW2ldO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogZG90IHByb2R1Y3Qgb2YgdHdvIGFycmF5cyB3aXRoIHNhbWUgc2l6ZVxuICogYXJyYXkxIGFuZCBhcnJheTIgYXJlIDFkIGFycmF5c1xuICovXG5NYXRyaXguZG90UHJvZHVjdCA9IGZ1bmN0aW9uIChhcnJheTEsIGFycmF5Mikge1xuICB2YXIgcHJvZHVjdCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheTEubGVuZ3RoOyBpKyspIHtcbiAgICBwcm9kdWN0ICs9IGFycmF5MVtpXSAqIGFycmF5MltpXTtcbiAgfVxuXG4gIHJldHVybiBwcm9kdWN0O1xufTtcblxuLyoqXG4gKiBtYWduaXR1ZGUgb2YgYW4gYXJyYXlcbiAqIGFycmF5IGlzIDFkIGFycmF5XG4gKi9cbk1hdHJpeC5tYWcgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmRvdFByb2R1Y3QoYXJyYXksIGFycmF5KSk7XG59O1xuXG4vKipcbiAqIG5vcm1hbGl6YXRpb24gb2YgYW4gYXJyYXlcbiAqIGFycmF5IGFuZCByZXN1bHQgYXJlIDFkIGFycmF5XG4gKi9cbk1hdHJpeC5ub3JtYWxpemUgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgbWFnbml0dWRlID0gdGhpcy5tYWcoYXJyYXkpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRbaV0gPSBhcnJheVtpXSAvIG1hZ25pdHVkZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIG11bHRpcGx5IGFuIGFycmF5IHdpdGggY2VudGVyaW5nIG1hdHJpeFxuICogYXJyYXkgYW5kIHJlc3VsdCBhcmUgMWQgYXJyYXlcbiAqL1xuTWF0cml4Lm11bHRHYW1tYSA9IGZ1bmN0aW9uIChhcnJheSkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBzdW0gPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBzdW0gKz0gYXJyYXlbaV07XG4gIH1cblxuICBzdW0gKj0gLTEgLyBhcnJheS5sZW5ndGg7XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFycmF5Lmxlbmd0aDsgX2krKykge1xuICAgIHJlc3VsdFtfaV0gPSBzdW0gKyBhcnJheVtfaV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogYSBzcGVjaWFsIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICogcmVzdWx0ID0gMC41ICogQyAqIElOViAqIENeVCAqIGFycmF5XG4gKiBhcnJheSBhbmQgcmVzdWx0IGFyZSAxZCwgQyBhbmQgSU5WIGFyZSAyZCBhcnJheXNcbiAqL1xuTWF0cml4Lm11bHRMID0gZnVuY3Rpb24gKGFycmF5LCBDLCBJTlYpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgdGVtcDEgPSBbXTtcbiAgdmFyIHRlbXAyID0gW107XG5cbiAgLy8gbXVsdGlwbHkgYnkgQ15UXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQ1swXS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzdW0gPSAwO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgQy5sZW5ndGg7IGorKykge1xuICAgICAgc3VtICs9IC0wLjUgKiBDW2pdW2ldICogYXJyYXlbal07XG4gICAgfVxuICAgIHRlbXAxW2ldID0gc3VtO1xuICB9XG4gIC8vIG11bHRpcGx5IHRoZSByZXN1bHQgYnkgSU5WXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IElOVi5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIF9zdW0gPSAwO1xuICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBJTlYubGVuZ3RoOyBfaisrKSB7XG4gICAgICBfc3VtICs9IElOVltfaTJdW19qXSAqIHRlbXAxW19qXTtcbiAgICB9XG4gICAgdGVtcDJbX2kyXSA9IF9zdW07XG4gIH1cbiAgLy8gbXVsdGlwbHkgdGhlIHJlc3VsdCBieSBDXG4gIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IEMubGVuZ3RoOyBfaTMrKykge1xuICAgIHZhciBfc3VtMiA9IDA7XG4gICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgQ1swXS5sZW5ndGg7IF9qMisrKSB7XG4gICAgICBfc3VtMiArPSBDW19pM11bX2oyXSAqIHRlbXAyW19qMl07XG4gICAgfVxuICAgIHJlc3VsdFtfaTNdID0gX3N1bTI7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXRyaXg7XG5cbi8qKiovIH0pLFxuLyogMjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBBIGNsYXNzaWMgUXVpY2tzb3J0IGFsZ29yaXRobSB3aXRoIEhvYXJlJ3MgcGFydGl0aW9uXG4gKiAtIFdvcmtzIGFsc28gb24gTGlua2VkTGlzdCBvYmplY3RzXG4gKlxuICogQ29weXJpZ2h0OiBpLVZpcyBSZXNlYXJjaCBHcm91cCwgQmlsa2VudCBVbml2ZXJzaXR5LCAyMDA3IC0gcHJlc2VudFxuICovXG5cbnZhciBMaW5rZWRMaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbnZhciBRdWlja3NvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUXVpY2tzb3J0KEEsIGNvbXBhcmVGdW5jdGlvbikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUXVpY2tzb3J0KTtcblxuICAgICAgICBpZiAoY29tcGFyZUZ1bmN0aW9uICE9PSBudWxsIHx8IGNvbXBhcmVGdW5jdGlvbiAhPT0gdW5kZWZpbmVkKSB0aGlzLmNvbXBhcmVGdW5jdGlvbiA9IHRoaXMuX2RlZmF1bHRDb21wYXJlRnVuY3Rpb247XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHZvaWQgMDtcbiAgICAgICAgaWYgKEEgaW5zdGFuY2VvZiBMaW5rZWRMaXN0KSBsZW5ndGggPSBBLnNpemUoKTtlbHNlIGxlbmd0aCA9IEEubGVuZ3RoO1xuXG4gICAgICAgIHRoaXMuX3F1aWNrc29ydChBLCAwLCBsZW5ndGggLSAxKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoUXVpY2tzb3J0LCBbe1xuICAgICAgICBrZXk6ICdfcXVpY2tzb3J0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9xdWlja3NvcnQoQSwgcCwgcikge1xuICAgICAgICAgICAgaWYgKHAgPCByKSB7XG4gICAgICAgICAgICAgICAgdmFyIHEgPSB0aGlzLl9wYXJ0aXRpb24oQSwgcCwgcik7XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVpY2tzb3J0KEEsIHAsIHEpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3F1aWNrc29ydChBLCBxICsgMSwgcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19wYXJ0aXRpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3BhcnRpdGlvbihBLCBwLCByKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHRoaXMuX2dldChBLCBwKTtcbiAgICAgICAgICAgIHZhciBpID0gcDtcbiAgICAgICAgICAgIHZhciBqID0gcjtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuY29tcGFyZUZ1bmN0aW9uKHgsIHRoaXMuX2dldChBLCBqKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgICAgIH13aGlsZSAodGhpcy5jb21wYXJlRnVuY3Rpb24odGhpcy5fZ2V0KEEsIGkpLCB4KSkge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfWlmIChpIDwgaikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zd2FwKEEsIGksIGopO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgcmV0dXJuIGo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19nZXQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldChvYmplY3QsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTGlua2VkTGlzdCkgcmV0dXJuIG9iamVjdC5nZXRfb2JqZWN0X2F0KGluZGV4KTtlbHNlIHJldHVybiBvYmplY3RbaW5kZXhdO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfc2V0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXQob2JqZWN0LCBpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBMaW5rZWRMaXN0KSBvYmplY3Quc2V0X29iamVjdF9hdChpbmRleCwgdmFsdWUpO2Vsc2Ugb2JqZWN0W2luZGV4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfc3dhcCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc3dhcChBLCBpLCBqKSB7XG4gICAgICAgICAgICB2YXIgdGVtcCA9IHRoaXMuX2dldChBLCBpKTtcbiAgICAgICAgICAgIHRoaXMuX3NldChBLCBpLCB0aGlzLl9nZXQoQSwgaikpO1xuICAgICAgICAgICAgdGhpcy5fc2V0KEEsIGosIHRlbXApO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfZGVmYXVsdENvbXBhcmVGdW5jdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVmYXVsdENvbXBhcmVGdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYiA+IGE7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUXVpY2tzb3J0O1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFF1aWNrc29ydDtcblxuLyoqKi8gfSksXG4vKiAyNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vLyBTaW5ndWxhciBWYWx1ZSBEZWNvbXBvc2l0aW9uIGltcGxlbWVudGF0aW9uXG5mdW5jdGlvbiBTVkQoKSB7fTtcblxuLyogQmVsb3cgc2luZ3VsYXIgdmFsdWUgZGVjb21wb3NpdGlvbiAoc3ZkKSBjb2RlIGluY2x1ZGluZyBoeXBvdCBmdW5jdGlvbiBpcyBhZG9wdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2RyYWdvbmZseS1haS9KYW1hSlNcbiAgIFNvbWUgY2hhbmdlcyBhcmUgYXBwbGllZCB0byBtYWtlIHRoZSBjb2RlIGNvbXBhdGlibGUgd2l0aCB0aGUgZmNvc2UgY29kZSBhbmQgdG8gbWFrZSBpdCBpbmRlcGVuZGVudCBmcm9tIEphbWEuXG4gICBJbnB1dCBtYXRyaXggaXMgY2hhbmdlZCB0byBhIDJEIGFycmF5IGluc3RlYWQgb2YgSmFtYSBtYXRyaXguIE1hdHJpeCBkaW1lbnNpb25zIGFyZSB0YWtlbiBhY2NvcmRpbmcgdG8gMkQgYXJyYXkgaW5zdGVhZCBvZiB1c2luZyBKYW1hIGZ1bmN0aW9ucy5cbiAgIEFuIG9iamVjdCB0aGF0IGluY2x1ZGVzIHNpbmd1bGFyIHZhbHVlIGNvbXBvbmVudHMgaXMgY3JlYXRlZCBmb3IgcmV0dXJuLiBcbiAgIFRoZSB0eXBlcyBvZiBpbnB1dCBwYXJhbWV0ZXJzIG9mIHRoZSBoeXBvdCBmdW5jdGlvbiBhcmUgcmVtb3ZlZC4gXG4gICBsZXQgaXMgdXNlZCBpbnN0ZWFkIG9mIHZhciBmb3IgdGhlIHZhcmlhYmxlIGluaXRpYWxpemF0aW9uLlxuKi9cbi8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXBhY2hlIExpY2Vuc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFZlcnNpb24gMi4wLCBKYW51YXJ5IDIwMDRcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9cblxuICAgVEVSTVMgQU5EIENPTkRJVElPTlMgRk9SIFVTRSwgUkVQUk9EVUNUSU9OLCBBTkQgRElTVFJJQlVUSU9OXG5cbiAgIDEuIERlZmluaXRpb25zLlxuXG4gICAgICBcIkxpY2Vuc2VcIiBzaGFsbCBtZWFuIHRoZSB0ZXJtcyBhbmQgY29uZGl0aW9ucyBmb3IgdXNlLCByZXByb2R1Y3Rpb24sXG4gICAgICBhbmQgZGlzdHJpYnV0aW9uIGFzIGRlZmluZWQgYnkgU2VjdGlvbnMgMSB0aHJvdWdoIDkgb2YgdGhpcyBkb2N1bWVudC5cblxuICAgICAgXCJMaWNlbnNvclwiIHNoYWxsIG1lYW4gdGhlIGNvcHlyaWdodCBvd25lciBvciBlbnRpdHkgYXV0aG9yaXplZCBieVxuICAgICAgdGhlIGNvcHlyaWdodCBvd25lciB0aGF0IGlzIGdyYW50aW5nIHRoZSBMaWNlbnNlLlxuXG4gICAgICBcIkxlZ2FsIEVudGl0eVwiIHNoYWxsIG1lYW4gdGhlIHVuaW9uIG9mIHRoZSBhY3RpbmcgZW50aXR5IGFuZCBhbGxcbiAgICAgIG90aGVyIGVudGl0aWVzIHRoYXQgY29udHJvbCwgYXJlIGNvbnRyb2xsZWQgYnksIG9yIGFyZSB1bmRlciBjb21tb25cbiAgICAgIGNvbnRyb2wgd2l0aCB0aGF0IGVudGl0eS4gRm9yIHRoZSBwdXJwb3NlcyBvZiB0aGlzIGRlZmluaXRpb24sXG4gICAgICBcImNvbnRyb2xcIiBtZWFucyAoaSkgdGhlIHBvd2VyLCBkaXJlY3Qgb3IgaW5kaXJlY3QsIHRvIGNhdXNlIHRoZVxuICAgICAgZGlyZWN0aW9uIG9yIG1hbmFnZW1lbnQgb2Ygc3VjaCBlbnRpdHksIHdoZXRoZXIgYnkgY29udHJhY3Qgb3JcbiAgICAgIG90aGVyd2lzZSwgb3IgKGlpKSBvd25lcnNoaXAgb2YgZmlmdHkgcGVyY2VudCAoNTAlKSBvciBtb3JlIG9mIHRoZVxuICAgICAgb3V0c3RhbmRpbmcgc2hhcmVzLCBvciAoaWlpKSBiZW5lZmljaWFsIG93bmVyc2hpcCBvZiBzdWNoIGVudGl0eS5cblxuICAgICAgXCJZb3VcIiAob3IgXCJZb3VyXCIpIHNoYWxsIG1lYW4gYW4gaW5kaXZpZHVhbCBvciBMZWdhbCBFbnRpdHlcbiAgICAgIGV4ZXJjaXNpbmcgcGVybWlzc2lvbnMgZ3JhbnRlZCBieSB0aGlzIExpY2Vuc2UuXG5cbiAgICAgIFwiU291cmNlXCIgZm9ybSBzaGFsbCBtZWFuIHRoZSBwcmVmZXJyZWQgZm9ybSBmb3IgbWFraW5nIG1vZGlmaWNhdGlvbnMsXG4gICAgICBpbmNsdWRpbmcgYnV0IG5vdCBsaW1pdGVkIHRvIHNvZnR3YXJlIHNvdXJjZSBjb2RlLCBkb2N1bWVudGF0aW9uXG4gICAgICBzb3VyY2UsIGFuZCBjb25maWd1cmF0aW9uIGZpbGVzLlxuXG4gICAgICBcIk9iamVjdFwiIGZvcm0gc2hhbGwgbWVhbiBhbnkgZm9ybSByZXN1bHRpbmcgZnJvbSBtZWNoYW5pY2FsXG4gICAgICB0cmFuc2Zvcm1hdGlvbiBvciB0cmFuc2xhdGlvbiBvZiBhIFNvdXJjZSBmb3JtLCBpbmNsdWRpbmcgYnV0XG4gICAgICBub3QgbGltaXRlZCB0byBjb21waWxlZCBvYmplY3QgY29kZSwgZ2VuZXJhdGVkIGRvY3VtZW50YXRpb24sXG4gICAgICBhbmQgY29udmVyc2lvbnMgdG8gb3RoZXIgbWVkaWEgdHlwZXMuXG5cbiAgICAgIFwiV29ya1wiIHNoYWxsIG1lYW4gdGhlIHdvcmsgb2YgYXV0aG9yc2hpcCwgd2hldGhlciBpbiBTb3VyY2Ugb3JcbiAgICAgIE9iamVjdCBmb3JtLCBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGUgTGljZW5zZSwgYXMgaW5kaWNhdGVkIGJ5IGFcbiAgICAgIGNvcHlyaWdodCBub3RpY2UgdGhhdCBpcyBpbmNsdWRlZCBpbiBvciBhdHRhY2hlZCB0byB0aGUgd29ya1xuICAgICAgKGFuIGV4YW1wbGUgaXMgcHJvdmlkZWQgaW4gdGhlIEFwcGVuZGl4IGJlbG93KS5cblxuICAgICAgXCJEZXJpdmF0aXZlIFdvcmtzXCIgc2hhbGwgbWVhbiBhbnkgd29yaywgd2hldGhlciBpbiBTb3VyY2Ugb3IgT2JqZWN0XG4gICAgICBmb3JtLCB0aGF0IGlzIGJhc2VkIG9uIChvciBkZXJpdmVkIGZyb20pIHRoZSBXb3JrIGFuZCBmb3Igd2hpY2ggdGhlXG4gICAgICBlZGl0b3JpYWwgcmV2aXNpb25zLCBhbm5vdGF0aW9ucywgZWxhYm9yYXRpb25zLCBvciBvdGhlciBtb2RpZmljYXRpb25zXG4gICAgICByZXByZXNlbnQsIGFzIGEgd2hvbGUsIGFuIG9yaWdpbmFsIHdvcmsgb2YgYXV0aG9yc2hpcC4gRm9yIHRoZSBwdXJwb3Nlc1xuICAgICAgb2YgdGhpcyBMaWNlbnNlLCBEZXJpdmF0aXZlIFdvcmtzIHNoYWxsIG5vdCBpbmNsdWRlIHdvcmtzIHRoYXQgcmVtYWluXG4gICAgICBzZXBhcmFibGUgZnJvbSwgb3IgbWVyZWx5IGxpbmsgKG9yIGJpbmQgYnkgbmFtZSkgdG8gdGhlIGludGVyZmFjZXMgb2YsXG4gICAgICB0aGUgV29yayBhbmQgRGVyaXZhdGl2ZSBXb3JrcyB0aGVyZW9mLlxuXG4gICAgICBcIkNvbnRyaWJ1dGlvblwiIHNoYWxsIG1lYW4gYW55IHdvcmsgb2YgYXV0aG9yc2hpcCwgaW5jbHVkaW5nXG4gICAgICB0aGUgb3JpZ2luYWwgdmVyc2lvbiBvZiB0aGUgV29yayBhbmQgYW55IG1vZGlmaWNhdGlvbnMgb3IgYWRkaXRpb25zXG4gICAgICB0byB0aGF0IFdvcmsgb3IgRGVyaXZhdGl2ZSBXb3JrcyB0aGVyZW9mLCB0aGF0IGlzIGludGVudGlvbmFsbHlcbiAgICAgIHN1Ym1pdHRlZCB0byBMaWNlbnNvciBmb3IgaW5jbHVzaW9uIGluIHRoZSBXb3JrIGJ5IHRoZSBjb3B5cmlnaHQgb3duZXJcbiAgICAgIG9yIGJ5IGFuIGluZGl2aWR1YWwgb3IgTGVnYWwgRW50aXR5IGF1dGhvcml6ZWQgdG8gc3VibWl0IG9uIGJlaGFsZiBvZlxuICAgICAgdGhlIGNvcHlyaWdodCBvd25lci4gRm9yIHRoZSBwdXJwb3NlcyBvZiB0aGlzIGRlZmluaXRpb24sIFwic3VibWl0dGVkXCJcbiAgICAgIG1lYW5zIGFueSBmb3JtIG9mIGVsZWN0cm9uaWMsIHZlcmJhbCwgb3Igd3JpdHRlbiBjb21tdW5pY2F0aW9uIHNlbnRcbiAgICAgIHRvIHRoZSBMaWNlbnNvciBvciBpdHMgcmVwcmVzZW50YXRpdmVzLCBpbmNsdWRpbmcgYnV0IG5vdCBsaW1pdGVkIHRvXG4gICAgICBjb21tdW5pY2F0aW9uIG9uIGVsZWN0cm9uaWMgbWFpbGluZyBsaXN0cywgc291cmNlIGNvZGUgY29udHJvbCBzeXN0ZW1zLFxuICAgICAgYW5kIGlzc3VlIHRyYWNraW5nIHN5c3RlbXMgdGhhdCBhcmUgbWFuYWdlZCBieSwgb3Igb24gYmVoYWxmIG9mLCB0aGVcbiAgICAgIExpY2Vuc29yIGZvciB0aGUgcHVycG9zZSBvZiBkaXNjdXNzaW5nIGFuZCBpbXByb3ZpbmcgdGhlIFdvcmssIGJ1dFxuICAgICAgZXhjbHVkaW5nIGNvbW11bmljYXRpb24gdGhhdCBpcyBjb25zcGljdW91c2x5IG1hcmtlZCBvciBvdGhlcndpc2VcbiAgICAgIGRlc2lnbmF0ZWQgaW4gd3JpdGluZyBieSB0aGUgY29weXJpZ2h0IG93bmVyIGFzIFwiTm90IGEgQ29udHJpYnV0aW9uLlwiXG5cbiAgICAgIFwiQ29udHJpYnV0b3JcIiBzaGFsbCBtZWFuIExpY2Vuc29yIGFuZCBhbnkgaW5kaXZpZHVhbCBvciBMZWdhbCBFbnRpdHlcbiAgICAgIG9uIGJlaGFsZiBvZiB3aG9tIGEgQ29udHJpYnV0aW9uIGhhcyBiZWVuIHJlY2VpdmVkIGJ5IExpY2Vuc29yIGFuZFxuICAgICAgc3Vic2VxdWVudGx5IGluY29ycG9yYXRlZCB3aXRoaW4gdGhlIFdvcmsuXG5cbiAgIDIuIEdyYW50IG9mIENvcHlyaWdodCBMaWNlbnNlLiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhbmQgY29uZGl0aW9ucyBvZlxuICAgICAgdGhpcyBMaWNlbnNlLCBlYWNoIENvbnRyaWJ1dG9yIGhlcmVieSBncmFudHMgdG8gWW91IGEgcGVycGV0dWFsLFxuICAgICAgd29ybGR3aWRlLCBub24tZXhjbHVzaXZlLCBuby1jaGFyZ2UsIHJveWFsdHktZnJlZSwgaXJyZXZvY2FibGVcbiAgICAgIGNvcHlyaWdodCBsaWNlbnNlIHRvIHJlcHJvZHVjZSwgcHJlcGFyZSBEZXJpdmF0aXZlIFdvcmtzIG9mLFxuICAgICAgcHVibGljbHkgZGlzcGxheSwgcHVibGljbHkgcGVyZm9ybSwgc3VibGljZW5zZSwgYW5kIGRpc3RyaWJ1dGUgdGhlXG4gICAgICBXb3JrIGFuZCBzdWNoIERlcml2YXRpdmUgV29ya3MgaW4gU291cmNlIG9yIE9iamVjdCBmb3JtLlxuXG4gICAzLiBHcmFudCBvZiBQYXRlbnQgTGljZW5zZS4gU3ViamVjdCB0byB0aGUgdGVybXMgYW5kIGNvbmRpdGlvbnMgb2ZcbiAgICAgIHRoaXMgTGljZW5zZSwgZWFjaCBDb250cmlidXRvciBoZXJlYnkgZ3JhbnRzIHRvIFlvdSBhIHBlcnBldHVhbCxcbiAgICAgIHdvcmxkd2lkZSwgbm9uLWV4Y2x1c2l2ZSwgbm8tY2hhcmdlLCByb3lhbHR5LWZyZWUsIGlycmV2b2NhYmxlXG4gICAgICAoZXhjZXB0IGFzIHN0YXRlZCBpbiB0aGlzIHNlY3Rpb24pIHBhdGVudCBsaWNlbnNlIHRvIG1ha2UsIGhhdmUgbWFkZSxcbiAgICAgIHVzZSwgb2ZmZXIgdG8gc2VsbCwgc2VsbCwgaW1wb3J0LCBhbmQgb3RoZXJ3aXNlIHRyYW5zZmVyIHRoZSBXb3JrLFxuICAgICAgd2hlcmUgc3VjaCBsaWNlbnNlIGFwcGxpZXMgb25seSB0byB0aG9zZSBwYXRlbnQgY2xhaW1zIGxpY2Vuc2FibGVcbiAgICAgIGJ5IHN1Y2ggQ29udHJpYnV0b3IgdGhhdCBhcmUgbmVjZXNzYXJpbHkgaW5mcmluZ2VkIGJ5IHRoZWlyXG4gICAgICBDb250cmlidXRpb24ocykgYWxvbmUgb3IgYnkgY29tYmluYXRpb24gb2YgdGhlaXIgQ29udHJpYnV0aW9uKHMpXG4gICAgICB3aXRoIHRoZSBXb3JrIHRvIHdoaWNoIHN1Y2ggQ29udHJpYnV0aW9uKHMpIHdhcyBzdWJtaXR0ZWQuIElmIFlvdVxuICAgICAgaW5zdGl0dXRlIHBhdGVudCBsaXRpZ2F0aW9uIGFnYWluc3QgYW55IGVudGl0eSAoaW5jbHVkaW5nIGFcbiAgICAgIGNyb3NzLWNsYWltIG9yIGNvdW50ZXJjbGFpbSBpbiBhIGxhd3N1aXQpIGFsbGVnaW5nIHRoYXQgdGhlIFdvcmtcbiAgICAgIG9yIGEgQ29udHJpYnV0aW9uIGluY29ycG9yYXRlZCB3aXRoaW4gdGhlIFdvcmsgY29uc3RpdHV0ZXMgZGlyZWN0XG4gICAgICBvciBjb250cmlidXRvcnkgcGF0ZW50IGluZnJpbmdlbWVudCwgdGhlbiBhbnkgcGF0ZW50IGxpY2Vuc2VzXG4gICAgICBncmFudGVkIHRvIFlvdSB1bmRlciB0aGlzIExpY2Vuc2UgZm9yIHRoYXQgV29yayBzaGFsbCB0ZXJtaW5hdGVcbiAgICAgIGFzIG9mIHRoZSBkYXRlIHN1Y2ggbGl0aWdhdGlvbiBpcyBmaWxlZC5cblxuICAgNC4gUmVkaXN0cmlidXRpb24uIFlvdSBtYXkgcmVwcm9kdWNlIGFuZCBkaXN0cmlidXRlIGNvcGllcyBvZiB0aGVcbiAgICAgIFdvcmsgb3IgRGVyaXZhdGl2ZSBXb3JrcyB0aGVyZW9mIGluIGFueSBtZWRpdW0sIHdpdGggb3Igd2l0aG91dFxuICAgICAgbW9kaWZpY2F0aW9ucywgYW5kIGluIFNvdXJjZSBvciBPYmplY3QgZm9ybSwgcHJvdmlkZWQgdGhhdCBZb3VcbiAgICAgIG1lZXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gICAgICAoYSkgWW91IG11c3QgZ2l2ZSBhbnkgb3RoZXIgcmVjaXBpZW50cyBvZiB0aGUgV29yayBvclxuICAgICAgICAgIERlcml2YXRpdmUgV29ya3MgYSBjb3B5IG9mIHRoaXMgTGljZW5zZTsgYW5kXG5cbiAgICAgIChiKSBZb3UgbXVzdCBjYXVzZSBhbnkgbW9kaWZpZWQgZmlsZXMgdG8gY2FycnkgcHJvbWluZW50IG5vdGljZXNcbiAgICAgICAgICBzdGF0aW5nIHRoYXQgWW91IGNoYW5nZWQgdGhlIGZpbGVzOyBhbmRcblxuICAgICAgKGMpIFlvdSBtdXN0IHJldGFpbiwgaW4gdGhlIFNvdXJjZSBmb3JtIG9mIGFueSBEZXJpdmF0aXZlIFdvcmtzXG4gICAgICAgICAgdGhhdCBZb3UgZGlzdHJpYnV0ZSwgYWxsIGNvcHlyaWdodCwgcGF0ZW50LCB0cmFkZW1hcmssIGFuZFxuICAgICAgICAgIGF0dHJpYnV0aW9uIG5vdGljZXMgZnJvbSB0aGUgU291cmNlIGZvcm0gb2YgdGhlIFdvcmssXG4gICAgICAgICAgZXhjbHVkaW5nIHRob3NlIG5vdGljZXMgdGhhdCBkbyBub3QgcGVydGFpbiB0byBhbnkgcGFydCBvZlxuICAgICAgICAgIHRoZSBEZXJpdmF0aXZlIFdvcmtzOyBhbmRcblxuICAgICAgKGQpIElmIHRoZSBXb3JrIGluY2x1ZGVzIGEgXCJOT1RJQ0VcIiB0ZXh0IGZpbGUgYXMgcGFydCBvZiBpdHNcbiAgICAgICAgICBkaXN0cmlidXRpb24sIHRoZW4gYW55IERlcml2YXRpdmUgV29ya3MgdGhhdCBZb3UgZGlzdHJpYnV0ZSBtdXN0XG4gICAgICAgICAgaW5jbHVkZSBhIHJlYWRhYmxlIGNvcHkgb2YgdGhlIGF0dHJpYnV0aW9uIG5vdGljZXMgY29udGFpbmVkXG4gICAgICAgICAgd2l0aGluIHN1Y2ggTk9USUNFIGZpbGUsIGV4Y2x1ZGluZyB0aG9zZSBub3RpY2VzIHRoYXQgZG8gbm90XG4gICAgICAgICAgcGVydGFpbiB0byBhbnkgcGFydCBvZiB0aGUgRGVyaXZhdGl2ZSBXb3JrcywgaW4gYXQgbGVhc3Qgb25lXG4gICAgICAgICAgb2YgdGhlIGZvbGxvd2luZyBwbGFjZXM6IHdpdGhpbiBhIE5PVElDRSB0ZXh0IGZpbGUgZGlzdHJpYnV0ZWRcbiAgICAgICAgICBhcyBwYXJ0IG9mIHRoZSBEZXJpdmF0aXZlIFdvcmtzOyB3aXRoaW4gdGhlIFNvdXJjZSBmb3JtIG9yXG4gICAgICAgICAgZG9jdW1lbnRhdGlvbiwgaWYgcHJvdmlkZWQgYWxvbmcgd2l0aCB0aGUgRGVyaXZhdGl2ZSBXb3Jrczsgb3IsXG4gICAgICAgICAgd2l0aGluIGEgZGlzcGxheSBnZW5lcmF0ZWQgYnkgdGhlIERlcml2YXRpdmUgV29ya3MsIGlmIGFuZFxuICAgICAgICAgIHdoZXJldmVyIHN1Y2ggdGhpcmQtcGFydHkgbm90aWNlcyBub3JtYWxseSBhcHBlYXIuIFRoZSBjb250ZW50c1xuICAgICAgICAgIG9mIHRoZSBOT1RJQ0UgZmlsZSBhcmUgZm9yIGluZm9ybWF0aW9uYWwgcHVycG9zZXMgb25seSBhbmRcbiAgICAgICAgICBkbyBub3QgbW9kaWZ5IHRoZSBMaWNlbnNlLiBZb3UgbWF5IGFkZCBZb3VyIG93biBhdHRyaWJ1dGlvblxuICAgICAgICAgIG5vdGljZXMgd2l0aGluIERlcml2YXRpdmUgV29ya3MgdGhhdCBZb3UgZGlzdHJpYnV0ZSwgYWxvbmdzaWRlXG4gICAgICAgICAgb3IgYXMgYW4gYWRkZW5kdW0gdG8gdGhlIE5PVElDRSB0ZXh0IGZyb20gdGhlIFdvcmssIHByb3ZpZGVkXG4gICAgICAgICAgdGhhdCBzdWNoIGFkZGl0aW9uYWwgYXR0cmlidXRpb24gbm90aWNlcyBjYW5ub3QgYmUgY29uc3RydWVkXG4gICAgICAgICAgYXMgbW9kaWZ5aW5nIHRoZSBMaWNlbnNlLlxuXG4gICAgICBZb3UgbWF5IGFkZCBZb3VyIG93biBjb3B5cmlnaHQgc3RhdGVtZW50IHRvIFlvdXIgbW9kaWZpY2F0aW9ucyBhbmRcbiAgICAgIG1heSBwcm92aWRlIGFkZGl0aW9uYWwgb3IgZGlmZmVyZW50IGxpY2Vuc2UgdGVybXMgYW5kIGNvbmRpdGlvbnNcbiAgICAgIGZvciB1c2UsIHJlcHJvZHVjdGlvbiwgb3IgZGlzdHJpYnV0aW9uIG9mIFlvdXIgbW9kaWZpY2F0aW9ucywgb3JcbiAgICAgIGZvciBhbnkgc3VjaCBEZXJpdmF0aXZlIFdvcmtzIGFzIGEgd2hvbGUsIHByb3ZpZGVkIFlvdXIgdXNlLFxuICAgICAgcmVwcm9kdWN0aW9uLCBhbmQgZGlzdHJpYnV0aW9uIG9mIHRoZSBXb3JrIG90aGVyd2lzZSBjb21wbGllcyB3aXRoXG4gICAgICB0aGUgY29uZGl0aW9ucyBzdGF0ZWQgaW4gdGhpcyBMaWNlbnNlLlxuXG4gICA1LiBTdWJtaXNzaW9uIG9mIENvbnRyaWJ1dGlvbnMuIFVubGVzcyBZb3UgZXhwbGljaXRseSBzdGF0ZSBvdGhlcndpc2UsXG4gICAgICBhbnkgQ29udHJpYnV0aW9uIGludGVudGlvbmFsbHkgc3VibWl0dGVkIGZvciBpbmNsdXNpb24gaW4gdGhlIFdvcmtcbiAgICAgIGJ5IFlvdSB0byB0aGUgTGljZW5zb3Igc2hhbGwgYmUgdW5kZXIgdGhlIHRlcm1zIGFuZCBjb25kaXRpb25zIG9mXG4gICAgICB0aGlzIExpY2Vuc2UsIHdpdGhvdXQgYW55IGFkZGl0aW9uYWwgdGVybXMgb3IgY29uZGl0aW9ucy5cbiAgICAgIE5vdHdpdGhzdGFuZGluZyB0aGUgYWJvdmUsIG5vdGhpbmcgaGVyZWluIHNoYWxsIHN1cGVyc2VkZSBvciBtb2RpZnlcbiAgICAgIHRoZSB0ZXJtcyBvZiBhbnkgc2VwYXJhdGUgbGljZW5zZSBhZ3JlZW1lbnQgeW91IG1heSBoYXZlIGV4ZWN1dGVkXG4gICAgICB3aXRoIExpY2Vuc29yIHJlZ2FyZGluZyBzdWNoIENvbnRyaWJ1dGlvbnMuXG5cbiAgIDYuIFRyYWRlbWFya3MuIFRoaXMgTGljZW5zZSBkb2VzIG5vdCBncmFudCBwZXJtaXNzaW9uIHRvIHVzZSB0aGUgdHJhZGVcbiAgICAgIG5hbWVzLCB0cmFkZW1hcmtzLCBzZXJ2aWNlIG1hcmtzLCBvciBwcm9kdWN0IG5hbWVzIG9mIHRoZSBMaWNlbnNvcixcbiAgICAgIGV4Y2VwdCBhcyByZXF1aXJlZCBmb3IgcmVhc29uYWJsZSBhbmQgY3VzdG9tYXJ5IHVzZSBpbiBkZXNjcmliaW5nIHRoZVxuICAgICAgb3JpZ2luIG9mIHRoZSBXb3JrIGFuZCByZXByb2R1Y2luZyB0aGUgY29udGVudCBvZiB0aGUgTk9USUNFIGZpbGUuXG5cbiAgIDcuIERpc2NsYWltZXIgb2YgV2FycmFudHkuIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvclxuICAgICAgYWdyZWVkIHRvIGluIHdyaXRpbmcsIExpY2Vuc29yIHByb3ZpZGVzIHRoZSBXb3JrIChhbmQgZWFjaFxuICAgICAgQ29udHJpYnV0b3IgcHJvdmlkZXMgaXRzIENvbnRyaWJ1dGlvbnMpIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICAgIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvclxuICAgICAgaW1wbGllZCwgaW5jbHVkaW5nLCB3aXRob3V0IGxpbWl0YXRpb24sIGFueSB3YXJyYW50aWVzIG9yIGNvbmRpdGlvbnNcbiAgICAgIG9mIFRJVExFLCBOT04tSU5GUklOR0VNRU5ULCBNRVJDSEFOVEFCSUxJVFksIG9yIEZJVE5FU1MgRk9SIEFcbiAgICAgIFBBUlRJQ1VMQVIgUFVSUE9TRS4gWW91IGFyZSBzb2xlbHkgcmVzcG9uc2libGUgZm9yIGRldGVybWluaW5nIHRoZVxuICAgICAgYXBwcm9wcmlhdGVuZXNzIG9mIHVzaW5nIG9yIHJlZGlzdHJpYnV0aW5nIHRoZSBXb3JrIGFuZCBhc3N1bWUgYW55XG4gICAgICByaXNrcyBhc3NvY2lhdGVkIHdpdGggWW91ciBleGVyY2lzZSBvZiBwZXJtaXNzaW9ucyB1bmRlciB0aGlzIExpY2Vuc2UuXG5cbiAgIDguIExpbWl0YXRpb24gb2YgTGlhYmlsaXR5LiBJbiBubyBldmVudCBhbmQgdW5kZXIgbm8gbGVnYWwgdGhlb3J5LFxuICAgICAgd2hldGhlciBpbiB0b3J0IChpbmNsdWRpbmcgbmVnbGlnZW5jZSksIGNvbnRyYWN0LCBvciBvdGhlcndpc2UsXG4gICAgICB1bmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgKHN1Y2ggYXMgZGVsaWJlcmF0ZSBhbmQgZ3Jvc3NseVxuICAgICAgbmVnbGlnZW50IGFjdHMpIG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzaGFsbCBhbnkgQ29udHJpYnV0b3IgYmVcbiAgICAgIGxpYWJsZSB0byBZb3UgZm9yIGRhbWFnZXMsIGluY2x1ZGluZyBhbnkgZGlyZWN0LCBpbmRpcmVjdCwgc3BlY2lhbCxcbiAgICAgIGluY2lkZW50YWwsIG9yIGNvbnNlcXVlbnRpYWwgZGFtYWdlcyBvZiBhbnkgY2hhcmFjdGVyIGFyaXNpbmcgYXMgYVxuICAgICAgcmVzdWx0IG9mIHRoaXMgTGljZW5zZSBvciBvdXQgb2YgdGhlIHVzZSBvciBpbmFiaWxpdHkgdG8gdXNlIHRoZVxuICAgICAgV29yayAoaW5jbHVkaW5nIGJ1dCBub3QgbGltaXRlZCB0byBkYW1hZ2VzIGZvciBsb3NzIG9mIGdvb2R3aWxsLFxuICAgICAgd29yayBzdG9wcGFnZSwgY29tcHV0ZXIgZmFpbHVyZSBvciBtYWxmdW5jdGlvbiwgb3IgYW55IGFuZCBhbGxcbiAgICAgIG90aGVyIGNvbW1lcmNpYWwgZGFtYWdlcyBvciBsb3NzZXMpLCBldmVuIGlmIHN1Y2ggQ29udHJpYnV0b3JcbiAgICAgIGhhcyBiZWVuIGFkdmlzZWQgb2YgdGhlIHBvc3NpYmlsaXR5IG9mIHN1Y2ggZGFtYWdlcy5cblxuICAgOS4gQWNjZXB0aW5nIFdhcnJhbnR5IG9yIEFkZGl0aW9uYWwgTGlhYmlsaXR5LiBXaGlsZSByZWRpc3RyaWJ1dGluZ1xuICAgICAgdGhlIFdvcmsgb3IgRGVyaXZhdGl2ZSBXb3JrcyB0aGVyZW9mLCBZb3UgbWF5IGNob29zZSB0byBvZmZlcixcbiAgICAgIGFuZCBjaGFyZ2UgYSBmZWUgZm9yLCBhY2NlcHRhbmNlIG9mIHN1cHBvcnQsIHdhcnJhbnR5LCBpbmRlbW5pdHksXG4gICAgICBvciBvdGhlciBsaWFiaWxpdHkgb2JsaWdhdGlvbnMgYW5kL29yIHJpZ2h0cyBjb25zaXN0ZW50IHdpdGggdGhpc1xuICAgICAgTGljZW5zZS4gSG93ZXZlciwgaW4gYWNjZXB0aW5nIHN1Y2ggb2JsaWdhdGlvbnMsIFlvdSBtYXkgYWN0IG9ubHlcbiAgICAgIG9uIFlvdXIgb3duIGJlaGFsZiBhbmQgb24gWW91ciBzb2xlIHJlc3BvbnNpYmlsaXR5LCBub3Qgb24gYmVoYWxmXG4gICAgICBvZiBhbnkgb3RoZXIgQ29udHJpYnV0b3IsIGFuZCBvbmx5IGlmIFlvdSBhZ3JlZSB0byBpbmRlbW5pZnksXG4gICAgICBkZWZlbmQsIGFuZCBob2xkIGVhY2ggQ29udHJpYnV0b3IgaGFybWxlc3MgZm9yIGFueSBsaWFiaWxpdHlcbiAgICAgIGluY3VycmVkIGJ5LCBvciBjbGFpbXMgYXNzZXJ0ZWQgYWdhaW5zdCwgc3VjaCBDb250cmlidXRvciBieSByZWFzb25cbiAgICAgIG9mIHlvdXIgYWNjZXB0aW5nIGFueSBzdWNoIHdhcnJhbnR5IG9yIGFkZGl0aW9uYWwgbGlhYmlsaXR5LlxuXG4gICBFTkQgT0YgVEVSTVMgQU5EIENPTkRJVElPTlNcblxuICAgQVBQRU5ESVg6IEhvdyB0byBhcHBseSB0aGUgQXBhY2hlIExpY2Vuc2UgdG8geW91ciB3b3JrLlxuXG4gICAgICBUbyBhcHBseSB0aGUgQXBhY2hlIExpY2Vuc2UgdG8geW91ciB3b3JrLCBhdHRhY2ggdGhlIGZvbGxvd2luZ1xuICAgICAgYm9pbGVycGxhdGUgbm90aWNlLCB3aXRoIHRoZSBmaWVsZHMgZW5jbG9zZWQgYnkgYnJhY2tldHMgXCJ7fVwiXG4gICAgICByZXBsYWNlZCB3aXRoIHlvdXIgb3duIGlkZW50aWZ5aW5nIGluZm9ybWF0aW9uLiAoRG9uJ3QgaW5jbHVkZVxuICAgICAgdGhlIGJyYWNrZXRzISkgIFRoZSB0ZXh0IHNob3VsZCBiZSBlbmNsb3NlZCBpbiB0aGUgYXBwcm9wcmlhdGVcbiAgICAgIGNvbW1lbnQgc3ludGF4IGZvciB0aGUgZmlsZSBmb3JtYXQuIFdlIGFsc28gcmVjb21tZW5kIHRoYXQgYVxuICAgICAgZmlsZSBvciBjbGFzcyBuYW1lIGFuZCBkZXNjcmlwdGlvbiBvZiBwdXJwb3NlIGJlIGluY2x1ZGVkIG9uIHRoZVxuICAgICAgc2FtZSBcInByaW50ZWQgcGFnZVwiIGFzIHRoZSBjb3B5cmlnaHQgbm90aWNlIGZvciBlYXNpZXJcbiAgICAgIGlkZW50aWZpY2F0aW9uIHdpdGhpbiB0aGlyZC1wYXJ0eSBhcmNoaXZlcy5cblxuICAgQ29weXJpZ2h0IHt5eXl5fSB7bmFtZSBvZiBjb3B5cmlnaHQgb3duZXJ9XG5cbiAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuU1ZELnN2ZCA9IGZ1bmN0aW9uIChBKSB7XG4gIHRoaXMuVSA9IG51bGw7XG4gIHRoaXMuViA9IG51bGw7XG4gIHRoaXMucyA9IG51bGw7XG4gIHRoaXMubSA9IDA7XG4gIHRoaXMubiA9IDA7XG4gIHRoaXMubSA9IEEubGVuZ3RoO1xuICB0aGlzLm4gPSBBWzBdLmxlbmd0aDtcbiAgdmFyIG51ID0gTWF0aC5taW4odGhpcy5tLCB0aGlzLm4pO1xuICB0aGlzLnMgPSBmdW5jdGlvbiAocykge1xuICAgIHZhciBhID0gW107XG4gICAgd2hpbGUgKHMtLSA+IDApIHtcbiAgICAgIGEucHVzaCgwKTtcbiAgICB9cmV0dXJuIGE7XG4gIH0oTWF0aC5taW4odGhpcy5tICsgMSwgdGhpcy5uKSk7XG4gIHRoaXMuVSA9IGZ1bmN0aW9uIChkaW1zKSB7XG4gICAgdmFyIGFsbG9jYXRlID0gZnVuY3Rpb24gYWxsb2NhdGUoZGltcykge1xuICAgICAgaWYgKGRpbXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaW1zWzBdOyBpKyspIHtcbiAgICAgICAgICBhcnJheS5wdXNoKGFsbG9jYXRlKGRpbXMuc2xpY2UoMSkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gYWxsb2NhdGUoZGltcyk7XG4gIH0oW3RoaXMubSwgbnVdKTtcbiAgdGhpcy5WID0gZnVuY3Rpb24gKGRpbXMpIHtcbiAgICB2YXIgYWxsb2NhdGUgPSBmdW5jdGlvbiBhbGxvY2F0ZShkaW1zKSB7XG4gICAgICBpZiAoZGltcy5sZW5ndGggPT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbXNbMF07IGkrKykge1xuICAgICAgICAgIGFycmF5LnB1c2goYWxsb2NhdGUoZGltcy5zbGljZSgxKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBhbGxvY2F0ZShkaW1zKTtcbiAgfShbdGhpcy5uLCB0aGlzLm5dKTtcbiAgdmFyIGUgPSBmdW5jdGlvbiAocykge1xuICAgIHZhciBhID0gW107XG4gICAgd2hpbGUgKHMtLSA+IDApIHtcbiAgICAgIGEucHVzaCgwKTtcbiAgICB9cmV0dXJuIGE7XG4gIH0odGhpcy5uKTtcbiAgdmFyIHdvcmsgPSBmdW5jdGlvbiAocykge1xuICAgIHZhciBhID0gW107XG4gICAgd2hpbGUgKHMtLSA+IDApIHtcbiAgICAgIGEucHVzaCgwKTtcbiAgICB9cmV0dXJuIGE7XG4gIH0odGhpcy5tKTtcbiAgdmFyIHdhbnR1ID0gdHJ1ZTtcbiAgdmFyIHdhbnR2ID0gdHJ1ZTtcbiAgdmFyIG5jdCA9IE1hdGgubWluKHRoaXMubSAtIDEsIHRoaXMubik7XG4gIHZhciBucnQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLm4gLSAyLCB0aGlzLm0pKTtcbiAgZm9yICh2YXIgayA9IDA7IGsgPCBNYXRoLm1heChuY3QsIG5ydCk7IGsrKykge1xuICAgIGlmIChrIDwgbmN0KSB7XG4gICAgICB0aGlzLnNba10gPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IGs7IGkgPCB0aGlzLm07IGkrKykge1xuICAgICAgICB0aGlzLnNba10gPSBTVkQuaHlwb3QodGhpcy5zW2tdLCBBW2ldW2tdKTtcbiAgICAgIH1cbiAgICAgIDtcbiAgICAgIGlmICh0aGlzLnNba10gIT09IDAuMCkge1xuICAgICAgICBpZiAoQVtrXVtrXSA8IDAuMCkge1xuICAgICAgICAgIHRoaXMuc1trXSA9IC10aGlzLnNba107XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2kgPSBrOyBfaSA8IHRoaXMubTsgX2krKykge1xuICAgICAgICAgIEFbX2ldW2tdIC89IHRoaXMuc1trXTtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIEFba11ba10gKz0gMS4wO1xuICAgICAgfVxuICAgICAgdGhpcy5zW2tdID0gLXRoaXMuc1trXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IGsgKyAxOyBqIDwgdGhpcy5uOyBqKyspIHtcbiAgICAgIGlmIChmdW5jdGlvbiAobGhzLCByaHMpIHtcbiAgICAgICAgcmV0dXJuIGxocyAmJiByaHM7XG4gICAgICB9KGsgPCBuY3QsIHRoaXMuc1trXSAhPT0gMC4wKSkge1xuICAgICAgICB2YXIgdCA9IDA7XG4gICAgICAgIGZvciAodmFyIF9pMiA9IGs7IF9pMiA8IHRoaXMubTsgX2kyKyspIHtcbiAgICAgICAgICB0ICs9IEFbX2kyXVtrXSAqIEFbX2kyXVtqXTtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIHQgPSAtdCAvIEFba11ba107XG4gICAgICAgIGZvciAodmFyIF9pMyA9IGs7IF9pMyA8IHRoaXMubTsgX2kzKyspIHtcbiAgICAgICAgICBBW19pM11bal0gKz0gdCAqIEFbX2kzXVtrXTtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICB9XG4gICAgICBlW2pdID0gQVtrXVtqXTtcbiAgICB9XG4gICAgO1xuICAgIGlmIChmdW5jdGlvbiAobGhzLCByaHMpIHtcbiAgICAgIHJldHVybiBsaHMgJiYgcmhzO1xuICAgIH0od2FudHUsIGsgPCBuY3QpKSB7XG4gICAgICBmb3IgKHZhciBfaTQgPSBrOyBfaTQgPCB0aGlzLm07IF9pNCsrKSB7XG4gICAgICAgIHRoaXMuVVtfaTRdW2tdID0gQVtfaTRdW2tdO1xuICAgICAgfVxuICAgICAgO1xuICAgIH1cbiAgICBpZiAoayA8IG5ydCkge1xuICAgICAgZVtrXSA9IDA7XG4gICAgICBmb3IgKHZhciBfaTUgPSBrICsgMTsgX2k1IDwgdGhpcy5uOyBfaTUrKykge1xuICAgICAgICBlW2tdID0gU1ZELmh5cG90KGVba10sIGVbX2k1XSk7XG4gICAgICB9XG4gICAgICA7XG4gICAgICBpZiAoZVtrXSAhPT0gMC4wKSB7XG4gICAgICAgIGlmIChlW2sgKyAxXSA8IDAuMCkge1xuICAgICAgICAgIGVba10gPSAtZVtrXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfaTYgPSBrICsgMTsgX2k2IDwgdGhpcy5uOyBfaTYrKykge1xuICAgICAgICAgIGVbX2k2XSAvPSBlW2tdO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgZVtrICsgMV0gKz0gMS4wO1xuICAgICAgfVxuICAgICAgZVtrXSA9IC1lW2tdO1xuICAgICAgaWYgKGZ1bmN0aW9uIChsaHMsIHJocykge1xuICAgICAgICByZXR1cm4gbGhzICYmIHJocztcbiAgICAgIH0oayArIDEgPCB0aGlzLm0sIGVba10gIT09IDAuMCkpIHtcbiAgICAgICAgZm9yICh2YXIgX2k3ID0gayArIDE7IF9pNyA8IHRoaXMubTsgX2k3KyspIHtcbiAgICAgICAgICB3b3JrW19pN10gPSAwLjA7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBmb3IgKHZhciBfaiA9IGsgKyAxOyBfaiA8IHRoaXMubjsgX2orKykge1xuICAgICAgICAgIGZvciAodmFyIF9pOCA9IGsgKyAxOyBfaTggPCB0aGlzLm07IF9pOCsrKSB7XG4gICAgICAgICAgICB3b3JrW19pOF0gKz0gZVtfal0gKiBBW19pOF1bX2pdO1xuICAgICAgICAgIH1cbiAgICAgICAgICA7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBmb3IgKHZhciBfajIgPSBrICsgMTsgX2oyIDwgdGhpcy5uOyBfajIrKykge1xuICAgICAgICAgIHZhciBfdCA9IC1lW19qMl0gLyBlW2sgKyAxXTtcbiAgICAgICAgICBmb3IgKHZhciBfaTkgPSBrICsgMTsgX2k5IDwgdGhpcy5tOyBfaTkrKykge1xuICAgICAgICAgICAgQVtfaTldW19qMl0gKz0gX3QgKiB3b3JrW19pOV07XG4gICAgICAgICAgfVxuICAgICAgICAgIDtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICB9XG4gICAgICBpZiAod2FudHYpIHtcbiAgICAgICAgZm9yICh2YXIgX2kxMCA9IGsgKyAxOyBfaTEwIDwgdGhpcy5uOyBfaTEwKyspIHtcbiAgICAgICAgICB0aGlzLlZbX2kxMF1ba10gPSBlW19pMTBdO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdmFyIHAgPSBNYXRoLm1pbih0aGlzLm4sIHRoaXMubSArIDEpO1xuICBpZiAobmN0IDwgdGhpcy5uKSB7XG4gICAgdGhpcy5zW25jdF0gPSBBW25jdF1bbmN0XTtcbiAgfVxuICBpZiAodGhpcy5tIDwgcCkge1xuICAgIHRoaXMuc1twIC0gMV0gPSAwLjA7XG4gIH1cbiAgaWYgKG5ydCArIDEgPCBwKSB7XG4gICAgZVtucnRdID0gQVtucnRdW3AgLSAxXTtcbiAgfVxuICBlW3AgLSAxXSA9IDAuMDtcbiAgaWYgKHdhbnR1KSB7XG4gICAgZm9yICh2YXIgX2ozID0gbmN0OyBfajMgPCBudTsgX2ozKyspIHtcbiAgICAgIGZvciAodmFyIF9pMTEgPSAwOyBfaTExIDwgdGhpcy5tOyBfaTExKyspIHtcbiAgICAgICAgdGhpcy5VW19pMTFdW19qM10gPSAwLjA7XG4gICAgICB9XG4gICAgICA7XG4gICAgICB0aGlzLlVbX2ozXVtfajNdID0gMS4wO1xuICAgIH07XG4gICAgZm9yICh2YXIgX2sgPSBuY3QgLSAxOyBfayA+PSAwOyBfay0tKSB7XG4gICAgICBpZiAodGhpcy5zW19rXSAhPT0gMC4wKSB7XG4gICAgICAgIGZvciAodmFyIF9qNCA9IF9rICsgMTsgX2o0IDwgbnU7IF9qNCsrKSB7XG4gICAgICAgICAgdmFyIF90MiA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgX2kxMiA9IF9rOyBfaTEyIDwgdGhpcy5tOyBfaTEyKyspIHtcbiAgICAgICAgICAgIF90MiArPSB0aGlzLlVbX2kxMl1bX2tdICogdGhpcy5VW19pMTJdW19qNF07XG4gICAgICAgICAgfTtcbiAgICAgICAgICBfdDIgPSAtX3QyIC8gdGhpcy5VW19rXVtfa107XG4gICAgICAgICAgZm9yICh2YXIgX2kxMyA9IF9rOyBfaTEzIDwgdGhpcy5tOyBfaTEzKyspIHtcbiAgICAgICAgICAgIHRoaXMuVVtfaTEzXVtfajRdICs9IF90MiAqIHRoaXMuVVtfaTEzXVtfa107XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgX2kxNCA9IF9rOyBfaTE0IDwgdGhpcy5tOyBfaTE0KyspIHtcbiAgICAgICAgICB0aGlzLlVbX2kxNF1bX2tdID0gLXRoaXMuVVtfaTE0XVtfa107XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuVVtfa11bX2tdID0gMS4wICsgdGhpcy5VW19rXVtfa107XG4gICAgICAgIGZvciAodmFyIF9pMTUgPSAwOyBfaTE1IDwgX2sgLSAxOyBfaTE1KyspIHtcbiAgICAgICAgICB0aGlzLlVbX2kxNV1bX2tdID0gMC4wO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgX2kxNiA9IDA7IF9pMTYgPCB0aGlzLm07IF9pMTYrKykge1xuICAgICAgICAgIHRoaXMuVVtfaTE2XVtfa10gPSAwLjA7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuVVtfa11bX2tdID0gMS4wO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgaWYgKHdhbnR2KSB7XG4gICAgZm9yICh2YXIgX2syID0gdGhpcy5uIC0gMTsgX2syID49IDA7IF9rMi0tKSB7XG4gICAgICBpZiAoZnVuY3Rpb24gKGxocywgcmhzKSB7XG4gICAgICAgIHJldHVybiBsaHMgJiYgcmhzO1xuICAgICAgfShfazIgPCBucnQsIGVbX2syXSAhPT0gMC4wKSkge1xuICAgICAgICBmb3IgKHZhciBfajUgPSBfazIgKyAxOyBfajUgPCBudTsgX2o1KyspIHtcbiAgICAgICAgICB2YXIgX3QzID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBfaTE3ID0gX2syICsgMTsgX2kxNyA8IHRoaXMubjsgX2kxNysrKSB7XG4gICAgICAgICAgICBfdDMgKz0gdGhpcy5WW19pMTddW19rMl0gKiB0aGlzLlZbX2kxN11bX2o1XTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIF90MyA9IC1fdDMgLyB0aGlzLlZbX2syICsgMV1bX2syXTtcbiAgICAgICAgICBmb3IgKHZhciBfaTE4ID0gX2syICsgMTsgX2kxOCA8IHRoaXMubjsgX2kxOCsrKSB7XG4gICAgICAgICAgICB0aGlzLlZbX2kxOF1bX2o1XSArPSBfdDMgKiB0aGlzLlZbX2kxOF1bX2syXTtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2kxOSA9IDA7IF9pMTkgPCB0aGlzLm47IF9pMTkrKykge1xuICAgICAgICB0aGlzLlZbX2kxOV1bX2syXSA9IDAuMDtcbiAgICAgIH07XG4gICAgICB0aGlzLlZbX2syXVtfazJdID0gMS4wO1xuICAgIH07XG4gIH1cbiAgdmFyIHBwID0gcCAtIDE7XG4gIHZhciBpdGVyID0gMDtcbiAgdmFyIGVwcyA9IE1hdGgucG93KDIuMCwgLTUyLjApO1xuICB2YXIgdGlueSA9IE1hdGgucG93KDIuMCwgLTk2Ni4wKTtcbiAgd2hpbGUgKHAgPiAwKSB7XG4gICAgdmFyIF9rMyA9IHZvaWQgMDtcbiAgICB2YXIga2FzZSA9IHZvaWQgMDtcbiAgICBmb3IgKF9rMyA9IHAgLSAyOyBfazMgPj0gLTE7IF9rMy0tKSB7XG4gICAgICBpZiAoX2szID09PSAtMSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChNYXRoLmFicyhlW19rM10pIDw9IHRpbnkgKyBlcHMgKiAoTWF0aC5hYnModGhpcy5zW19rM10pICsgTWF0aC5hYnModGhpcy5zW19rMyArIDFdKSkpIHtcbiAgICAgICAgZVtfazNdID0gMC4wO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChfazMgPT09IHAgLSAyKSB7XG4gICAgICBrYXNlID0gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtzID0gdm9pZCAwO1xuICAgICAgZm9yIChrcyA9IHAgLSAxOyBrcyA+PSBfazM7IGtzLS0pIHtcbiAgICAgICAgaWYgKGtzID09PSBfazMpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgX3Q0ID0gKGtzICE9PSBwID8gTWF0aC5hYnMoZVtrc10pIDogMC4wKSArIChrcyAhPT0gX2szICsgMSA/IE1hdGguYWJzKGVba3MgLSAxXSkgOiAwLjApO1xuICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5zW2tzXSkgPD0gdGlueSArIGVwcyAqIF90NCkge1xuICAgICAgICAgIHRoaXMuc1trc10gPSAwLjA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoa3MgPT09IF9rMykge1xuICAgICAgICBrYXNlID0gMztcbiAgICAgIH0gZWxzZSBpZiAoa3MgPT09IHAgLSAxKSB7XG4gICAgICAgIGthc2UgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2FzZSA9IDI7XG4gICAgICAgIF9rMyA9IGtzO1xuICAgICAgfVxuICAgIH1cbiAgICBfazMrKztcbiAgICBzd2l0Y2ggKGthc2UpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBmID0gZVtwIC0gMl07XG4gICAgICAgICAgZVtwIC0gMl0gPSAwLjA7XG4gICAgICAgICAgZm9yICh2YXIgX2o2ID0gcCAtIDI7IF9qNiA+PSBfazM7IF9qNi0tKSB7XG4gICAgICAgICAgICB2YXIgX3Q1ID0gU1ZELmh5cG90KHRoaXMuc1tfajZdLCBmKTtcbiAgICAgICAgICAgIHZhciBjcyA9IHRoaXMuc1tfajZdIC8gX3Q1O1xuICAgICAgICAgICAgdmFyIHNuID0gZiAvIF90NTtcbiAgICAgICAgICAgIHRoaXMuc1tfajZdID0gX3Q1O1xuICAgICAgICAgICAgaWYgKF9qNiAhPT0gX2szKSB7XG4gICAgICAgICAgICAgIGYgPSAtc24gKiBlW19qNiAtIDFdO1xuICAgICAgICAgICAgICBlW19qNiAtIDFdID0gY3MgKiBlW19qNiAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdhbnR2KSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pMjAgPSAwOyBfaTIwIDwgdGhpcy5uOyBfaTIwKyspIHtcbiAgICAgICAgICAgICAgICBfdDUgPSBjcyAqIHRoaXMuVltfaTIwXVtfajZdICsgc24gKiB0aGlzLlZbX2kyMF1bcCAtIDFdO1xuICAgICAgICAgICAgICAgIHRoaXMuVltfaTIwXVtwIC0gMV0gPSAtc24gKiB0aGlzLlZbX2kyMF1bX2o2XSArIGNzICogdGhpcy5WW19pMjBdW3AgLSAxXTtcbiAgICAgICAgICAgICAgICB0aGlzLlZbX2kyMF1bX2o2XSA9IF90NTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfZiA9IGVbX2szIC0gMV07XG4gICAgICAgICAgZVtfazMgLSAxXSA9IDAuMDtcbiAgICAgICAgICBmb3IgKHZhciBfajcgPSBfazM7IF9qNyA8IHA7IF9qNysrKSB7XG4gICAgICAgICAgICB2YXIgX3Q2ID0gU1ZELmh5cG90KHRoaXMuc1tfajddLCBfZik7XG4gICAgICAgICAgICB2YXIgX2NzID0gdGhpcy5zW19qN10gLyBfdDY7XG4gICAgICAgICAgICB2YXIgX3NuID0gX2YgLyBfdDY7XG4gICAgICAgICAgICB0aGlzLnNbX2o3XSA9IF90NjtcbiAgICAgICAgICAgIF9mID0gLV9zbiAqIGVbX2o3XTtcbiAgICAgICAgICAgIGVbX2o3XSA9IF9jcyAqIGVbX2o3XTtcbiAgICAgICAgICAgIGlmICh3YW50dSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfaTIxID0gMDsgX2kyMSA8IHRoaXMubTsgX2kyMSsrKSB7XG4gICAgICAgICAgICAgICAgX3Q2ID0gX2NzICogdGhpcy5VW19pMjFdW19qN10gKyBfc24gKiB0aGlzLlVbX2kyMV1bX2szIC0gMV07XG4gICAgICAgICAgICAgICAgdGhpcy5VW19pMjFdW19rMyAtIDFdID0gLV9zbiAqIHRoaXMuVVtfaTIxXVtfajddICsgX2NzICogdGhpcy5VW19pMjFdW19rMyAtIDFdO1xuICAgICAgICAgICAgICAgIHRoaXMuVVtfaTIxXVtfajddID0gX3Q2O1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHNjYWxlID0gTWF0aC5tYXgoTWF0aC5tYXgoTWF0aC5tYXgoTWF0aC5tYXgoTWF0aC5hYnModGhpcy5zW3AgLSAxXSksIE1hdGguYWJzKHRoaXMuc1twIC0gMl0pKSwgTWF0aC5hYnMoZVtwIC0gMl0pKSwgTWF0aC5hYnModGhpcy5zW19rM10pKSwgTWF0aC5hYnMoZVtfazNdKSk7XG4gICAgICAgICAgdmFyIHNwID0gdGhpcy5zW3AgLSAxXSAvIHNjYWxlO1xuICAgICAgICAgIHZhciBzcG0xID0gdGhpcy5zW3AgLSAyXSAvIHNjYWxlO1xuICAgICAgICAgIHZhciBlcG0xID0gZVtwIC0gMl0gLyBzY2FsZTtcbiAgICAgICAgICB2YXIgc2sgPSB0aGlzLnNbX2szXSAvIHNjYWxlO1xuICAgICAgICAgIHZhciBlayA9IGVbX2szXSAvIHNjYWxlO1xuICAgICAgICAgIHZhciBiID0gKChzcG0xICsgc3ApICogKHNwbTEgLSBzcCkgKyBlcG0xICogZXBtMSkgLyAyLjA7XG4gICAgICAgICAgdmFyIGMgPSBzcCAqIGVwbTEgKiAoc3AgKiBlcG0xKTtcbiAgICAgICAgICB2YXIgc2hpZnQgPSAwLjA7XG4gICAgICAgICAgaWYgKGZ1bmN0aW9uIChsaHMsIHJocykge1xuICAgICAgICAgICAgcmV0dXJuIGxocyB8fCByaHM7XG4gICAgICAgICAgfShiICE9PSAwLjAsIGMgIT09IDAuMCkpIHtcbiAgICAgICAgICAgIHNoaWZ0ID0gTWF0aC5zcXJ0KGIgKiBiICsgYyk7XG4gICAgICAgICAgICBpZiAoYiA8IDAuMCkge1xuICAgICAgICAgICAgICBzaGlmdCA9IC1zaGlmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNoaWZ0ID0gYyAvIChiICsgc2hpZnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgX2YyID0gKHNrICsgc3ApICogKHNrIC0gc3ApICsgc2hpZnQ7XG4gICAgICAgICAgdmFyIGcgPSBzayAqIGVrO1xuICAgICAgICAgIGZvciAodmFyIF9qOCA9IF9rMzsgX2o4IDwgcCAtIDE7IF9qOCsrKSB7XG4gICAgICAgICAgICB2YXIgX3Q3ID0gU1ZELmh5cG90KF9mMiwgZyk7XG4gICAgICAgICAgICB2YXIgX2NzMiA9IF9mMiAvIF90NztcbiAgICAgICAgICAgIHZhciBfc24yID0gZyAvIF90NztcbiAgICAgICAgICAgIGlmIChfajggIT09IF9rMykge1xuICAgICAgICAgICAgICBlW19qOCAtIDFdID0gX3Q3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2YyID0gX2NzMiAqIHRoaXMuc1tfajhdICsgX3NuMiAqIGVbX2o4XTtcbiAgICAgICAgICAgIGVbX2o4XSA9IF9jczIgKiBlW19qOF0gLSBfc24yICogdGhpcy5zW19qOF07XG4gICAgICAgICAgICBnID0gX3NuMiAqIHRoaXMuc1tfajggKyAxXTtcbiAgICAgICAgICAgIHRoaXMuc1tfajggKyAxXSA9IF9jczIgKiB0aGlzLnNbX2o4ICsgMV07XG4gICAgICAgICAgICBpZiAod2FudHYpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2kyMiA9IDA7IF9pMjIgPCB0aGlzLm47IF9pMjIrKykge1xuICAgICAgICAgICAgICAgIF90NyA9IF9jczIgKiB0aGlzLlZbX2kyMl1bX2o4XSArIF9zbjIgKiB0aGlzLlZbX2kyMl1bX2o4ICsgMV07XG4gICAgICAgICAgICAgICAgdGhpcy5WW19pMjJdW19qOCArIDFdID0gLV9zbjIgKiB0aGlzLlZbX2kyMl1bX2o4XSArIF9jczIgKiB0aGlzLlZbX2kyMl1bX2o4ICsgMV07XG4gICAgICAgICAgICAgICAgdGhpcy5WW19pMjJdW19qOF0gPSBfdDc7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdDcgPSBTVkQuaHlwb3QoX2YyLCBnKTtcbiAgICAgICAgICAgIF9jczIgPSBfZjIgLyBfdDc7XG4gICAgICAgICAgICBfc24yID0gZyAvIF90NztcbiAgICAgICAgICAgIHRoaXMuc1tfajhdID0gX3Q3O1xuICAgICAgICAgICAgX2YyID0gX2NzMiAqIGVbX2o4XSArIF9zbjIgKiB0aGlzLnNbX2o4ICsgMV07XG4gICAgICAgICAgICB0aGlzLnNbX2o4ICsgMV0gPSAtX3NuMiAqIGVbX2o4XSArIF9jczIgKiB0aGlzLnNbX2o4ICsgMV07XG4gICAgICAgICAgICBnID0gX3NuMiAqIGVbX2o4ICsgMV07XG4gICAgICAgICAgICBlW19qOCArIDFdID0gX2NzMiAqIGVbX2o4ICsgMV07XG4gICAgICAgICAgICBpZiAod2FudHUgJiYgX2o4IDwgdGhpcy5tIC0gMSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfaTIzID0gMDsgX2kyMyA8IHRoaXMubTsgX2kyMysrKSB7XG4gICAgICAgICAgICAgICAgX3Q3ID0gX2NzMiAqIHRoaXMuVVtfaTIzXVtfajhdICsgX3NuMiAqIHRoaXMuVVtfaTIzXVtfajggKyAxXTtcbiAgICAgICAgICAgICAgICB0aGlzLlVbX2kyM11bX2o4ICsgMV0gPSAtX3NuMiAqIHRoaXMuVVtfaTIzXVtfajhdICsgX2NzMiAqIHRoaXMuVVtfaTIzXVtfajggKyAxXTtcbiAgICAgICAgICAgICAgICB0aGlzLlVbX2kyM11bX2o4XSA9IF90NztcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGVbcCAtIDJdID0gX2YyO1xuICAgICAgICAgIGl0ZXIgPSBpdGVyICsgMTtcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodGhpcy5zW19rM10gPD0gMC4wKSB7XG4gICAgICAgICAgICB0aGlzLnNbX2szXSA9IHRoaXMuc1tfazNdIDwgMC4wID8gLXRoaXMuc1tfazNdIDogMC4wO1xuICAgICAgICAgICAgaWYgKHdhbnR2KSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pMjQgPSAwOyBfaTI0IDw9IHBwOyBfaTI0KyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLlZbX2kyNF1bX2szXSA9IC10aGlzLlZbX2kyNF1bX2szXTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKF9rMyA8IHBwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zW19rM10gPj0gdGhpcy5zW19rMyArIDFdKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF90OCA9IHRoaXMuc1tfazNdO1xuICAgICAgICAgICAgdGhpcy5zW19rM10gPSB0aGlzLnNbX2szICsgMV07XG4gICAgICAgICAgICB0aGlzLnNbX2szICsgMV0gPSBfdDg7XG4gICAgICAgICAgICBpZiAod2FudHYgJiYgX2szIDwgdGhpcy5uIC0gMSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfaTI1ID0gMDsgX2kyNSA8IHRoaXMubjsgX2kyNSsrKSB7XG4gICAgICAgICAgICAgICAgX3Q4ID0gdGhpcy5WW19pMjVdW19rMyArIDFdO1xuICAgICAgICAgICAgICAgIHRoaXMuVltfaTI1XVtfazMgKyAxXSA9IHRoaXMuVltfaTI1XVtfazNdO1xuICAgICAgICAgICAgICAgIHRoaXMuVltfaTI1XVtfazNdID0gX3Q4O1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdhbnR1ICYmIF9rMyA8IHRoaXMubSAtIDEpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2kyNiA9IDA7IF9pMjYgPCB0aGlzLm07IF9pMjYrKykge1xuICAgICAgICAgICAgICAgIF90OCA9IHRoaXMuVVtfaTI2XVtfazMgKyAxXTtcbiAgICAgICAgICAgICAgICB0aGlzLlVbX2kyNl1bX2szICsgMV0gPSB0aGlzLlVbX2kyNl1bX2szXTtcbiAgICAgICAgICAgICAgICB0aGlzLlVbX2kyNl1bX2szXSA9IF90ODtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9rMysrO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaXRlciA9IDA7XG4gICAgICAgICAgcC0tO1xuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH07XG4gIHZhciByZXN1bHQgPSB7IFU6IHRoaXMuVSwgVjogdGhpcy5WLCBTOiB0aGlzLnMgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIHNxcnQoYV4yICsgYl4yKSB3aXRob3V0IHVuZGVyL292ZXJmbG93LlxuU1ZELmh5cG90ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgdmFyIHIgPSB2b2lkIDA7XG4gIGlmIChNYXRoLmFicyhhKSA+IE1hdGguYWJzKGIpKSB7XG4gICAgciA9IGIgLyBhO1xuICAgIHIgPSBNYXRoLmFicyhhKSAqIE1hdGguc3FydCgxICsgciAqIHIpO1xuICB9IGVsc2UgaWYgKGIgIT0gMCkge1xuICAgIHIgPSBhIC8gYjtcbiAgICByID0gTWF0aC5hYnMoYikgKiBNYXRoLnNxcnQoMSArIHIgKiByKTtcbiAgfSBlbHNlIHtcbiAgICByID0gMC4wO1xuICB9XG4gIHJldHVybiByO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTVkQ7XG5cbi8qKiovIH0pLFxuLyogMjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiAgIE5lZWRsZW1hbi1XdW5zY2ggYWxnb3JpdGhtIGlzIGFuIHByb2NlZHVyZSB0byBjb21wdXRlIHRoZSBvcHRpbWFsIGdsb2JhbCBhbGlnbm1lbnQgb2YgdHdvIHN0cmluZ1xuICogICBzZXF1ZW5jZXMgYnkgUy5CLk5lZWRsZW1hbiBhbmQgQy5ELld1bnNjaCAoMTk3MCkuXG4gKlxuICogICBBc2lkZSBmcm9tIHRoZSBpbnB1dHMsIHlvdSBjYW4gYXNzaWduIHRoZSBzY29yZXMgZm9yLFxuICogICAtIE1hdGNoOiBUaGUgdHdvIGNoYXJhY3RlcnMgYXQgdGhlIGN1cnJlbnQgaW5kZXggYXJlIHNhbWUuXG4gKiAgIC0gTWlzbWF0Y2g6IFRoZSB0d28gY2hhcmFjdGVycyBhdCB0aGUgY3VycmVudCBpbmRleCBhcmUgZGlmZmVyZW50LlxuICogICAtIEluc2VydGlvbi9EZWxldGlvbihnYXBzKTogVGhlIGJlc3QgYWxpZ25tZW50IGludm9sdmVzIG9uZSBsZXR0ZXIgYWxpZ25pbmcgdG8gYSBnYXAgaW4gdGhlIG90aGVyIHN0cmluZy5cbiAqL1xuXG52YXIgTmVlZGxlbWFuV3Vuc2NoID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5lZWRsZW1hbld1bnNjaChzZXF1ZW5jZTEsIHNlcXVlbmNlMikge1xuICAgICAgICB2YXIgbWF0Y2hfc2NvcmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG4gICAgICAgIHZhciBtaXNtYXRjaF9wZW5hbHR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAtMTtcbiAgICAgICAgdmFyIGdhcF9wZW5hbHR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiAtMTtcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTmVlZGxlbWFuV3Vuc2NoKTtcblxuICAgICAgICB0aGlzLnNlcXVlbmNlMSA9IHNlcXVlbmNlMTtcbiAgICAgICAgdGhpcy5zZXF1ZW5jZTIgPSBzZXF1ZW5jZTI7XG4gICAgICAgIHRoaXMubWF0Y2hfc2NvcmUgPSBtYXRjaF9zY29yZTtcbiAgICAgICAgdGhpcy5taXNtYXRjaF9wZW5hbHR5ID0gbWlzbWF0Y2hfcGVuYWx0eTtcbiAgICAgICAgdGhpcy5nYXBfcGVuYWx0eSA9IGdhcF9wZW5hbHR5O1xuXG4gICAgICAgIC8vIEp1c3QgdGhlIHJlbW92ZSByZWR1bmRhbmN5XG4gICAgICAgIHRoaXMuaU1heCA9IHNlcXVlbmNlMS5sZW5ndGggKyAxO1xuICAgICAgICB0aGlzLmpNYXggPSBzZXF1ZW5jZTIubGVuZ3RoICsgMTtcblxuICAgICAgICAvLyBHcmlkIG1hdHJpeCBvZiBzY29yZXNcbiAgICAgICAgdGhpcy5ncmlkID0gbmV3IEFycmF5KHRoaXMuaU1heCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pTWF4OyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZFtpXSA9IG5ldyBBcnJheSh0aGlzLmpNYXgpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuak1heDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkW2ldW2pdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyYWNlYmFjayBtYXRyaXggKDJEIGFycmF5LCBlYWNoIGNlbGwgaXMgYW4gYXJyYXkgb2YgYm9vbGVhbiB2YWx1ZXMgZm9yIFtgRGlhZ2AsIGBVcGAsIGBMZWZ0YF0gcG9zaXRpb25zKVxuICAgICAgICB0aGlzLnRyYWNlYmFja0dyaWQgPSBuZXcgQXJyYXkodGhpcy5pTWF4KTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMuaU1heDsgX2krKykge1xuICAgICAgICAgICAgdGhpcy50cmFjZWJhY2tHcmlkW19pXSA9IG5ldyBBcnJheSh0aGlzLmpNYXgpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgdGhpcy5qTWF4OyBfaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZWJhY2tHcmlkW19pXVtfal0gPSBbbnVsbCwgbnVsbCwgbnVsbF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgYWxpZ25lZCBzZXF1ZW5jZXMgKHJldHVybiBtdWx0aXBsZSBwb3NzaWJpbGl0aWVzKVxuICAgICAgICB0aGlzLmFsaWdubWVudHMgPSBbXTtcblxuICAgICAgICAvLyBGaW5hbCBhbGlnbm1lbnQgc2NvcmVcbiAgICAgICAgdGhpcy5zY29yZSA9IC0xO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBzY29yZXMgYW5kIHRyYWNlYmFja3NcbiAgICAgICAgdGhpcy5jb21wdXRlR3JpZHMoKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoTmVlZGxlbWFuV3Vuc2NoLCBbe1xuICAgICAgICBrZXk6IFwiZ2V0U2NvcmVcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNjb3JlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NvcmU7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJnZXRBbGlnbm1lbnRzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBbGlnbm1lbnRzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWxpZ25tZW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1haW4gZHluYW1pYyBwcm9ncmFtbWluZyBwcm9jZWR1cmVcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImNvbXB1dGVHcmlkc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcHV0ZUdyaWRzKCkge1xuICAgICAgICAgICAgLy8gRmlsbCBpbiB0aGUgZmlyc3Qgcm93XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHRoaXMuak1heDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkWzBdW2pdID0gdGhpcy5ncmlkWzBdW2ogLSAxXSArIHRoaXMuZ2FwX3BlbmFsdHk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZWJhY2tHcmlkWzBdW2pdID0gW2ZhbHNlLCBmYWxzZSwgdHJ1ZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpbGwgaW4gdGhlIGZpcnN0IGNvbHVtblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLmlNYXg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZFtpXVswXSA9IHRoaXMuZ3JpZFtpIC0gMV1bMF0gKyB0aGlzLmdhcF9wZW5hbHR5O1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2ViYWNrR3JpZFtpXVswXSA9IFtmYWxzZSwgdHJ1ZSwgZmFsc2VdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaWxsIHRoZSByZXN0IG9mIHRoZSBncmlkXG4gICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAxOyBfaTIgPCB0aGlzLmlNYXg7IF9pMisrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2oyID0gMTsgX2oyIDwgdGhpcy5qTWF4OyBfajIrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBtYXggc2NvcmUocykgYW1vbmcgW2BEaWFnYCwgYFVwYCwgYExlZnRgXVxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlhZyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VxdWVuY2UxW19pMiAtIDFdID09PSB0aGlzLnNlcXVlbmNlMltfajIgLSAxXSkgZGlhZyA9IHRoaXMuZ3JpZFtfaTIgLSAxXVtfajIgLSAxXSArIHRoaXMubWF0Y2hfc2NvcmU7ZWxzZSBkaWFnID0gdGhpcy5ncmlkW19pMiAtIDFdW19qMiAtIDFdICsgdGhpcy5taXNtYXRjaF9wZW5hbHR5O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB1cCA9IHRoaXMuZ3JpZFtfaTIgLSAxXVtfajJdICsgdGhpcy5nYXBfcGVuYWx0eTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnQgPSB0aGlzLmdyaWRbX2kyXVtfajIgLSAxXSArIHRoaXMuZ2FwX3BlbmFsdHk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgZXhpc3RzIG11bHRpcGxlIG1heCB2YWx1ZXMsIGNhcHR1cmUgdGhlbSBmb3IgbXVsdGlwbGUgcGF0aHNcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heE9mID0gW2RpYWcsIHVwLCBsZWZ0XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGljZXMgPSB0aGlzLmFycmF5QWxsTWF4SW5kZXhlcyhtYXhPZik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIEdyaWRzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JpZFtfaTJdW19qMl0gPSBtYXhPZltpbmRpY2VzWzBdXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZWJhY2tHcmlkW19pMl1bX2oyXSA9IFtpbmRpY2VzLmluY2x1ZGVzKDApLCBpbmRpY2VzLmluY2x1ZGVzKDEpLCBpbmRpY2VzLmluY2x1ZGVzKDIpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBhbGlnbm1lbnQgc2NvcmVcbiAgICAgICAgICAgIHRoaXMuc2NvcmUgPSB0aGlzLmdyaWRbdGhpcy5pTWF4IC0gMV1bdGhpcy5qTWF4IC0gMV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXRzIGFsbCBwb3NzaWJsZSB2YWxpZCBzZXF1ZW5jZSBjb21iaW5hdGlvbnNcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImFsaWdubWVudFRyYWNlYmFja1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWxpZ25tZW50VHJhY2ViYWNrKCkge1xuICAgICAgICAgICAgdmFyIGluUHJvY2Vzc0FsaWdubWVudHMgPSBbXTtcblxuICAgICAgICAgICAgaW5Qcm9jZXNzQWxpZ25tZW50cy5wdXNoKHsgcG9zOiBbdGhpcy5zZXF1ZW5jZTEubGVuZ3RoLCB0aGlzLnNlcXVlbmNlMi5sZW5ndGhdLFxuICAgICAgICAgICAgICAgIHNlcTE6IFwiXCIsXG4gICAgICAgICAgICAgICAgc2VxMjogXCJcIlxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHdoaWxlIChpblByb2Nlc3NBbGlnbm1lbnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBpblByb2Nlc3NBbGlnbm1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb25zID0gdGhpcy50cmFjZWJhY2tHcmlkW2N1cnJlbnQucG9zWzBdXVtjdXJyZW50LnBvc1sxXV07XG5cbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uc1swXSkge1xuICAgICAgICAgICAgICAgICAgICBpblByb2Nlc3NBbGlnbm1lbnRzLnB1c2goeyBwb3M6IFtjdXJyZW50LnBvc1swXSAtIDEsIGN1cnJlbnQucG9zWzFdIC0gMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXExOiB0aGlzLnNlcXVlbmNlMVtjdXJyZW50LnBvc1swXSAtIDFdICsgY3VycmVudC5zZXExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxMjogdGhpcy5zZXF1ZW5jZTJbY3VycmVudC5wb3NbMV0gLSAxXSArIGN1cnJlbnQuc2VxMlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbnNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5Qcm9jZXNzQWxpZ25tZW50cy5wdXNoKHsgcG9zOiBbY3VycmVudC5wb3NbMF0gLSAxLCBjdXJyZW50LnBvc1sxXV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXExOiB0aGlzLnNlcXVlbmNlMVtjdXJyZW50LnBvc1swXSAtIDFdICsgY3VycmVudC5zZXExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxMjogJy0nICsgY3VycmVudC5zZXEyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uc1syXSkge1xuICAgICAgICAgICAgICAgICAgICBpblByb2Nlc3NBbGlnbm1lbnRzLnB1c2goeyBwb3M6IFtjdXJyZW50LnBvc1swXSwgY3VycmVudC5wb3NbMV0gLSAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcTE6ICctJyArIGN1cnJlbnQuc2VxMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcTI6IHRoaXMuc2VxdWVuY2UyW2N1cnJlbnQucG9zWzFdIC0gMV0gKyBjdXJyZW50LnNlcTJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQucG9zWzBdID09PSAwICYmIGN1cnJlbnQucG9zWzFdID09PSAwKSB0aGlzLmFsaWdubWVudHMucHVzaCh7IHNlcXVlbmNlMTogY3VycmVudC5zZXExLFxuICAgICAgICAgICAgICAgICAgICBzZXF1ZW5jZTI6IGN1cnJlbnQuc2VxMlxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgaW5Qcm9jZXNzQWxpZ25tZW50cy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbGlnbm1lbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGVscGVyIEZ1bmN0aW9uc1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZ2V0QWxsSW5kZXhlc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWxsSW5kZXhlcyhhcnIsIHZhbCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgICAgICAgICBpID0gLTE7XG4gICAgICAgICAgICB3aGlsZSAoKGkgPSBhcnIuaW5kZXhPZih2YWwsIGkgKyAxKSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4ZXM7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJhcnJheUFsbE1heEluZGV4ZXNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFycmF5QWxsTWF4SW5kZXhlcyhhcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxsSW5kZXhlcyhhcnJheSwgTWF0aC5tYXguYXBwbHkobnVsbCwgYXJyYXkpKTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBOZWVkbGVtYW5XdW5zY2g7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gTmVlZGxlbWFuV3Vuc2NoO1xuXG4vKioqLyB9KSxcbi8qIDI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBsYXlvdXRCYXNlID0gZnVuY3Rpb24gbGF5b3V0QmFzZSgpIHtcbiAgcmV0dXJuO1xufTtcblxubGF5b3V0QmFzZS5GRExheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xubGF5b3V0QmFzZS5GRExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5sYXlvdXRCYXNlLkZETGF5b3V0RWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xubGF5b3V0QmFzZS5GRExheW91dE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcbmxheW91dEJhc2UuRGltZW5zaW9uRCA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xubGF5b3V0QmFzZS5IYXNoTWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5sYXlvdXRCYXNlLkhhc2hTZXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcbmxheW91dEJhc2UuSUdlb21ldHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbmxheW91dEJhc2UuSU1hdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xubGF5b3V0QmFzZS5JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5sYXlvdXRCYXNlLlBvaW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5sYXlvdXRCYXNlLlBvaW50RCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5sYXlvdXRCYXNlLlJhbmRvbVNlZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcbmxheW91dEJhc2UuUmVjdGFuZ2xlRCA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xubGF5b3V0QmFzZS5UcmFuc2Zvcm0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcbmxheW91dEJhc2UuVW5pcXVlSURHZW5lcmV0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcbmxheW91dEJhc2UuUXVpY2tzb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5sYXlvdXRCYXNlLkxpbmtlZExpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbmxheW91dEJhc2UuTEdyYXBoT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbmxheW91dEJhc2UuTEdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbmxheW91dEJhc2UuTEVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xubGF5b3V0QmFzZS5MR3JhcGhNYW5hZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbmxheW91dEJhc2UuTE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xubGF5b3V0QmFzZS5MYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcbmxheW91dEJhc2UuTGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbmxheW91dEJhc2UuTmVlZGxlbWFuV3Vuc2NoID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG5sYXlvdXRCYXNlLk1hdHJpeCA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xubGF5b3V0QmFzZS5TVkQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcblxubW9kdWxlLmV4cG9ydHMgPSBsYXlvdXRCYXNlO1xuXG4vKioqLyB9KSxcbi8qIDI5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIEVtaXR0ZXIoKSB7XG4gIHRoaXMubGlzdGVuZXJzID0gW107XG59XG5cbnZhciBwID0gRW1pdHRlci5wcm90b3R5cGU7XG5cbnAuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQsIGNhbGxiYWNrKSB7XG4gIHRoaXMubGlzdGVuZXJzLnB1c2goe1xuICAgIGV2ZW50OiBldmVudCxcbiAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgfSk7XG59O1xuXG5wLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50LCBjYWxsYmFjaykge1xuICBmb3IgKHZhciBpID0gdGhpcy5saXN0ZW5lcnMubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsID0gdGhpcy5saXN0ZW5lcnNbaV07XG5cbiAgICBpZiAobC5ldmVudCA9PT0gZXZlbnQgJiYgbC5jYWxsYmFjayA9PT0gY2FsbGJhY2spIHtcbiAgICAgIHRoaXMubGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbn07XG5cbnAuZW1pdCA9IGZ1bmN0aW9uIChldmVudCwgZGF0YSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGwgPSB0aGlzLmxpc3RlbmVyc1tpXTtcblxuICAgIGlmIChldmVudCA9PT0gbC5ldmVudCkge1xuICAgICAgbC5jYWxsYmFjayhkYXRhKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7Il0sIm5hbWVzIjpbIndlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwicm9vdCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwiYW1kIiwibW9kdWxlcyIsImluc3RhbGxlZE1vZHVsZXMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwibW9kdWxlSWQiLCJpIiwibCIsImNhbGwiLCJtIiwiYyIsInZhbHVlIiwiZCIsIm5hbWUiLCJnZXR0ZXIiLCJvIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwibiIsIl9fZXNNb2R1bGUiLCJnZXREZWZhdWx0IiwiZ2V0TW9kdWxlRXhwb3J0cyIsIm9iamVjdCIsInByb3BlcnR5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJwIiwicyIsIkxheW91dENvbnN0YW50cyIsIlFVQUxJVFkiLCJERUZBVUxUX0NSRUFURV9CRU5EU19BU19ORUVERUQiLCJERUZBVUxUX0lOQ1JFTUVOVEFMIiwiREVGQVVMVF9BTklNQVRJT05fT05fTEFZT1VUIiwiREVGQVVMVF9BTklNQVRJT05fRFVSSU5HX0xBWU9VVCIsIkRFRkFVTFRfQU5JTUFUSU9OX1BFUklPRCIsIkRFRkFVTFRfVU5JRk9STV9MRUFGX05PREVfU0laRVMiLCJERUZBVUxUX0dSQVBIX01BUkdJTiIsIk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUyIsIlNJTVBMRV9OT0RFX1NJWkUiLCJTSU1QTEVfTk9ERV9IQUxGX1NJWkUiLCJFTVBUWV9DT01QT1VORF9OT0RFX1NJWkUiLCJNSU5fRURHRV9MRU5HVEgiLCJXT1JMRF9CT1VOREFSWSIsIklOSVRJQUxfV09STERfQk9VTkRBUlkiLCJXT1JMRF9DRU5URVJfWCIsIldPUkxEX0NFTlRFUl9ZIiwiTEdyYXBoT2JqZWN0IiwiSUdlb21ldHJ5IiwiSU1hdGgiLCJMRWRnZSIsInNvdXJjZSIsInRhcmdldCIsInZFZGdlIiwiaXNPdmVybGFwaW5nU291cmNlQW5kVGFyZ2V0IiwidkdyYXBoT2JqZWN0IiwiYmVuZHBvaW50cyIsImNyZWF0ZSIsInByb3AiLCJnZXRTb3VyY2UiLCJnZXRUYXJnZXQiLCJpc0ludGVyR3JhcGgiLCJnZXRMZW5ndGgiLCJsZW5ndGgiLCJnZXRCZW5kcG9pbnRzIiwiZ2V0TGNhIiwibGNhIiwiZ2V0U291cmNlSW5MY2EiLCJzb3VyY2VJbkxjYSIsImdldFRhcmdldEluTGNhIiwidGFyZ2V0SW5MY2EiLCJnZXRPdGhlckVuZCIsIm5vZGUiLCJnZXRPdGhlckVuZEluR3JhcGgiLCJncmFwaCIsIm90aGVyRW5kIiwiZ2V0R3JhcGhNYW5hZ2VyIiwiZ2V0Um9vdCIsImdldE93bmVyIiwiZ2V0UGFyZW50IiwidXBkYXRlTGVuZ3RoIiwiY2xpcFBvaW50Q29vcmRpbmF0ZXMiLCJBcnJheSIsImdldEludGVyc2VjdGlvbiIsImdldFJlY3QiLCJsZW5ndGhYIiwibGVuZ3RoWSIsIk1hdGgiLCJhYnMiLCJzaWduIiwic3FydCIsInVwZGF0ZUxlbmd0aFNpbXBsZSIsImdldENlbnRlclgiLCJnZXRDZW50ZXJZIiwiSW50ZWdlciIsIlJlY3RhbmdsZUQiLCJSYW5kb21TZWVkIiwiUG9pbnREIiwiTE5vZGUiLCJnbSIsImxvYyIsInNpemUiLCJ2Tm9kZSIsImdyYXBoTWFuYWdlciIsImVzdGltYXRlZFNpemUiLCJNSU5fVkFMVUUiLCJpbmNsdXNpb25UcmVlRGVwdGgiLCJNQVhfVkFMVUUiLCJlZGdlcyIsInJlY3QiLCJ4IiwieSIsIndpZHRoIiwiaGVpZ2h0IiwiZ2V0RWRnZXMiLCJnZXRDaGlsZCIsImNoaWxkIiwib3duZXIiLCJnZXRXaWR0aCIsInNldFdpZHRoIiwiZ2V0SGVpZ2h0Iiwic2V0SGVpZ2h0IiwiZ2V0Q2VudGVyIiwiZ2V0TG9jYXRpb24iLCJnZXREaWFnb25hbCIsImdldEhhbGZUaGVEaWFnb25hbCIsInNldFJlY3QiLCJ1cHBlckxlZnQiLCJkaW1lbnNpb24iLCJzZXRDZW50ZXIiLCJjeCIsImN5Iiwic2V0TG9jYXRpb24iLCJtb3ZlQnkiLCJkeCIsImR5IiwiZ2V0RWRnZUxpc3RUb05vZGUiLCJ0byIsImVkZ2VMaXN0IiwiZWRnZSIsInNlbGYiLCJmb3JFYWNoIiwicHVzaCIsImdldEVkZ2VzQmV0d2VlbiIsIm90aGVyIiwiZ2V0TmVpZ2hib3JzTGlzdCIsIm5laWdoYm9ycyIsIlNldCIsImFkZCIsIndpdGhDaGlsZHJlbiIsIndpdGhOZWlnaGJvcnNMaXN0IiwiY2hpbGROb2RlIiwiY2hpbGRyZW4iLCJub2RlcyIsImdldE5vZGVzIiwiZ2V0Tm9PZkNoaWxkcmVuIiwibm9PZkNoaWxkcmVuIiwiZ2V0RXN0aW1hdGVkU2l6ZSIsImNhbGNFc3RpbWF0ZWRTaXplIiwic2NhdHRlciIsInJhbmRvbUNlbnRlclgiLCJyYW5kb21DZW50ZXJZIiwibWluWCIsIm1heFgiLCJuZXh0RG91YmxlIiwibWluWSIsIm1heFkiLCJ1cGRhdGVCb3VuZHMiLCJjaGlsZEdyYXBoIiwiZ2V0TGVmdCIsImdldFRvcCIsImdldFJpZ2h0IiwiZ2V0Qm90dG9tIiwibGFiZWxXaWR0aCIsImxhYmVsUG9zSG9yaXpvbnRhbCIsImxhYmVsSGVpZ2h0IiwibGFiZWxQb3NWZXJ0aWNhbCIsImdldEluY2x1c2lvblRyZWVEZXB0aCIsInRyYW5zZm9ybSIsInRyYW5zIiwibGVmdCIsInRvcCIsImxlZnRUb3AiLCJ2TGVmdFRvcCIsImludmVyc2VUcmFuc2Zvcm1Qb2ludCIsIkZETGF5b3V0Q29uc3RhbnRzIiwiTUFYX0lURVJBVElPTlMiLCJERUZBVUxUX0VER0VfTEVOR1RIIiwiREVGQVVMVF9TUFJJTkdfU1RSRU5HVEgiLCJERUZBVUxUX1JFUFVMU0lPTl9TVFJFTkdUSCIsIkRFRkFVTFRfR1JBVklUWV9TVFJFTkdUSCIsIkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9TVFJFTkdUSCIsIkRFRkFVTFRfR1JBVklUWV9SQU5HRV9GQUNUT1IiLCJERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfUkFOR0VfRkFDVE9SIiwiREVGQVVMVF9VU0VfU01BUlRfSURFQUxfRURHRV9MRU5HVEhfQ0FMQ1VMQVRJT04iLCJERUZBVUxUX1VTRV9TTUFSVF9SRVBVTFNJT05fUkFOR0VfQ0FMQ1VMQVRJT04iLCJERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMIiwiQ09PTElOR19BREFQVEFUSU9OX0ZBQ1RPUiIsIkFEQVBUQVRJT05fTE9XRVJfTk9ERV9MSU1JVCIsIkFEQVBUQVRJT05fVVBQRVJfTk9ERV9MSU1JVCIsIk1BWF9OT0RFX0RJU1BMQUNFTUVOVF9JTkNSRU1FTlRBTCIsIk1BWF9OT0RFX0RJU1BMQUNFTUVOVCIsIk1JTl9SRVBVTFNJT05fRElTVCIsIkNPTlZFUkdFTkNFX0NIRUNLX1BFUklPRCIsIlBFUl9MRVZFTF9JREVBTF9FREdFX0xFTkdUSF9GQUNUT1IiLCJHUklEX0NBTENVTEFUSU9OX0NIRUNLX1BFUklPRCIsImdldFgiLCJnZXRZIiwic2V0WCIsInNldFkiLCJnZXREaWZmZXJlbmNlIiwicHQiLCJEaW1lbnNpb25EIiwiZ2V0Q29weSIsInRyYW5zbGF0ZSIsImRpbSIsIkxHcmFwaE1hbmFnZXIiLCJQb2ludCIsIkxpbmtlZExpc3QiLCJMR3JhcGgiLCJwYXJlbnQiLCJvYmoyIiwidkdyYXBoIiwibWFyZ2luIiwiaXNDb25uZWN0ZWQiLCJMYXlvdXQiLCJyaWdodCIsImJvdHRvbSIsIm9iajEiLCJzb3VyY2VOb2RlIiwidGFyZ2V0Tm9kZSIsIm5ld05vZGUiLCJpbmRleE9mIiwibmV3RWRnZSIsInJlbW92ZSIsIm9iaiIsImVkZ2VzVG9CZVJlbW92ZWQiLCJzbGljZSIsImluZGV4Iiwic3BsaWNlIiwic291cmNlSW5kZXgiLCJ0YXJnZXRJbmRleCIsInVwZGF0ZUxlZnRUb3AiLCJub2RlVG9wIiwibm9kZUxlZnQiLCJsTm9kZSIsInBhZGRpbmdMZWZ0IiwidW5kZWZpbmVkIiwicmVjdXJzaXZlIiwibm9kZVJpZ2h0Iiwibm9kZUJvdHRvbSIsImJvdW5kaW5nUmVjdCIsImNhbGN1bGF0ZUJvdW5kcyIsInVwZGF0ZUNvbm5lY3RlZCIsInF1ZXVlIiwidmlzaXRlZCIsImN1cnJlbnROb2RlIiwibmVpZ2hib3JFZGdlcyIsImN1cnJlbnROZWlnaGJvciIsImNoaWxkcmVuT2ZOb2RlIiwic2hpZnQiLCJuZWlnaGJvckVkZ2UiLCJoYXMiLCJjaGlsZHJlbk9mTmVpZ2hib3IiLCJub09mVmlzaXRlZEluVGhpc0dyYXBoIiwidmlzaXRlZE5vZGUiLCJsYXlvdXQiLCJncmFwaHMiLCJhZGRSb290IiwibmdyYXBoIiwibmV3R3JhcGgiLCJubm9kZSIsInNldFJvb3RHcmFwaCIsInJvb3RHcmFwaCIsInBhcmVudE5vZGUiLCJzb3VyY2VHcmFwaCIsInRhcmdldEdyYXBoIiwibE9iaiIsImNvbmNhdCIsIm5vZGVzVG9CZVJlbW92ZWQiLCJnZXRHcmFwaHMiLCJnZXRBbGxOb2RlcyIsImFsbE5vZGVzIiwibm9kZUxpc3QiLCJyZXNldEFsbE5vZGVzIiwicmVzZXRBbGxFZGdlcyIsImFsbEVkZ2VzIiwicmVzZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiIsImFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uIiwiZ2V0QWxsRWRnZXMiLCJnZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiIsInNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uIiwiZ2V0TGF5b3V0IiwiaXNPbmVBbmNlc3Rvck9mT3RoZXIiLCJmaXJzdE5vZGUiLCJzZWNvbmROb2RlIiwib3duZXJHcmFwaCIsImNhbGNMb3dlc3RDb21tb25BbmNlc3RvcnMiLCJzb3VyY2VBbmNlc3RvckdyYXBoIiwidGFyZ2V0QW5jZXN0b3JHcmFwaCIsImNhbGNMb3dlc3RDb21tb25BbmNlc3RvciIsImZpcnN0T3duZXJHcmFwaCIsInNlY29uZE93bmVyR3JhcGgiLCJjYWxjSW5jbHVzaW9uVHJlZURlcHRocyIsImRlcHRoIiwiaW5jbHVkZXNJbnZhbGlkRWRnZSIsImVkZ2VzVG9SZW1vdmUiLCJjYWxjU2VwYXJhdGlvbkFtb3VudCIsInJlY3RBIiwicmVjdEIiLCJvdmVybGFwQW1vdW50Iiwic2VwYXJhdGlvbkJ1ZmZlciIsImludGVyc2VjdHMiLCJkaXJlY3Rpb25zIiwiZGVjaWRlRGlyZWN0aW9uc0Zvck92ZXJsYXBwaW5nTm9kZXMiLCJtaW4iLCJtYXgiLCJzbG9wZSIsIm1vdmVCeVkiLCJtb3ZlQnlYIiwiZ2V0SW50ZXJzZWN0aW9uMiIsInJlc3VsdCIsInAxeCIsInAxeSIsInAyeCIsInAyeSIsInRvcExlZnRBeCIsInRvcExlZnRBeSIsInRvcFJpZ2h0QXgiLCJib3R0b21MZWZ0QXgiLCJib3R0b21MZWZ0QXkiLCJib3R0b21SaWdodEF4IiwiaGFsZldpZHRoQSIsImdldFdpZHRoSGFsZiIsImhhbGZIZWlnaHRBIiwiZ2V0SGVpZ2h0SGFsZiIsInRvcExlZnRCeCIsInRvcExlZnRCeSIsInRvcFJpZ2h0QngiLCJib3R0b21MZWZ0QngiLCJib3R0b21MZWZ0QnkiLCJib3R0b21SaWdodEJ4IiwiaGFsZldpZHRoQiIsImhhbGZIZWlnaHRCIiwiY2xpcFBvaW50QUZvdW5kIiwiY2xpcFBvaW50QkZvdW5kIiwic2xvcGVBIiwic2xvcGVCIiwic2xvcGVQcmltZSIsImNhcmRpbmFsRGlyZWN0aW9uQSIsImNhcmRpbmFsRGlyZWN0aW9uQiIsInRlbXBQb2ludEF4IiwidGVtcFBvaW50QXkiLCJ0ZW1wUG9pbnRCeCIsInRlbXBQb2ludEJ5IiwiZ2V0Q2FyZGluYWxEaXJlY3Rpb24iLCJsaW5lIiwiczEiLCJzMiIsImYxIiwiZjIiLCJ4MSIsInkxIiwieDIiLCJ5MiIsIngzIiwieTMiLCJ4NCIsInk0IiwiYTEiLCJhMiIsImIxIiwiYjIiLCJjMSIsImMyIiwiZGVub20iLCJhbmdsZU9mVmVjdG9yIiwiQ3giLCJDeSIsIk54IiwiTnkiLCJDX2FuZ2xlIiwiYXRhbiIsIlBJIiwiVFdPX1BJIiwiT05FX0FORF9IQUxGX1BJIiwiSEFMRl9QSSIsImRvSW50ZXJzZWN0IiwicDEiLCJwMiIsInAzIiwicDQiLCJhIiwiYiIsInEiLCJyIiwiZGV0IiwibGFtYmRhIiwiZ2FtbWEiLCJmaW5kQ2lyY2xlTGluZUludGVyc2VjdGlvbnMiLCJFeCIsIkV5IiwiTHgiLCJMeSIsImRpc2MiLCJ0MSIsInQyIiwiaW50ZXJzZWN0aW9ucyIsIlRIUkVFX1BJIiwiZmxvb3IiLCJjZWlsIiwiX2NyZWF0ZUNsYXNzIiwiZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwiZGVzY3JpcHRvciIsIndyaXRhYmxlIiwia2V5IiwiQ29uc3RydWN0b3IiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJfY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsIlR5cGVFcnJvciIsIm5vZGVGcm9tIiwibmV4dCIsInByZXYiLCJsaXN0IiwiaGVhZCIsInRhaWwiLCJfcmVtb3ZlIiwidmFscyIsIl90aGlzIiwidiIsImluc2VydEJlZm9yZSIsInZhbCIsIm90aGVyTm9kZSIsImluc2VydEFmdGVyIiwiaW5zZXJ0Tm9kZUJlZm9yZSIsImluc2VydE5vZGVBZnRlciIsInVuc2hpZnQiLCJwb3AiLCJwb3BOb2RlIiwic2hpZnROb2RlIiwiZ2V0X29iamVjdF9hdCIsImN1cnJlbnQiLCJzZXRfb2JqZWN0X2F0IiwiY29uc3RydWN0b3IiLCJwYXJzZUludCIsIm1vdmUiLCJlcXVhbHMiLCJ0b1N0cmluZyIsImdldE1pblgiLCJnZXRNYXhYIiwiZ2V0TWluWSIsImdldE1heFkiLCJfdHlwZW9mIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJVbmlxdWVJREdlbmVyZXRvciIsImxhc3RJRCIsImNyZWF0ZUlEIiwiaXNQcmltaXRpdmUiLCJ1bmlxdWVJRCIsImdldFN0cmluZyIsImlkIiwiYXJnIiwidHlwZSIsIl90b0NvbnN1bWFibGVBcnJheSIsImFyciIsImlzQXJyYXkiLCJhcnIyIiwiZnJvbSIsIlRyYW5zZm9ybSIsIkVtaXR0ZXIiLCJpc1JlbW90ZVVzZSIsImxheW91dFF1YWxpdHkiLCJjcmVhdGVCZW5kc0FzTmVlZGVkIiwiaW5jcmVtZW50YWwiLCJhbmltYXRpb25PbkxheW91dCIsImFuaW1hdGlvbkR1cmluZ0xheW91dCIsImFuaW1hdGlvblBlcmlvZCIsInVuaWZvcm1MZWFmTm9kZVNpemVzIiwiZWRnZVRvRHVtbXlOb2RlcyIsIk1hcCIsImlzTGF5b3V0RmluaXNoZWQiLCJpc1N1YkxheW91dCIsIlJBTkRPTV9TRUVEIiwibmV3R3JhcGhNYW5hZ2VyIiwiY2hlY2tMYXlvdXRTdWNjZXNzIiwicnVuTGF5b3V0IiwidGlsaW5nUHJlTGF5b3V0IiwiaW5pdFBhcmFtZXRlcnMiLCJpc0xheW91dFN1Y2Nlc3NmdWxsIiwiQU5JTUFURSIsImRvUG9zdExheW91dCIsInRpbGluZ1Bvc3RMYXlvdXQiLCJ1cGRhdGUiLCJ1cGRhdGUyIiwiY3JlYXRlQmVuZHBvaW50c0Zyb21EdW1teU5vZGVzIiwibmV3TGVmdFRvcCIsInNldFdvcmxkT3JnWCIsInNldFdvcmxkT3JnWSIsInNldERldmljZU9yZ1giLCJzZXREZXZpY2VPcmdZIiwicG9zaXRpb25Ob2Rlc1JhbmRvbWx5IiwiZ2V0RmxhdEZvcmVzdCIsImZsYXRGb3Jlc3QiLCJpc0ZvcmVzdCIsImlzRmxhdCIsInRvQmVWaXNpdGVkIiwicGFyZW50cyIsInVuUHJvY2Vzc2VkTm9kZXMiLCJzZXQiLCJ0ZW1wIiwiY3JlYXRlRHVtbXlOb2Rlc0ZvckJlbmRwb2ludHMiLCJkdW1teU5vZGVzIiwiZHVtbXlOb2RlIiwiRGltZW5zaW9uIiwiZHVtbXlFZGdlIiwia2V5cyIsImsiLCJsRWRnZSIsInBhdGgiLCJlYnAiLCJzbGlkZXJWYWx1ZSIsImRlZmF1bHRWYWx1ZSIsIm1pbkRpdiIsIm1heE11bCIsIm1pblZhbHVlIiwibWF4VmFsdWUiLCJmaW5kQ2VudGVyT2ZUcmVlIiwicmVtb3ZlZE5vZGVzIiwicmVtYWluaW5nRGVncmVlcyIsImZvdW5kQ2VudGVyIiwiY2VudGVyTm9kZSIsImRlZ3JlZSIsInRlbXBMaXN0IiwidGVtcExpc3QyIiwibmVpZ2hib3VycyIsIm5laWdoYm91ciIsIm90aGVyRGVncmVlIiwibmV3RGVncmVlIiwic2V0R3JhcGhNYW5hZ2VyIiwic2VlZCIsInNpbiIsImx3b3JsZE9yZ1giLCJsd29ybGRPcmdZIiwibGRldmljZU9yZ1giLCJsZGV2aWNlT3JnWSIsImx3b3JsZEV4dFgiLCJsd29ybGRFeHRZIiwibGRldmljZUV4dFgiLCJsZGV2aWNlRXh0WSIsImdldFdvcmxkT3JnWCIsIndveCIsImdldFdvcmxkT3JnWSIsIndveSIsImdldFdvcmxkRXh0WCIsInNldFdvcmxkRXh0WCIsIndleCIsImdldFdvcmxkRXh0WSIsInNldFdvcmxkRXh0WSIsIndleSIsImdldERldmljZU9yZ1giLCJkb3giLCJnZXREZXZpY2VPcmdZIiwiZG95IiwiZ2V0RGV2aWNlRXh0WCIsInNldERldmljZUV4dFgiLCJkZXgiLCJnZXREZXZpY2VFeHRZIiwic2V0RGV2aWNlRXh0WSIsImRleSIsInRyYW5zZm9ybVgiLCJ4RGV2aWNlIiwid29ybGRFeHRYIiwidHJhbnNmb3JtWSIsInlEZXZpY2UiLCJ3b3JsZEV4dFkiLCJpbnZlcnNlVHJhbnNmb3JtWCIsInhXb3JsZCIsImRldmljZUV4dFgiLCJpbnZlcnNlVHJhbnNmb3JtWSIsInlXb3JsZCIsImRldmljZUV4dFkiLCJpblBvaW50Iiwib3V0UG9pbnQiLCJGRExheW91dCIsInVzZVNtYXJ0SWRlYWxFZGdlTGVuZ3RoQ2FsY3VsYXRpb24iLCJncmF2aXR5Q29uc3RhbnQiLCJjb21wb3VuZEdyYXZpdHlDb25zdGFudCIsImdyYXZpdHlSYW5nZUZhY3RvciIsImNvbXBvdW5kR3Jhdml0eVJhbmdlRmFjdG9yIiwiZGlzcGxhY2VtZW50VGhyZXNob2xkUGVyTm9kZSIsImNvb2xpbmdGYWN0b3IiLCJpbml0aWFsQ29vbGluZ0ZhY3RvciIsInRvdGFsRGlzcGxhY2VtZW50Iiwib2xkVG90YWxEaXNwbGFjZW1lbnQiLCJtYXhJdGVyYXRpb25zIiwiYXJndW1lbnRzIiwidG90YWxJdGVyYXRpb25zIiwibm90QW5pbWF0ZWRJdGVyYXRpb25zIiwidXNlRlJHcmlkVmFyaWFudCIsImdyaWQiLCJjYWxjSWRlYWxFZGdlTGVuZ3RocyIsIm9yaWdpbmFsSWRlYWxMZW5ndGgiLCJsY2FEZXB0aCIsInNpemVPZlNvdXJjZUluTGNhIiwic2l6ZU9mVGFyZ2V0SW5MY2EiLCJpZGVhbExlbmd0aCIsImluaXRTcHJpbmdFbWJlZGRlciIsIm1heE5vZGVEaXNwbGFjZW1lbnQiLCJ0b3RhbERpc3BsYWNlbWVudFRocmVzaG9sZCIsInJlcHVsc2lvblJhbmdlIiwiY2FsY1JlcHVsc2lvblJhbmdlIiwiY2FsY1NwcmluZ0ZvcmNlcyIsImxFZGdlcyIsImNhbGNTcHJpbmdGb3JjZSIsImNhbGNSZXB1bHNpb25Gb3JjZXMiLCJncmlkVXBkYXRlQWxsb3dlZCIsImZvcmNlVG9Ob2RlU3Vycm91bmRpbmdVcGRhdGUiLCJqIiwibm9kZUEiLCJub2RlQiIsImxOb2RlcyIsInByb2Nlc3NlZE5vZGVTZXQiLCJ1cGRhdGVHcmlkIiwiY2FsY3VsYXRlUmVwdWxzaW9uRm9yY2VPZkFOb2RlIiwiY2FsY1JlcHVsc2lvbkZvcmNlIiwiY2FsY0dyYXZpdGF0aW9uYWxGb3JjZXMiLCJjYWxjR3Jhdml0YXRpb25hbEZvcmNlIiwibW92ZU5vZGVzIiwic3ByaW5nRm9yY2UiLCJzcHJpbmdGb3JjZVgiLCJzcHJpbmdGb3JjZVkiLCJlZGdlRWxhc3RpY2l0eSIsImNsaXBQb2ludHMiLCJkaXN0YW5jZVgiLCJkaXN0YW5jZVkiLCJkaXN0YW5jZVNxdWFyZWQiLCJkaXN0YW5jZSIsInJlcHVsc2lvbkZvcmNlIiwicmVwdWxzaW9uRm9yY2VYIiwicmVwdWxzaW9uRm9yY2VZIiwiY2hpbGRyZW5Db25zdGFudCIsIm5vZGVSZXB1bHNpb24iLCJvd25lckNlbnRlclgiLCJvd25lckNlbnRlclkiLCJhYnNEaXN0YW5jZVgiLCJhYnNEaXN0YW5jZVkiLCJncmF2aXRhdGlvbkZvcmNlWCIsImdyYXZpdGF0aW9uRm9yY2VZIiwiaXNDb252ZXJnZWQiLCJjb252ZXJnZWQiLCJvc2NpbGF0aW5nIiwiYW5pbWF0ZSIsImNhbGNOb09mQ2hpbGRyZW5Gb3JBbGxOb2RlcyIsImNhbGNHcmlkIiwic2l6ZVgiLCJzaXplWSIsImFkZE5vZGVUb0dyaWQiLCJzdGFydFgiLCJmaW5pc2hYIiwic3RhcnRZIiwiZmluaXNoWSIsInNldEdyaWRDb29yZGluYXRlcyIsInN1cnJvdW5kaW5nIiwiRkRMYXlvdXRFZGdlIiwiRkRMYXlvdXROb2RlIiwiZGlzcGxhY2VtZW50WCIsImRpc3BsYWNlbWVudFkiLCJfc3RhcnRYIiwiX2ZpbmlzaFgiLCJfc3RhcnRZIiwiX2ZpbmlzaFkiLCJIYXNoTWFwIiwibWFwIiwicHV0IiwidGhlSWQiLCJjb250YWlucyIsImtleVNldCIsIkhhc2hTZXQiLCJjbGVhciIsImlzRW1wdHkiLCJhZGRBbGxUbyIsImFkZEFsbCIsIk1hdHJpeCIsIm11bHRNYXQiLCJhcnJheTEiLCJhcnJheTIiLCJ0cmFuc3Bvc2UiLCJhcnJheSIsIm11bHRDb25zIiwiY29uc3RhbnQiLCJtaW51c09wIiwiZG90UHJvZHVjdCIsInByb2R1Y3QiLCJtYWciLCJub3JtYWxpemUiLCJtYWduaXR1ZGUiLCJtdWx0R2FtbWEiLCJzdW0iLCJfaSIsIm11bHRMIiwiQyIsIklOViIsInRlbXAxIiwidGVtcDIiLCJfaTIiLCJfc3VtIiwiX2oiLCJfaTMiLCJfc3VtMiIsIl9qMiIsIlF1aWNrc29ydCIsIkEiLCJjb21wYXJlRnVuY3Rpb24iLCJfZGVmYXVsdENvbXBhcmVGdW5jdGlvbiIsIl9xdWlja3NvcnQiLCJfcGFydGl0aW9uIiwiX2dldCIsIl9zd2FwIiwiX3NldCIsIlNWRCIsInN2ZCIsIlUiLCJWIiwibnUiLCJkaW1zIiwiYWxsb2NhdGUiLCJlIiwid29yayIsIndhbnR1Iiwid2FudHYiLCJuY3QiLCJucnQiLCJoeXBvdCIsImxocyIsInJocyIsInQiLCJfaTQiLCJfaTUiLCJfaTYiLCJfaTciLCJfaTgiLCJfdCIsIl9pOSIsIl9pMTAiLCJfajMiLCJfaTExIiwiX2siLCJfajQiLCJfdDIiLCJfaTEyIiwiX2kxMyIsIl9pMTQiLCJfaTE1IiwiX2kxNiIsIl9rMiIsIl9qNSIsIl90MyIsIl9pMTciLCJfaTE4IiwiX2kxOSIsInBwIiwiaXRlciIsImVwcyIsInBvdyIsInRpbnkiLCJfazMiLCJrYXNlIiwia3MiLCJfdDQiLCJmIiwiX2o2IiwiX3Q1IiwiY3MiLCJzbiIsIl9pMjAiLCJfZiIsIl9qNyIsIl90NiIsIl9jcyIsIl9zbiIsIl9pMjEiLCJzY2FsZSIsInNwIiwic3BtMSIsImVwbTEiLCJzayIsImVrIiwiX2YyIiwiZyIsIl9qOCIsIl90NyIsIl9jczIiLCJfc24yIiwiX2kyMiIsIl9pMjMiLCJfaTI0IiwiX3Q4IiwiX2kyNSIsIl9pMjYiLCJTIiwiTmVlZGxlbWFuV3Vuc2NoIiwic2VxdWVuY2UxIiwic2VxdWVuY2UyIiwibWF0Y2hfc2NvcmUiLCJtaXNtYXRjaF9wZW5hbHR5IiwiZ2FwX3BlbmFsdHkiLCJpTWF4Iiwiak1heCIsInRyYWNlYmFja0dyaWQiLCJhbGlnbm1lbnRzIiwic2NvcmUiLCJjb21wdXRlR3JpZHMiLCJnZXRTY29yZSIsImdldEFsaWdubWVudHMiLCJkaWFnIiwidXAiLCJtYXhPZiIsImluZGljZXMiLCJhcnJheUFsbE1heEluZGV4ZXMiLCJpbmNsdWRlcyIsImFsaWdubWVudFRyYWNlYmFjayIsImluUHJvY2Vzc0FsaWdubWVudHMiLCJwb3MiLCJzZXExIiwic2VxMiIsImdldEFsbEluZGV4ZXMiLCJpbmRleGVzIiwiYXBwbHkiLCJsYXlvdXRCYXNlIiwibGlzdGVuZXJzIiwiYWRkTGlzdGVuZXIiLCJldmVudCIsImNhbGxiYWNrIiwicmVtb3ZlTGlzdGVuZXIiLCJlbWl0IiwiZGF0YSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cytoscape-fcose/node_modules/layout-base/layout-base.js\n");

/***/ })

};
;