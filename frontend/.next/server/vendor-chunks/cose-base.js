"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/cose-base";
exports.ids = ["vendor-chunks/cose-base"];
exports.modules = {

/***/ "(ssr)/./node_modules/cose-base/cose-base.js":
/*!*********************************************!*\
  !*** ./node_modules/cose-base/cose-base.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n(function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory(__webpack_require__(/*! layout-base */ \"(ssr)/./node_modules/layout-base/layout-base.js\"));\n    else {}\n})(void 0, function(__WEBPACK_EXTERNAL_MODULE_0__) {\n    return /******/ function(modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_691__(moduleId) {\n            /******/ /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_691__);\n            /******/ /******/ // Flag the module as loaded\n            /******/ module1.l = true;\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n        /******/ __nested_webpack_require_691__.m = modules;\n        /******/ /******/ // expose the module cache\n        /******/ __nested_webpack_require_691__.c = installedModules;\n        /******/ /******/ // identity function for calling harmony imports with the correct context\n        /******/ __nested_webpack_require_691__.i = function(value) {\n            return value;\n        };\n        /******/ /******/ // define getter function for harmony exports\n        /******/ __nested_webpack_require_691__.d = function(exports1, name, getter) {\n            /******/ if (!__nested_webpack_require_691__.o(exports1, name)) {\n                /******/ Object.defineProperty(exports1, name, {\n                    /******/ configurable: false,\n                    /******/ enumerable: true,\n                    /******/ get: getter\n                });\n            /******/ }\n        /******/ };\n        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __nested_webpack_require_691__.n = function(module1) {\n            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {\n                return module1[\"default\"];\n            } : /******/ function getModuleExports() {\n                return module1;\n            };\n            /******/ __nested_webpack_require_691__.d(getter, \"a\", getter);\n            /******/ return getter;\n        /******/ };\n        /******/ /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __nested_webpack_require_691__.o = function(object, property) {\n            return Object.prototype.hasOwnProperty.call(object, property);\n        };\n        /******/ /******/ // __webpack_public_path__\n        /******/ __nested_webpack_require_691__.p = \"\";\n        /******/ /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_691__(__nested_webpack_require_691__.s = 7);\n    /******/ }([\n        /* 0 */ /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n        /***/ },\n        /* 1 */ /***/ function(module1, exports1, __nested_webpack_require_3704__) {\n            \"use strict\";\n            var FDLayoutConstants = __nested_webpack_require_3704__(0).FDLayoutConstants;\n            function CoSEConstants() {}\n            //CoSEConstants inherits static props in FDLayoutConstants\n            for(var prop in FDLayoutConstants){\n                CoSEConstants[prop] = FDLayoutConstants[prop];\n            }\n            CoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;\n            CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n            CoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;\n            CoSEConstants.TILE = true;\n            CoSEConstants.TILING_PADDING_VERTICAL = 10;\n            CoSEConstants.TILING_PADDING_HORIZONTAL = 10;\n            CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false; // make this true when cose is used incrementally as a part of other non-incremental layout\n            module1.exports = CoSEConstants;\n        /***/ },\n        /* 2 */ /***/ function(module1, exports1, __nested_webpack_require_4710__) {\n            \"use strict\";\n            var FDLayoutEdge = __nested_webpack_require_4710__(0).FDLayoutEdge;\n            function CoSEEdge(source, target, vEdge) {\n                FDLayoutEdge.call(this, source, target, vEdge);\n            }\n            CoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);\n            for(var prop in FDLayoutEdge){\n                CoSEEdge[prop] = FDLayoutEdge[prop];\n            }\n            module1.exports = CoSEEdge;\n        /***/ },\n        /* 3 */ /***/ function(module1, exports1, __nested_webpack_require_5249__) {\n            \"use strict\";\n            var LGraph = __nested_webpack_require_5249__(0).LGraph;\n            function CoSEGraph(parent, graphMgr, vGraph) {\n                LGraph.call(this, parent, graphMgr, vGraph);\n            }\n            CoSEGraph.prototype = Object.create(LGraph.prototype);\n            for(var prop in LGraph){\n                CoSEGraph[prop] = LGraph[prop];\n            }\n            module1.exports = CoSEGraph;\n        /***/ },\n        /* 4 */ /***/ function(module1, exports1, __nested_webpack_require_5762__) {\n            \"use strict\";\n            var LGraphManager = __nested_webpack_require_5762__(0).LGraphManager;\n            function CoSEGraphManager(layout) {\n                LGraphManager.call(this, layout);\n            }\n            CoSEGraphManager.prototype = Object.create(LGraphManager.prototype);\n            for(var prop in LGraphManager){\n                CoSEGraphManager[prop] = LGraphManager[prop];\n            }\n            module1.exports = CoSEGraphManager;\n        /***/ },\n        /* 5 */ /***/ function(module1, exports1, __nested_webpack_require_6309__) {\n            \"use strict\";\n            var FDLayoutNode = __nested_webpack_require_6309__(0).FDLayoutNode;\n            var IMath = __nested_webpack_require_6309__(0).IMath;\n            function CoSENode(gm, loc, size, vNode) {\n                FDLayoutNode.call(this, gm, loc, size, vNode);\n            }\n            CoSENode.prototype = Object.create(FDLayoutNode.prototype);\n            for(var prop in FDLayoutNode){\n                CoSENode[prop] = FDLayoutNode[prop];\n            }\n            CoSENode.prototype.move = function() {\n                var layout = this.graphManager.getLayout();\n                this.displacementX = layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;\n                this.displacementY = layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;\n                if (Math.abs(this.displacementX) > layout.coolingFactor * layout.maxNodeDisplacement) {\n                    this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);\n                }\n                if (Math.abs(this.displacementY) > layout.coolingFactor * layout.maxNodeDisplacement) {\n                    this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);\n                }\n                // a simple node, just move it\n                if (this.child == null) {\n                    this.moveBy(this.displacementX, this.displacementY);\n                } else if (this.child.getNodes().length == 0) {\n                    this.moveBy(this.displacementX, this.displacementY);\n                } else {\n                    this.propogateDisplacementToChildren(this.displacementX, this.displacementY);\n                }\n                layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);\n                this.springForceX = 0;\n                this.springForceY = 0;\n                this.repulsionForceX = 0;\n                this.repulsionForceY = 0;\n                this.gravitationForceX = 0;\n                this.gravitationForceY = 0;\n                this.displacementX = 0;\n                this.displacementY = 0;\n            };\n            CoSENode.prototype.propogateDisplacementToChildren = function(dX, dY) {\n                var nodes = this.getChild().getNodes();\n                var node;\n                for(var i = 0; i < nodes.length; i++){\n                    node = nodes[i];\n                    if (node.getChild() == null) {\n                        node.moveBy(dX, dY);\n                        node.displacementX += dX;\n                        node.displacementY += dY;\n                    } else {\n                        node.propogateDisplacementToChildren(dX, dY);\n                    }\n                }\n            };\n            CoSENode.prototype.setPred1 = function(pred11) {\n                this.pred1 = pred11;\n            };\n            CoSENode.prototype.getPred1 = function() {\n                return pred1;\n            };\n            CoSENode.prototype.getPred2 = function() {\n                return pred2;\n            };\n            CoSENode.prototype.setNext = function(next1) {\n                this.next = next1;\n            };\n            CoSENode.prototype.getNext = function() {\n                return next;\n            };\n            CoSENode.prototype.setProcessed = function(processed1) {\n                this.processed = processed1;\n            };\n            CoSENode.prototype.isProcessed = function() {\n                return processed;\n            };\n            module1.exports = CoSENode;\n        /***/ },\n        /* 6 */ /***/ function(module1, exports1, __nested_webpack_require_10057__) {\n            \"use strict\";\n            var FDLayout = __nested_webpack_require_10057__(0).FDLayout;\n            var CoSEGraphManager = __nested_webpack_require_10057__(4);\n            var CoSEGraph = __nested_webpack_require_10057__(3);\n            var CoSENode = __nested_webpack_require_10057__(5);\n            var CoSEEdge = __nested_webpack_require_10057__(2);\n            var CoSEConstants = __nested_webpack_require_10057__(1);\n            var FDLayoutConstants = __nested_webpack_require_10057__(0).FDLayoutConstants;\n            var LayoutConstants = __nested_webpack_require_10057__(0).LayoutConstants;\n            var Point = __nested_webpack_require_10057__(0).Point;\n            var PointD = __nested_webpack_require_10057__(0).PointD;\n            var Layout = __nested_webpack_require_10057__(0).Layout;\n            var Integer = __nested_webpack_require_10057__(0).Integer;\n            var IGeometry = __nested_webpack_require_10057__(0).IGeometry;\n            var LGraph = __nested_webpack_require_10057__(0).LGraph;\n            var Transform = __nested_webpack_require_10057__(0).Transform;\n            function CoSELayout() {\n                FDLayout.call(this);\n                this.toBeTiled = {}; // Memorize if a node is to be tiled or is tiled\n            }\n            CoSELayout.prototype = Object.create(FDLayout.prototype);\n            for(var prop in FDLayout){\n                CoSELayout[prop] = FDLayout[prop];\n            }\n            CoSELayout.prototype.newGraphManager = function() {\n                var gm = new CoSEGraphManager(this);\n                this.graphManager = gm;\n                return gm;\n            };\n            CoSELayout.prototype.newGraph = function(vGraph) {\n                return new CoSEGraph(null, this.graphManager, vGraph);\n            };\n            CoSELayout.prototype.newNode = function(vNode) {\n                return new CoSENode(this.graphManager, vNode);\n            };\n            CoSELayout.prototype.newEdge = function(vEdge) {\n                return new CoSEEdge(null, null, vEdge);\n            };\n            CoSELayout.prototype.initParameters = function() {\n                FDLayout.prototype.initParameters.call(this, arguments);\n                if (!this.isSubLayout) {\n                    if (CoSEConstants.DEFAULT_EDGE_LENGTH < 10) {\n                        this.idealEdgeLength = 10;\n                    } else {\n                        this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;\n                    }\n                    this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n                    this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n                    this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n                    this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n                    this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n                    this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n                    this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n                    // variables for tree reduction support\n                    this.prunedNodesAll = [];\n                    this.growTreeIterations = 0;\n                    this.afterGrowthIterations = 0;\n                    this.isTreeGrowing = false;\n                    this.isGrowthFinished = false;\n                    // variables for cooling\n                    this.coolingCycle = 0;\n                    this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;\n                    this.finalTemperature = FDLayoutConstants.CONVERGENCE_CHECK_PERIOD / this.maxIterations;\n                    this.coolingAdjuster = 1;\n                }\n            };\n            CoSELayout.prototype.layout = function() {\n                var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n                if (createBendsAsNeeded) {\n                    this.createBendpoints();\n                    this.graphManager.resetAllEdges();\n                }\n                this.level = 0;\n                return this.classicLayout();\n            };\n            CoSELayout.prototype.classicLayout = function() {\n                this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();\n                this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);\n                this.calcNoOfChildrenForAllNodes();\n                this.graphManager.calcLowestCommonAncestors();\n                this.graphManager.calcInclusionTreeDepths();\n                this.graphManager.getRoot().calcEstimatedSize();\n                this.calcIdealEdgeLengths();\n                if (!this.incremental) {\n                    var forest = this.getFlatForest();\n                    // The graph associated with this layout is flat and a forest\n                    if (forest.length > 0) {\n                        this.positionNodesRadially(forest);\n                    } else {\n                        // Reduce the trees when incremental mode is not enabled and graph is not a forest \n                        this.reduceTrees();\n                        // Update nodes that gravity will be applied\n                        this.graphManager.resetAllNodesToApplyGravitation();\n                        var allNodes = new Set(this.getAllNodes());\n                        var intersection = this.nodesWithGravity.filter(function(x) {\n                            return allNodes.has(x);\n                        });\n                        this.graphManager.setAllNodesToApplyGravitation(intersection);\n                        this.positionNodesRandomly();\n                    }\n                } else {\n                    if (CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL) {\n                        // Reduce the trees in incremental mode if only this constant is set to true \n                        this.reduceTrees();\n                        // Update nodes that gravity will be applied\n                        this.graphManager.resetAllNodesToApplyGravitation();\n                        var allNodes = new Set(this.getAllNodes());\n                        var intersection = this.nodesWithGravity.filter(function(x) {\n                            return allNodes.has(x);\n                        });\n                        this.graphManager.setAllNodesToApplyGravitation(intersection);\n                    }\n                }\n                this.initSpringEmbedder();\n                this.runSpringEmbedder();\n                return true;\n            };\n            CoSELayout.prototype.tick = function() {\n                this.totalIterations++;\n                if (this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) {\n                    if (this.prunedNodesAll.length > 0) {\n                        this.isTreeGrowing = true;\n                    } else {\n                        return true;\n                    }\n                }\n                if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {\n                    if (this.isConverged()) {\n                        if (this.prunedNodesAll.length > 0) {\n                            this.isTreeGrowing = true;\n                        } else {\n                            return true;\n                        }\n                    }\n                    this.coolingCycle++;\n                    if (this.layoutQuality == 0) {\n                        // quality - \"draft\"\n                        this.coolingAdjuster = this.coolingCycle;\n                    } else if (this.layoutQuality == 1) {\n                        // quality - \"default\"\n                        this.coolingAdjuster = this.coolingCycle / 3;\n                    }\n                    // cooling schedule is based on http://www.btluke.com/simanf1.html -> cooling schedule 3\n                    this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);\n                    this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));\n                }\n                // Operations while tree is growing again \n                if (this.isTreeGrowing) {\n                    if (this.growTreeIterations % 10 == 0) {\n                        if (this.prunedNodesAll.length > 0) {\n                            this.graphManager.updateBounds();\n                            this.updateGrid();\n                            this.growTree(this.prunedNodesAll);\n                            // Update nodes that gravity will be applied\n                            this.graphManager.resetAllNodesToApplyGravitation();\n                            var allNodes = new Set(this.getAllNodes());\n                            var intersection = this.nodesWithGravity.filter(function(x) {\n                                return allNodes.has(x);\n                            });\n                            this.graphManager.setAllNodesToApplyGravitation(intersection);\n                            this.graphManager.updateBounds();\n                            this.updateGrid();\n                            this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n                        } else {\n                            this.isTreeGrowing = false;\n                            this.isGrowthFinished = true;\n                        }\n                    }\n                    this.growTreeIterations++;\n                }\n                // Operations after growth is finished\n                if (this.isGrowthFinished) {\n                    if (this.isConverged()) {\n                        return true;\n                    }\n                    if (this.afterGrowthIterations % 10 == 0) {\n                        this.graphManager.updateBounds();\n                        this.updateGrid();\n                    }\n                    this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);\n                    this.afterGrowthIterations++;\n                }\n                var gridUpdateAllowed = !this.isTreeGrowing && !this.isGrowthFinished;\n                var forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;\n                this.totalDisplacement = 0;\n                this.graphManager.updateBounds();\n                this.calcSpringForces();\n                this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);\n                this.calcGravitationalForces();\n                this.moveNodes();\n                this.animate();\n                return false; // Layout is not ended yet return false\n            };\n            CoSELayout.prototype.getPositionsData = function() {\n                var allNodes = this.graphManager.getAllNodes();\n                var pData = {};\n                for(var i = 0; i < allNodes.length; i++){\n                    var rect = allNodes[i].rect;\n                    var id = allNodes[i].id;\n                    pData[id] = {\n                        id: id,\n                        x: rect.getCenterX(),\n                        y: rect.getCenterY(),\n                        w: rect.width,\n                        h: rect.height\n                    };\n                }\n                return pData;\n            };\n            CoSELayout.prototype.runSpringEmbedder = function() {\n                this.initialAnimationPeriod = 25;\n                this.animationPeriod = this.initialAnimationPeriod;\n                var layoutEnded = false;\n                // If aminate option is 'during' signal that layout is supposed to start iterating\n                if (FDLayoutConstants.ANIMATE === \"during\") {\n                    this.emit(\"layoutstarted\");\n                } else {\n                    // If aminate option is 'during' tick() function will be called on index.js\n                    while(!layoutEnded){\n                        layoutEnded = this.tick();\n                    }\n                    this.graphManager.updateBounds();\n                }\n            };\n            CoSELayout.prototype.calculateNodesToApplyGravitationTo = function() {\n                var nodeList = [];\n                var graph;\n                var graphs = this.graphManager.getGraphs();\n                var size = graphs.length;\n                var i;\n                for(i = 0; i < size; i++){\n                    graph = graphs[i];\n                    graph.updateConnected();\n                    if (!graph.isConnected) {\n                        nodeList = nodeList.concat(graph.getNodes());\n                    }\n                }\n                return nodeList;\n            };\n            CoSELayout.prototype.createBendpoints = function() {\n                var edges = [];\n                edges = edges.concat(this.graphManager.getAllEdges());\n                var visited = new Set();\n                var i;\n                for(i = 0; i < edges.length; i++){\n                    var edge = edges[i];\n                    if (!visited.has(edge)) {\n                        var source = edge.getSource();\n                        var target = edge.getTarget();\n                        if (source == target) {\n                            edge.getBendpoints().push(new PointD());\n                            edge.getBendpoints().push(new PointD());\n                            this.createDummyNodesForBendpoints(edge);\n                            visited.add(edge);\n                        } else {\n                            var edgeList = [];\n                            edgeList = edgeList.concat(source.getEdgeListToNode(target));\n                            edgeList = edgeList.concat(target.getEdgeListToNode(source));\n                            if (!visited.has(edgeList[0])) {\n                                if (edgeList.length > 1) {\n                                    var k;\n                                    for(k = 0; k < edgeList.length; k++){\n                                        var multiEdge = edgeList[k];\n                                        multiEdge.getBendpoints().push(new PointD());\n                                        this.createDummyNodesForBendpoints(multiEdge);\n                                    }\n                                }\n                                edgeList.forEach(function(edge) {\n                                    visited.add(edge);\n                                });\n                            }\n                        }\n                    }\n                    if (visited.size == edges.length) {\n                        break;\n                    }\n                }\n            };\n            CoSELayout.prototype.positionNodesRadially = function(forest) {\n                // We tile the trees to a grid row by row; first tree starts at (0,0)\n                var currentStartingPoint = new Point(0, 0);\n                var numberOfColumns = Math.ceil(Math.sqrt(forest.length));\n                var height = 0;\n                var currentY = 0;\n                var currentX = 0;\n                var point = new PointD(0, 0);\n                for(var i = 0; i < forest.length; i++){\n                    if (i % numberOfColumns == 0) {\n                        // Start of a new row, make the x coordinate 0, increment the\n                        // y coordinate with the max height of the previous row\n                        currentX = 0;\n                        currentY = height;\n                        if (i != 0) {\n                            currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;\n                        }\n                        height = 0;\n                    }\n                    var tree = forest[i];\n                    // Find the center of the tree\n                    var centerNode = Layout.findCenterOfTree(tree);\n                    // Set the staring point of the next tree\n                    currentStartingPoint.x = currentX;\n                    currentStartingPoint.y = currentY;\n                    // Do a radial layout starting with the center\n                    point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);\n                    if (point.y > height) {\n                        height = Math.floor(point.y);\n                    }\n                    currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);\n                }\n                this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));\n            };\n            CoSELayout.radialLayout = function(tree, centerNode, startingPoint) {\n                var radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);\n                CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);\n                var bounds = LGraph.calculateBounds(tree);\n                var transform = new Transform();\n                transform.setDeviceOrgX(bounds.getMinX());\n                transform.setDeviceOrgY(bounds.getMinY());\n                transform.setWorldOrgX(startingPoint.x);\n                transform.setWorldOrgY(startingPoint.y);\n                for(var i = 0; i < tree.length; i++){\n                    var node = tree[i];\n                    node.transform(transform);\n                }\n                var bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());\n                return transform.inverseTransformPoint(bottomRight);\n            };\n            CoSELayout.branchRadialLayout = function(node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {\n                // First, position this node by finding its angle.\n                var halfInterval = (endAngle - startAngle + 1) / 2;\n                if (halfInterval < 0) {\n                    halfInterval += 180;\n                }\n                var nodeAngle = (halfInterval + startAngle) % 360;\n                var teta = nodeAngle * IGeometry.TWO_PI / 360;\n                // Make polar to java cordinate conversion.\n                var cos_teta = Math.cos(teta);\n                var x_ = distance * Math.cos(teta);\n                var y_ = distance * Math.sin(teta);\n                node.setCenter(x_, y_);\n                // Traverse all neighbors of this node and recursively call this\n                // function.\n                var neighborEdges = [];\n                neighborEdges = neighborEdges.concat(node.getEdges());\n                var childCount = neighborEdges.length;\n                if (parentOfNode != null) {\n                    childCount--;\n                }\n                var branchCount = 0;\n                var incEdgesCount = neighborEdges.length;\n                var startIndex;\n                var edges = node.getEdgesBetween(parentOfNode);\n                // If there are multiple edges, prune them until there remains only one\n                // edge.\n                while(edges.length > 1){\n                    //neighborEdges.remove(edges.remove(0));\n                    var temp = edges[0];\n                    edges.splice(0, 1);\n                    var index = neighborEdges.indexOf(temp);\n                    if (index >= 0) {\n                        neighborEdges.splice(index, 1);\n                    }\n                    incEdgesCount--;\n                    childCount--;\n                }\n                if (parentOfNode != null) {\n                    //assert edges.length == 1;\n                    startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;\n                } else {\n                    startIndex = 0;\n                }\n                var stepAngle = Math.abs(endAngle - startAngle) / childCount;\n                for(var i = startIndex; branchCount != childCount; i = ++i % incEdgesCount){\n                    var currentNeighbor = neighborEdges[i].getOtherEnd(node);\n                    // Don't back traverse to root node in current tree.\n                    if (currentNeighbor == parentOfNode) {\n                        continue;\n                    }\n                    var childStartAngle = (startAngle + branchCount * stepAngle) % 360;\n                    var childEndAngle = (childStartAngle + stepAngle) % 360;\n                    CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);\n                    branchCount++;\n                }\n            };\n            CoSELayout.maxDiagonalInTree = function(tree) {\n                var maxDiagonal = Integer.MIN_VALUE;\n                for(var i = 0; i < tree.length; i++){\n                    var node = tree[i];\n                    var diagonal = node.getDiagonal();\n                    if (diagonal > maxDiagonal) {\n                        maxDiagonal = diagonal;\n                    }\n                }\n                return maxDiagonal;\n            };\n            CoSELayout.prototype.calcRepulsionRange = function() {\n                // formula is 2 x (level + 1) x idealEdgeLength\n                return 2 * (this.level + 1) * this.idealEdgeLength;\n            };\n            // Tiling methods\n            // Group zero degree members whose parents are not to be tiled, create dummy parents where needed and fill memberGroups by their dummp parent id's\n            CoSELayout.prototype.groupZeroDegreeMembers = function() {\n                var self = this;\n                // array of [parent_id x oneDegreeNode_id]\n                var tempMemberGroups = {}; // A temporary map of parent node and its zero degree members\n                this.memberGroups = {}; // A map of dummy parent node and its zero degree members whose parents are not to be tiled\n                this.idToDummyNode = {}; // A map of id to dummy node \n                var zeroDegree = []; // List of zero degree nodes whose parents are not to be tiled\n                var allNodes = this.graphManager.getAllNodes();\n                // Fill zero degree list\n                for(var i = 0; i < allNodes.length; i++){\n                    var node = allNodes[i];\n                    var parent = node.getParent();\n                    // If a node has zero degree and its parent is not to be tiled if exists add that node to zeroDegres list\n                    if (this.getNodeDegreeWithChildren(node) === 0 && (parent.id == undefined || !this.getToBeTiled(parent))) {\n                        zeroDegree.push(node);\n                    }\n                }\n                // Create a map of parent node and its zero degree members\n                for(var i = 0; i < zeroDegree.length; i++){\n                    var node = zeroDegree[i]; // Zero degree node itself\n                    var p_id = node.getParent().id; // Parent id\n                    if (typeof tempMemberGroups[p_id] === \"undefined\") tempMemberGroups[p_id] = [];\n                    tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node); // Push node to the list belongs to its parent in tempMemberGroups\n                }\n                // If there are at least two nodes at a level, create a dummy compound for them\n                Object.keys(tempMemberGroups).forEach(function(p_id) {\n                    if (tempMemberGroups[p_id].length > 1) {\n                        var dummyCompoundId = \"DummyCompound_\" + p_id; // The id of dummy compound which will be created soon\n                        self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id]; // Add dummy compound to memberGroups\n                        var parent = tempMemberGroups[p_id][0].getParent(); // The parent of zero degree nodes will be the parent of new dummy compound\n                        // Create a dummy compound with calculated id\n                        var dummyCompound = new CoSENode(self.graphManager);\n                        dummyCompound.id = dummyCompoundId;\n                        dummyCompound.paddingLeft = parent.paddingLeft || 0;\n                        dummyCompound.paddingRight = parent.paddingRight || 0;\n                        dummyCompound.paddingBottom = parent.paddingBottom || 0;\n                        dummyCompound.paddingTop = parent.paddingTop || 0;\n                        self.idToDummyNode[dummyCompoundId] = dummyCompound;\n                        var dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);\n                        var parentGraph = parent.getChild();\n                        // Add dummy compound to parent the graph\n                        parentGraph.add(dummyCompound);\n                        // For each zero degree node in this level remove it from its parent graph and add it to the graph of dummy parent\n                        for(var i = 0; i < tempMemberGroups[p_id].length; i++){\n                            var node = tempMemberGroups[p_id][i];\n                            parentGraph.remove(node);\n                            dummyParentGraph.add(node);\n                        }\n                    }\n                });\n            };\n            CoSELayout.prototype.clearCompounds = function() {\n                var childGraphMap = {};\n                var idToNode = {};\n                // Get compound ordering by finding the inner one first\n                this.performDFSOnCompounds();\n                for(var i = 0; i < this.compoundOrder.length; i++){\n                    idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];\n                    childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes());\n                    // Remove children of compounds\n                    this.graphManager.remove(this.compoundOrder[i].getChild());\n                    this.compoundOrder[i].child = null;\n                }\n                this.graphManager.resetAllNodes();\n                // Tile the removed children\n                this.tileCompoundMembers(childGraphMap, idToNode);\n            };\n            CoSELayout.prototype.clearZeroDegreeMembers = function() {\n                var self = this;\n                var tiledZeroDegreePack = this.tiledZeroDegreePack = [];\n                Object.keys(this.memberGroups).forEach(function(id) {\n                    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound\n                    tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n                    // Set the width and height of the dummy compound as calculated\n                    compoundNode.rect.width = tiledZeroDegreePack[id].width;\n                    compoundNode.rect.height = tiledZeroDegreePack[id].height;\n                });\n            };\n            CoSELayout.prototype.repopulateCompounds = function() {\n                for(var i = this.compoundOrder.length - 1; i >= 0; i--){\n                    var lCompoundNode = this.compoundOrder[i];\n                    var id = lCompoundNode.id;\n                    var horizontalMargin = lCompoundNode.paddingLeft;\n                    var verticalMargin = lCompoundNode.paddingTop;\n                    this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin);\n                }\n            };\n            CoSELayout.prototype.repopulateZeroDegreeMembers = function() {\n                var self = this;\n                var tiledPack = this.tiledZeroDegreePack;\n                Object.keys(tiledPack).forEach(function(id) {\n                    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound by its id\n                    var horizontalMargin = compoundNode.paddingLeft;\n                    var verticalMargin = compoundNode.paddingTop;\n                    // Adjust the positions of nodes wrt its compound\n                    self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin);\n                });\n            };\n            CoSELayout.prototype.getToBeTiled = function(node) {\n                var id = node.id;\n                //firstly check the previous results\n                if (this.toBeTiled[id] != null) {\n                    return this.toBeTiled[id];\n                }\n                //only compound nodes are to be tiled\n                var childGraph = node.getChild();\n                if (childGraph == null) {\n                    this.toBeTiled[id] = false;\n                    return false;\n                }\n                var children = childGraph.getNodes(); // Get the children nodes\n                //a compound node is not to be tiled if all of its compound children are not to be tiled\n                for(var i = 0; i < children.length; i++){\n                    var theChild = children[i];\n                    if (this.getNodeDegree(theChild) > 0) {\n                        this.toBeTiled[id] = false;\n                        return false;\n                    }\n                    //pass the children not having the compound structure\n                    if (theChild.getChild() == null) {\n                        this.toBeTiled[theChild.id] = false;\n                        continue;\n                    }\n                    if (!this.getToBeTiled(theChild)) {\n                        this.toBeTiled[id] = false;\n                        return false;\n                    }\n                }\n                this.toBeTiled[id] = true;\n                return true;\n            };\n            // Get degree of a node depending of its edges and independent of its children\n            CoSELayout.prototype.getNodeDegree = function(node) {\n                var id = node.id;\n                var edges = node.getEdges();\n                var degree = 0;\n                // For the edges connected\n                for(var i = 0; i < edges.length; i++){\n                    var edge = edges[i];\n                    if (edge.getSource().id !== edge.getTarget().id) {\n                        degree = degree + 1;\n                    }\n                }\n                return degree;\n            };\n            // Get degree of a node with its children\n            CoSELayout.prototype.getNodeDegreeWithChildren = function(node) {\n                var degree = this.getNodeDegree(node);\n                if (node.getChild() == null) {\n                    return degree;\n                }\n                var children = node.getChild().getNodes();\n                for(var i = 0; i < children.length; i++){\n                    var child = children[i];\n                    degree += this.getNodeDegreeWithChildren(child);\n                }\n                return degree;\n            };\n            CoSELayout.prototype.performDFSOnCompounds = function() {\n                this.compoundOrder = [];\n                this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());\n            };\n            CoSELayout.prototype.fillCompexOrderByDFS = function(children) {\n                for(var i = 0; i < children.length; i++){\n                    var child = children[i];\n                    if (child.getChild() != null) {\n                        this.fillCompexOrderByDFS(child.getChild().getNodes());\n                    }\n                    if (this.getToBeTiled(child)) {\n                        this.compoundOrder.push(child);\n                    }\n                }\n            };\n            /**\n* This method places each zero degree member wrt given (x,y) coordinates (top left).\n*/ CoSELayout.prototype.adjustLocations = function(organization, x, y, compoundHorizontalMargin, compoundVerticalMargin) {\n                x += compoundHorizontalMargin;\n                y += compoundVerticalMargin;\n                var left = x;\n                for(var i = 0; i < organization.rows.length; i++){\n                    var row = organization.rows[i];\n                    x = left;\n                    var maxHeight = 0;\n                    for(var j = 0; j < row.length; j++){\n                        var lnode = row[j];\n                        lnode.rect.x = x; // + lnode.rect.width / 2;\n                        lnode.rect.y = y; // + lnode.rect.height / 2;\n                        x += lnode.rect.width + organization.horizontalPadding;\n                        if (lnode.rect.height > maxHeight) maxHeight = lnode.rect.height;\n                    }\n                    y += maxHeight + organization.verticalPadding;\n                }\n            };\n            CoSELayout.prototype.tileCompoundMembers = function(childGraphMap, idToNode) {\n                var self = this;\n                this.tiledMemberPack = [];\n                Object.keys(childGraphMap).forEach(function(id) {\n                    // Get the compound node\n                    var compoundNode = idToNode[id];\n                    self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n                    compoundNode.rect.width = self.tiledMemberPack[id].width;\n                    compoundNode.rect.height = self.tiledMemberPack[id].height;\n                });\n            };\n            CoSELayout.prototype.tileNodes = function(nodes, minWidth) {\n                var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n                var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n                var organization = {\n                    rows: [],\n                    rowWidth: [],\n                    rowHeight: [],\n                    width: 0,\n                    height: minWidth,\n                    verticalPadding: verticalPadding,\n                    horizontalPadding: horizontalPadding\n                };\n                // Sort the nodes in ascending order of their areas\n                nodes.sort(function(n1, n2) {\n                    if (n1.rect.width * n1.rect.height > n2.rect.width * n2.rect.height) return -1;\n                    if (n1.rect.width * n1.rect.height < n2.rect.width * n2.rect.height) return 1;\n                    return 0;\n                });\n                // Create the organization -> tile members\n                for(var i = 0; i < nodes.length; i++){\n                    var lNode = nodes[i];\n                    if (organization.rows.length == 0) {\n                        this.insertNodeToRow(organization, lNode, 0, minWidth);\n                    } else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {\n                        this.insertNodeToRow(organization, lNode, this.getShortestRowIndex(organization), minWidth);\n                    } else {\n                        this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);\n                    }\n                    this.shiftToLastRow(organization);\n                }\n                return organization;\n            };\n            CoSELayout.prototype.insertNodeToRow = function(organization, node, rowIndex, minWidth) {\n                var minCompoundSize = minWidth;\n                // Add new row if needed\n                if (rowIndex == organization.rows.length) {\n                    var secondDimension = [];\n                    organization.rows.push(secondDimension);\n                    organization.rowWidth.push(minCompoundSize);\n                    organization.rowHeight.push(0);\n                }\n                // Update row width\n                var w = organization.rowWidth[rowIndex] + node.rect.width;\n                if (organization.rows[rowIndex].length > 0) {\n                    w += organization.horizontalPadding;\n                }\n                organization.rowWidth[rowIndex] = w;\n                // Update compound width\n                if (organization.width < w) {\n                    organization.width = w;\n                }\n                // Update height\n                var h = node.rect.height;\n                if (rowIndex > 0) h += organization.verticalPadding;\n                var extraHeight = 0;\n                if (h > organization.rowHeight[rowIndex]) {\n                    extraHeight = organization.rowHeight[rowIndex];\n                    organization.rowHeight[rowIndex] = h;\n                    extraHeight = organization.rowHeight[rowIndex] - extraHeight;\n                }\n                organization.height += extraHeight;\n                // Insert node\n                organization.rows[rowIndex].push(node);\n            };\n            //Scans the rows of an organization and returns the one with the min width\n            CoSELayout.prototype.getShortestRowIndex = function(organization) {\n                var r = -1;\n                var min = Number.MAX_VALUE;\n                for(var i = 0; i < organization.rows.length; i++){\n                    if (organization.rowWidth[i] < min) {\n                        r = i;\n                        min = organization.rowWidth[i];\n                    }\n                }\n                return r;\n            };\n            //Scans the rows of an organization and returns the one with the max width\n            CoSELayout.prototype.getLongestRowIndex = function(organization) {\n                var r = -1;\n                var max = Number.MIN_VALUE;\n                for(var i = 0; i < organization.rows.length; i++){\n                    if (organization.rowWidth[i] > max) {\n                        r = i;\n                        max = organization.rowWidth[i];\n                    }\n                }\n                return r;\n            };\n            /**\n* This method checks whether adding extra width to the organization violates\n* the aspect ratio(1) or not.\n*/ CoSELayout.prototype.canAddHorizontal = function(organization, extraWidth, extraHeight) {\n                var sri = this.getShortestRowIndex(organization);\n                if (sri < 0) {\n                    return true;\n                }\n                var min = organization.rowWidth[sri];\n                if (min + organization.horizontalPadding + extraWidth <= organization.width) return true;\n                var hDiff = 0;\n                // Adding to an existing row\n                if (organization.rowHeight[sri] < extraHeight) {\n                    if (sri > 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];\n                }\n                var add_to_row_ratio;\n                if (organization.width - min >= extraWidth + organization.horizontalPadding) {\n                    add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);\n                } else {\n                    add_to_row_ratio = (organization.height + hDiff) / organization.width;\n                }\n                // Adding a new row for this node\n                hDiff = extraHeight + organization.verticalPadding;\n                var add_new_row_ratio;\n                if (organization.width < extraWidth) {\n                    add_new_row_ratio = (organization.height + hDiff) / extraWidth;\n                } else {\n                    add_new_row_ratio = (organization.height + hDiff) / organization.width;\n                }\n                if (add_new_row_ratio < 1) add_new_row_ratio = 1 / add_new_row_ratio;\n                if (add_to_row_ratio < 1) add_to_row_ratio = 1 / add_to_row_ratio;\n                return add_to_row_ratio < add_new_row_ratio;\n            };\n            //If moving the last node from the longest row and adding it to the last\n            //row makes the bounding box smaller, do it.\n            CoSELayout.prototype.shiftToLastRow = function(organization) {\n                var longest = this.getLongestRowIndex(organization);\n                var last = organization.rowWidth.length - 1;\n                var row = organization.rows[longest];\n                var node = row[row.length - 1];\n                var diff = node.width + organization.horizontalPadding;\n                // Check if there is enough space on the last row\n                if (organization.width - organization.rowWidth[last] > diff && longest != last) {\n                    // Remove the last element of the longest row\n                    row.splice(-1, 1);\n                    // Push it to the last row\n                    organization.rows[last].push(node);\n                    organization.rowWidth[longest] = organization.rowWidth[longest] - diff;\n                    organization.rowWidth[last] = organization.rowWidth[last] + diff;\n                    organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)];\n                    // Update heights of the organization\n                    var maxHeight = Number.MIN_VALUE;\n                    for(var i = 0; i < row.length; i++){\n                        if (row[i].height > maxHeight) maxHeight = row[i].height;\n                    }\n                    if (longest > 0) maxHeight += organization.verticalPadding;\n                    var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n                    organization.rowHeight[longest] = maxHeight;\n                    if (organization.rowHeight[last] < node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;\n                    var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n                    organization.height += finalTotal - prevTotal;\n                    this.shiftToLastRow(organization);\n                }\n            };\n            CoSELayout.prototype.tilingPreLayout = function() {\n                if (CoSEConstants.TILE) {\n                    // Find zero degree nodes and create a compound for each level\n                    this.groupZeroDegreeMembers();\n                    // Tile and clear children of each compound\n                    this.clearCompounds();\n                    // Separately tile and clear zero degree nodes for each level\n                    this.clearZeroDegreeMembers();\n                }\n            };\n            CoSELayout.prototype.tilingPostLayout = function() {\n                if (CoSEConstants.TILE) {\n                    this.repopulateZeroDegreeMembers();\n                    this.repopulateCompounds();\n                }\n            };\n            // -----------------------------------------------------------------------------\n            // Section: Tree Reduction methods\n            // -----------------------------------------------------------------------------\n            // Reduce trees \n            CoSELayout.prototype.reduceTrees = function() {\n                var prunedNodesAll = [];\n                var containsLeaf = true;\n                var node;\n                while(containsLeaf){\n                    var allNodes = this.graphManager.getAllNodes();\n                    var prunedNodesInStepTemp = [];\n                    containsLeaf = false;\n                    for(var i = 0; i < allNodes.length; i++){\n                        node = allNodes[i];\n                        if (node.getEdges().length == 1 && !node.getEdges()[0].isInterGraph && node.getChild() == null) {\n                            prunedNodesInStepTemp.push([\n                                node,\n                                node.getEdges()[0],\n                                node.getOwner()\n                            ]);\n                            containsLeaf = true;\n                        }\n                    }\n                    if (containsLeaf == true) {\n                        var prunedNodesInStep = [];\n                        for(var j = 0; j < prunedNodesInStepTemp.length; j++){\n                            if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {\n                                prunedNodesInStep.push(prunedNodesInStepTemp[j]);\n                                prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);\n                            }\n                        }\n                        prunedNodesAll.push(prunedNodesInStep);\n                        this.graphManager.resetAllNodes();\n                        this.graphManager.resetAllEdges();\n                    }\n                }\n                this.prunedNodesAll = prunedNodesAll;\n            };\n            // Grow tree one step \n            CoSELayout.prototype.growTree = function(prunedNodesAll) {\n                var lengthOfPrunedNodesInStep = prunedNodesAll.length;\n                var prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];\n                var nodeData;\n                for(var i = 0; i < prunedNodesInStep.length; i++){\n                    nodeData = prunedNodesInStep[i];\n                    this.findPlaceforPrunedNode(nodeData);\n                    nodeData[2].add(nodeData[0]);\n                    nodeData[2].add(nodeData[1], nodeData[1].source, nodeData[1].target);\n                }\n                prunedNodesAll.splice(prunedNodesAll.length - 1, 1);\n                this.graphManager.resetAllNodes();\n                this.graphManager.resetAllEdges();\n            };\n            // Find an appropriate position to replace pruned node, this method can be improved\n            CoSELayout.prototype.findPlaceforPrunedNode = function(nodeData) {\n                var gridForPrunedNode;\n                var nodeToConnect;\n                var prunedNode = nodeData[0];\n                if (prunedNode == nodeData[1].source) {\n                    nodeToConnect = nodeData[1].target;\n                } else {\n                    nodeToConnect = nodeData[1].source;\n                }\n                var startGridX = nodeToConnect.startX;\n                var finishGridX = nodeToConnect.finishX;\n                var startGridY = nodeToConnect.startY;\n                var finishGridY = nodeToConnect.finishY;\n                var upNodeCount = 0;\n                var downNodeCount = 0;\n                var rightNodeCount = 0;\n                var leftNodeCount = 0;\n                var controlRegions = [\n                    upNodeCount,\n                    rightNodeCount,\n                    downNodeCount,\n                    leftNodeCount\n                ];\n                if (startGridY > 0) {\n                    for(var i = startGridX; i <= finishGridX; i++){\n                        controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;\n                    }\n                }\n                if (finishGridX < this.grid.length - 1) {\n                    for(var i = startGridY; i <= finishGridY; i++){\n                        controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;\n                    }\n                }\n                if (finishGridY < this.grid[0].length - 1) {\n                    for(var i = startGridX; i <= finishGridX; i++){\n                        controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;\n                    }\n                }\n                if (startGridX > 0) {\n                    for(var i = startGridY; i <= finishGridY; i++){\n                        controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;\n                    }\n                }\n                var min = Integer.MAX_VALUE;\n                var minCount;\n                var minIndex;\n                for(var j = 0; j < controlRegions.length; j++){\n                    if (controlRegions[j] < min) {\n                        min = controlRegions[j];\n                        minCount = 1;\n                        minIndex = j;\n                    } else if (controlRegions[j] == min) {\n                        minCount++;\n                    }\n                }\n                if (minCount == 3 && min == 0) {\n                    if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[2] == 0) {\n                        gridForPrunedNode = 1;\n                    } else if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[3] == 0) {\n                        gridForPrunedNode = 0;\n                    } else if (controlRegions[0] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n                        gridForPrunedNode = 3;\n                    } else if (controlRegions[1] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n                        gridForPrunedNode = 2;\n                    }\n                } else if (minCount == 2 && min == 0) {\n                    var random = Math.floor(Math.random() * 2);\n                    if (controlRegions[0] == 0 && controlRegions[1] == 0) {\n                        ;\n                        if (random == 0) {\n                            gridForPrunedNode = 0;\n                        } else {\n                            gridForPrunedNode = 1;\n                        }\n                    } else if (controlRegions[0] == 0 && controlRegions[2] == 0) {\n                        if (random == 0) {\n                            gridForPrunedNode = 0;\n                        } else {\n                            gridForPrunedNode = 2;\n                        }\n                    } else if (controlRegions[0] == 0 && controlRegions[3] == 0) {\n                        if (random == 0) {\n                            gridForPrunedNode = 0;\n                        } else {\n                            gridForPrunedNode = 3;\n                        }\n                    } else if (controlRegions[1] == 0 && controlRegions[2] == 0) {\n                        if (random == 0) {\n                            gridForPrunedNode = 1;\n                        } else {\n                            gridForPrunedNode = 2;\n                        }\n                    } else if (controlRegions[1] == 0 && controlRegions[3] == 0) {\n                        if (random == 0) {\n                            gridForPrunedNode = 1;\n                        } else {\n                            gridForPrunedNode = 3;\n                        }\n                    } else {\n                        if (random == 0) {\n                            gridForPrunedNode = 2;\n                        } else {\n                            gridForPrunedNode = 3;\n                        }\n                    }\n                } else if (minCount == 4 && min == 0) {\n                    var random = Math.floor(Math.random() * 4);\n                    gridForPrunedNode = random;\n                } else {\n                    gridForPrunedNode = minIndex;\n                }\n                if (gridForPrunedNode == 0) {\n                    prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);\n                } else if (gridForPrunedNode == 1) {\n                    prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n                } else if (gridForPrunedNode == 2) {\n                    prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);\n                } else {\n                    prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n                }\n            };\n            module1.exports = CoSELayout;\n        /***/ },\n        /* 7 */ /***/ function(module1, exports1, __nested_webpack_require_61777__) {\n            \"use strict\";\n            var coseBase = {};\n            coseBase.layoutBase = __nested_webpack_require_61777__(0);\n            coseBase.CoSEConstants = __nested_webpack_require_61777__(1);\n            coseBase.CoSEEdge = __nested_webpack_require_61777__(2);\n            coseBase.CoSEGraph = __nested_webpack_require_61777__(3);\n            coseBase.CoSEGraphManager = __nested_webpack_require_61777__(4);\n            coseBase.CoSELayout = __nested_webpack_require_61777__(6);\n            coseBase.CoSENode = __nested_webpack_require_61777__(5);\n            module1.exports = coseBase;\n        /***/ }\n    ]);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY29zZS1iYXNlL2Nvc2UtYmFzZS5qcyIsIm1hcHBpbmdzIjoiO0FBQUMsVUFBU0EsaUNBQWlDQyxJQUFJLEVBQUVDLE9BQU87SUFDdkQsSUFBRyxJQUFpRCxFQUNuREUsT0FBT0QsT0FBTyxHQUFHRCxRQUFRRyxtQkFBT0EsQ0FBQyxvRUFBYTtTQUMxQyxFQUsyQztBQUNqRCxHQUFHLFFBQU0sU0FBU0csNkJBQTZCO0lBQy9DLE9BQWdCLE1BQUgsR0FBSSxTQUFTQyxPQUFPO1FBQ2pDLE1BQU0sR0FBSSxtQkFBbUI7UUFDN0IsTUFBTSxHQUFJLElBQUlDLG1CQUFtQixDQUFDO1FBQ2xDLE1BQU0sR0FDTixNQUFNLEdBQUksdUJBQXVCO1FBQ2pDLE1BQU0sR0FBSSxTQUFTQyw4QkFBbUJBLENBQUNDLFFBQVE7WUFDL0MsTUFBTSxHQUNOLE1BQU0sR0FBSyw4QkFBOEI7WUFDekMsTUFBTSxHQUFLLElBQUdGLGdCQUFnQixDQUFDRSxTQUFTLEVBQUU7Z0JBQzFDLE1BQU0sR0FBTSxPQUFPRixnQkFBZ0IsQ0FBQ0UsU0FBUyxDQUFDVCxPQUFPO1lBQ3JELE1BQU0sR0FBSztZQUNYLE1BQU0sR0FBSyxrREFBa0Q7WUFDN0QsTUFBTSxHQUFLLElBQUlDLFVBQVNNLGdCQUFnQixDQUFDRSxTQUFTLEdBQUc7Z0JBQ3JELE1BQU0sR0FBTUMsR0FBR0Q7Z0JBQ2YsTUFBTSxHQUFNRSxHQUFHO2dCQUNmLE1BQU0sR0FBTVgsU0FBUyxDQUFDO1lBQ1g7WUFDWCxNQUFNLEdBQ04sTUFBTSxHQUFLLDhCQUE4QjtZQUN6QyxNQUFNLEdBQUtNLE9BQU8sQ0FBQ0csU0FBUyxDQUFDRyxJQUFJLENBQUNYLFFBQU9ELE9BQU8sRUFBRUMsU0FBUUEsUUFBT0QsT0FBTyxFQUFFUSw4QkFBbUJBO1lBQzdGLE1BQU0sR0FDTixNQUFNLEdBQUssNEJBQTRCO1lBQ3ZDLE1BQU0sR0FBS1AsUUFBT1UsQ0FBQyxHQUFHO1lBQ3RCLE1BQU0sR0FDTixNQUFNLEdB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LEtBQUssR0FBR3BCLGNBQWNuTSxVQUFVO2dCQUM5SyxPQUFPLElBQUlrTSxxQkFBcUIsR0FBRztvQkFDakNFLFdBQVczSCxTQUFTLENBQUMwSCxjQUFjck0sVUFBVSxJQUFJcU0sY0FBY25NLFVBQVUsS0FBS21NLGNBQWNtQixTQUFTLEtBQUssSUFBSXBZLGtCQUFrQkssbUJBQW1CLEdBQUc2VyxXQUFXa0IsU0FBUyxLQUFLO2dCQUNqTCxPQUFPO29CQUNMbEIsV0FBVzNILFNBQVMsQ0FBQzBILGNBQWNyTSxVQUFVLEtBQUtxTSxjQUFjb0IsUUFBUSxLQUFLLElBQUlyWSxrQkFBa0JLLG1CQUFtQixHQUFHNlcsV0FBV21CLFFBQVEsS0FBSyxHQUFHcEIsY0FBY25NLFVBQVU7Z0JBQzlLO1lBQ0Y7WUFFQWhOLFFBQU9ELE9BQU8sR0FBR2tIO1FBRWpCLEdBQUcsR0FBRztRQUNOLEtBQUssR0FDTCxHQUFHLEdBQUksU0FBU2pILE9BQU0sRUFBRUQsUUFBTyxFQUFFUSxnQ0FBbUI7WUFFcEQ7WUFHQSxJQUFJaWEsV0FBVyxDQUFDO1lBRWhCQSxTQUFTQyxVQUFVLEdBQUdsYSxnQ0FBbUJBLENBQUM7WUFDMUNpYSxTQUFTclksYUFBYSxHQUFHNUIsZ0NBQW1CQSxDQUFDO1lBQzdDaWEsU0FBUzFYLFFBQVEsR0FBR3ZDLGdDQUFtQkEsQ0FBQztZQUN4Q2lhLFNBQVNwWCxTQUFTLEdBQUc3QyxnQ0FBbUJBLENBQUM7WUFDekNpYSxTQUFTL1csZ0JBQWdCLEdBQUdsRCxnQ0FBbUJBLENBQUM7WUFDaERpYSxTQUFTdlQsVUFBVSxHQUFHMUcsZ0NBQW1CQSxDQUFDO1lBQzFDaWEsU0FBUzNXLFFBQVEsR0FBR3RELGdDQUFtQkEsQ0FBQztZQUV4Q1AsUUFBT0QsT0FBTyxHQUFHeWE7UUFFakIsR0FBRyxHQUFHO0tBQ0k7QUFDViIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLXBtLWFnZW50LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2Nvc2UtYmFzZS9jb3NlLWJhc2UuanM/ZjhjZiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJsYXlvdXQtYmFzZVwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJsYXlvdXQtYmFzZVwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJjb3NlQmFzZVwiXSA9IGZhY3RvcnkocmVxdWlyZShcImxheW91dC1iYXNlXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJjb3NlQmFzZVwiXSA9IGZhY3Rvcnkocm9vdFtcImxheW91dEJhc2VcIl0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8wX18pIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmkgPSBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA3KTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzBfXztcblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBGRExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuRkRMYXlvdXRDb25zdGFudHM7XG5cbmZ1bmN0aW9uIENvU0VDb25zdGFudHMoKSB7fVxuXG4vL0NvU0VDb25zdGFudHMgaW5oZXJpdHMgc3RhdGljIHByb3BzIGluIEZETGF5b3V0Q29uc3RhbnRzXG5mb3IgKHZhciBwcm9wIGluIEZETGF5b3V0Q29uc3RhbnRzKSB7XG4gIENvU0VDb25zdGFudHNbcHJvcF0gPSBGRExheW91dENvbnN0YW50c1twcm9wXTtcbn1cblxuQ29TRUNvbnN0YW50cy5ERUZBVUxUX1VTRV9NVUxUSV9MRVZFTF9TQ0FMSU5HID0gZmFsc2U7XG5Db1NFQ29uc3RhbnRzLkRFRkFVTFRfUkFESUFMX1NFUEFSQVRJT04gPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIO1xuQ29TRUNvbnN0YW50cy5ERUZBVUxUX0NPTVBPTkVOVF9TRVBFUkFUSU9OID0gNjA7XG5Db1NFQ29uc3RhbnRzLlRJTEUgPSB0cnVlO1xuQ29TRUNvbnN0YW50cy5USUxJTkdfUEFERElOR19WRVJUSUNBTCA9IDEwO1xuQ29TRUNvbnN0YW50cy5USUxJTkdfUEFERElOR19IT1JJWk9OVEFMID0gMTA7XG5Db1NFQ29uc3RhbnRzLlRSRUVfUkVEVUNUSU9OX09OX0lOQ1JFTUVOVEFMID0gZmFsc2U7IC8vIG1ha2UgdGhpcyB0cnVlIHdoZW4gY29zZSBpcyB1c2VkIGluY3JlbWVudGFsbHkgYXMgYSBwYXJ0IG9mIG90aGVyIG5vbi1pbmNyZW1lbnRhbCBsYXlvdXRcblxubW9kdWxlLmV4cG9ydHMgPSBDb1NFQ29uc3RhbnRzO1xuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEZETGF5b3V0RWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuRkRMYXlvdXRFZGdlO1xuXG5mdW5jdGlvbiBDb1NFRWRnZShzb3VyY2UsIHRhcmdldCwgdkVkZ2UpIHtcbiAgRkRMYXlvdXRFZGdlLmNhbGwodGhpcywgc291cmNlLCB0YXJnZXQsIHZFZGdlKTtcbn1cblxuQ29TRUVkZ2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGRExheW91dEVkZ2UucHJvdG90eXBlKTtcbmZvciAodmFyIHByb3AgaW4gRkRMYXlvdXRFZGdlKSB7XG4gIENvU0VFZGdlW3Byb3BdID0gRkRMYXlvdXRFZGdlW3Byb3BdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvU0VFZGdlO1xuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIExHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuTEdyYXBoO1xuXG5mdW5jdGlvbiBDb1NFR3JhcGgocGFyZW50LCBncmFwaE1nciwgdkdyYXBoKSB7XG4gIExHcmFwaC5jYWxsKHRoaXMsIHBhcmVudCwgZ3JhcGhNZ3IsIHZHcmFwaCk7XG59XG5cbkNvU0VHcmFwaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExHcmFwaC5wcm90b3R5cGUpO1xuZm9yICh2YXIgcHJvcCBpbiBMR3JhcGgpIHtcbiAgQ29TRUdyYXBoW3Byb3BdID0gTEdyYXBoW3Byb3BdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvU0VHcmFwaDtcblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBMR3JhcGhNYW5hZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5MR3JhcGhNYW5hZ2VyO1xuXG5mdW5jdGlvbiBDb1NFR3JhcGhNYW5hZ2VyKGxheW91dCkge1xuICBMR3JhcGhNYW5hZ2VyLmNhbGwodGhpcywgbGF5b3V0KTtcbn1cblxuQ29TRUdyYXBoTWFuYWdlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExHcmFwaE1hbmFnZXIucHJvdG90eXBlKTtcbmZvciAodmFyIHByb3AgaW4gTEdyYXBoTWFuYWdlcikge1xuICBDb1NFR3JhcGhNYW5hZ2VyW3Byb3BdID0gTEdyYXBoTWFuYWdlcltwcm9wXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb1NFR3JhcGhNYW5hZ2VyO1xuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIEZETGF5b3V0Tm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuRkRMYXlvdXROb2RlO1xudmFyIElNYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5JTWF0aDtcblxuZnVuY3Rpb24gQ29TRU5vZGUoZ20sIGxvYywgc2l6ZSwgdk5vZGUpIHtcbiAgRkRMYXlvdXROb2RlLmNhbGwodGhpcywgZ20sIGxvYywgc2l6ZSwgdk5vZGUpO1xufVxuXG5Db1NFTm9kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZETGF5b3V0Tm9kZS5wcm90b3R5cGUpO1xuZm9yICh2YXIgcHJvcCBpbiBGRExheW91dE5vZGUpIHtcbiAgQ29TRU5vZGVbcHJvcF0gPSBGRExheW91dE5vZGVbcHJvcF07XG59XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGF5b3V0ID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0TGF5b3V0KCk7XG4gIHRoaXMuZGlzcGxhY2VtZW50WCA9IGxheW91dC5jb29saW5nRmFjdG9yICogKHRoaXMuc3ByaW5nRm9yY2VYICsgdGhpcy5yZXB1bHNpb25Gb3JjZVggKyB0aGlzLmdyYXZpdGF0aW9uRm9yY2VYKSAvIHRoaXMubm9PZkNoaWxkcmVuO1xuICB0aGlzLmRpc3BsYWNlbWVudFkgPSBsYXlvdXQuY29vbGluZ0ZhY3RvciAqICh0aGlzLnNwcmluZ0ZvcmNlWSArIHRoaXMucmVwdWxzaW9uRm9yY2VZICsgdGhpcy5ncmF2aXRhdGlvbkZvcmNlWSkgLyB0aGlzLm5vT2ZDaGlsZHJlbjtcblxuICBpZiAoTWF0aC5hYnModGhpcy5kaXNwbGFjZW1lbnRYKSA+IGxheW91dC5jb29saW5nRmFjdG9yICogbGF5b3V0Lm1heE5vZGVEaXNwbGFjZW1lbnQpIHtcbiAgICB0aGlzLmRpc3BsYWNlbWVudFggPSBsYXlvdXQuY29vbGluZ0ZhY3RvciAqIGxheW91dC5tYXhOb2RlRGlzcGxhY2VtZW50ICogSU1hdGguc2lnbih0aGlzLmRpc3BsYWNlbWVudFgpO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKHRoaXMuZGlzcGxhY2VtZW50WSkgPiBsYXlvdXQuY29vbGluZ0ZhY3RvciAqIGxheW91dC5tYXhOb2RlRGlzcGxhY2VtZW50KSB7XG4gICAgdGhpcy5kaXNwbGFjZW1lbnRZID0gbGF5b3V0LmNvb2xpbmdGYWN0b3IgKiBsYXlvdXQubWF4Tm9kZURpc3BsYWNlbWVudCAqIElNYXRoLnNpZ24odGhpcy5kaXNwbGFjZW1lbnRZKTtcbiAgfVxuXG4gIC8vIGEgc2ltcGxlIG5vZGUsIGp1c3QgbW92ZSBpdFxuICBpZiAodGhpcy5jaGlsZCA9PSBudWxsKSB7XG4gICAgdGhpcy5tb3ZlQnkodGhpcy5kaXNwbGFjZW1lbnRYLCB0aGlzLmRpc3BsYWNlbWVudFkpO1xuICB9XG4gIC8vIGFuIGVtcHR5IGNvbXBvdW5kIG5vZGUsIGFnYWluIGp1c3QgbW92ZSBpdFxuICBlbHNlIGlmICh0aGlzLmNoaWxkLmdldE5vZGVzKCkubGVuZ3RoID09IDApIHtcbiAgICAgIHRoaXMubW92ZUJ5KHRoaXMuZGlzcGxhY2VtZW50WCwgdGhpcy5kaXNwbGFjZW1lbnRZKTtcbiAgICB9XG4gICAgLy8gbm9uLWVtcHR5IGNvbXBvdW5kIG5vZGUsIHByb3BvZ2F0ZSBtb3ZlbWVudCB0byBjaGlsZHJlbiBhcyB3ZWxsXG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMucHJvcG9nYXRlRGlzcGxhY2VtZW50VG9DaGlsZHJlbih0aGlzLmRpc3BsYWNlbWVudFgsIHRoaXMuZGlzcGxhY2VtZW50WSk7XG4gICAgICB9XG5cbiAgbGF5b3V0LnRvdGFsRGlzcGxhY2VtZW50ICs9IE1hdGguYWJzKHRoaXMuZGlzcGxhY2VtZW50WCkgKyBNYXRoLmFicyh0aGlzLmRpc3BsYWNlbWVudFkpO1xuXG4gIHRoaXMuc3ByaW5nRm9yY2VYID0gMDtcbiAgdGhpcy5zcHJpbmdGb3JjZVkgPSAwO1xuICB0aGlzLnJlcHVsc2lvbkZvcmNlWCA9IDA7XG4gIHRoaXMucmVwdWxzaW9uRm9yY2VZID0gMDtcbiAgdGhpcy5ncmF2aXRhdGlvbkZvcmNlWCA9IDA7XG4gIHRoaXMuZ3Jhdml0YXRpb25Gb3JjZVkgPSAwO1xuICB0aGlzLmRpc3BsYWNlbWVudFggPSAwO1xuICB0aGlzLmRpc3BsYWNlbWVudFkgPSAwO1xufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLnByb3BvZ2F0ZURpc3BsYWNlbWVudFRvQ2hpbGRyZW4gPSBmdW5jdGlvbiAoZFgsIGRZKSB7XG4gIHZhciBub2RlcyA9IHRoaXMuZ2V0Q2hpbGQoKS5nZXROb2RlcygpO1xuICB2YXIgbm9kZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICBpZiAobm9kZS5nZXRDaGlsZCgpID09IG51bGwpIHtcbiAgICAgIG5vZGUubW92ZUJ5KGRYLCBkWSk7XG4gICAgICBub2RlLmRpc3BsYWNlbWVudFggKz0gZFg7XG4gICAgICBub2RlLmRpc3BsYWNlbWVudFkgKz0gZFk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUucHJvcG9nYXRlRGlzcGxhY2VtZW50VG9DaGlsZHJlbihkWCwgZFkpO1xuICAgIH1cbiAgfVxufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLnNldFByZWQxID0gZnVuY3Rpb24gKHByZWQxKSB7XG4gIHRoaXMucHJlZDEgPSBwcmVkMTtcbn07XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5nZXRQcmVkMSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHByZWQxO1xufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLmdldFByZWQyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcHJlZDI7XG59O1xuXG5Db1NFTm9kZS5wcm90b3R5cGUuc2V0TmV4dCA9IGZ1bmN0aW9uIChuZXh0KSB7XG4gIHRoaXMubmV4dCA9IG5leHQ7XG59O1xuXG5Db1NFTm9kZS5wcm90b3R5cGUuZ2V0TmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5leHQ7XG59O1xuXG5Db1NFTm9kZS5wcm90b3R5cGUuc2V0UHJvY2Vzc2VkID0gZnVuY3Rpb24gKHByb2Nlc3NlZCkge1xuICB0aGlzLnByb2Nlc3NlZCA9IHByb2Nlc3NlZDtcbn07XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5pc1Byb2Nlc3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHByb2Nlc3NlZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29TRU5vZGU7XG5cbi8qKiovIH0pLFxuLyogNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgRkRMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkZETGF5b3V0O1xudmFyIENvU0VHcmFwaE1hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xudmFyIENvU0VHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgQ29TRU5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIENvU0VFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbnZhciBDb1NFQ29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBGRExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuRkRMYXlvdXRDb25zdGFudHM7XG52YXIgTGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5MYXlvdXRDb25zdGFudHM7XG52YXIgUG9pbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLlBvaW50O1xudmFyIFBvaW50RCA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuUG9pbnREO1xudmFyIExheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oMCkuTGF5b3V0O1xudmFyIEludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApLkludGVnZXI7XG52YXIgSUdlb21ldHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5JR2VvbWV0cnk7XG52YXIgTEdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5MR3JhcGg7XG52YXIgVHJhbnNmb3JtID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKS5UcmFuc2Zvcm07XG5cbmZ1bmN0aW9uIENvU0VMYXlvdXQoKSB7XG4gIEZETGF5b3V0LmNhbGwodGhpcyk7XG5cbiAgdGhpcy50b0JlVGlsZWQgPSB7fTsgLy8gTWVtb3JpemUgaWYgYSBub2RlIGlzIHRvIGJlIHRpbGVkIG9yIGlzIHRpbGVkXG59XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGRExheW91dC5wcm90b3R5cGUpO1xuXG5mb3IgKHZhciBwcm9wIGluIEZETGF5b3V0KSB7XG4gIENvU0VMYXlvdXRbcHJvcF0gPSBGRExheW91dFtwcm9wXTtcbn1cblxuQ29TRUxheW91dC5wcm90b3R5cGUubmV3R3JhcGhNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZ20gPSBuZXcgQ29TRUdyYXBoTWFuYWdlcih0aGlzKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIgPSBnbTtcbiAgcmV0dXJuIGdtO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUubmV3R3JhcGggPSBmdW5jdGlvbiAodkdyYXBoKSB7XG4gIHJldHVybiBuZXcgQ29TRUdyYXBoKG51bGwsIHRoaXMuZ3JhcGhNYW5hZ2VyLCB2R3JhcGgpO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUubmV3Tm9kZSA9IGZ1bmN0aW9uICh2Tm9kZSkge1xuICByZXR1cm4gbmV3IENvU0VOb2RlKHRoaXMuZ3JhcGhNYW5hZ2VyLCB2Tm9kZSk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5uZXdFZGdlID0gZnVuY3Rpb24gKHZFZGdlKSB7XG4gIHJldHVybiBuZXcgQ29TRUVkZ2UobnVsbCwgbnVsbCwgdkVkZ2UpO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUuaW5pdFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gIEZETGF5b3V0LnByb3RvdHlwZS5pbml0UGFyYW1ldGVycy5jYWxsKHRoaXMsIGFyZ3VtZW50cyk7XG4gIGlmICghdGhpcy5pc1N1YkxheW91dCkge1xuICAgIGlmIChDb1NFQ29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggPCAxMCkge1xuICAgICAgdGhpcy5pZGVhbEVkZ2VMZW5ndGggPSAxMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pZGVhbEVkZ2VMZW5ndGggPSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEg7XG4gICAgfVxuXG4gICAgdGhpcy51c2VTbWFydElkZWFsRWRnZUxlbmd0aENhbGN1bGF0aW9uID0gQ29TRUNvbnN0YW50cy5ERUZBVUxUX1VTRV9TTUFSVF9JREVBTF9FREdFX0xFTkdUSF9DQUxDVUxBVElPTjtcbiAgICB0aGlzLnNwcmluZ0NvbnN0YW50ID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9TUFJJTkdfU1RSRU5HVEg7XG4gICAgdGhpcy5yZXB1bHNpb25Db25zdGFudCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfUkVQVUxTSU9OX1NUUkVOR1RIO1xuICAgIHRoaXMuZ3Jhdml0eUNvbnN0YW50ID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1NUUkVOR1RIO1xuICAgIHRoaXMuY29tcG91bmRHcmF2aXR5Q29uc3RhbnQgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfU1RSRU5HVEg7XG4gICAgdGhpcy5ncmF2aXR5UmFuZ2VGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfUkFOR0VfRkFDVE9SO1xuICAgIHRoaXMuY29tcG91bmRHcmF2aXR5UmFuZ2VGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfUkFOR0VfRkFDVE9SO1xuXG4gICAgLy8gdmFyaWFibGVzIGZvciB0cmVlIHJlZHVjdGlvbiBzdXBwb3J0XG4gICAgdGhpcy5wcnVuZWROb2Rlc0FsbCA9IFtdO1xuICAgIHRoaXMuZ3Jvd1RyZWVJdGVyYXRpb25zID0gMDtcbiAgICB0aGlzLmFmdGVyR3Jvd3RoSXRlcmF0aW9ucyA9IDA7XG4gICAgdGhpcy5pc1RyZWVHcm93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5pc0dyb3d0aEZpbmlzaGVkID0gZmFsc2U7XG5cbiAgICAvLyB2YXJpYWJsZXMgZm9yIGNvb2xpbmdcbiAgICB0aGlzLmNvb2xpbmdDeWNsZSA9IDA7XG4gICAgdGhpcy5tYXhDb29saW5nQ3ljbGUgPSB0aGlzLm1heEl0ZXJhdGlvbnMgLyBGRExheW91dENvbnN0YW50cy5DT05WRVJHRU5DRV9DSEVDS19QRVJJT0Q7XG4gICAgdGhpcy5maW5hbFRlbXBlcmF0dXJlID0gRkRMYXlvdXRDb25zdGFudHMuQ09OVkVSR0VOQ0VfQ0hFQ0tfUEVSSU9EIC8gdGhpcy5tYXhJdGVyYXRpb25zO1xuICAgIHRoaXMuY29vbGluZ0FkanVzdGVyID0gMTtcbiAgfVxufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUubGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY3JlYXRlQmVuZHNBc05lZWRlZCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0NSRUFURV9CRU5EU19BU19ORUVERUQ7XG4gIGlmIChjcmVhdGVCZW5kc0FzTmVlZGVkKSB7XG4gICAgdGhpcy5jcmVhdGVCZW5kcG9pbnRzKCk7XG4gICAgdGhpcy5ncmFwaE1hbmFnZXIucmVzZXRBbGxFZGdlcygpO1xuICB9XG5cbiAgdGhpcy5sZXZlbCA9IDA7XG4gIHJldHVybiB0aGlzLmNsYXNzaWNMYXlvdXQoKTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmNsYXNzaWNMYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubm9kZXNXaXRoR3Jhdml0eSA9IHRoaXMuY2FsY3VsYXRlTm9kZXNUb0FwcGx5R3Jhdml0YXRpb25UbygpO1xuICB0aGlzLmdyYXBoTWFuYWdlci5zZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbih0aGlzLm5vZGVzV2l0aEdyYXZpdHkpO1xuICB0aGlzLmNhbGNOb09mQ2hpbGRyZW5Gb3JBbGxOb2RlcygpO1xuICB0aGlzLmdyYXBoTWFuYWdlci5jYWxjTG93ZXN0Q29tbW9uQW5jZXN0b3JzKCk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLmNhbGNJbmNsdXNpb25UcmVlRGVwdGhzKCk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKS5jYWxjRXN0aW1hdGVkU2l6ZSgpO1xuICB0aGlzLmNhbGNJZGVhbEVkZ2VMZW5ndGhzKCk7XG5cbiAgaWYgKCF0aGlzLmluY3JlbWVudGFsKSB7XG4gICAgdmFyIGZvcmVzdCA9IHRoaXMuZ2V0RmxhdEZvcmVzdCgpO1xuXG4gICAgLy8gVGhlIGdyYXBoIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxheW91dCBpcyBmbGF0IGFuZCBhIGZvcmVzdFxuICAgIGlmIChmb3Jlc3QubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5wb3NpdGlvbk5vZGVzUmFkaWFsbHkoZm9yZXN0KTtcbiAgICB9XG4gICAgLy8gVGhlIGdyYXBoIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxheW91dCBpcyBub3QgZmxhdCBvciBhIGZvcmVzdFxuICAgIGVsc2Uge1xuICAgICAgICAvLyBSZWR1Y2UgdGhlIHRyZWVzIHdoZW4gaW5jcmVtZW50YWwgbW9kZSBpcyBub3QgZW5hYmxlZCBhbmQgZ3JhcGggaXMgbm90IGEgZm9yZXN0IFxuICAgICAgICB0aGlzLnJlZHVjZVRyZWVzKCk7XG4gICAgICAgIC8vIFVwZGF0ZSBub2RlcyB0aGF0IGdyYXZpdHkgd2lsbCBiZSBhcHBsaWVkXG4gICAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oKTtcbiAgICAgICAgdmFyIGFsbE5vZGVzID0gbmV3IFNldCh0aGlzLmdldEFsbE5vZGVzKCkpO1xuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gdGhpcy5ub2Rlc1dpdGhHcmF2aXR5LmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiBhbGxOb2Rlcy5oYXMoeCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdyYXBoTWFuYWdlci5zZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbihpbnRlcnNlY3Rpb24pO1xuXG4gICAgICAgIHRoaXMucG9zaXRpb25Ob2Rlc1JhbmRvbWx5KCk7XG4gICAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKENvU0VDb25zdGFudHMuVFJFRV9SRURVQ1RJT05fT05fSU5DUkVNRU5UQUwpIHtcbiAgICAgIC8vIFJlZHVjZSB0aGUgdHJlZXMgaW4gaW5jcmVtZW50YWwgbW9kZSBpZiBvbmx5IHRoaXMgY29uc3RhbnQgaXMgc2V0IHRvIHRydWUgXG4gICAgICB0aGlzLnJlZHVjZVRyZWVzKCk7XG4gICAgICAvLyBVcGRhdGUgbm9kZXMgdGhhdCBncmF2aXR5IHdpbGwgYmUgYXBwbGllZFxuICAgICAgdGhpcy5ncmFwaE1hbmFnZXIucmVzZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbigpO1xuICAgICAgdmFyIGFsbE5vZGVzID0gbmV3IFNldCh0aGlzLmdldEFsbE5vZGVzKCkpO1xuICAgICAgdmFyIGludGVyc2VjdGlvbiA9IHRoaXMubm9kZXNXaXRoR3Jhdml0eS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIGFsbE5vZGVzLmhhcyh4KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ncmFwaE1hbmFnZXIuc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oaW50ZXJzZWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmluaXRTcHJpbmdFbWJlZGRlcigpO1xuICB0aGlzLnJ1blNwcmluZ0VtYmVkZGVyKCk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnRvdGFsSXRlcmF0aW9ucysrO1xuXG4gIGlmICh0aGlzLnRvdGFsSXRlcmF0aW9ucyA9PT0gdGhpcy5tYXhJdGVyYXRpb25zICYmICF0aGlzLmlzVHJlZUdyb3dpbmcgJiYgIXRoaXMuaXNHcm93dGhGaW5pc2hlZCkge1xuICAgIGlmICh0aGlzLnBydW5lZE5vZGVzQWxsLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuaXNUcmVlR3Jvd2luZyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnRvdGFsSXRlcmF0aW9ucyAlIEZETGF5b3V0Q29uc3RhbnRzLkNPTlZFUkdFTkNFX0NIRUNLX1BFUklPRCA9PSAwICYmICF0aGlzLmlzVHJlZUdyb3dpbmcgJiYgIXRoaXMuaXNHcm93dGhGaW5pc2hlZCkge1xuICAgIGlmICh0aGlzLmlzQ29udmVyZ2VkKCkpIHtcbiAgICAgIGlmICh0aGlzLnBydW5lZE5vZGVzQWxsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5pc1RyZWVHcm93aW5nID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY29vbGluZ0N5Y2xlKys7XG5cbiAgICBpZiAodGhpcy5sYXlvdXRRdWFsaXR5ID09IDApIHtcbiAgICAgIC8vIHF1YWxpdHkgLSBcImRyYWZ0XCJcbiAgICAgIHRoaXMuY29vbGluZ0FkanVzdGVyID0gdGhpcy5jb29saW5nQ3ljbGU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxheW91dFF1YWxpdHkgPT0gMSkge1xuICAgICAgLy8gcXVhbGl0eSAtIFwiZGVmYXVsdFwiXG4gICAgICB0aGlzLmNvb2xpbmdBZGp1c3RlciA9IHRoaXMuY29vbGluZ0N5Y2xlIC8gMztcbiAgICB9XG5cbiAgICAvLyBjb29saW5nIHNjaGVkdWxlIGlzIGJhc2VkIG9uIGh0dHA6Ly93d3cuYnRsdWtlLmNvbS9zaW1hbmYxLmh0bWwgLT4gY29vbGluZyBzY2hlZHVsZSAzXG4gICAgdGhpcy5jb29saW5nRmFjdG9yID0gTWF0aC5tYXgodGhpcy5pbml0aWFsQ29vbGluZ0ZhY3RvciAtIE1hdGgucG93KHRoaXMuY29vbGluZ0N5Y2xlLCBNYXRoLmxvZygxMDAgKiAodGhpcy5pbml0aWFsQ29vbGluZ0ZhY3RvciAtIHRoaXMuZmluYWxUZW1wZXJhdHVyZSkpIC8gTWF0aC5sb2codGhpcy5tYXhDb29saW5nQ3ljbGUpKSAvIDEwMCAqIHRoaXMuY29vbGluZ0FkanVzdGVyLCB0aGlzLmZpbmFsVGVtcGVyYXR1cmUpO1xuICAgIHRoaXMuYW5pbWF0aW9uUGVyaW9kID0gTWF0aC5jZWlsKHRoaXMuaW5pdGlhbEFuaW1hdGlvblBlcmlvZCAqIE1hdGguc3FydCh0aGlzLmNvb2xpbmdGYWN0b3IpKTtcbiAgfVxuICAvLyBPcGVyYXRpb25zIHdoaWxlIHRyZWUgaXMgZ3Jvd2luZyBhZ2FpbiBcbiAgaWYgKHRoaXMuaXNUcmVlR3Jvd2luZykge1xuICAgIGlmICh0aGlzLmdyb3dUcmVlSXRlcmF0aW9ucyAlIDEwID09IDApIHtcbiAgICAgIGlmICh0aGlzLnBydW5lZE5vZGVzQWxsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5ncmFwaE1hbmFnZXIudXBkYXRlQm91bmRzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlR3JpZCgpO1xuICAgICAgICB0aGlzLmdyb3dUcmVlKHRoaXMucHJ1bmVkTm9kZXNBbGwpO1xuICAgICAgICAvLyBVcGRhdGUgbm9kZXMgdGhhdCBncmF2aXR5IHdpbGwgYmUgYXBwbGllZFxuICAgICAgICB0aGlzLmdyYXBoTWFuYWdlci5yZXNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uKCk7XG4gICAgICAgIHZhciBhbGxOb2RlcyA9IG5ldyBTZXQodGhpcy5nZXRBbGxOb2RlcygpKTtcbiAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IHRoaXMubm9kZXNXaXRoR3Jhdml0eS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4gYWxsTm9kZXMuaGFzKHgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ncmFwaE1hbmFnZXIuc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oaW50ZXJzZWN0aW9uKTtcblxuICAgICAgICB0aGlzLmdyYXBoTWFuYWdlci51cGRhdGVCb3VuZHMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVHcmlkKCk7XG4gICAgICAgIHRoaXMuY29vbGluZ0ZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmlzVHJlZUdyb3dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0dyb3d0aEZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5ncm93VHJlZUl0ZXJhdGlvbnMrKztcbiAgfVxuICAvLyBPcGVyYXRpb25zIGFmdGVyIGdyb3d0aCBpcyBmaW5pc2hlZFxuICBpZiAodGhpcy5pc0dyb3d0aEZpbmlzaGVkKSB7XG4gICAgaWYgKHRoaXMuaXNDb252ZXJnZWQoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmFmdGVyR3Jvd3RoSXRlcmF0aW9ucyAlIDEwID09IDApIHtcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnVwZGF0ZUJvdW5kcygpO1xuICAgICAgdGhpcy51cGRhdGVHcmlkKCk7XG4gICAgfVxuICAgIHRoaXMuY29vbGluZ0ZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUwgKiAoKDEwMCAtIHRoaXMuYWZ0ZXJHcm93dGhJdGVyYXRpb25zKSAvIDEwMCk7XG4gICAgdGhpcy5hZnRlckdyb3d0aEl0ZXJhdGlvbnMrKztcbiAgfVxuXG4gIHZhciBncmlkVXBkYXRlQWxsb3dlZCA9ICF0aGlzLmlzVHJlZUdyb3dpbmcgJiYgIXRoaXMuaXNHcm93dGhGaW5pc2hlZDtcbiAgdmFyIGZvcmNlVG9Ob2RlU3Vycm91bmRpbmdVcGRhdGUgPSB0aGlzLmdyb3dUcmVlSXRlcmF0aW9ucyAlIDEwID09IDEgJiYgdGhpcy5pc1RyZWVHcm93aW5nIHx8IHRoaXMuYWZ0ZXJHcm93dGhJdGVyYXRpb25zICUgMTAgPT0gMSAmJiB0aGlzLmlzR3Jvd3RoRmluaXNoZWQ7XG5cbiAgdGhpcy50b3RhbERpc3BsYWNlbWVudCA9IDA7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLnVwZGF0ZUJvdW5kcygpO1xuICB0aGlzLmNhbGNTcHJpbmdGb3JjZXMoKTtcbiAgdGhpcy5jYWxjUmVwdWxzaW9uRm9yY2VzKGdyaWRVcGRhdGVBbGxvd2VkLCBmb3JjZVRvTm9kZVN1cnJvdW5kaW5nVXBkYXRlKTtcbiAgdGhpcy5jYWxjR3Jhdml0YXRpb25hbEZvcmNlcygpO1xuICB0aGlzLm1vdmVOb2RlcygpO1xuICB0aGlzLmFuaW1hdGUoKTtcblxuICByZXR1cm4gZmFsc2U7IC8vIExheW91dCBpcyBub3QgZW5kZWQgeWV0IHJldHVybiBmYWxzZVxufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUuZ2V0UG9zaXRpb25zRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFsbE5vZGVzID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsTm9kZXMoKTtcbiAgdmFyIHBEYXRhID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcmVjdCA9IGFsbE5vZGVzW2ldLnJlY3Q7XG4gICAgdmFyIGlkID0gYWxsTm9kZXNbaV0uaWQ7XG4gICAgcERhdGFbaWRdID0ge1xuICAgICAgaWQ6IGlkLFxuICAgICAgeDogcmVjdC5nZXRDZW50ZXJYKCksXG4gICAgICB5OiByZWN0LmdldENlbnRlclkoKSxcbiAgICAgIHc6IHJlY3Qud2lkdGgsXG4gICAgICBoOiByZWN0LmhlaWdodFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gcERhdGE7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5ydW5TcHJpbmdFbWJlZGRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5pbml0aWFsQW5pbWF0aW9uUGVyaW9kID0gMjU7XG4gIHRoaXMuYW5pbWF0aW9uUGVyaW9kID0gdGhpcy5pbml0aWFsQW5pbWF0aW9uUGVyaW9kO1xuICB2YXIgbGF5b3V0RW5kZWQgPSBmYWxzZTtcblxuICAvLyBJZiBhbWluYXRlIG9wdGlvbiBpcyAnZHVyaW5nJyBzaWduYWwgdGhhdCBsYXlvdXQgaXMgc3VwcG9zZWQgdG8gc3RhcnQgaXRlcmF0aW5nXG4gIGlmIChGRExheW91dENvbnN0YW50cy5BTklNQVRFID09PSAnZHVyaW5nJykge1xuICAgIHRoaXMuZW1pdCgnbGF5b3V0c3RhcnRlZCcpO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIGFtaW5hdGUgb3B0aW9uIGlzICdkdXJpbmcnIHRpY2soKSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBvbiBpbmRleC5qc1xuICAgIHdoaWxlICghbGF5b3V0RW5kZWQpIHtcbiAgICAgIGxheW91dEVuZGVkID0gdGhpcy50aWNrKCk7XG4gICAgfVxuXG4gICAgdGhpcy5ncmFwaE1hbmFnZXIudXBkYXRlQm91bmRzKCk7XG4gIH1cbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmNhbGN1bGF0ZU5vZGVzVG9BcHBseUdyYXZpdGF0aW9uVG8gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlTGlzdCA9IFtdO1xuICB2YXIgZ3JhcGg7XG5cbiAgdmFyIGdyYXBocyA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEdyYXBocygpO1xuICB2YXIgc2l6ZSA9IGdyYXBocy5sZW5ndGg7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgZ3JhcGggPSBncmFwaHNbaV07XG5cbiAgICBncmFwaC51cGRhdGVDb25uZWN0ZWQoKTtcblxuICAgIGlmICghZ3JhcGguaXNDb25uZWN0ZWQpIHtcbiAgICAgIG5vZGVMaXN0ID0gbm9kZUxpc3QuY29uY2F0KGdyYXBoLmdldE5vZGVzKCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2RlTGlzdDtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmNyZWF0ZUJlbmRwb2ludHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlZGdlcyA9IFtdO1xuICBlZGdlcyA9IGVkZ2VzLmNvbmNhdCh0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxFZGdlcygpKTtcbiAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuXG4gICAgaWYgKCF2aXNpdGVkLmhhcyhlZGdlKSkge1xuICAgICAgdmFyIHNvdXJjZSA9IGVkZ2UuZ2V0U291cmNlKCk7XG4gICAgICB2YXIgdGFyZ2V0ID0gZWRnZS5nZXRUYXJnZXQoKTtcblxuICAgICAgaWYgKHNvdXJjZSA9PSB0YXJnZXQpIHtcbiAgICAgICAgZWRnZS5nZXRCZW5kcG9pbnRzKCkucHVzaChuZXcgUG9pbnREKCkpO1xuICAgICAgICBlZGdlLmdldEJlbmRwb2ludHMoKS5wdXNoKG5ldyBQb2ludEQoKSk7XG4gICAgICAgIHRoaXMuY3JlYXRlRHVtbXlOb2Rlc0ZvckJlbmRwb2ludHMoZWRnZSk7XG4gICAgICAgIHZpc2l0ZWQuYWRkKGVkZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVkZ2VMaXN0ID0gW107XG5cbiAgICAgICAgZWRnZUxpc3QgPSBlZGdlTGlzdC5jb25jYXQoc291cmNlLmdldEVkZ2VMaXN0VG9Ob2RlKHRhcmdldCkpO1xuICAgICAgICBlZGdlTGlzdCA9IGVkZ2VMaXN0LmNvbmNhdCh0YXJnZXQuZ2V0RWRnZUxpc3RUb05vZGUoc291cmNlKSk7XG5cbiAgICAgICAgaWYgKCF2aXNpdGVkLmhhcyhlZGdlTGlzdFswXSkpIHtcbiAgICAgICAgICBpZiAoZWRnZUxpc3QubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIGs7XG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgZWRnZUxpc3QubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgdmFyIG11bHRpRWRnZSA9IGVkZ2VMaXN0W2tdO1xuICAgICAgICAgICAgICBtdWx0aUVkZ2UuZ2V0QmVuZHBvaW50cygpLnB1c2gobmV3IFBvaW50RCgpKTtcbiAgICAgICAgICAgICAgdGhpcy5jcmVhdGVEdW1teU5vZGVzRm9yQmVuZHBvaW50cyhtdWx0aUVkZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlZGdlTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgICB2aXNpdGVkLmFkZChlZGdlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2aXNpdGVkLnNpemUgPT0gZWRnZXMubGVuZ3RoKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnBvc2l0aW9uTm9kZXNSYWRpYWxseSA9IGZ1bmN0aW9uIChmb3Jlc3QpIHtcbiAgLy8gV2UgdGlsZSB0aGUgdHJlZXMgdG8gYSBncmlkIHJvdyBieSByb3c7IGZpcnN0IHRyZWUgc3RhcnRzIGF0ICgwLDApXG4gIHZhciBjdXJyZW50U3RhcnRpbmdQb2ludCA9IG5ldyBQb2ludCgwLCAwKTtcbiAgdmFyIG51bWJlck9mQ29sdW1ucyA9IE1hdGguY2VpbChNYXRoLnNxcnQoZm9yZXN0Lmxlbmd0aCkpO1xuICB2YXIgaGVpZ2h0ID0gMDtcbiAgdmFyIGN1cnJlbnRZID0gMDtcbiAgdmFyIGN1cnJlbnRYID0gMDtcbiAgdmFyIHBvaW50ID0gbmV3IFBvaW50RCgwLCAwKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcmVzdC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpICUgbnVtYmVyT2ZDb2x1bW5zID09IDApIHtcbiAgICAgIC8vIFN0YXJ0IG9mIGEgbmV3IHJvdywgbWFrZSB0aGUgeCBjb29yZGluYXRlIDAsIGluY3JlbWVudCB0aGVcbiAgICAgIC8vIHkgY29vcmRpbmF0ZSB3aXRoIHRoZSBtYXggaGVpZ2h0IG9mIHRoZSBwcmV2aW91cyByb3dcbiAgICAgIGN1cnJlbnRYID0gMDtcbiAgICAgIGN1cnJlbnRZID0gaGVpZ2h0O1xuXG4gICAgICBpZiAoaSAhPSAwKSB7XG4gICAgICAgIGN1cnJlbnRZICs9IENvU0VDb25zdGFudHMuREVGQVVMVF9DT01QT05FTlRfU0VQRVJBVElPTjtcbiAgICAgIH1cblxuICAgICAgaGVpZ2h0ID0gMDtcbiAgICB9XG5cbiAgICB2YXIgdHJlZSA9IGZvcmVzdFtpXTtcblxuICAgIC8vIEZpbmQgdGhlIGNlbnRlciBvZiB0aGUgdHJlZVxuICAgIHZhciBjZW50ZXJOb2RlID0gTGF5b3V0LmZpbmRDZW50ZXJPZlRyZWUodHJlZSk7XG5cbiAgICAvLyBTZXQgdGhlIHN0YXJpbmcgcG9pbnQgb2YgdGhlIG5leHQgdHJlZVxuICAgIGN1cnJlbnRTdGFydGluZ1BvaW50LnggPSBjdXJyZW50WDtcbiAgICBjdXJyZW50U3RhcnRpbmdQb2ludC55ID0gY3VycmVudFk7XG5cbiAgICAvLyBEbyBhIHJhZGlhbCBsYXlvdXQgc3RhcnRpbmcgd2l0aCB0aGUgY2VudGVyXG4gICAgcG9pbnQgPSBDb1NFTGF5b3V0LnJhZGlhbExheW91dCh0cmVlLCBjZW50ZXJOb2RlLCBjdXJyZW50U3RhcnRpbmdQb2ludCk7XG5cbiAgICBpZiAocG9pbnQueSA+IGhlaWdodCkge1xuICAgICAgaGVpZ2h0ID0gTWF0aC5mbG9vcihwb2ludC55KTtcbiAgICB9XG5cbiAgICBjdXJyZW50WCA9IE1hdGguZmxvb3IocG9pbnQueCArIENvU0VDb25zdGFudHMuREVGQVVMVF9DT01QT05FTlRfU0VQRVJBVElPTik7XG4gIH1cblxuICB0aGlzLnRyYW5zZm9ybShuZXcgUG9pbnREKExheW91dENvbnN0YW50cy5XT1JMRF9DRU5URVJfWCAtIHBvaW50LnggLyAyLCBMYXlvdXRDb25zdGFudHMuV09STERfQ0VOVEVSX1kgLSBwb2ludC55IC8gMikpO1xufTtcblxuQ29TRUxheW91dC5yYWRpYWxMYXlvdXQgPSBmdW5jdGlvbiAodHJlZSwgY2VudGVyTm9kZSwgc3RhcnRpbmdQb2ludCkge1xuICB2YXIgcmFkaWFsU2VwID0gTWF0aC5tYXgodGhpcy5tYXhEaWFnb25hbEluVHJlZSh0cmVlKSwgQ29TRUNvbnN0YW50cy5ERUZBVUxUX1JBRElBTF9TRVBBUkFUSU9OKTtcbiAgQ29TRUxheW91dC5icmFuY2hSYWRpYWxMYXlvdXQoY2VudGVyTm9kZSwgbnVsbCwgMCwgMzU5LCAwLCByYWRpYWxTZXApO1xuICB2YXIgYm91bmRzID0gTEdyYXBoLmNhbGN1bGF0ZUJvdW5kcyh0cmVlKTtcblxuICB2YXIgdHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybSgpO1xuICB0cmFuc2Zvcm0uc2V0RGV2aWNlT3JnWChib3VuZHMuZ2V0TWluWCgpKTtcbiAgdHJhbnNmb3JtLnNldERldmljZU9yZ1koYm91bmRzLmdldE1pblkoKSk7XG4gIHRyYW5zZm9ybS5zZXRXb3JsZE9yZ1goc3RhcnRpbmdQb2ludC54KTtcbiAgdHJhbnNmb3JtLnNldFdvcmxkT3JnWShzdGFydGluZ1BvaW50LnkpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gdHJlZVtpXTtcbiAgICBub2RlLnRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuICB9XG5cbiAgdmFyIGJvdHRvbVJpZ2h0ID0gbmV3IFBvaW50RChib3VuZHMuZ2V0TWF4WCgpLCBib3VuZHMuZ2V0TWF4WSgpKTtcblxuICByZXR1cm4gdHJhbnNmb3JtLmludmVyc2VUcmFuc2Zvcm1Qb2ludChib3R0b21SaWdodCk7XG59O1xuXG5Db1NFTGF5b3V0LmJyYW5jaFJhZGlhbExheW91dCA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnRPZk5vZGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBkaXN0YW5jZSwgcmFkaWFsU2VwYXJhdGlvbikge1xuICAvLyBGaXJzdCwgcG9zaXRpb24gdGhpcyBub2RlIGJ5IGZpbmRpbmcgaXRzIGFuZ2xlLlxuICB2YXIgaGFsZkludGVydmFsID0gKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSArIDEpIC8gMjtcblxuICBpZiAoaGFsZkludGVydmFsIDwgMCkge1xuICAgIGhhbGZJbnRlcnZhbCArPSAxODA7XG4gIH1cblxuICB2YXIgbm9kZUFuZ2xlID0gKGhhbGZJbnRlcnZhbCArIHN0YXJ0QW5nbGUpICUgMzYwO1xuICB2YXIgdGV0YSA9IG5vZGVBbmdsZSAqIElHZW9tZXRyeS5UV09fUEkgLyAzNjA7XG5cbiAgLy8gTWFrZSBwb2xhciB0byBqYXZhIGNvcmRpbmF0ZSBjb252ZXJzaW9uLlxuICB2YXIgY29zX3RldGEgPSBNYXRoLmNvcyh0ZXRhKTtcbiAgdmFyIHhfID0gZGlzdGFuY2UgKiBNYXRoLmNvcyh0ZXRhKTtcbiAgdmFyIHlfID0gZGlzdGFuY2UgKiBNYXRoLnNpbih0ZXRhKTtcblxuICBub2RlLnNldENlbnRlcih4XywgeV8pO1xuXG4gIC8vIFRyYXZlcnNlIGFsbCBuZWlnaGJvcnMgb2YgdGhpcyBub2RlIGFuZCByZWN1cnNpdmVseSBjYWxsIHRoaXNcbiAgLy8gZnVuY3Rpb24uXG4gIHZhciBuZWlnaGJvckVkZ2VzID0gW107XG4gIG5laWdoYm9yRWRnZXMgPSBuZWlnaGJvckVkZ2VzLmNvbmNhdChub2RlLmdldEVkZ2VzKCkpO1xuICB2YXIgY2hpbGRDb3VudCA9IG5laWdoYm9yRWRnZXMubGVuZ3RoO1xuXG4gIGlmIChwYXJlbnRPZk5vZGUgIT0gbnVsbCkge1xuICAgIGNoaWxkQ291bnQtLTtcbiAgfVxuXG4gIHZhciBicmFuY2hDb3VudCA9IDA7XG5cbiAgdmFyIGluY0VkZ2VzQ291bnQgPSBuZWlnaGJvckVkZ2VzLmxlbmd0aDtcbiAgdmFyIHN0YXJ0SW5kZXg7XG5cbiAgdmFyIGVkZ2VzID0gbm9kZS5nZXRFZGdlc0JldHdlZW4ocGFyZW50T2ZOb2RlKTtcblxuICAvLyBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgZWRnZXMsIHBydW5lIHRoZW0gdW50aWwgdGhlcmUgcmVtYWlucyBvbmx5IG9uZVxuICAvLyBlZGdlLlxuICB3aGlsZSAoZWRnZXMubGVuZ3RoID4gMSkge1xuICAgIC8vbmVpZ2hib3JFZGdlcy5yZW1vdmUoZWRnZXMucmVtb3ZlKDApKTtcbiAgICB2YXIgdGVtcCA9IGVkZ2VzWzBdO1xuICAgIGVkZ2VzLnNwbGljZSgwLCAxKTtcbiAgICB2YXIgaW5kZXggPSBuZWlnaGJvckVkZ2VzLmluZGV4T2YodGVtcCk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIG5laWdoYm9yRWRnZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgaW5jRWRnZXNDb3VudC0tO1xuICAgIGNoaWxkQ291bnQtLTtcbiAgfVxuXG4gIGlmIChwYXJlbnRPZk5vZGUgIT0gbnVsbCkge1xuICAgIC8vYXNzZXJ0IGVkZ2VzLmxlbmd0aCA9PSAxO1xuICAgIHN0YXJ0SW5kZXggPSAobmVpZ2hib3JFZGdlcy5pbmRleE9mKGVkZ2VzWzBdKSArIDEpICUgaW5jRWRnZXNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBzdGFydEluZGV4ID0gMDtcbiAgfVxuXG4gIHZhciBzdGVwQW5nbGUgPSBNYXRoLmFicyhlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpIC8gY2hpbGRDb3VudDtcblxuICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgYnJhbmNoQ291bnQgIT0gY2hpbGRDb3VudDsgaSA9ICsraSAlIGluY0VkZ2VzQ291bnQpIHtcbiAgICB2YXIgY3VycmVudE5laWdoYm9yID0gbmVpZ2hib3JFZGdlc1tpXS5nZXRPdGhlckVuZChub2RlKTtcblxuICAgIC8vIERvbid0IGJhY2sgdHJhdmVyc2UgdG8gcm9vdCBub2RlIGluIGN1cnJlbnQgdHJlZS5cbiAgICBpZiAoY3VycmVudE5laWdoYm9yID09IHBhcmVudE9mTm9kZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkU3RhcnRBbmdsZSA9IChzdGFydEFuZ2xlICsgYnJhbmNoQ291bnQgKiBzdGVwQW5nbGUpICUgMzYwO1xuICAgIHZhciBjaGlsZEVuZEFuZ2xlID0gKGNoaWxkU3RhcnRBbmdsZSArIHN0ZXBBbmdsZSkgJSAzNjA7XG5cbiAgICBDb1NFTGF5b3V0LmJyYW5jaFJhZGlhbExheW91dChjdXJyZW50TmVpZ2hib3IsIG5vZGUsIGNoaWxkU3RhcnRBbmdsZSwgY2hpbGRFbmRBbmdsZSwgZGlzdGFuY2UgKyByYWRpYWxTZXBhcmF0aW9uLCByYWRpYWxTZXBhcmF0aW9uKTtcblxuICAgIGJyYW5jaENvdW50Kys7XG4gIH1cbn07XG5cbkNvU0VMYXlvdXQubWF4RGlhZ29uYWxJblRyZWUgPSBmdW5jdGlvbiAodHJlZSkge1xuICB2YXIgbWF4RGlhZ29uYWwgPSBJbnRlZ2VyLk1JTl9WQUxVRTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IHRyZWVbaV07XG4gICAgdmFyIGRpYWdvbmFsID0gbm9kZS5nZXREaWFnb25hbCgpO1xuXG4gICAgaWYgKGRpYWdvbmFsID4gbWF4RGlhZ29uYWwpIHtcbiAgICAgIG1heERpYWdvbmFsID0gZGlhZ29uYWw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1heERpYWdvbmFsO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUuY2FsY1JlcHVsc2lvblJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAvLyBmb3JtdWxhIGlzIDIgeCAobGV2ZWwgKyAxKSB4IGlkZWFsRWRnZUxlbmd0aFxuICByZXR1cm4gMiAqICh0aGlzLmxldmVsICsgMSkgKiB0aGlzLmlkZWFsRWRnZUxlbmd0aDtcbn07XG5cbi8vIFRpbGluZyBtZXRob2RzXG5cbi8vIEdyb3VwIHplcm8gZGVncmVlIG1lbWJlcnMgd2hvc2UgcGFyZW50cyBhcmUgbm90IHRvIGJlIHRpbGVkLCBjcmVhdGUgZHVtbXkgcGFyZW50cyB3aGVyZSBuZWVkZWQgYW5kIGZpbGwgbWVtYmVyR3JvdXBzIGJ5IHRoZWlyIGR1bW1wIHBhcmVudCBpZCdzXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5ncm91cFplcm9EZWdyZWVNZW1iZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIC8vIGFycmF5IG9mIFtwYXJlbnRfaWQgeCBvbmVEZWdyZWVOb2RlX2lkXVxuICB2YXIgdGVtcE1lbWJlckdyb3VwcyA9IHt9OyAvLyBBIHRlbXBvcmFyeSBtYXAgb2YgcGFyZW50IG5vZGUgYW5kIGl0cyB6ZXJvIGRlZ3JlZSBtZW1iZXJzXG4gIHRoaXMubWVtYmVyR3JvdXBzID0ge307IC8vIEEgbWFwIG9mIGR1bW15IHBhcmVudCBub2RlIGFuZCBpdHMgemVybyBkZWdyZWUgbWVtYmVycyB3aG9zZSBwYXJlbnRzIGFyZSBub3QgdG8gYmUgdGlsZWRcbiAgdGhpcy5pZFRvRHVtbXlOb2RlID0ge307IC8vIEEgbWFwIG9mIGlkIHRvIGR1bW15IG5vZGUgXG5cbiAgdmFyIHplcm9EZWdyZWUgPSBbXTsgLy8gTGlzdCBvZiB6ZXJvIGRlZ3JlZSBub2RlcyB3aG9zZSBwYXJlbnRzIGFyZSBub3QgdG8gYmUgdGlsZWRcbiAgdmFyIGFsbE5vZGVzID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsTm9kZXMoKTtcblxuICAvLyBGaWxsIHplcm8gZGVncmVlIGxpc3RcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gYWxsTm9kZXNbaV07XG4gICAgdmFyIHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgLy8gSWYgYSBub2RlIGhhcyB6ZXJvIGRlZ3JlZSBhbmQgaXRzIHBhcmVudCBpcyBub3QgdG8gYmUgdGlsZWQgaWYgZXhpc3RzIGFkZCB0aGF0IG5vZGUgdG8gemVyb0RlZ3JlcyBsaXN0XG4gICAgaWYgKHRoaXMuZ2V0Tm9kZURlZ3JlZVdpdGhDaGlsZHJlbihub2RlKSA9PT0gMCAmJiAocGFyZW50LmlkID09IHVuZGVmaW5lZCB8fCAhdGhpcy5nZXRUb0JlVGlsZWQocGFyZW50KSkpIHtcbiAgICAgIHplcm9EZWdyZWUucHVzaChub2RlKTtcbiAgICB9XG4gIH1cblxuICAvLyBDcmVhdGUgYSBtYXAgb2YgcGFyZW50IG5vZGUgYW5kIGl0cyB6ZXJvIGRlZ3JlZSBtZW1iZXJzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgemVyb0RlZ3JlZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gemVyb0RlZ3JlZVtpXTsgLy8gWmVybyBkZWdyZWUgbm9kZSBpdHNlbGZcbiAgICB2YXIgcF9pZCA9IG5vZGUuZ2V0UGFyZW50KCkuaWQ7IC8vIFBhcmVudCBpZFxuXG4gICAgaWYgKHR5cGVvZiB0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdID09PSBcInVuZGVmaW5lZFwiKSB0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdID0gW107XG5cbiAgICB0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdID0gdGVtcE1lbWJlckdyb3Vwc1twX2lkXS5jb25jYXQobm9kZSk7IC8vIFB1c2ggbm9kZSB0byB0aGUgbGlzdCBiZWxvbmdzIHRvIGl0cyBwYXJlbnQgaW4gdGVtcE1lbWJlckdyb3Vwc1xuICB9XG5cbiAgLy8gSWYgdGhlcmUgYXJlIGF0IGxlYXN0IHR3byBub2RlcyBhdCBhIGxldmVsLCBjcmVhdGUgYSBkdW1teSBjb21wb3VuZCBmb3IgdGhlbVxuICBPYmplY3Qua2V5cyh0ZW1wTWVtYmVyR3JvdXBzKS5mb3JFYWNoKGZ1bmN0aW9uIChwX2lkKSB7XG4gICAgaWYgKHRlbXBNZW1iZXJHcm91cHNbcF9pZF0ubGVuZ3RoID4gMSkge1xuICAgICAgdmFyIGR1bW15Q29tcG91bmRJZCA9IFwiRHVtbXlDb21wb3VuZF9cIiArIHBfaWQ7IC8vIFRoZSBpZCBvZiBkdW1teSBjb21wb3VuZCB3aGljaCB3aWxsIGJlIGNyZWF0ZWQgc29vblxuICAgICAgc2VsZi5tZW1iZXJHcm91cHNbZHVtbXlDb21wb3VuZElkXSA9IHRlbXBNZW1iZXJHcm91cHNbcF9pZF07IC8vIEFkZCBkdW1teSBjb21wb3VuZCB0byBtZW1iZXJHcm91cHNcblxuICAgICAgdmFyIHBhcmVudCA9IHRlbXBNZW1iZXJHcm91cHNbcF9pZF1bMF0uZ2V0UGFyZW50KCk7IC8vIFRoZSBwYXJlbnQgb2YgemVybyBkZWdyZWUgbm9kZXMgd2lsbCBiZSB0aGUgcGFyZW50IG9mIG5ldyBkdW1teSBjb21wb3VuZFxuXG4gICAgICAvLyBDcmVhdGUgYSBkdW1teSBjb21wb3VuZCB3aXRoIGNhbGN1bGF0ZWQgaWRcbiAgICAgIHZhciBkdW1teUNvbXBvdW5kID0gbmV3IENvU0VOb2RlKHNlbGYuZ3JhcGhNYW5hZ2VyKTtcbiAgICAgIGR1bW15Q29tcG91bmQuaWQgPSBkdW1teUNvbXBvdW5kSWQ7XG4gICAgICBkdW1teUNvbXBvdW5kLnBhZGRpbmdMZWZ0ID0gcGFyZW50LnBhZGRpbmdMZWZ0IHx8IDA7XG4gICAgICBkdW1teUNvbXBvdW5kLnBhZGRpbmdSaWdodCA9IHBhcmVudC5wYWRkaW5nUmlnaHQgfHwgMDtcbiAgICAgIGR1bW15Q29tcG91bmQucGFkZGluZ0JvdHRvbSA9IHBhcmVudC5wYWRkaW5nQm90dG9tIHx8IDA7XG4gICAgICBkdW1teUNvbXBvdW5kLnBhZGRpbmdUb3AgPSBwYXJlbnQucGFkZGluZ1RvcCB8fCAwO1xuXG4gICAgICBzZWxmLmlkVG9EdW1teU5vZGVbZHVtbXlDb21wb3VuZElkXSA9IGR1bW15Q29tcG91bmQ7XG5cbiAgICAgIHZhciBkdW1teVBhcmVudEdyYXBoID0gc2VsZi5nZXRHcmFwaE1hbmFnZXIoKS5hZGQoc2VsZi5uZXdHcmFwaCgpLCBkdW1teUNvbXBvdW5kKTtcbiAgICAgIHZhciBwYXJlbnRHcmFwaCA9IHBhcmVudC5nZXRDaGlsZCgpO1xuXG4gICAgICAvLyBBZGQgZHVtbXkgY29tcG91bmQgdG8gcGFyZW50IHRoZSBncmFwaFxuICAgICAgcGFyZW50R3JhcGguYWRkKGR1bW15Q29tcG91bmQpO1xuXG4gICAgICAvLyBGb3IgZWFjaCB6ZXJvIGRlZ3JlZSBub2RlIGluIHRoaXMgbGV2ZWwgcmVtb3ZlIGl0IGZyb20gaXRzIHBhcmVudCBncmFwaCBhbmQgYWRkIGl0IHRvIHRoZSBncmFwaCBvZiBkdW1teSBwYXJlbnRcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGVtcE1lbWJlckdyb3Vwc1twX2lkXS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IHRlbXBNZW1iZXJHcm91cHNbcF9pZF1baV07XG5cbiAgICAgICAgcGFyZW50R3JhcGgucmVtb3ZlKG5vZGUpO1xuICAgICAgICBkdW1teVBhcmVudEdyYXBoLmFkZChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUuY2xlYXJDb21wb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjaGlsZEdyYXBoTWFwID0ge307XG4gIHZhciBpZFRvTm9kZSA9IHt9O1xuXG4gIC8vIEdldCBjb21wb3VuZCBvcmRlcmluZyBieSBmaW5kaW5nIHRoZSBpbm5lciBvbmUgZmlyc3RcbiAgdGhpcy5wZXJmb3JtREZTT25Db21wb3VuZHMoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29tcG91bmRPcmRlci5sZW5ndGg7IGkrKykge1xuXG4gICAgaWRUb05vZGVbdGhpcy5jb21wb3VuZE9yZGVyW2ldLmlkXSA9IHRoaXMuY29tcG91bmRPcmRlcltpXTtcbiAgICBjaGlsZEdyYXBoTWFwW3RoaXMuY29tcG91bmRPcmRlcltpXS5pZF0gPSBbXS5jb25jYXQodGhpcy5jb21wb3VuZE9yZGVyW2ldLmdldENoaWxkKCkuZ2V0Tm9kZXMoKSk7XG5cbiAgICAvLyBSZW1vdmUgY2hpbGRyZW4gb2YgY29tcG91bmRzXG4gICAgdGhpcy5ncmFwaE1hbmFnZXIucmVtb3ZlKHRoaXMuY29tcG91bmRPcmRlcltpXS5nZXRDaGlsZCgpKTtcbiAgICB0aGlzLmNvbXBvdW5kT3JkZXJbaV0uY2hpbGQgPSBudWxsO1xuICB9XG5cbiAgdGhpcy5ncmFwaE1hbmFnZXIucmVzZXRBbGxOb2RlcygpO1xuXG4gIC8vIFRpbGUgdGhlIHJlbW92ZWQgY2hpbGRyZW5cbiAgdGhpcy50aWxlQ29tcG91bmRNZW1iZXJzKGNoaWxkR3JhcGhNYXAsIGlkVG9Ob2RlKTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmNsZWFyWmVyb0RlZ3JlZU1lbWJlcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHRpbGVkWmVyb0RlZ3JlZVBhY2sgPSB0aGlzLnRpbGVkWmVyb0RlZ3JlZVBhY2sgPSBbXTtcblxuICBPYmplY3Qua2V5cyh0aGlzLm1lbWJlckdyb3VwcykuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgY29tcG91bmROb2RlID0gc2VsZi5pZFRvRHVtbXlOb2RlW2lkXTsgLy8gR2V0IHRoZSBkdW1teSBjb21wb3VuZFxuXG4gICAgdGlsZWRaZXJvRGVncmVlUGFja1tpZF0gPSBzZWxmLnRpbGVOb2RlcyhzZWxmLm1lbWJlckdyb3Vwc1tpZF0sIGNvbXBvdW5kTm9kZS5wYWRkaW5nTGVmdCArIGNvbXBvdW5kTm9kZS5wYWRkaW5nUmlnaHQpO1xuXG4gICAgLy8gU2V0IHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBkdW1teSBjb21wb3VuZCBhcyBjYWxjdWxhdGVkXG4gICAgY29tcG91bmROb2RlLnJlY3Qud2lkdGggPSB0aWxlZFplcm9EZWdyZWVQYWNrW2lkXS53aWR0aDtcbiAgICBjb21wb3VuZE5vZGUucmVjdC5oZWlnaHQgPSB0aWxlZFplcm9EZWdyZWVQYWNrW2lkXS5oZWlnaHQ7XG4gIH0pO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUucmVwb3B1bGF0ZUNvbXBvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IHRoaXMuY29tcG91bmRPcmRlci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsQ29tcG91bmROb2RlID0gdGhpcy5jb21wb3VuZE9yZGVyW2ldO1xuICAgIHZhciBpZCA9IGxDb21wb3VuZE5vZGUuaWQ7XG4gICAgdmFyIGhvcml6b250YWxNYXJnaW4gPSBsQ29tcG91bmROb2RlLnBhZGRpbmdMZWZ0O1xuICAgIHZhciB2ZXJ0aWNhbE1hcmdpbiA9IGxDb21wb3VuZE5vZGUucGFkZGluZ1RvcDtcblxuICAgIHRoaXMuYWRqdXN0TG9jYXRpb25zKHRoaXMudGlsZWRNZW1iZXJQYWNrW2lkXSwgbENvbXBvdW5kTm9kZS5yZWN0LngsIGxDb21wb3VuZE5vZGUucmVjdC55LCBob3Jpem9udGFsTWFyZ2luLCB2ZXJ0aWNhbE1hcmdpbik7XG4gIH1cbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnJlcG9wdWxhdGVaZXJvRGVncmVlTWVtYmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdGlsZWRQYWNrID0gdGhpcy50aWxlZFplcm9EZWdyZWVQYWNrO1xuXG4gIE9iamVjdC5rZXlzKHRpbGVkUGFjaykuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgY29tcG91bmROb2RlID0gc2VsZi5pZFRvRHVtbXlOb2RlW2lkXTsgLy8gR2V0IHRoZSBkdW1teSBjb21wb3VuZCBieSBpdHMgaWRcbiAgICB2YXIgaG9yaXpvbnRhbE1hcmdpbiA9IGNvbXBvdW5kTm9kZS5wYWRkaW5nTGVmdDtcbiAgICB2YXIgdmVydGljYWxNYXJnaW4gPSBjb21wb3VuZE5vZGUucGFkZGluZ1RvcDtcblxuICAgIC8vIEFkanVzdCB0aGUgcG9zaXRpb25zIG9mIG5vZGVzIHdydCBpdHMgY29tcG91bmRcbiAgICBzZWxmLmFkanVzdExvY2F0aW9ucyh0aWxlZFBhY2tbaWRdLCBjb21wb3VuZE5vZGUucmVjdC54LCBjb21wb3VuZE5vZGUucmVjdC55LCBob3Jpem9udGFsTWFyZ2luLCB2ZXJ0aWNhbE1hcmdpbik7XG4gIH0pO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUuZ2V0VG9CZVRpbGVkID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdmFyIGlkID0gbm9kZS5pZDtcbiAgLy9maXJzdGx5IGNoZWNrIHRoZSBwcmV2aW91cyByZXN1bHRzXG4gIGlmICh0aGlzLnRvQmVUaWxlZFtpZF0gIT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLnRvQmVUaWxlZFtpZF07XG4gIH1cblxuICAvL29ubHkgY29tcG91bmQgbm9kZXMgYXJlIHRvIGJlIHRpbGVkXG4gIHZhciBjaGlsZEdyYXBoID0gbm9kZS5nZXRDaGlsZCgpO1xuICBpZiAoY2hpbGRHcmFwaCA9PSBudWxsKSB7XG4gICAgdGhpcy50b0JlVGlsZWRbaWRdID0gZmFsc2U7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGNoaWxkcmVuID0gY2hpbGRHcmFwaC5nZXROb2RlcygpOyAvLyBHZXQgdGhlIGNoaWxkcmVuIG5vZGVzXG5cbiAgLy9hIGNvbXBvdW5kIG5vZGUgaXMgbm90IHRvIGJlIHRpbGVkIGlmIGFsbCBvZiBpdHMgY29tcG91bmQgY2hpbGRyZW4gYXJlIG5vdCB0byBiZSB0aWxlZFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRoZUNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICBpZiAodGhpcy5nZXROb2RlRGVncmVlKHRoZUNoaWxkKSA+IDApIHtcbiAgICAgIHRoaXMudG9CZVRpbGVkW2lkXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vcGFzcyB0aGUgY2hpbGRyZW4gbm90IGhhdmluZyB0aGUgY29tcG91bmQgc3RydWN0dXJlXG4gICAgaWYgKHRoZUNoaWxkLmdldENoaWxkKCkgPT0gbnVsbCkge1xuICAgICAgdGhpcy50b0JlVGlsZWRbdGhlQ2hpbGQuaWRdID0gZmFsc2U7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZ2V0VG9CZVRpbGVkKHRoZUNoaWxkKSkge1xuICAgICAgdGhpcy50b0JlVGlsZWRbaWRdID0gZmFsc2U7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHRoaXMudG9CZVRpbGVkW2lkXSA9IHRydWU7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gR2V0IGRlZ3JlZSBvZiBhIG5vZGUgZGVwZW5kaW5nIG9mIGl0cyBlZGdlcyBhbmQgaW5kZXBlbmRlbnQgb2YgaXRzIGNoaWxkcmVuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5nZXROb2RlRGVncmVlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdmFyIGlkID0gbm9kZS5pZDtcbiAgdmFyIGVkZ2VzID0gbm9kZS5nZXRFZGdlcygpO1xuICB2YXIgZGVncmVlID0gMDtcblxuICAvLyBGb3IgdGhlIGVkZ2VzIGNvbm5lY3RlZFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICBpZiAoZWRnZS5nZXRTb3VyY2UoKS5pZCAhPT0gZWRnZS5nZXRUYXJnZXQoKS5pZCkge1xuICAgICAgZGVncmVlID0gZGVncmVlICsgMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlZ3JlZTtcbn07XG5cbi8vIEdldCBkZWdyZWUgb2YgYSBub2RlIHdpdGggaXRzIGNoaWxkcmVuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5nZXROb2RlRGVncmVlV2l0aENoaWxkcmVuID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdmFyIGRlZ3JlZSA9IHRoaXMuZ2V0Tm9kZURlZ3JlZShub2RlKTtcbiAgaWYgKG5vZGUuZ2V0Q2hpbGQoKSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGRlZ3JlZTtcbiAgfVxuICB2YXIgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkKCkuZ2V0Tm9kZXMoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIGRlZ3JlZSArPSB0aGlzLmdldE5vZGVEZWdyZWVXaXRoQ2hpbGRyZW4oY2hpbGQpO1xuICB9XG4gIHJldHVybiBkZWdyZWU7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5wZXJmb3JtREZTT25Db21wb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuY29tcG91bmRPcmRlciA9IFtdO1xuICB0aGlzLmZpbGxDb21wZXhPcmRlckJ5REZTKHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKS5nZXROb2RlcygpKTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmZpbGxDb21wZXhPcmRlckJ5REZTID0gZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoY2hpbGQuZ2V0Q2hpbGQoKSAhPSBudWxsKSB7XG4gICAgICB0aGlzLmZpbGxDb21wZXhPcmRlckJ5REZTKGNoaWxkLmdldENoaWxkKCkuZ2V0Tm9kZXMoKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmdldFRvQmVUaWxlZChjaGlsZCkpIHtcbiAgICAgIHRoaXMuY29tcG91bmRPcmRlci5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuKiBUaGlzIG1ldGhvZCBwbGFjZXMgZWFjaCB6ZXJvIGRlZ3JlZSBtZW1iZXIgd3J0IGdpdmVuICh4LHkpIGNvb3JkaW5hdGVzICh0b3AgbGVmdCkuXG4qL1xuQ29TRUxheW91dC5wcm90b3R5cGUuYWRqdXN0TG9jYXRpb25zID0gZnVuY3Rpb24gKG9yZ2FuaXphdGlvbiwgeCwgeSwgY29tcG91bmRIb3Jpem9udGFsTWFyZ2luLCBjb21wb3VuZFZlcnRpY2FsTWFyZ2luKSB7XG4gIHggKz0gY29tcG91bmRIb3Jpem9udGFsTWFyZ2luO1xuICB5ICs9IGNvbXBvdW5kVmVydGljYWxNYXJnaW47XG5cbiAgdmFyIGxlZnQgPSB4O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcm93ID0gb3JnYW5pemF0aW9uLnJvd3NbaV07XG4gICAgeCA9IGxlZnQ7XG4gICAgdmFyIG1heEhlaWdodCA9IDA7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJvdy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGxub2RlID0gcm93W2pdO1xuXG4gICAgICBsbm9kZS5yZWN0LnggPSB4OyAvLyArIGxub2RlLnJlY3Qud2lkdGggLyAyO1xuICAgICAgbG5vZGUucmVjdC55ID0geTsgLy8gKyBsbm9kZS5yZWN0LmhlaWdodCAvIDI7XG5cbiAgICAgIHggKz0gbG5vZGUucmVjdC53aWR0aCArIG9yZ2FuaXphdGlvbi5ob3Jpem9udGFsUGFkZGluZztcblxuICAgICAgaWYgKGxub2RlLnJlY3QuaGVpZ2h0ID4gbWF4SGVpZ2h0KSBtYXhIZWlnaHQgPSBsbm9kZS5yZWN0LmhlaWdodDtcbiAgICB9XG5cbiAgICB5ICs9IG1heEhlaWdodCArIG9yZ2FuaXphdGlvbi52ZXJ0aWNhbFBhZGRpbmc7XG4gIH1cbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnRpbGVDb21wb3VuZE1lbWJlcnMgPSBmdW5jdGlvbiAoY2hpbGRHcmFwaE1hcCwgaWRUb05vZGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnRpbGVkTWVtYmVyUGFjayA9IFtdO1xuXG4gIE9iamVjdC5rZXlzKGNoaWxkR3JhcGhNYXApLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgLy8gR2V0IHRoZSBjb21wb3VuZCBub2RlXG4gICAgdmFyIGNvbXBvdW5kTm9kZSA9IGlkVG9Ob2RlW2lkXTtcblxuICAgIHNlbGYudGlsZWRNZW1iZXJQYWNrW2lkXSA9IHNlbGYudGlsZU5vZGVzKGNoaWxkR3JhcGhNYXBbaWRdLCBjb21wb3VuZE5vZGUucGFkZGluZ0xlZnQgKyBjb21wb3VuZE5vZGUucGFkZGluZ1JpZ2h0KTtcblxuICAgIGNvbXBvdW5kTm9kZS5yZWN0LndpZHRoID0gc2VsZi50aWxlZE1lbWJlclBhY2tbaWRdLndpZHRoO1xuICAgIGNvbXBvdW5kTm9kZS5yZWN0LmhlaWdodCA9IHNlbGYudGlsZWRNZW1iZXJQYWNrW2lkXS5oZWlnaHQ7XG4gIH0pO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUudGlsZU5vZGVzID0gZnVuY3Rpb24gKG5vZGVzLCBtaW5XaWR0aCkge1xuICB2YXIgdmVydGljYWxQYWRkaW5nID0gQ29TRUNvbnN0YW50cy5USUxJTkdfUEFERElOR19WRVJUSUNBTDtcbiAgdmFyIGhvcml6b250YWxQYWRkaW5nID0gQ29TRUNvbnN0YW50cy5USUxJTkdfUEFERElOR19IT1JJWk9OVEFMO1xuICB2YXIgb3JnYW5pemF0aW9uID0ge1xuICAgIHJvd3M6IFtdLFxuICAgIHJvd1dpZHRoOiBbXSxcbiAgICByb3dIZWlnaHQ6IFtdLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogbWluV2lkdGgsIC8vIGFzc3VtZSBtaW5IZWlnaHQgZXF1YWxzIHRvIG1pbldpZHRoXG4gICAgdmVydGljYWxQYWRkaW5nOiB2ZXJ0aWNhbFBhZGRpbmcsXG4gICAgaG9yaXpvbnRhbFBhZGRpbmc6IGhvcml6b250YWxQYWRkaW5nXG4gIH07XG5cbiAgLy8gU29ydCB0aGUgbm9kZXMgaW4gYXNjZW5kaW5nIG9yZGVyIG9mIHRoZWlyIGFyZWFzXG4gIG5vZGVzLnNvcnQoZnVuY3Rpb24gKG4xLCBuMikge1xuICAgIGlmIChuMS5yZWN0LndpZHRoICogbjEucmVjdC5oZWlnaHQgPiBuMi5yZWN0LndpZHRoICogbjIucmVjdC5oZWlnaHQpIHJldHVybiAtMTtcbiAgICBpZiAobjEucmVjdC53aWR0aCAqIG4xLnJlY3QuaGVpZ2h0IDwgbjIucmVjdC53aWR0aCAqIG4yLnJlY3QuaGVpZ2h0KSByZXR1cm4gMTtcbiAgICByZXR1cm4gMDtcbiAgfSk7XG5cbiAgLy8gQ3JlYXRlIHRoZSBvcmdhbml6YXRpb24gLT4gdGlsZSBtZW1iZXJzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbE5vZGUgPSBub2Rlc1tpXTtcblxuICAgIGlmIChvcmdhbml6YXRpb24ucm93cy5sZW5ndGggPT0gMCkge1xuICAgICAgdGhpcy5pbnNlcnROb2RlVG9Sb3cob3JnYW5pemF0aW9uLCBsTm9kZSwgMCwgbWluV2lkdGgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jYW5BZGRIb3Jpem9udGFsKG9yZ2FuaXphdGlvbiwgbE5vZGUucmVjdC53aWR0aCwgbE5vZGUucmVjdC5oZWlnaHQpKSB7XG4gICAgICB0aGlzLmluc2VydE5vZGVUb1Jvdyhvcmdhbml6YXRpb24sIGxOb2RlLCB0aGlzLmdldFNob3J0ZXN0Um93SW5kZXgob3JnYW5pemF0aW9uKSwgbWluV2lkdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmluc2VydE5vZGVUb1Jvdyhvcmdhbml6YXRpb24sIGxOb2RlLCBvcmdhbml6YXRpb24ucm93cy5sZW5ndGgsIG1pbldpZHRoKTtcbiAgICB9XG5cbiAgICB0aGlzLnNoaWZ0VG9MYXN0Um93KG9yZ2FuaXphdGlvbik7XG4gIH1cblxuICByZXR1cm4gb3JnYW5pemF0aW9uO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUuaW5zZXJ0Tm9kZVRvUm93ID0gZnVuY3Rpb24gKG9yZ2FuaXphdGlvbiwgbm9kZSwgcm93SW5kZXgsIG1pbldpZHRoKSB7XG4gIHZhciBtaW5Db21wb3VuZFNpemUgPSBtaW5XaWR0aDtcblxuICAvLyBBZGQgbmV3IHJvdyBpZiBuZWVkZWRcbiAgaWYgKHJvd0luZGV4ID09IG9yZ2FuaXphdGlvbi5yb3dzLmxlbmd0aCkge1xuICAgIHZhciBzZWNvbmREaW1lbnNpb24gPSBbXTtcblxuICAgIG9yZ2FuaXphdGlvbi5yb3dzLnB1c2goc2Vjb25kRGltZW5zaW9uKTtcbiAgICBvcmdhbml6YXRpb24ucm93V2lkdGgucHVzaChtaW5Db21wb3VuZFNpemUpO1xuICAgIG9yZ2FuaXphdGlvbi5yb3dIZWlnaHQucHVzaCgwKTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSByb3cgd2lkdGhcbiAgdmFyIHcgPSBvcmdhbml6YXRpb24ucm93V2lkdGhbcm93SW5kZXhdICsgbm9kZS5yZWN0LndpZHRoO1xuXG4gIGlmIChvcmdhbml6YXRpb24ucm93c1tyb3dJbmRleF0ubGVuZ3RoID4gMCkge1xuICAgIHcgKz0gb3JnYW5pemF0aW9uLmhvcml6b250YWxQYWRkaW5nO1xuICB9XG5cbiAgb3JnYW5pemF0aW9uLnJvd1dpZHRoW3Jvd0luZGV4XSA9IHc7XG4gIC8vIFVwZGF0ZSBjb21wb3VuZCB3aWR0aFxuICBpZiAob3JnYW5pemF0aW9uLndpZHRoIDwgdykge1xuICAgIG9yZ2FuaXphdGlvbi53aWR0aCA9IHc7XG4gIH1cblxuICAvLyBVcGRhdGUgaGVpZ2h0XG4gIHZhciBoID0gbm9kZS5yZWN0LmhlaWdodDtcbiAgaWYgKHJvd0luZGV4ID4gMCkgaCArPSBvcmdhbml6YXRpb24udmVydGljYWxQYWRkaW5nO1xuXG4gIHZhciBleHRyYUhlaWdodCA9IDA7XG4gIGlmIChoID4gb3JnYW5pemF0aW9uLnJvd0hlaWdodFtyb3dJbmRleF0pIHtcbiAgICBleHRyYUhlaWdodCA9IG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbcm93SW5kZXhdO1xuICAgIG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbcm93SW5kZXhdID0gaDtcbiAgICBleHRyYUhlaWdodCA9IG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbcm93SW5kZXhdIC0gZXh0cmFIZWlnaHQ7XG4gIH1cblxuICBvcmdhbml6YXRpb24uaGVpZ2h0ICs9IGV4dHJhSGVpZ2h0O1xuXG4gIC8vIEluc2VydCBub2RlXG4gIG9yZ2FuaXphdGlvbi5yb3dzW3Jvd0luZGV4XS5wdXNoKG5vZGUpO1xufTtcblxuLy9TY2FucyB0aGUgcm93cyBvZiBhbiBvcmdhbml6YXRpb24gYW5kIHJldHVybnMgdGhlIG9uZSB3aXRoIHRoZSBtaW4gd2lkdGhcbkNvU0VMYXlvdXQucHJvdG90eXBlLmdldFNob3J0ZXN0Um93SW5kZXggPSBmdW5jdGlvbiAob3JnYW5pemF0aW9uKSB7XG4gIHZhciByID0gLTE7XG4gIHZhciBtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAob3JnYW5pemF0aW9uLnJvd1dpZHRoW2ldIDwgbWluKSB7XG4gICAgICByID0gaTtcbiAgICAgIG1pbiA9IG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHI7XG59O1xuXG4vL1NjYW5zIHRoZSByb3dzIG9mIGFuIG9yZ2FuaXphdGlvbiBhbmQgcmV0dXJucyB0aGUgb25lIHdpdGggdGhlIG1heCB3aWR0aFxuQ29TRUxheW91dC5wcm90b3R5cGUuZ2V0TG9uZ2VzdFJvd0luZGV4ID0gZnVuY3Rpb24gKG9yZ2FuaXphdGlvbikge1xuICB2YXIgciA9IC0xO1xuICB2YXIgbWF4ID0gTnVtYmVyLk1JTl9WQUxVRTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZ2FuaXphdGlvbi5yb3dzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICBpZiAob3JnYW5pemF0aW9uLnJvd1dpZHRoW2ldID4gbWF4KSB7XG4gICAgICByID0gaTtcbiAgICAgIG1heCA9IG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcjtcbn07XG5cbi8qKlxuKiBUaGlzIG1ldGhvZCBjaGVja3Mgd2hldGhlciBhZGRpbmcgZXh0cmEgd2lkdGggdG8gdGhlIG9yZ2FuaXphdGlvbiB2aW9sYXRlc1xuKiB0aGUgYXNwZWN0IHJhdGlvKDEpIG9yIG5vdC5cbiovXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jYW5BZGRIb3Jpem9udGFsID0gZnVuY3Rpb24gKG9yZ2FuaXphdGlvbiwgZXh0cmFXaWR0aCwgZXh0cmFIZWlnaHQpIHtcblxuICB2YXIgc3JpID0gdGhpcy5nZXRTaG9ydGVzdFJvd0luZGV4KG9yZ2FuaXphdGlvbik7XG5cbiAgaWYgKHNyaSA8IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBtaW4gPSBvcmdhbml6YXRpb24ucm93V2lkdGhbc3JpXTtcblxuICBpZiAobWluICsgb3JnYW5pemF0aW9uLmhvcml6b250YWxQYWRkaW5nICsgZXh0cmFXaWR0aCA8PSBvcmdhbml6YXRpb24ud2lkdGgpIHJldHVybiB0cnVlO1xuXG4gIHZhciBoRGlmZiA9IDA7XG5cbiAgLy8gQWRkaW5nIHRvIGFuIGV4aXN0aW5nIHJvd1xuICBpZiAob3JnYW5pemF0aW9uLnJvd0hlaWdodFtzcmldIDwgZXh0cmFIZWlnaHQpIHtcbiAgICBpZiAoc3JpID4gMCkgaERpZmYgPSBleHRyYUhlaWdodCArIG9yZ2FuaXphdGlvbi52ZXJ0aWNhbFBhZGRpbmcgLSBvcmdhbml6YXRpb24ucm93SGVpZ2h0W3NyaV07XG4gIH1cblxuICB2YXIgYWRkX3RvX3Jvd19yYXRpbztcbiAgaWYgKG9yZ2FuaXphdGlvbi53aWR0aCAtIG1pbiA+PSBleHRyYVdpZHRoICsgb3JnYW5pemF0aW9uLmhvcml6b250YWxQYWRkaW5nKSB7XG4gICAgYWRkX3RvX3Jvd19yYXRpbyA9IChvcmdhbml6YXRpb24uaGVpZ2h0ICsgaERpZmYpIC8gKG1pbiArIGV4dHJhV2lkdGggKyBvcmdhbml6YXRpb24uaG9yaXpvbnRhbFBhZGRpbmcpO1xuICB9IGVsc2Uge1xuICAgIGFkZF90b19yb3dfcmF0aW8gPSAob3JnYW5pemF0aW9uLmhlaWdodCArIGhEaWZmKSAvIG9yZ2FuaXphdGlvbi53aWR0aDtcbiAgfVxuXG4gIC8vIEFkZGluZyBhIG5ldyByb3cgZm9yIHRoaXMgbm9kZVxuICBoRGlmZiA9IGV4dHJhSGVpZ2h0ICsgb3JnYW5pemF0aW9uLnZlcnRpY2FsUGFkZGluZztcbiAgdmFyIGFkZF9uZXdfcm93X3JhdGlvO1xuICBpZiAob3JnYW5pemF0aW9uLndpZHRoIDwgZXh0cmFXaWR0aCkge1xuICAgIGFkZF9uZXdfcm93X3JhdGlvID0gKG9yZ2FuaXphdGlvbi5oZWlnaHQgKyBoRGlmZikgLyBleHRyYVdpZHRoO1xuICB9IGVsc2Uge1xuICAgIGFkZF9uZXdfcm93X3JhdGlvID0gKG9yZ2FuaXphdGlvbi5oZWlnaHQgKyBoRGlmZikgLyBvcmdhbml6YXRpb24ud2lkdGg7XG4gIH1cblxuICBpZiAoYWRkX25ld19yb3dfcmF0aW8gPCAxKSBhZGRfbmV3X3Jvd19yYXRpbyA9IDEgLyBhZGRfbmV3X3Jvd19yYXRpbztcblxuICBpZiAoYWRkX3RvX3Jvd19yYXRpbyA8IDEpIGFkZF90b19yb3dfcmF0aW8gPSAxIC8gYWRkX3RvX3Jvd19yYXRpbztcblxuICByZXR1cm4gYWRkX3RvX3Jvd19yYXRpbyA8IGFkZF9uZXdfcm93X3JhdGlvO1xufTtcblxuLy9JZiBtb3ZpbmcgdGhlIGxhc3Qgbm9kZSBmcm9tIHRoZSBsb25nZXN0IHJvdyBhbmQgYWRkaW5nIGl0IHRvIHRoZSBsYXN0XG4vL3JvdyBtYWtlcyB0aGUgYm91bmRpbmcgYm94IHNtYWxsZXIsIGRvIGl0LlxuQ29TRUxheW91dC5wcm90b3R5cGUuc2hpZnRUb0xhc3RSb3cgPSBmdW5jdGlvbiAob3JnYW5pemF0aW9uKSB7XG4gIHZhciBsb25nZXN0ID0gdGhpcy5nZXRMb25nZXN0Um93SW5kZXgob3JnYW5pemF0aW9uKTtcbiAgdmFyIGxhc3QgPSBvcmdhbml6YXRpb24ucm93V2lkdGgubGVuZ3RoIC0gMTtcbiAgdmFyIHJvdyA9IG9yZ2FuaXphdGlvbi5yb3dzW2xvbmdlc3RdO1xuICB2YXIgbm9kZSA9IHJvd1tyb3cubGVuZ3RoIC0gMV07XG5cbiAgdmFyIGRpZmYgPSBub2RlLndpZHRoICsgb3JnYW5pemF0aW9uLmhvcml6b250YWxQYWRkaW5nO1xuXG4gIC8vIENoZWNrIGlmIHRoZXJlIGlzIGVub3VnaCBzcGFjZSBvbiB0aGUgbGFzdCByb3dcbiAgaWYgKG9yZ2FuaXphdGlvbi53aWR0aCAtIG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtsYXN0XSA+IGRpZmYgJiYgbG9uZ2VzdCAhPSBsYXN0KSB7XG4gICAgLy8gUmVtb3ZlIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGxvbmdlc3Qgcm93XG4gICAgcm93LnNwbGljZSgtMSwgMSk7XG5cbiAgICAvLyBQdXNoIGl0IHRvIHRoZSBsYXN0IHJvd1xuICAgIG9yZ2FuaXphdGlvbi5yb3dzW2xhc3RdLnB1c2gobm9kZSk7XG5cbiAgICBvcmdhbml6YXRpb24ucm93V2lkdGhbbG9uZ2VzdF0gPSBvcmdhbml6YXRpb24ucm93V2lkdGhbbG9uZ2VzdF0gLSBkaWZmO1xuICAgIG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtsYXN0XSA9IG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtsYXN0XSArIGRpZmY7XG4gICAgb3JnYW5pemF0aW9uLndpZHRoID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW2luc3RhbmNlLmdldExvbmdlc3RSb3dJbmRleChvcmdhbml6YXRpb24pXTtcblxuICAgIC8vIFVwZGF0ZSBoZWlnaHRzIG9mIHRoZSBvcmdhbml6YXRpb25cbiAgICB2YXIgbWF4SGVpZ2h0ID0gTnVtYmVyLk1JTl9WQUxVRTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvdy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJvd1tpXS5oZWlnaHQgPiBtYXhIZWlnaHQpIG1heEhlaWdodCA9IHJvd1tpXS5oZWlnaHQ7XG4gICAgfVxuICAgIGlmIChsb25nZXN0ID4gMCkgbWF4SGVpZ2h0ICs9IG9yZ2FuaXphdGlvbi52ZXJ0aWNhbFBhZGRpbmc7XG5cbiAgICB2YXIgcHJldlRvdGFsID0gb3JnYW5pemF0aW9uLnJvd0hlaWdodFtsb25nZXN0XSArIG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbbGFzdF07XG5cbiAgICBvcmdhbml6YXRpb24ucm93SGVpZ2h0W2xvbmdlc3RdID0gbWF4SGVpZ2h0O1xuICAgIGlmIChvcmdhbml6YXRpb24ucm93SGVpZ2h0W2xhc3RdIDwgbm9kZS5oZWlnaHQgKyBvcmdhbml6YXRpb24udmVydGljYWxQYWRkaW5nKSBvcmdhbml6YXRpb24ucm93SGVpZ2h0W2xhc3RdID0gbm9kZS5oZWlnaHQgKyBvcmdhbml6YXRpb24udmVydGljYWxQYWRkaW5nO1xuXG4gICAgdmFyIGZpbmFsVG90YWwgPSBvcmdhbml6YXRpb24ucm93SGVpZ2h0W2xvbmdlc3RdICsgb3JnYW5pemF0aW9uLnJvd0hlaWdodFtsYXN0XTtcbiAgICBvcmdhbml6YXRpb24uaGVpZ2h0ICs9IGZpbmFsVG90YWwgLSBwcmV2VG90YWw7XG5cbiAgICB0aGlzLnNoaWZ0VG9MYXN0Um93KG9yZ2FuaXphdGlvbik7XG4gIH1cbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnRpbGluZ1ByZUxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKENvU0VDb25zdGFudHMuVElMRSkge1xuICAgIC8vIEZpbmQgemVybyBkZWdyZWUgbm9kZXMgYW5kIGNyZWF0ZSBhIGNvbXBvdW5kIGZvciBlYWNoIGxldmVsXG4gICAgdGhpcy5ncm91cFplcm9EZWdyZWVNZW1iZXJzKCk7XG4gICAgLy8gVGlsZSBhbmQgY2xlYXIgY2hpbGRyZW4gb2YgZWFjaCBjb21wb3VuZFxuICAgIHRoaXMuY2xlYXJDb21wb3VuZHMoKTtcbiAgICAvLyBTZXBhcmF0ZWx5IHRpbGUgYW5kIGNsZWFyIHplcm8gZGVncmVlIG5vZGVzIGZvciBlYWNoIGxldmVsXG4gICAgdGhpcy5jbGVhclplcm9EZWdyZWVNZW1iZXJzKCk7XG4gIH1cbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnRpbGluZ1Bvc3RMYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChDb1NFQ29uc3RhbnRzLlRJTEUpIHtcbiAgICB0aGlzLnJlcG9wdWxhdGVaZXJvRGVncmVlTWVtYmVycygpO1xuICAgIHRoaXMucmVwb3B1bGF0ZUNvbXBvdW5kcygpO1xuICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU2VjdGlvbjogVHJlZSBSZWR1Y3Rpb24gbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFJlZHVjZSB0cmVlcyBcbkNvU0VMYXlvdXQucHJvdG90eXBlLnJlZHVjZVRyZWVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcHJ1bmVkTm9kZXNBbGwgPSBbXTtcbiAgdmFyIGNvbnRhaW5zTGVhZiA9IHRydWU7XG4gIHZhciBub2RlO1xuXG4gIHdoaWxlIChjb250YWluc0xlYWYpIHtcbiAgICB2YXIgYWxsTm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxOb2RlcygpO1xuICAgIHZhciBwcnVuZWROb2Rlc0luU3RlcFRlbXAgPSBbXTtcbiAgICBjb250YWluc0xlYWYgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGUgPSBhbGxOb2Rlc1tpXTtcbiAgICAgIGlmIChub2RlLmdldEVkZ2VzKCkubGVuZ3RoID09IDEgJiYgIW5vZGUuZ2V0RWRnZXMoKVswXS5pc0ludGVyR3JhcGggJiYgbm9kZS5nZXRDaGlsZCgpID09IG51bGwpIHtcbiAgICAgICAgcHJ1bmVkTm9kZXNJblN0ZXBUZW1wLnB1c2goW25vZGUsIG5vZGUuZ2V0RWRnZXMoKVswXSwgbm9kZS5nZXRPd25lcigpXSk7XG4gICAgICAgIGNvbnRhaW5zTGVhZiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb250YWluc0xlYWYgPT0gdHJ1ZSkge1xuICAgICAgdmFyIHBydW5lZE5vZGVzSW5TdGVwID0gW107XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBydW5lZE5vZGVzSW5TdGVwVGVtcC5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocHJ1bmVkTm9kZXNJblN0ZXBUZW1wW2pdWzBdLmdldEVkZ2VzKCkubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICBwcnVuZWROb2Rlc0luU3RlcC5wdXNoKHBydW5lZE5vZGVzSW5TdGVwVGVtcFtqXSk7XG4gICAgICAgICAgcHJ1bmVkTm9kZXNJblN0ZXBUZW1wW2pdWzBdLmdldE93bmVyKCkucmVtb3ZlKHBydW5lZE5vZGVzSW5TdGVwVGVtcFtqXVswXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBydW5lZE5vZGVzQWxsLnB1c2gocHJ1bmVkTm9kZXNJblN0ZXApO1xuICAgICAgdGhpcy5ncmFwaE1hbmFnZXIucmVzZXRBbGxOb2RlcygpO1xuICAgICAgdGhpcy5ncmFwaE1hbmFnZXIucmVzZXRBbGxFZGdlcygpO1xuICAgIH1cbiAgfVxuICB0aGlzLnBydW5lZE5vZGVzQWxsID0gcHJ1bmVkTm9kZXNBbGw7XG59O1xuXG4vLyBHcm93IHRyZWUgb25lIHN0ZXAgXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5ncm93VHJlZSA9IGZ1bmN0aW9uIChwcnVuZWROb2Rlc0FsbCkge1xuICB2YXIgbGVuZ3RoT2ZQcnVuZWROb2Rlc0luU3RlcCA9IHBydW5lZE5vZGVzQWxsLmxlbmd0aDtcbiAgdmFyIHBydW5lZE5vZGVzSW5TdGVwID0gcHJ1bmVkTm9kZXNBbGxbbGVuZ3RoT2ZQcnVuZWROb2Rlc0luU3RlcCAtIDFdO1xuXG4gIHZhciBub2RlRGF0YTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcnVuZWROb2Rlc0luU3RlcC5sZW5ndGg7IGkrKykge1xuICAgIG5vZGVEYXRhID0gcHJ1bmVkTm9kZXNJblN0ZXBbaV07XG5cbiAgICB0aGlzLmZpbmRQbGFjZWZvclBydW5lZE5vZGUobm9kZURhdGEpO1xuXG4gICAgbm9kZURhdGFbMl0uYWRkKG5vZGVEYXRhWzBdKTtcbiAgICBub2RlRGF0YVsyXS5hZGQobm9kZURhdGFbMV0sIG5vZGVEYXRhWzFdLnNvdXJjZSwgbm9kZURhdGFbMV0udGFyZ2V0KTtcbiAgfVxuXG4gIHBydW5lZE5vZGVzQWxsLnNwbGljZShwcnVuZWROb2Rlc0FsbC5sZW5ndGggLSAxLCAxKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIucmVzZXRBbGxOb2RlcygpO1xuICB0aGlzLmdyYXBoTWFuYWdlci5yZXNldEFsbEVkZ2VzKCk7XG59O1xuXG4vLyBGaW5kIGFuIGFwcHJvcHJpYXRlIHBvc2l0aW9uIHRvIHJlcGxhY2UgcHJ1bmVkIG5vZGUsIHRoaXMgbWV0aG9kIGNhbiBiZSBpbXByb3ZlZFxuQ29TRUxheW91dC5wcm90b3R5cGUuZmluZFBsYWNlZm9yUHJ1bmVkTm9kZSA9IGZ1bmN0aW9uIChub2RlRGF0YSkge1xuXG4gIHZhciBncmlkRm9yUHJ1bmVkTm9kZTtcbiAgdmFyIG5vZGVUb0Nvbm5lY3Q7XG4gIHZhciBwcnVuZWROb2RlID0gbm9kZURhdGFbMF07XG4gIGlmIChwcnVuZWROb2RlID09IG5vZGVEYXRhWzFdLnNvdXJjZSkge1xuICAgIG5vZGVUb0Nvbm5lY3QgPSBub2RlRGF0YVsxXS50YXJnZXQ7XG4gIH0gZWxzZSB7XG4gICAgbm9kZVRvQ29ubmVjdCA9IG5vZGVEYXRhWzFdLnNvdXJjZTtcbiAgfVxuICB2YXIgc3RhcnRHcmlkWCA9IG5vZGVUb0Nvbm5lY3Quc3RhcnRYO1xuICB2YXIgZmluaXNoR3JpZFggPSBub2RlVG9Db25uZWN0LmZpbmlzaFg7XG4gIHZhciBzdGFydEdyaWRZID0gbm9kZVRvQ29ubmVjdC5zdGFydFk7XG4gIHZhciBmaW5pc2hHcmlkWSA9IG5vZGVUb0Nvbm5lY3QuZmluaXNoWTtcblxuICB2YXIgdXBOb2RlQ291bnQgPSAwO1xuICB2YXIgZG93bk5vZGVDb3VudCA9IDA7XG4gIHZhciByaWdodE5vZGVDb3VudCA9IDA7XG4gIHZhciBsZWZ0Tm9kZUNvdW50ID0gMDtcbiAgdmFyIGNvbnRyb2xSZWdpb25zID0gW3VwTm9kZUNvdW50LCByaWdodE5vZGVDb3VudCwgZG93bk5vZGVDb3VudCwgbGVmdE5vZGVDb3VudF07XG5cbiAgaWYgKHN0YXJ0R3JpZFkgPiAwKSB7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0R3JpZFg7IGkgPD0gZmluaXNoR3JpZFg7IGkrKykge1xuICAgICAgY29udHJvbFJlZ2lvbnNbMF0gKz0gdGhpcy5ncmlkW2ldW3N0YXJ0R3JpZFkgLSAxXS5sZW5ndGggKyB0aGlzLmdyaWRbaV1bc3RhcnRHcmlkWV0ubGVuZ3RoIC0gMTtcbiAgICB9XG4gIH1cbiAgaWYgKGZpbmlzaEdyaWRYIDwgdGhpcy5ncmlkLmxlbmd0aCAtIDEpIHtcbiAgICBmb3IgKHZhciBpID0gc3RhcnRHcmlkWTsgaSA8PSBmaW5pc2hHcmlkWTsgaSsrKSB7XG4gICAgICBjb250cm9sUmVnaW9uc1sxXSArPSB0aGlzLmdyaWRbZmluaXNoR3JpZFggKyAxXVtpXS5sZW5ndGggKyB0aGlzLmdyaWRbZmluaXNoR3JpZFhdW2ldLmxlbmd0aCAtIDE7XG4gICAgfVxuICB9XG4gIGlmIChmaW5pc2hHcmlkWSA8IHRoaXMuZ3JpZFswXS5sZW5ndGggLSAxKSB7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0R3JpZFg7IGkgPD0gZmluaXNoR3JpZFg7IGkrKykge1xuICAgICAgY29udHJvbFJlZ2lvbnNbMl0gKz0gdGhpcy5ncmlkW2ldW2ZpbmlzaEdyaWRZICsgMV0ubGVuZ3RoICsgdGhpcy5ncmlkW2ldW2ZpbmlzaEdyaWRZXS5sZW5ndGggLSAxO1xuICAgIH1cbiAgfVxuICBpZiAoc3RhcnRHcmlkWCA+IDApIHtcbiAgICBmb3IgKHZhciBpID0gc3RhcnRHcmlkWTsgaSA8PSBmaW5pc2hHcmlkWTsgaSsrKSB7XG4gICAgICBjb250cm9sUmVnaW9uc1szXSArPSB0aGlzLmdyaWRbc3RhcnRHcmlkWCAtIDFdW2ldLmxlbmd0aCArIHRoaXMuZ3JpZFtzdGFydEdyaWRYXVtpXS5sZW5ndGggLSAxO1xuICAgIH1cbiAgfVxuICB2YXIgbWluID0gSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciBtaW5Db3VudDtcbiAgdmFyIG1pbkluZGV4O1xuICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbnRyb2xSZWdpb25zLmxlbmd0aDsgaisrKSB7XG4gICAgaWYgKGNvbnRyb2xSZWdpb25zW2pdIDwgbWluKSB7XG4gICAgICBtaW4gPSBjb250cm9sUmVnaW9uc1tqXTtcbiAgICAgIG1pbkNvdW50ID0gMTtcbiAgICAgIG1pbkluZGV4ID0gajtcbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xSZWdpb25zW2pdID09IG1pbikge1xuICAgICAgbWluQ291bnQrKztcbiAgICB9XG4gIH1cblxuICBpZiAobWluQ291bnQgPT0gMyAmJiBtaW4gPT0gMCkge1xuICAgIGlmIChjb250cm9sUmVnaW9uc1swXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzFdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbMl0gPT0gMCkge1xuICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAxO1xuICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMF0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1sxXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzNdID09IDApIHtcbiAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMDtcbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xSZWdpb25zWzBdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbMl0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1szXSA9PSAwKSB7XG4gICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDM7XG4gICAgfSBlbHNlIGlmIChjb250cm9sUmVnaW9uc1sxXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzJdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbM10gPT0gMCkge1xuICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAyO1xuICAgIH1cbiAgfSBlbHNlIGlmIChtaW5Db3VudCA9PSAyICYmIG1pbiA9PSAwKSB7XG4gICAgdmFyIHJhbmRvbSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDIpO1xuICAgIGlmIChjb250cm9sUmVnaW9uc1swXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzFdID09IDApIHtcbiAgICAgIDtcbiAgICAgIGlmIChyYW5kb20gPT0gMCkge1xuICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDE7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb250cm9sUmVnaW9uc1swXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzJdID09IDApIHtcbiAgICAgIGlmIChyYW5kb20gPT0gMCkge1xuICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb250cm9sUmVnaW9uc1swXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzNdID09IDApIHtcbiAgICAgIGlmIChyYW5kb20gPT0gMCkge1xuICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDM7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb250cm9sUmVnaW9uc1sxXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzJdID09IDApIHtcbiAgICAgIGlmIChyYW5kb20gPT0gMCkge1xuICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb250cm9sUmVnaW9uc1sxXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzNdID09IDApIHtcbiAgICAgIGlmIChyYW5kb20gPT0gMCkge1xuICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDM7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyYW5kb20gPT0gMCkge1xuICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDM7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKG1pbkNvdW50ID09IDQgJiYgbWluID09IDApIHtcbiAgICB2YXIgcmFuZG9tID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNCk7XG4gICAgZ3JpZEZvclBydW5lZE5vZGUgPSByYW5kb207XG4gIH0gZWxzZSB7XG4gICAgZ3JpZEZvclBydW5lZE5vZGUgPSBtaW5JbmRleDtcbiAgfVxuXG4gIGlmIChncmlkRm9yUHJ1bmVkTm9kZSA9PSAwKSB7XG4gICAgcHJ1bmVkTm9kZS5zZXRDZW50ZXIobm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJYKCksIG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWSgpIC0gbm9kZVRvQ29ubmVjdC5nZXRIZWlnaHQoKSAvIDIgLSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIIC0gcHJ1bmVkTm9kZS5nZXRIZWlnaHQoKSAvIDIpO1xuICB9IGVsc2UgaWYgKGdyaWRGb3JQcnVuZWROb2RlID09IDEpIHtcbiAgICBwcnVuZWROb2RlLnNldENlbnRlcihub2RlVG9Db25uZWN0LmdldENlbnRlclgoKSArIG5vZGVUb0Nvbm5lY3QuZ2V0V2lkdGgoKSAvIDIgKyBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIICsgcHJ1bmVkTm9kZS5nZXRXaWR0aCgpIC8gMiwgbm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJZKCkpO1xuICB9IGVsc2UgaWYgKGdyaWRGb3JQcnVuZWROb2RlID09IDIpIHtcbiAgICBwcnVuZWROb2RlLnNldENlbnRlcihub2RlVG9Db25uZWN0LmdldENlbnRlclgoKSwgbm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJZKCkgKyBub2RlVG9Db25uZWN0LmdldEhlaWdodCgpIC8gMiArIEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggKyBwcnVuZWROb2RlLmdldEhlaWdodCgpIC8gMik7XG4gIH0gZWxzZSB7XG4gICAgcHJ1bmVkTm9kZS5zZXRDZW50ZXIobm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJYKCkgLSBub2RlVG9Db25uZWN0LmdldFdpZHRoKCkgLyAyIC0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCAtIHBydW5lZE5vZGUuZ2V0V2lkdGgoKSAvIDIsIG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWSgpKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb1NFTGF5b3V0O1xuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGNvc2VCYXNlID0ge307XG5cbmNvc2VCYXNlLmxheW91dEJhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuY29zZUJhc2UuQ29TRUNvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5jb3NlQmFzZS5Db1NFRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5jb3NlQmFzZS5Db1NFR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuY29zZUJhc2UuQ29TRUdyYXBoTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5jb3NlQmFzZS5Db1NFTGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbmNvc2VCYXNlLkNvU0VOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3NlQmFzZTtcblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7Il0sIm5hbWVzIjpbIndlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwicm9vdCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsImRlZmluZSIsImFtZCIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfMF9fIiwibW9kdWxlcyIsImluc3RhbGxlZE1vZHVsZXMiLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwibW9kdWxlSWQiLCJpIiwibCIsImNhbGwiLCJtIiwiYyIsInZhbHVlIiwiZCIsIm5hbWUiLCJnZXR0ZXIiLCJvIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwibiIsIl9fZXNNb2R1bGUiLCJnZXREZWZhdWx0IiwiZ2V0TW9kdWxlRXhwb3J0cyIsIm9iamVjdCIsInByb3BlcnR5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJwIiwicyIsIkZETGF5b3V0Q29uc3RhbnRzIiwiQ29TRUNvbnN0YW50cyIsInByb3AiLCJERUZBVUxUX1VTRV9NVUxUSV9MRVZFTF9TQ0FMSU5HIiwiREVGQVVMVF9SQURJQUxfU0VQQVJBVElPTiIsIkRFRkFVTFRfRURHRV9MRU5HVEgiLCJERUZBVUxUX0NPTVBPTkVOVF9TRVBFUkFUSU9OIiwiVElMRSIsIlRJTElOR19QQURESU5HX1ZFUlRJQ0FMIiwiVElMSU5HX1BBRERJTkdfSE9SSVpPTlRBTCIsIlRSRUVfUkVEVUNUSU9OX09OX0lOQ1JFTUVOVEFMIiwiRkRMYXlvdXRFZGdlIiwiQ29TRUVkZ2UiLCJzb3VyY2UiLCJ0YXJnZXQiLCJ2RWRnZSIsImNyZWF0ZSIsIkxHcmFwaCIsIkNvU0VHcmFwaCIsInBhcmVudCIsImdyYXBoTWdyIiwidkdyYXBoIiwiTEdyYXBoTWFuYWdlciIsIkNvU0VHcmFwaE1hbmFnZXIiLCJsYXlvdXQiLCJGRExheW91dE5vZGUiLCJJTWF0aCIsIkNvU0VOb2RlIiwiZ20iLCJsb2MiLCJzaXplIiwidk5vZGUiLCJtb3ZlIiwiZ3JhcGhNYW5hZ2VyIiwiZ2V0TGF5b3V0IiwiZGlzcGxhY2VtZW50WCIsImNvb2xpbmdGYWN0b3IiLCJzcHJpbmdGb3JjZVgiLCJyZXB1bHNpb25Gb3JjZVgiLCJncmF2aXRhdGlvbkZvcmNlWCIsIm5vT2ZDaGlsZHJlbiIsImRpc3BsYWNlbWVudFkiLCJzcHJpbmdGb3JjZVkiLCJyZXB1bHNpb25Gb3JjZVkiLCJncmF2aXRhdGlvbkZvcmNlWSIsIk1hdGgiLCJhYnMiLCJtYXhOb2RlRGlzcGxhY2VtZW50Iiwic2lnbiIsImNoaWxkIiwibW92ZUJ5IiwiZ2V0Tm9kZXMiLCJsZW5ndGgiLCJwcm9wb2dhdGVEaXNwbGFjZW1lbnRUb0NoaWxkcmVuIiwidG90YWxEaXNwbGFjZW1lbnQiLCJkWCIsImRZIiwibm9kZXMiLCJnZXRDaGlsZCIsIm5vZGUiLCJzZXRQcmVkMSIsInByZWQxIiwiZ2V0UHJlZDEiLCJnZXRQcmVkMiIsInByZWQyIiwic2V0TmV4dCIsIm5leHQiLCJnZXROZXh0Iiwic2V0UHJvY2Vzc2VkIiwicHJvY2Vzc2VkIiwiaXNQcm9jZXNzZWQiLCJGRExheW91dCIsIkxheW91dENvbnN0YW50cyIsIlBvaW50IiwiUG9pbnREIiwiTGF5b3V0IiwiSW50ZWdlciIsIklHZW9tZXRyeSIsIlRyYW5zZm9ybSIsIkNvU0VMYXlvdXQiLCJ0b0JlVGlsZWQiLCJuZXdHcmFwaE1hbmFnZXIiLCJuZXdHcmFwaCIsIm5ld05vZGUiLCJuZXdFZGdlIiwiaW5pdFBhcmFtZXRlcnMiLCJhcmd1bWVudHMiLCJpc1N1YkxheW91dCIsImlkZWFsRWRnZUxlbmd0aCIsInVzZVNtYXJ0SWRlYWxFZGdlTGVuZ3RoQ2FsY3VsYXRpb24iLCJERUZBVUxUX1VTRV9TTUFSVF9JREVBTF9FREdFX0xFTkdUSF9DQUxDVUxBVElPTiIsInNwcmluZ0NvbnN0YW50IiwiREVGQVVMVF9TUFJJTkdfU1RSRU5HVEgiLCJyZXB1bHNpb25Db25zdGFudCIsIkRFRkFVTFRfUkVQVUxTSU9OX1NUUkVOR1RIIiwiZ3Jhdml0eUNvbnN0YW50IiwiREVGQVVMVF9HUkFWSVRZX1NUUkVOR1RIIiwiY29tcG91bmRHcmF2aXR5Q29uc3RhbnQiLCJERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfU1RSRU5HVEgiLCJncmF2aXR5UmFuZ2VGYWN0b3IiLCJERUZBVUxUX0dSQVZJVFlfUkFOR0VfRkFDVE9SIiwiY29tcG91bmRHcmF2aXR5UmFuZ2VGYWN0b3IiLCJERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfUkFOR0VfRkFDVE9SIiwicHJ1bmVkTm9kZXNBbGwiLCJncm93VHJlZUl0ZXJhdGlvbnMiLCJhZnRlckdyb3d0aEl0ZXJhdGlvbnMiLCJpc1RyZWVHcm93aW5nIiwiaXNHcm93dGhGaW5pc2hlZCIsImNvb2xpbmdDeWNsZSIsIm1heENvb2xpbmdDeWNsZSIsIm1heEl0ZXJhdGlvbnMiLCJDT05WRVJHRU5DRV9DSEVDS19QRVJJT0QiLCJmaW5hbFRlbXBlcmF0dXJlIiwiY29vbGluZ0FkanVzdGVyIiwiY3JlYXRlQmVuZHNBc05lZWRlZCIsIkRFRkFVTFRfQ1JFQVRFX0JFTkRTX0FTX05FRURFRCIsImNyZWF0ZUJlbmRwb2ludHMiLCJyZXNldEFsbEVkZ2VzIiwibGV2ZWwiLCJjbGFzc2ljTGF5b3V0Iiwibm9kZXNXaXRoR3Jhdml0eSIsImNhbGN1bGF0ZU5vZGVzVG9BcHBseUdyYXZpdGF0aW9uVG8iLCJzZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiIsImNhbGNOb09mQ2hpbGRyZW5Gb3JBbGxOb2RlcyIsImNhbGNMb3dlc3RDb21tb25BbmNlc3RvcnMiLCJjYWxjSW5jbHVzaW9uVHJlZURlcHRocyIsImdldFJvb3QiLCJjYWxjRXN0aW1hdGVkU2l6ZSIsImNhbGNJZGVhbEVkZ2VMZW5ndGhzIiwiaW5jcmVtZW50YWwiLCJmb3Jlc3QiLCJnZXRGbGF0Rm9yZXN0IiwicG9zaXRpb25Ob2Rlc1JhZGlhbGx5IiwicmVkdWNlVHJlZXMiLCJyZXNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uIiwiYWxsTm9kZXMiLCJTZXQiLCJnZXRBbGxOb2RlcyIsImludGVyc2VjdGlvbiIsImZpbHRlciIsIngiLCJoYXMiLCJwb3NpdGlvbk5vZGVzUmFuZG9tbHkiLCJpbml0U3ByaW5nRW1iZWRkZXIiLCJydW5TcHJpbmdFbWJlZGRlciIsInRpY2siLCJ0b3RhbEl0ZXJhdGlvbnMiLCJpc0NvbnZlcmdlZCIsImxheW91dFF1YWxpdHkiLCJtYXgiLCJpbml0aWFsQ29vbGluZ0ZhY3RvciIsInBvdyIsImxvZyIsImFuaW1hdGlvblBlcmlvZCIsImNlaWwiLCJpbml0aWFsQW5pbWF0aW9uUGVyaW9kIiwic3FydCIsInVwZGF0ZUJvdW5kcyIsInVwZGF0ZUdyaWQiLCJncm93VHJlZSIsIkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUwiLCJncmlkVXBkYXRlQWxsb3dlZCIsImZvcmNlVG9Ob2RlU3Vycm91bmRpbmdVcGRhdGUiLCJjYWxjU3ByaW5nRm9yY2VzIiwiY2FsY1JlcHVsc2lvbkZvcmNlcyIsImNhbGNHcmF2aXRhdGlvbmFsRm9yY2VzIiwibW92ZU5vZGVzIiwiYW5pbWF0ZSIsImdldFBvc2l0aW9uc0RhdGEiLCJwRGF0YSIsInJlY3QiLCJpZCIsImdldENlbnRlclgiLCJ5IiwiZ2V0Q2VudGVyWSIsInciLCJ3aWR0aCIsImgiLCJoZWlnaHQiLCJsYXlvdXRFbmRlZCIsIkFOSU1BVEUiLCJlbWl0Iiwibm9kZUxpc3QiLCJncmFwaCIsImdyYXBocyIsImdldEdyYXBocyIsInVwZGF0ZUNvbm5lY3RlZCIsImlzQ29ubmVjdGVkIiwiY29uY2F0IiwiZWRnZXMiLCJnZXRBbGxFZGdlcyIsInZpc2l0ZWQiLCJlZGdlIiwiZ2V0U291cmNlIiwiZ2V0VGFyZ2V0IiwiZ2V0QmVuZHBvaW50cyIsInB1c2giLCJjcmVhdGVEdW1teU5vZGVzRm9yQmVuZHBvaW50cyIsImFkZCIsImVkZ2VMaXN0IiwiZ2V0RWRnZUxpc3RUb05vZGUiLCJrIiwibXVsdGlFZGdlIiwiZm9yRWFjaCIsImN1cnJlbnRTdGFydGluZ1BvaW50IiwibnVtYmVyT2ZDb2x1bW5zIiwiY3VycmVudFkiLCJjdXJyZW50WCIsInBvaW50IiwidHJlZSIsImNlbnRlck5vZGUiLCJmaW5kQ2VudGVyT2ZUcmVlIiwicmFkaWFsTGF5b3V0IiwiZmxvb3IiLCJ0cmFuc2Zvcm0iLCJXT1JMRF9DRU5URVJfWCIsIldPUkxEX0NFTlRFUl9ZIiwic3RhcnRpbmdQb2ludCIsInJhZGlhbFNlcCIsIm1heERpYWdvbmFsSW5UcmVlIiwiYnJhbmNoUmFkaWFsTGF5b3V0IiwiYm91bmRzIiwiY2FsY3VsYXRlQm91bmRzIiwic2V0RGV2aWNlT3JnWCIsImdldE1pblgiLCJzZXREZXZpY2VPcmdZIiwiZ2V0TWluWSIsInNldFdvcmxkT3JnWCIsInNldFdvcmxkT3JnWSIsImJvdHRvbVJpZ2h0IiwiZ2V0TWF4WCIsImdldE1heFkiLCJpbnZlcnNlVHJhbnNmb3JtUG9pbnQiLCJwYXJlbnRPZk5vZGUiLCJzdGFydEFuZ2xlIiwiZW5kQW5nbGUiLCJkaXN0YW5jZSIsInJhZGlhbFNlcGFyYXRpb24iLCJoYWxmSW50ZXJ2YWwiLCJub2RlQW5nbGUiLCJ0ZXRhIiwiVFdPX1BJIiwiY29zX3RldGEiLCJjb3MiLCJ4XyIsInlfIiwic2luIiwic2V0Q2VudGVyIiwibmVpZ2hib3JFZGdlcyIsImdldEVkZ2VzIiwiY2hpbGRDb3VudCIsImJyYW5jaENvdW50IiwiaW5jRWRnZXNDb3VudCIsInN0YXJ0SW5kZXgiLCJnZXRFZGdlc0JldHdlZW4iLCJ0ZW1wIiwic3BsaWNlIiwiaW5kZXgiLCJpbmRleE9mIiwic3RlcEFuZ2xlIiwiY3VycmVudE5laWdoYm9yIiwiZ2V0T3RoZXJFbmQiLCJjaGlsZFN0YXJ0QW5nbGUiLCJjaGlsZEVuZEFuZ2xlIiwibWF4RGlhZ29uYWwiLCJNSU5fVkFMVUUiLCJkaWFnb25hbCIsImdldERpYWdvbmFsIiwiY2FsY1JlcHVsc2lvblJhbmdlIiwiZ3JvdXBaZXJvRGVncmVlTWVtYmVycyIsInNlbGYiLCJ0ZW1wTWVtYmVyR3JvdXBzIiwibWVtYmVyR3JvdXBzIiwiaWRUb0R1bW15Tm9kZSIsInplcm9EZWdyZWUiLCJnZXRQYXJlbnQiLCJnZXROb2RlRGVncmVlV2l0aENoaWxkcmVuIiwidW5kZWZpbmVkIiwiZ2V0VG9CZVRpbGVkIiwicF9pZCIsImtleXMiLCJkdW1teUNvbXBvdW5kSWQiLCJkdW1teUNvbXBvdW5kIiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nUmlnaHQiLCJwYWRkaW5nQm90dG9tIiwicGFkZGluZ1RvcCIsImR1bW15UGFyZW50R3JhcGgiLCJnZXRHcmFwaE1hbmFnZXIiLCJwYXJlbnRHcmFwaCIsInJlbW92ZSIsImNsZWFyQ29tcG91bmRzIiwiY2hpbGRHcmFwaE1hcCIsImlkVG9Ob2RlIiwicGVyZm9ybURGU09uQ29tcG91bmRzIiwiY29tcG91bmRPcmRlciIsInJlc2V0QWxsTm9kZXMiLCJ0aWxlQ29tcG91bmRNZW1iZXJzIiwiY2xlYXJaZXJvRGVncmVlTWVtYmVycyIsInRpbGVkWmVyb0RlZ3JlZVBhY2siLCJjb21wb3VuZE5vZGUiLCJ0aWxlTm9kZXMiLCJyZXBvcHVsYXRlQ29tcG91bmRzIiwibENvbXBvdW5kTm9kZSIsImhvcml6b250YWxNYXJnaW4iLCJ2ZXJ0aWNhbE1hcmdpbiIsImFkanVzdExvY2F0aW9ucyIsInRpbGVkTWVtYmVyUGFjayIsInJlcG9wdWxhdGVaZXJvRGVncmVlTWVtYmVycyIsInRpbGVkUGFjayIsImNoaWxkR3JhcGgiLCJjaGlsZHJlbiIsInRoZUNoaWxkIiwiZ2V0Tm9kZURlZ3JlZSIsImRlZ3JlZSIsImZpbGxDb21wZXhPcmRlckJ5REZTIiwib3JnYW5pemF0aW9uIiwiY29tcG91bmRIb3Jpem9udGFsTWFyZ2luIiwiY29tcG91bmRWZXJ0aWNhbE1hcmdpbiIsImxlZnQiLCJyb3dzIiwicm93IiwibWF4SGVpZ2h0IiwiaiIsImxub2RlIiwiaG9yaXpvbnRhbFBhZGRpbmciLCJ2ZXJ0aWNhbFBhZGRpbmciLCJtaW5XaWR0aCIsInJvd1dpZHRoIiwicm93SGVpZ2h0Iiwic29ydCIsIm4xIiwibjIiLCJsTm9kZSIsImluc2VydE5vZGVUb1JvdyIsImNhbkFkZEhvcml6b250YWwiLCJnZXRTaG9ydGVzdFJvd0luZGV4Iiwic2hpZnRUb0xhc3RSb3ciLCJyb3dJbmRleCIsIm1pbkNvbXBvdW5kU2l6ZSIsInNlY29uZERpbWVuc2lvbiIsImV4dHJhSGVpZ2h0IiwiciIsIm1pbiIsIk51bWJlciIsIk1BWF9WQUxVRSIsImdldExvbmdlc3RSb3dJbmRleCIsImV4dHJhV2lkdGgiLCJzcmkiLCJoRGlmZiIsImFkZF90b19yb3dfcmF0aW8iLCJhZGRfbmV3X3Jvd19yYXRpbyIsImxvbmdlc3QiLCJsYXN0IiwiZGlmZiIsImluc3RhbmNlIiwicHJldlRvdGFsIiwiZmluYWxUb3RhbCIsInRpbGluZ1ByZUxheW91dCIsInRpbGluZ1Bvc3RMYXlvdXQiLCJjb250YWluc0xlYWYiLCJwcnVuZWROb2Rlc0luU3RlcFRlbXAiLCJpc0ludGVyR3JhcGgiLCJnZXRPd25lciIsInBydW5lZE5vZGVzSW5TdGVwIiwibGVuZ3RoT2ZQcnVuZWROb2Rlc0luU3RlcCIsIm5vZGVEYXRhIiwiZmluZFBsYWNlZm9yUHJ1bmVkTm9kZSIsImdyaWRGb3JQcnVuZWROb2RlIiwibm9kZVRvQ29ubmVjdCIsInBydW5lZE5vZGUiLCJzdGFydEdyaWRYIiwic3RhcnRYIiwiZmluaXNoR3JpZFgiLCJmaW5pc2hYIiwic3RhcnRHcmlkWSIsInN0YXJ0WSIsImZpbmlzaEdyaWRZIiwiZmluaXNoWSIsInVwTm9kZUNvdW50IiwiZG93bk5vZGVDb3VudCIsInJpZ2h0Tm9kZUNvdW50IiwibGVmdE5vZGVDb3VudCIsImNvbnRyb2xSZWdpb25zIiwiZ3JpZCIsIm1pbkNvdW50IiwibWluSW5kZXgiLCJyYW5kb20iLCJnZXRIZWlnaHQiLCJnZXRXaWR0aCIsImNvc2VCYXNlIiwibGF5b3V0QmFzZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/cose-base/cose-base.js\n");

/***/ })

};
;